webpackJsonp([2],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(263);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	/**
	 * @module
	 * @description
	 * Entry point from which you should import all public core APIs.
	 */
	__export(__webpack_require__(210));
	__export(__webpack_require__(216));
	__export(__webpack_require__(24));
	var application_ref_1 = __webpack_require__(61);
	exports.createPlatform = application_ref_1.createPlatform;
	exports.assertPlatform = application_ref_1.assertPlatform;
	exports.disposePlatform = application_ref_1.disposePlatform;
	exports.getPlatform = application_ref_1.getPlatform;
	exports.coreBootstrap = application_ref_1.coreBootstrap;
	exports.coreLoadAndBootstrap = application_ref_1.coreLoadAndBootstrap;
	exports.createNgZone = application_ref_1.createNgZone;
	exports.PlatformRef = application_ref_1.PlatformRef;
	exports.ApplicationRef = application_ref_1.ApplicationRef;
	exports.enableProdMode = application_ref_1.enableProdMode;
	exports.lockRunMode = application_ref_1.lockRunMode;
	exports.isDevMode = application_ref_1.isDevMode;
	var application_tokens_1 = __webpack_require__(39);
	exports.APP_ID = application_tokens_1.APP_ID;
	exports.APP_INITIALIZER = application_tokens_1.APP_INITIALIZER;
	exports.PACKAGE_ROOT_URL = application_tokens_1.PACKAGE_ROOT_URL;
	exports.PLATFORM_INITIALIZER = application_tokens_1.PLATFORM_INITIALIZER;
	__export(__webpack_require__(217));
	__export(__webpack_require__(215));
	__export(__webpack_require__(204));
	var debug_node_1 = __webpack_require__(107);
	exports.DebugElement = debug_node_1.DebugElement;
	exports.DebugNode = debug_node_1.DebugNode;
	exports.asNativeElements = debug_node_1.asNativeElements;
	exports.getDebugNode = debug_node_1.getDebugNode;
	__export(__webpack_require__(76));
	__export(__webpack_require__(198));
	__export(__webpack_require__(212));
	__export(__webpack_require__(211));
	__export(__webpack_require__(197));
	var profile_1 = __webpack_require__(45);
	exports.wtfCreateScope = profile_1.wtfCreateScope;
	exports.wtfLeave = profile_1.wtfLeave;
	exports.wtfStartTimeRange = profile_1.wtfStartTimeRange;
	exports.wtfEndTimeRange = profile_1.wtfEndTimeRange;
	var lang_1 = __webpack_require__(2);
	exports.Type = lang_1.Type;
	var async_1 = __webpack_require__(18);
	exports.EventEmitter = async_1.EventEmitter;
	var exceptions_1 = __webpack_require__(5);
	exports.ExceptionHandler = exceptions_1.ExceptionHandler;
	exports.WrappedException = exceptions_1.WrappedException;
	exports.BaseException = exceptions_1.BaseException;
	__export(__webpack_require__(190));
	__export(__webpack_require__(103));
	var animation_player_1 = __webpack_require__(38);
	exports.AnimationPlayer = animation_player_1.AnimationPlayer;
	//# sourceMappingURL=index.js.map

/***/ },
/* 2 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var globalScope;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope = self;
	    }
	    else {
	        globalScope = global;
	    }
	}
	else {
	    globalScope = window;
	}
	function scheduleMicroTask(fn) {
	    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	}
	exports.scheduleMicroTask = scheduleMicroTask;
	exports.IS_DART = false;
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var _global = globalScope;
	exports.global = _global;
	/**
	 * Runtime representation a type that a Component or other object is instances of.
	 *
	 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	 * the `MyCustomComponent` constructor function.
	 *
	 * @stable
	 */
	exports.Type = Function;
	function getTypeNameForDebugging(type) {
	    if (type['name']) {
	        return type['name'];
	    }
	    return typeof type;
	}
	exports.getTypeNameForDebugging = getTypeNameForDebugging;
	exports.Math = _global.Math;
	exports.Date = _global.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	_global.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent(obj) {
	    return obj !== undefined && obj !== null;
	}
	exports.isPresent = isPresent;
	function isBlank(obj) {
	    return obj === undefined || obj === null;
	}
	exports.isBlank = isBlank;
	function isBoolean(obj) {
	    return typeof obj === 'boolean';
	}
	exports.isBoolean = isBoolean;
	function isNumber(obj) {
	    return typeof obj === 'number';
	}
	exports.isNumber = isNumber;
	function isString(obj) {
	    return typeof obj === 'string';
	}
	exports.isString = isString;
	function isFunction(obj) {
	    return typeof obj === 'function';
	}
	exports.isFunction = isFunction;
	function isType(obj) {
	    return isFunction(obj);
	}
	exports.isType = isType;
	function isStringMap(obj) {
	    return typeof obj === 'object' && obj !== null;
	}
	exports.isStringMap = isStringMap;
	var STRING_MAP_PROTO = Object.getPrototypeOf({});
	function isStrictStringMap(obj) {
	    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
	}
	exports.isStrictStringMap = isStrictStringMap;
	function isPromise(obj) {
	    return obj instanceof _global.Promise;
	}
	exports.isPromise = isPromise;
	function isArray(obj) {
	    return Array.isArray(obj);
	}
	exports.isArray = isArray;
	function isDate(obj) {
	    return obj instanceof exports.Date && !isNaN(obj.valueOf());
	}
	exports.isDate = isDate;
	function noop() { }
	exports.noop = noop;
	function stringify(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token === undefined || token === null) {
	        return '' + token;
	    }
	    if (token.name) {
	        return token.name;
	    }
	    if (token.overriddenName) {
	        return token.overriddenName;
	    }
	    var res = token.toString();
	    var newLineIndex = res.indexOf('\n');
	    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
	}
	exports.stringify = stringify;
	// serialize / deserialize enum exist only for consistency with dart API
	// enums in typescript don't need to be serialized
	function serializeEnum(val) {
	    return val;
	}
	exports.serializeEnum = serializeEnum;
	function deserializeEnum(val, values) {
	    return val;
	}
	exports.deserializeEnum = deserializeEnum;
	function resolveEnumToken(enumValue, val) {
	    return enumValue[val];
	}
	exports.resolveEnumToken = resolveEnumToken;
	var StringWrapper = (function () {
	    function StringWrapper() {
	    }
	    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
	    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
	    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
	    StringWrapper.equals = function (s, s2) { return s === s2; };
	    StringWrapper.stripLeft = function (s, charVal) {
	        if (s && s.length) {
	            var pos = 0;
	            for (var i = 0; i < s.length; i++) {
	                if (s[i] != charVal)
	                    break;
	                pos++;
	            }
	            s = s.substring(pos);
	        }
	        return s;
	    };
	    StringWrapper.stripRight = function (s, charVal) {
	        if (s && s.length) {
	            var pos = s.length;
	            for (var i = s.length - 1; i >= 0; i--) {
	                if (s[i] != charVal)
	                    break;
	                pos--;
	            }
	            s = s.substring(0, pos);
	        }
	        return s;
	    };
	    StringWrapper.replace = function (s, from, replace) {
	        return s.replace(from, replace);
	    };
	    StringWrapper.replaceAll = function (s, from, replace) {
	        return s.replace(from, replace);
	    };
	    StringWrapper.slice = function (s, from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = null; }
	        return s.slice(from, to === null ? undefined : to);
	    };
	    StringWrapper.replaceAllMapped = function (s, from, cb) {
	        return s.replace(from, function () {
	            var matches = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                matches[_i - 0] = arguments[_i];
	            }
	            // Remove offset & string from the result array
	            matches.splice(-2, 2);
	            // The callback receives match, p1, ..., pn
	            return cb(matches);
	        });
	    };
	    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
	    StringWrapper.compare = function (a, b) {
	        if (a < b) {
	            return -1;
	        }
	        else if (a > b) {
	            return 1;
	        }
	        else {
	            return 0;
	        }
	    };
	    return StringWrapper;
	}());
	exports.StringWrapper = StringWrapper;
	var StringJoiner = (function () {
	    function StringJoiner(parts) {
	        if (parts === void 0) { parts = []; }
	        this.parts = parts;
	    }
	    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
	    StringJoiner.prototype.toString = function () { return this.parts.join(''); };
	    return StringJoiner;
	}());
	exports.StringJoiner = StringJoiner;
	var NumberParseError = (function (_super) {
	    __extends(NumberParseError, _super);
	    function NumberParseError(message) {
	        _super.call(this);
	        this.message = message;
	    }
	    NumberParseError.prototype.toString = function () { return this.message; };
	    return NumberParseError;
	}(Error));
	exports.NumberParseError = NumberParseError;
	var NumberWrapper = (function () {
	    function NumberWrapper() {
	    }
	    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
	    NumberWrapper.equal = function (a, b) { return a === b; };
	    NumberWrapper.parseIntAutoRadix = function (text) {
	        var result = parseInt(text);
	        if (isNaN(result)) {
	            throw new NumberParseError('Invalid integer literal when parsing ' + text);
	        }
	        return result;
	    };
	    NumberWrapper.parseInt = function (text, radix) {
	        if (radix == 10) {
	            if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                return parseInt(text, radix);
	            }
	        }
	        else if (radix == 16) {
	            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                return parseInt(text, radix);
	            }
	        }
	        else {
	            var result = parseInt(text, radix);
	            if (!isNaN(result)) {
	                return result;
	            }
	        }
	        throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	    };
	    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
	    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
	    Object.defineProperty(NumberWrapper, "NaN", {
	        get: function () { return NaN; },
	        enumerable: true,
	        configurable: true
	    });
	    NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
	    NumberWrapper.isNaN = function (value) { return isNaN(value); };
	    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
	    return NumberWrapper;
	}());
	exports.NumberWrapper = NumberWrapper;
	exports.RegExp = _global.RegExp;
	var RegExpWrapper = (function () {
	    function RegExpWrapper() {
	    }
	    RegExpWrapper.create = function (regExpStr, flags) {
	        if (flags === void 0) { flags = ''; }
	        flags = flags.replace(/g/g, '');
	        return new _global.RegExp(regExpStr, flags + 'g');
	    };
	    RegExpWrapper.firstMatch = function (regExp, input) {
	        // Reset multimatch regex state
	        regExp.lastIndex = 0;
	        return regExp.exec(input);
	    };
	    RegExpWrapper.test = function (regExp, input) {
	        regExp.lastIndex = 0;
	        return regExp.test(input);
	    };
	    RegExpWrapper.matcher = function (regExp, input) {
	        // Reset regex state for the case
	        // someone did not loop over all matches
	        // last time.
	        regExp.lastIndex = 0;
	        return { re: regExp, input: input };
	    };
	    RegExpWrapper.replaceAll = function (regExp, input, replace) {
	        var c = regExp.exec(input);
	        var res = '';
	        regExp.lastIndex = 0;
	        var prev = 0;
	        while (c) {
	            res += input.substring(prev, c.index);
	            res += replace(c);
	            prev = c.index + c[0].length;
	            regExp.lastIndex = prev;
	            c = regExp.exec(input);
	        }
	        res += input.substring(prev);
	        return res;
	    };
	    return RegExpWrapper;
	}());
	exports.RegExpWrapper = RegExpWrapper;
	var RegExpMatcherWrapper = (function () {
	    function RegExpMatcherWrapper() {
	    }
	    RegExpMatcherWrapper.next = function (matcher) {
	        return matcher.re.exec(matcher.input);
	    };
	    return RegExpMatcherWrapper;
	}());
	exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
	var FunctionWrapper = (function () {
	    function FunctionWrapper() {
	    }
	    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
	    FunctionWrapper.bind = function (fn, scope) { return fn.bind(scope); };
	    return FunctionWrapper;
	}());
	exports.FunctionWrapper = FunctionWrapper;
	// JS has NaN !== NaN
	function looseIdentical(a, b) {
	    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	}
	exports.looseIdentical = looseIdentical;
	// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
	// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
	function getMapKey(value) {
	    return value;
	}
	exports.getMapKey = getMapKey;
	function normalizeBlank(obj) {
	    return isBlank(obj) ? null : obj;
	}
	exports.normalizeBlank = normalizeBlank;
	function normalizeBool(obj) {
	    return isBlank(obj) ? false : obj;
	}
	exports.normalizeBool = normalizeBool;
	function isJsObject(o) {
	    return o !== null && (typeof o === 'function' || typeof o === 'object');
	}
	exports.isJsObject = isJsObject;
	function print(obj) {
	    console.log(obj);
	}
	exports.print = print;
	function warn(obj) {
	    console.warn(obj);
	}
	exports.warn = warn;
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json = (function () {
	    function Json() {
	    }
	    Json.parse = function (s) { return _global.JSON.parse(s); };
	    Json.stringify = function (data) {
	        // Dart doesn't take 3 arguments
	        return _global.JSON.stringify(data, null, 2);
	    };
	    return Json;
	}());
	exports.Json = Json;
	var DateWrapper = (function () {
	    function DateWrapper() {
	    }
	    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
	        if (month === void 0) { month = 1; }
	        if (day === void 0) { day = 1; }
	        if (hour === void 0) { hour = 0; }
	        if (minutes === void 0) { minutes = 0; }
	        if (seconds === void 0) { seconds = 0; }
	        if (milliseconds === void 0) { milliseconds = 0; }
	        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
	    };
	    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
	    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
	    DateWrapper.toMillis = function (date) { return date.getTime(); };
	    DateWrapper.now = function () { return new exports.Date(); };
	    DateWrapper.toJson = function (date) { return date.toJSON(); };
	    return DateWrapper;
	}());
	exports.DateWrapper = DateWrapper;
	function setValueOnPath(global, path, value) {
	    var parts = path.split('.');
	    var obj = global;
	    while (parts.length > 1) {
	        var name = parts.shift();
	        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
	            obj = obj[name];
	        }
	        else {
	            obj = obj[name] = {};
	        }
	    }
	    if (obj === undefined || obj === null) {
	        obj = {};
	    }
	    obj[parts.shift()] = value;
	}
	exports.setValueOnPath = setValueOnPath;
	var _symbolIterator = null;
	function getSymbolIterator() {
	    if (isBlank(_symbolIterator)) {
	        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
	            _symbolIterator = Symbol.iterator;
	        }
	        else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' &&
	                    Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator;
	}
	exports.getSymbolIterator = getSymbolIterator;
	function evalExpression(sourceUrl, expr, declarations, vars) {
	    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
	    var fnArgNames = [];
	    var fnArgValues = [];
	    for (var argName in vars) {
	        fnArgNames.push(argName);
	        fnArgValues.push(vars[argName]);
	    }
	    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
	}
	exports.evalExpression = evalExpression;
	function isPrimitive(obj) {
	    return !isJsObject(obj);
	}
	exports.isPrimitive = isPrimitive;
	function hasConstructor(value, type) {
	    return value.constructor === type;
	}
	exports.hasConstructor = hasConstructor;
	function escape(s) {
	    return _global.encodeURI(s);
	}
	exports.escape = escape;
	function escapeRegExp(s) {
	    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
	}
	exports.escapeRegExp = escapeRegExp;
	//# sourceMappingURL=lang.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */,
/* 4 */,
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_wrapped_exception_1 = __webpack_require__(110);
	var exception_handler_1 = __webpack_require__(111);
	var exception_handler_2 = __webpack_require__(111);
	exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
	/**
	 * @stable
	 */
	var BaseException = (function (_super) {
	    __extends(BaseException, _super);
	    function BaseException(message) {
	        if (message === void 0) { message = '--'; }
	        _super.call(this, message);
	        this.message = message;
	        this.stack = (new Error(message)).stack;
	    }
	    BaseException.prototype.toString = function () { return this.message; };
	    return BaseException;
	}(Error));
	exports.BaseException = BaseException;
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException = (function (_super) {
	    __extends(WrappedException, _super);
	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        _super.call(this, _wrapperMessage);
	        this._wrapperMessage = _wrapperMessage;
	        this._originalException = _originalException;
	        this._originalStack = _originalStack;
	        this._context = _context;
	        this._wrapperStack = (new Error(_wrapperMessage)).stack;
	    }
	    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
	        get: function () { return this._wrapperMessage; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
	        get: function () { return this._wrapperStack; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "originalException", {
	        get: function () { return this._originalException; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "originalStack", {
	        get: function () { return this._originalStack; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "context", {
	        get: function () { return this._context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "message", {
	        get: function () { return exception_handler_1.ExceptionHandler.exceptionToString(this); },
	        enumerable: true,
	        configurable: true
	    });
	    WrappedException.prototype.toString = function () { return this.message; };
	    return WrappedException;
	}(base_wrapped_exception_1.BaseWrappedException));
	exports.WrappedException = WrappedException;
	function makeTypeError(message) {
	    return new TypeError(message);
	}
	exports.makeTypeError = makeTypeError;
	function unimplemented() {
	    throw new BaseException('unimplemented');
	}
	exports.unimplemented = unimplemented;
	//# sourceMappingURL=exceptions.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	exports.Map = lang_1.global.Map;
	exports.Set = lang_1.global.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs = (function () {
	    try {
	        if (new exports.Map([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) { return new exports.Map(pairs); };
	        }
	    }
	    catch (e) {
	    }
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new exports.Map();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	})();
	var createMapFromMap = (function () {
	    try {
	        if (new exports.Map(new exports.Map())) {
	            return function createMapFromMap(m) { return new exports.Map(m); };
	        }
	    }
	    catch (e) {
	    }
	    return function createMapAndPopulateFromMap(m) {
	        var map = new exports.Map();
	        m.forEach(function (v, k) { map.set(k, v); });
	        return map;
	    };
	})();
	var _clearValues = (function () {
	    if ((new exports.Map()).keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!((k = keyIterator.next()).done)) {
	                m.set(k.value, null);
	            }
	        };
	    }
	    else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) { m.set(k, null); });
	        };
	    }
	})();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap = (function () {
	    try {
	        if ((new exports.Map()).values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    }
	    catch (e) {
	    }
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper.createFixedSize(m.size), i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	})();
	var MapWrapper = (function () {
	    function MapWrapper() {
	    }
	    MapWrapper.clone = function (m) { return createMapFromMap(m); };
	    MapWrapper.createFromStringMap = function (stringMap) {
	        var result = new exports.Map();
	        for (var prop in stringMap) {
	            result.set(prop, stringMap[prop]);
	        }
	        return result;
	    };
	    MapWrapper.toStringMap = function (m) {
	        var r = {};
	        m.forEach(function (v, k) { return r[k] = v; });
	        return r;
	    };
	    MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
	    MapWrapper.clearValues = function (m) { _clearValues(m); };
	    MapWrapper.iterable = function (m) { return m; };
	    MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
	    MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
	    return MapWrapper;
	}());
	exports.MapWrapper = MapWrapper;
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper = (function () {
	    function StringMapWrapper() {
	    }
	    StringMapWrapper.create = function () {
	        // Note: We are not using Object.create(null) here due to
	        // performance!
	        // http://jsperf.com/ng2-object-create-null
	        return {};
	    };
	    StringMapWrapper.contains = function (map, key) {
	        return map.hasOwnProperty(key);
	    };
	    StringMapWrapper.get = function (map, key) {
	        return map.hasOwnProperty(key) ? map[key] : undefined;
	    };
	    StringMapWrapper.set = function (map, key, value) { map[key] = value; };
	    StringMapWrapper.keys = function (map) { return Object.keys(map); };
	    StringMapWrapper.values = function (map) {
	        return Object.keys(map).reduce(function (r, a) {
	            r.push(map[a]);
	            return r;
	        }, []);
	    };
	    StringMapWrapper.isEmpty = function (map) {
	        for (var prop in map) {
	            return false;
	        }
	        return true;
	    };
	    StringMapWrapper.delete = function (map, key) { delete map[key]; };
	    StringMapWrapper.forEach = function (map, callback) {
	        for (var prop in map) {
	            if (map.hasOwnProperty(prop)) {
	                callback(map[prop], prop);
	            }
	        }
	    };
	    StringMapWrapper.merge = function (m1, m2) {
	        var m = {};
	        for (var attr in m1) {
	            if (m1.hasOwnProperty(attr)) {
	                m[attr] = m1[attr];
	            }
	        }
	        for (var attr in m2) {
	            if (m2.hasOwnProperty(attr)) {
	                m[attr] = m2[attr];
	            }
	        }
	        return m;
	    };
	    StringMapWrapper.equals = function (m1, m2) {
	        var k1 = Object.keys(m1);
	        var k2 = Object.keys(m2);
	        if (k1.length != k2.length) {
	            return false;
	        }
	        var key;
	        for (var i = 0; i < k1.length; i++) {
	            key = k1[i];
	            if (m1[key] !== m2[key]) {
	                return false;
	            }
	        }
	        return true;
	    };
	    return StringMapWrapper;
	}());
	exports.StringMapWrapper = StringMapWrapper;
	var ListWrapper = (function () {
	    function ListWrapper() {
	    }
	    // JS has no way to express a statically fixed size list, but dart does so we
	    // keep both methods.
	    ListWrapper.createFixedSize = function (size) { return new Array(size); };
	    ListWrapper.createGrowableSize = function (size) { return new Array(size); };
	    ListWrapper.clone = function (array) { return array.slice(0); };
	    ListWrapper.forEachWithIndex = function (array, fn) {
	        for (var i = 0; i < array.length; i++) {
	            fn(array[i], i);
	        }
	    };
	    ListWrapper.first = function (array) {
	        if (!array)
	            return null;
	        return array[0];
	    };
	    ListWrapper.last = function (array) {
	        if (!array || array.length == 0)
	            return null;
	        return array[array.length - 1];
	    };
	    ListWrapper.indexOf = function (array, value, startIndex) {
	        if (startIndex === void 0) { startIndex = 0; }
	        return array.indexOf(value, startIndex);
	    };
	    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
	    ListWrapper.reversed = function (array) {
	        var a = ListWrapper.clone(array);
	        return a.reverse();
	    };
	    ListWrapper.concat = function (a, b) { return a.concat(b); };
	    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
	    ListWrapper.removeAt = function (list, index) {
	        var res = list[index];
	        list.splice(index, 1);
	        return res;
	    };
	    ListWrapper.removeAll = function (list, items) {
	        for (var i = 0; i < items.length; ++i) {
	            var index = list.indexOf(items[i]);
	            list.splice(index, 1);
	        }
	    };
	    ListWrapper.remove = function (list, el) {
	        var index = list.indexOf(el);
	        if (index > -1) {
	            list.splice(index, 1);
	            return true;
	        }
	        return false;
	    };
	    ListWrapper.clear = function (list) { list.length = 0; };
	    ListWrapper.isEmpty = function (list) { return list.length == 0; };
	    ListWrapper.fill = function (list, value, start, end) {
	        if (start === void 0) { start = 0; }
	        if (end === void 0) { end = null; }
	        list.fill(value, start, end === null ? list.length : end);
	    };
	    ListWrapper.equals = function (a, b) {
	        if (a.length != b.length)
	            return false;
	        for (var i = 0; i < a.length; ++i) {
	            if (a[i] !== b[i])
	                return false;
	        }
	        return true;
	    };
	    ListWrapper.slice = function (l, from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = null; }
	        return l.slice(from, to === null ? undefined : to);
	    };
	    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
	    ListWrapper.sort = function (l, compareFn) {
	        if (lang_1.isPresent(compareFn)) {
	            l.sort(compareFn);
	        }
	        else {
	            l.sort();
	        }
	    };
	    ListWrapper.toString = function (l) { return l.toString(); };
	    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
	    ListWrapper.maximum = function (list, predicate) {
	        if (list.length == 0) {
	            return null;
	        }
	        var solution = null;
	        var maxValue = -Infinity;
	        for (var index = 0; index < list.length; index++) {
	            var candidate = list[index];
	            if (lang_1.isBlank(candidate)) {
	                continue;
	            }
	            var candidateValue = predicate(candidate);
	            if (candidateValue > maxValue) {
	                solution = candidate;
	                maxValue = candidateValue;
	            }
	        }
	        return solution;
	    };
	    ListWrapper.flatten = function (list) {
	        var target = [];
	        _flattenArray(list, target);
	        return target;
	    };
	    ListWrapper.addAll = function (list, source) {
	        for (var i = 0; i < source.length; i++) {
	            list.push(source[i]);
	        }
	    };
	    return ListWrapper;
	}());
	exports.ListWrapper = ListWrapper;
	function _flattenArray(source, target) {
	    if (lang_1.isPresent(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (lang_1.isArray(item)) {
	                _flattenArray(item, target);
	            }
	            else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable(obj) {
	    if (!lang_1.isJsObject(obj))
	        return false;
	    return lang_1.isArray(obj) ||
	        (!(obj instanceof exports.Map) &&
	            lang_1.getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	}
	exports.isListLikeIterable = isListLikeIterable;
	function areIterablesEqual(a, b, comparator) {
	    var iterator1 = a[lang_1.getSymbolIterator()]();
	    var iterator2 = b[lang_1.getSymbolIterator()]();
	    while (true) {
	        var item1 = iterator1.next();
	        var item2 = iterator2.next();
	        if (item1.done && item2.done)
	            return true;
	        if (item1.done || item2.done)
	            return false;
	        if (!comparator(item1.value, item2.value))
	            return false;
	    }
	}
	exports.areIterablesEqual = areIterablesEqual;
	function iterateListLike(obj, fn) {
	    if (lang_1.isArray(obj)) {
	        for (var i = 0; i < obj.length; i++) {
	            fn(obj[i]);
	        }
	    }
	    else {
	        var iterator = obj[lang_1.getSymbolIterator()]();
	        var item;
	        while (!((item = iterator.next()).done)) {
	            fn(item.value);
	        }
	    }
	}
	exports.iterateListLike = iterateListLike;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList = (function () {
	    var test = new exports.Set([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) { return new exports.Set(lst); };
	    }
	    else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new exports.Set(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	})();
	var SetWrapper = (function () {
	    function SetWrapper() {
	    }
	    SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };
	    SetWrapper.has = function (s, key) { return s.has(key); };
	    SetWrapper.delete = function (m, k) { m.delete(k); };
	    return SetWrapper;
	}());
	exports.SetWrapper = SetWrapper;
	//# sourceMappingURL=collection.js.map

/***/ },
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(21);
	var observable_1 = __webpack_require__(131);
	var toSubscriber_1 = __webpack_require__(259);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     * @method subscribe
	     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` imple will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(20);
	var PromiseObservable_1 = __webpack_require__(50);
	var toPromise_1 = __webpack_require__(59);
	var lang_1 = __webpack_require__(2);
	var Observable_1 = __webpack_require__(12);
	exports.Observable = Observable_1.Observable;
	var Subject_2 = __webpack_require__(20);
	exports.Subject = Subject_2.Subject;
	var promise_1 = __webpack_require__(203);
	exports.PromiseCompleter = promise_1.PromiseCompleter;
	exports.PromiseWrapper = promise_1.PromiseWrapper;
	var TimerWrapper = (function () {
	    function TimerWrapper() {
	    }
	    TimerWrapper.setTimeout = function (fn, millis) {
	        return lang_1.global.setTimeout(fn, millis);
	    };
	    TimerWrapper.clearTimeout = function (id) { lang_1.global.clearTimeout(id); };
	    TimerWrapper.setInterval = function (fn, millis) {
	        return lang_1.global.setInterval(fn, millis);
	    };
	    TimerWrapper.clearInterval = function (id) { lang_1.global.clearInterval(id); };
	    return TimerWrapper;
	}());
	exports.TimerWrapper = TimerWrapper;
	var ObservableWrapper = (function () {
	    function ObservableWrapper() {
	    }
	    // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	    ObservableWrapper.subscribe = function (emitter, onNext, onError, onComplete) {
	        if (onComplete === void 0) { onComplete = function () { }; }
	        onError = (typeof onError === 'function') && onError || lang_1.noop;
	        onComplete = (typeof onComplete === 'function') && onComplete || lang_1.noop;
	        return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
	    };
	    ObservableWrapper.isObservable = function (obs) { return !!obs.subscribe; };
	    /**
	     * Returns whether `obs` has any subscribers listening to events.
	     */
	    ObservableWrapper.hasSubscribers = function (obs) { return obs.observers.length > 0; };
	    ObservableWrapper.dispose = function (subscription) { subscription.unsubscribe(); };
	    /**
	     * @deprecated - use callEmit() instead
	     */
	    ObservableWrapper.callNext = function (emitter, value) { emitter.emit(value); };
	    ObservableWrapper.callEmit = function (emitter, value) { emitter.emit(value); };
	    ObservableWrapper.callError = function (emitter, error) { emitter.error(error); };
	    ObservableWrapper.callComplete = function (emitter) { emitter.complete(); };
	    ObservableWrapper.fromPromise = function (promise) {
	        return PromiseObservable_1.PromiseObservable.create(promise);
	    };
	    ObservableWrapper.toPromise = function (obj) { return toPromise_1.toPromise.call(obj); };
	    return ObservableWrapper;
	}());
	exports.ObservableWrapper = ObservableWrapper;
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter = (function (_super) {
	    __extends(EventEmitter, _super);
	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */
	    function EventEmitter(isAsync) {
	        if (isAsync === void 0) { isAsync = false; }
	        _super.call(this);
	        this.__isAsync = isAsync;
	    }
	    EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	    /**
	     * @deprecated - use .emit(value) instead
	     */
	    EventEmitter.prototype.next = function (value) { _super.prototype.next.call(this, value); };
	    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	        var schedulerFn;
	        var errorFn = function (err) { return null; };
	        var completeFn = function () { return null; };
	        if (generatorOrNext && typeof generatorOrNext === 'object') {
	            schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                setTimeout(function () { return generatorOrNext.next(value); });
	            } : function (value /** TODO #9100 */) { generatorOrNext.next(value); };
	            if (generatorOrNext.error) {
	                errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                    function (err) { generatorOrNext.error(err); };
	            }
	            if (generatorOrNext.complete) {
	                completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                    function () { generatorOrNext.complete(); };
	            }
	        }
	        else {
	            schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                setTimeout(function () { return generatorOrNext(value); });
	            } : function (value /** TODO #9100 */) { generatorOrNext(value); };
	            if (error) {
	                errorFn =
	                    this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	            }
	            if (complete) {
	                completeFn =
	                    this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	            }
	        }
	        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	    };
	    return EventEmitter;
	}(Subject_1.Subject));
	exports.EventEmitter = EventEmitter;
	//# sourceMappingURL=async.js.map

/***/ },
/* 19 */,
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(12);
	var Subscriber_1 = __webpack_require__(29);
	var Subscription_1 = __webpack_require__(58);
	var SubjectSubscription_1 = __webpack_require__(253);
	var rxSubscriber_1 = __webpack_require__(84);
	var throwError_1 = __webpack_require__(258);
	var ObjectUnsubscribedError_1 = __webpack_require__(256);
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	        this.observers = [];
	        this.isUnsubscribed = false;
	        this.isStopped = false;
	        this.hasErrored = false;
	        this.dispatching = false;
	        this.hasCompleted = false;
	        this.source = source;
	    }
	    Subject.prototype.lift = function (operator) {
	        var subject = new Subject(this.destination || this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.add = function (subscription) {
	        return Subscription_1.Subscription.prototype.add.call(this, subscription);
	    };
	    Subject.prototype.remove = function (subscription) {
	        Subscription_1.Subscription.prototype.remove.call(this, subscription);
	    };
	    Subject.prototype.unsubscribe = function () {
	        Subscription_1.Subscription.prototype.unsubscribe.call(this);
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            if (subscriber.isUnsubscribed) {
	                return;
	            }
	            else if (this.hasErrored) {
	                return subscriber.error(this.errorValue);
	            }
	            else if (this.hasCompleted) {
	                return subscriber.complete();
	            }
	            this.throwIfUnsubscribed();
	            var subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	            this.observers.push(subscriber);
	            return subscription;
	        }
	    };
	    Subject.prototype._unsubscribe = function () {
	        this.source = null;
	        this.isStopped = true;
	        this.observers = null;
	        this.destination = null;
	    };
	    Subject.prototype.next = function (value) {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.dispatching = true;
	        this._next(value);
	        this.dispatching = false;
	        if (this.hasErrored) {
	            this._error(this.errorValue);
	        }
	        else if (this.hasCompleted) {
	            this._complete();
	        }
	    };
	    Subject.prototype.error = function (err) {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.isStopped = true;
	        this.hasErrored = true;
	        this.errorValue = err;
	        if (this.dispatching) {
	            return;
	        }
	        this._error(err);
	    };
	    Subject.prototype.complete = function () {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.isStopped = true;
	        this.hasCompleted = true;
	        if (this.dispatching) {
	            return;
	        }
	        this._complete();
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new SubjectObservable(this);
	        return observable;
	    };
	    Subject.prototype._next = function (value) {
	        if (this.destination) {
	            this.destination.next(value);
	        }
	        else {
	            this._finalNext(value);
	        }
	    };
	    Subject.prototype._finalNext = function (value) {
	        var index = -1;
	        var observers = this.observers.slice(0);
	        var len = observers.length;
	        while (++index < len) {
	            observers[index].next(value);
	        }
	    };
	    Subject.prototype._error = function (err) {
	        if (this.destination) {
	            this.destination.error(err);
	        }
	        else {
	            this._finalError(err);
	        }
	    };
	    Subject.prototype._finalError = function (err) {
	        var index = -1;
	        var observers = this.observers;
	        // optimization to block our SubjectSubscriptions from
	        // splicing themselves out of the observers list one by one.
	        this.observers = null;
	        this.isUnsubscribed = true;
	        if (observers) {
	            var len = observers.length;
	            while (++index < len) {
	                observers[index].error(err);
	            }
	        }
	        this.isUnsubscribed = false;
	        this.unsubscribe();
	    };
	    Subject.prototype._complete = function () {
	        if (this.destination) {
	            this.destination.complete();
	        }
	        else {
	            this._finalComplete();
	        }
	    };
	    Subject.prototype._finalComplete = function () {
	        var index = -1;
	        var observers = this.observers;
	        // optimization to block our SubjectSubscriptions from
	        // splicing themselves out of the observers list one by one.
	        this.observers = null;
	        this.isUnsubscribed = true;
	        if (observers) {
	            var len = observers.length;
	            while (++index < len) {
	                observers[index].complete();
	            }
	        }
	        this.isUnsubscribed = false;
	        this.unsubscribe();
	    };
	    Subject.prototype.throwIfUnsubscribed = function () {
	        if (this.isUnsubscribed) {
	            throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
	        }
	    };
	    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return new Subscriber_1.Subscriber(this);
	    };
	    Subject.create = function (destination, source) {
	        return new Subject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectObservable = (function (_super) {
	    __extends(SubjectObservable, _super);
	    function SubjectObservable(source) {
	        _super.call(this);
	        this.source = source;
	    }
	    return SubjectObservable;
	}(Observable_1.Observable));
	//# sourceMappingURL=Subject.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
	/* tslint:disable:no-unused-variable */
	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = freeGlobal;
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(162)(module), (function() { return this; }())))

/***/ },
/* 22 */,
/* 23 */,
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	/**
	 * @module
	 * @description
	 * The `di` module provides dependency injection container services.
	 */
	var metadata_1 = __webpack_require__(26);
	exports.HostMetadata = metadata_1.HostMetadata;
	exports.InjectMetadata = metadata_1.InjectMetadata;
	exports.InjectableMetadata = metadata_1.InjectableMetadata;
	exports.OptionalMetadata = metadata_1.OptionalMetadata;
	exports.SelfMetadata = metadata_1.SelfMetadata;
	exports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;
	// we have to reexport * because Dart and TS export two different sets of types
	__export(__webpack_require__(25));
	var forward_ref_1 = __webpack_require__(42);
	exports.forwardRef = forward_ref_1.forwardRef;
	exports.resolveForwardRef = forward_ref_1.resolveForwardRef;
	var injector_1 = __webpack_require__(65);
	exports.Injector = injector_1.Injector;
	var reflective_injector_1 = __webpack_require__(109);
	exports.ReflectiveInjector = reflective_injector_1.ReflectiveInjector;
	var provider_1 = __webpack_require__(66);
	exports.Binding = provider_1.Binding;
	exports.ProviderBuilder = provider_1.ProviderBuilder;
	exports.bind = provider_1.bind;
	exports.Provider = provider_1.Provider;
	exports.provide = provider_1.provide;
	var reflective_provider_1 = __webpack_require__(69);
	exports.ResolvedReflectiveFactory = reflective_provider_1.ResolvedReflectiveFactory;
	var reflective_key_1 = __webpack_require__(68);
	exports.ReflectiveKey = reflective_key_1.ReflectiveKey;
	var reflective_exceptions_1 = __webpack_require__(67);
	exports.NoProviderError = reflective_exceptions_1.NoProviderError;
	exports.AbstractProviderError = reflective_exceptions_1.AbstractProviderError;
	exports.CyclicDependencyError = reflective_exceptions_1.CyclicDependencyError;
	exports.InstantiationError = reflective_exceptions_1.InstantiationError;
	exports.InvalidProviderError = reflective_exceptions_1.InvalidProviderError;
	exports.NoAnnotationError = reflective_exceptions_1.NoAnnotationError;
	exports.OutOfBoundsError = reflective_exceptions_1.OutOfBoundsError;
	var opaque_token_1 = __webpack_require__(201);
	exports.OpaqueToken = opaque_token_1.OpaqueToken;
	//# sourceMappingURL=di.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var decorators_1 = __webpack_require__(47);
	var metadata_1 = __webpack_require__(26);
	/**
	 * Factory for creating {@link InjectMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);
	/**
	 * Factory for creating {@link OptionalMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
	/**
	 * Factory for creating {@link InjectableMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
	/**
	 * Factory for creating {@link SelfMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
	/**
	 * Factory for creating {@link HostMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
	/**
	 * Factory for creating {@link SkipSelfMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);
	//# sourceMappingURL=decorators.js.map

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	/**
	 * A parameter metadata that specifies a dependency.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   engine;
	 *   constructor(@Inject("MyEngine") engine:Engine) {
	 *     this.engine = engine;
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([
	 *  {provide: "MyEngine", useClass: Engine},
	 *  Car
	 * ]);
	 *
	 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([Engine, Car]);
	 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var InjectMetadata = (function () {
	    function InjectMetadata(token) {
	        this.token = token;
	    }
	    InjectMetadata.prototype.toString = function () { return "@Inject(" + lang_1.stringify(this.token) + ")"; };
	    return InjectMetadata;
	}());
	exports.InjectMetadata = InjectMetadata;
	/**
	 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
	 * the dependency is not found.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   engine;
	 *   constructor(@Optional() engine:Engine) {
	 *     this.engine = engine;
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([Car]);
	 * expect(injector.get(Car).engine).toBeNull();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var OptionalMetadata = (function () {
	    function OptionalMetadata() {
	    }
	    OptionalMetadata.prototype.toString = function () { return "@Optional()"; };
	    return OptionalMetadata;
	}());
	exports.OptionalMetadata = OptionalMetadata;
	/**
	 * `DependencyMetadata` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 * @ts2dart_const
	 * @stable
	 */
	var DependencyMetadata = (function () {
	    function DependencyMetadata() {
	    }
	    Object.defineProperty(DependencyMetadata.prototype, "token", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return DependencyMetadata;
	}());
	exports.DependencyMetadata = DependencyMetadata;
	/**
	 * A marker metadata that marks a class as available to {@link Injector} for creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))
	 *
	 * ```typescript
	 * @Injectable()
	 * class UsefulService {}
	 *
	 * @Injectable()
	 * class NeedsService {
	 *   constructor(public service:UsefulService) {}
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
	 * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
	 * ```
	 * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
	 * does not have `@Injectable` marker, as shown in the example below.
	 *
	 * ```typescript
	 * class UsefulService {}
	 *
	 * class NeedsService {
	 *   constructor(public service:UsefulService) {}
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
	 * expect(() => injector.get(NeedsService)).toThrowError();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var InjectableMetadata = (function () {
	    function InjectableMetadata() {
	    }
	    return InjectableMetadata;
	}());
	exports.InjectableMetadata = InjectableMetadata;
	/**
	 * Specifies that an {@link Injector} should retrieve a dependency only from itself.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))
	 *
	 * ```typescript
	 * class Dependency {
	 * }
	 *
	 * @Injectable()
	 * class NeedsDependency {
	 *   dependency;
	 *   constructor(@Self() dependency:Dependency) {
	 *     this.dependency = dependency;
	 *   }
	 * }
	 *
	 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
	 * var nd = inj.get(NeedsDependency);
	 *
	 * expect(nd.dependency instanceof Dependency).toBe(true);
	 *
	 * var inj = Injector.resolveAndCreate([Dependency]);
	 * var child = inj.resolveAndCreateChild([NeedsDependency]);
	 * expect(() => child.get(NeedsDependency)).toThrowError();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var SelfMetadata = (function () {
	    function SelfMetadata() {
	    }
	    SelfMetadata.prototype.toString = function () { return "@Self()"; };
	    return SelfMetadata;
	}());
	exports.SelfMetadata = SelfMetadata;
	/**
	 * Specifies that the dependency resolution should start from the parent injector.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))
	 *
	 * ```typescript
	 * class Dependency {
	 * }
	 *
	 * @Injectable()
	 * class NeedsDependency {
	 *   dependency;
	 *   constructor(@SkipSelf() dependency:Dependency) {
	 *     this.dependency = dependency;
	 *   }
	 * }
	 *
	 * var parent = Injector.resolveAndCreate([Dependency]);
	 * var child = parent.resolveAndCreateChild([NeedsDependency]);
	 * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);
	 *
	 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
	 * expect(() => inj.get(NeedsDependency)).toThrowError();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var SkipSelfMetadata = (function () {
	    function SkipSelfMetadata() {
	    }
	    SkipSelfMetadata.prototype.toString = function () { return "@SkipSelf()"; };
	    return SkipSelfMetadata;
	}());
	exports.SkipSelfMetadata = SkipSelfMetadata;
	/**
	 * Specifies that an injector should retrieve a dependency from any injector until reaching the
	 * closest host.
	 *
	 * In Angular, a component element is automatically declared as a host for all the injectors in
	 * its view.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))
	 *
	 * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.
	 * So `ParentCmp` is the host of `ChildDirective`.
	 *
	 * `ChildDirective` depends on two services: `HostService` and `OtherService`.
	 * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.
	 *
	 *```typescript
	 * class OtherService {}
	 * class HostService {}
	 *
	 * @Directive({
	 *   selector: 'child-directive'
	 * })
	 * class ChildDirective {
	 *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){
	 *     console.log("os is null", os);
	 *     console.log("hs is NOT null", hs);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   providers: [HostService],
	 *   template: `
	 *     Dir: <child-directive></child-directive>
	 *   `,
	 *   directives: [ChildDirective]
	 * })
	 * class ParentCmp {
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   providers: [OtherService],
	 *   template: `
	 *     Parent: <parent-cmp></parent-cmp>
	 *   `,
	 *   directives: [ParentCmp]
	 * })
	 * class App {
	 * }
	 *
	 * bootstrap(App);
	 *```
	 * @ts2dart_const
	 * @stable
	 */
	var HostMetadata = (function () {
	    function HostMetadata() {
	    }
	    HostMetadata.prototype.toString = function () { return "@Host()"; };
	    return HostMetadata;
	}());
	exports.HostMetadata = HostMetadata;
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 27 */,
/* 28 */,
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(85);
	var Subscription_1 = __webpack_require__(58);
	var rxSubscriber_1 = __webpack_require__(84);
	var Observer_1 = __webpack_require__(252);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var decorators_1 = __webpack_require__(25);
	var async_1 = __webpack_require__(18);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var reflection_1 = __webpack_require__(46);
	var component_factory_1 = __webpack_require__(112);
	/**
	 * Low-level service for loading {@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 * @experimental
	 */
	var ComponentResolver = (function () {
	    function ComponentResolver() {
	    }
	    return ComponentResolver;
	}());
	exports.ComponentResolver = ComponentResolver;
	function _isComponentFactory(type) {
	    return type instanceof component_factory_1.ComponentFactory;
	}
	var ReflectorComponentResolver = (function (_super) {
	    __extends(ReflectorComponentResolver, _super);
	    function ReflectorComponentResolver() {
	        _super.apply(this, arguments);
	    }
	    ReflectorComponentResolver.prototype.resolveComponent = function (component) {
	        if (lang_1.isString(component)) {
	            return async_1.PromiseWrapper.reject(new exceptions_1.BaseException("Cannot resolve component using '" + component + "'."), null);
	        }
	        var metadatas = reflection_1.reflector.annotations(component);
	        var componentFactory = metadatas.find(_isComponentFactory);
	        if (lang_1.isBlank(componentFactory)) {
	            throw new exceptions_1.BaseException("No precompiled component " + lang_1.stringify(component) + " found");
	        }
	        return async_1.PromiseWrapper.resolve(componentFactory);
	    };
	    ReflectorComponentResolver.prototype.clearCache = function () { };
	    /** @nocollapse */
	    ReflectorComponentResolver.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    return ReflectorComponentResolver;
	}(ComponentResolver));
	exports.ReflectorComponentResolver = ReflectorComponentResolver;
	//# sourceMappingURL=component_resolver.js.map

/***/ },
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationPlayer = (function () {
	    function AnimationPlayer() {
	    }
	    Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
	        get: function () { throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class'); },
	        set: function (player) {
	            throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class');
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationPlayer;
	}());
	exports.AnimationPlayer = AnimationPlayer;
	var NoOpAnimationPlayer = (function () {
	    function NoOpAnimationPlayer() {
	        var _this = this;
	        this._subscriptions = [];
	        this.parentPlayer = null;
	        lang_1.scheduleMicroTask(function () { return _this._onFinish(); });
	    }
	    /** @internal */
	    NoOpAnimationPlayer.prototype._onFinish = function () {
	        this._subscriptions.forEach(function (entry) { entry(); });
	        this._subscriptions = [];
	    };
	    NoOpAnimationPlayer.prototype.onDone = function (fn) { this._subscriptions.push(fn); };
	    NoOpAnimationPlayer.prototype.play = function () { };
	    NoOpAnimationPlayer.prototype.pause = function () { };
	    NoOpAnimationPlayer.prototype.restart = function () { };
	    NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
	    NoOpAnimationPlayer.prototype.destroy = function () { };
	    NoOpAnimationPlayer.prototype.reset = function () { };
	    NoOpAnimationPlayer.prototype.setPosition = function (p /** TODO #9100 */) { };
	    NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
	    return NoOpAnimationPlayer;
	}());
	exports.NoOpAnimationPlayer = NoOpAnimationPlayer;
	//# sourceMappingURL=animation_player.js.map

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var di_1 = __webpack_require__(24);
	/**
	 * A DI Token representing a unique string id assigned to the application by Angular and used
	 * primarily for prefixing application attributes and CSS styles when
	 * {@link ViewEncapsulation#Emulated} is being used.
	 *
	 * If you need to avoid randomly generated value to be used as an application id, you can provide
	 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
	 * using this token.
	 * @experimental
	 */
	exports.APP_ID = new di_1.OpaqueToken('AppId');
	function _appIdRandomProviderFactory() {
	    return "" + _randomChar() + _randomChar() + _randomChar();
	}
	/**
	 * Providers that will generate a random APP_ID_TOKEN.
	 * @experimental
	 */
	exports.APP_ID_RANDOM_PROVIDER = 
	/*@ts2dart_const*/ /* @ts2dart_Provider */ {
	    provide: exports.APP_ID,
	    useFactory: _appIdRandomProviderFactory,
	    deps: []
	};
	function _randomChar() {
	    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));
	}
	/**
	 * A function that will be executed when a platform is initialized.
	 * @experimental
	 */
	exports.PLATFORM_INITIALIZER = 
	/*@ts2dart_const*/ new di_1.OpaqueToken('Platform Initializer');
	/**
	 * A function that will be executed when an application is initialized.
	 * @experimental
	 */
	exports.APP_INITIALIZER = 
	/*@ts2dart_const*/ new di_1.OpaqueToken('Application Initializer');
	/**
	 * A token which indicates the root directory of the application
	 * @experimental
	 */
	exports.PACKAGE_ROOT_URL = 
	/*@ts2dart_const*/ new di_1.OpaqueToken('Application Packages Root URL');
	//# sourceMappingURL=application_tokens.js.map

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var default_iterable_differ_1 = __webpack_require__(63);
	var default_keyvalue_differ_1 = __webpack_require__(104);
	var iterable_differs_1 = __webpack_require__(105);
	var keyvalue_differs_1 = __webpack_require__(106);
	var change_detection_util_1 = __webpack_require__(62);
	exports.SimpleChange = change_detection_util_1.SimpleChange;
	exports.ValueUnwrapper = change_detection_util_1.ValueUnwrapper;
	exports.WrappedValue = change_detection_util_1.WrappedValue;
	exports.devModeEqual = change_detection_util_1.devModeEqual;
	exports.looseIdentical = change_detection_util_1.looseIdentical;
	exports.uninitialized = change_detection_util_1.uninitialized;
	var change_detector_ref_1 = __webpack_require__(199);
	exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
	var constants_1 = __webpack_require__(41);
	exports.CHANGE_DETECTION_STRATEGY_VALUES = constants_1.CHANGE_DETECTION_STRATEGY_VALUES;
	exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
	exports.ChangeDetectorStatus = constants_1.ChangeDetectorStatus;
	exports.isDefaultChangeDetectionStrategy = constants_1.isDefaultChangeDetectionStrategy;
	var default_iterable_differ_2 = __webpack_require__(63);
	exports.CollectionChangeRecord = default_iterable_differ_2.CollectionChangeRecord;
	exports.DefaultIterableDifferFactory = default_iterable_differ_2.DefaultIterableDifferFactory;
	var default_iterable_differ_3 = __webpack_require__(63);
	exports.DefaultIterableDiffer = default_iterable_differ_3.DefaultIterableDiffer;
	var default_keyvalue_differ_2 = __webpack_require__(104);
	exports.DefaultKeyValueDifferFactory = default_keyvalue_differ_2.DefaultKeyValueDifferFactory;
	exports.KeyValueChangeRecord = default_keyvalue_differ_2.KeyValueChangeRecord;
	var iterable_differs_2 = __webpack_require__(105);
	exports.IterableDiffers = iterable_differs_2.IterableDiffers;
	var keyvalue_differs_2 = __webpack_require__(106);
	exports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;
	/**
	 * Structural diffing for `Object`s and `Map`s.
	 */
	exports.keyValDiff = 
	/*@ts2dart_const*/ [new default_keyvalue_differ_1.DefaultKeyValueDifferFactory()];
	/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */
	exports.iterableDiff = 
	/*@ts2dart_const*/ [new default_iterable_differ_1.DefaultIterableDifferFactory()];
	exports.defaultIterableDiffers = new iterable_differs_1.IterableDiffers(exports.iterableDiff);
	exports.defaultKeyValueDiffers = new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff);
	//# sourceMappingURL=change_detection.js.map

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	/**
	 * Describes within the change detector which strategy will be used the next time change
	 * detection is triggered.
	 * @stable
	 */
	(function (ChangeDetectionStrategy) {
	    /**
	     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
	    /**
	     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
	})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
	var ChangeDetectionStrategy = exports.ChangeDetectionStrategy;
	/**
	 * Describes the status of the detector.
	 */
	(function (ChangeDetectorStatus) {
	    /**
	     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
	     * will become `Checked`.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
	    /**
	     * `Checked` means that the change detector should be skipped until its mode changes to
	     * `CheckOnce`.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
	    /**
	     * `CheckAlways` means that after calling detectChanges the mode of the change detector
	     * will remain `CheckAlways`.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
	    /**
	     * `Detached` means that the change detector sub tree is not a part of the main tree and
	     * should be skipped.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
	    /**
	     * `Errored` means that the change detector encountered an error checking a binding
	     * or calling a directive lifecycle method and is now in an inconsistent state. Change
	     * detectors in this state will no longer detect changes.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
	    /**
	     * `Destroyed` means that the change detector is destroyed.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
	})(exports.ChangeDetectorStatus || (exports.ChangeDetectorStatus = {}));
	var ChangeDetectorStatus = exports.ChangeDetectorStatus;
	/**
	 * List of possible {@link ChangeDetectionStrategy} values.
	 */
	exports.CHANGE_DETECTION_STRATEGY_VALUES = [
	    ChangeDetectionStrategy.OnPush,
	    ChangeDetectionStrategy.Default,
	];
	/**
	 * List of possible {@link ChangeDetectorStatus} values.
	 */
	exports.CHANGE_DETECTOR_STATUS_VALUES = [
	    ChangeDetectorStatus.CheckOnce,
	    ChangeDetectorStatus.Checked,
	    ChangeDetectorStatus.CheckAlways,
	    ChangeDetectorStatus.Detached,
	    ChangeDetectorStatus.Errored,
	    ChangeDetectorStatus.Destroyed,
	];
	function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	    return lang_1.isBlank(changeDetectionStrategy) ||
	        changeDetectionStrategy === ChangeDetectionStrategy.Default;
	}
	exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
	//# sourceMappingURL=constants.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	/**
	 * Allows to refer to references which are not yet defined.
	 *
	 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	 * DI is declared,
	 * but not yet defined. It is also used when the `token` which we use when creating a query is not
	 * yet defined.
	 *
	 * ### Example
	 * {@example core/di/ts/forward_ref/forward_ref.ts region='forward_ref'}
	 * @experimental
	 */
	function forwardRef(forwardRefFn) {
	    forwardRefFn.__forward_ref__ = forwardRef;
	    forwardRefFn.toString = function () { return lang_1.stringify(this()); };
	    return forwardRefFn;
	}
	exports.forwardRef = forwardRef;
	/**
	 * Lazily retrieves the reference value from a forwardRef.
	 *
	 * Acts as the identity function when given a non-forward-ref value.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	 *
	 * ```typescript
	 * var ref = forwardRef(() => "refValue");
	 * expect(resolveForwardRef(ref)).toEqual("refValue");
	 * expect(resolveForwardRef("regularValue")).toEqual("regularValue");
	 * ```
	 *
	 * See: {@link forwardRef}
	 * @experimental
	 */
	function resolveForwardRef(type) {
	    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') &&
	        type.__forward_ref__ === forwardRef) {
	        return type();
	    }
	    else {
	        return type;
	    }
	}
	exports.resolveForwardRef = resolveForwardRef;
	//# sourceMappingURL=forward_ref.js.map

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	(function (ViewType) {
	    // A view that contains the host element with bound component directive.
	    // Contains a COMPONENT view
	    ViewType[ViewType["HOST"] = 0] = "HOST";
	    // The view of the component
	    // Can contain 0 to n EMBEDDED views
	    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
	    // A view that is embedded into another View via a <template> element
	    // inside of a COMPONENT view
	    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
	})(exports.ViewType || (exports.ViewType = {}));
	var ViewType = exports.ViewType;
	//# sourceMappingURL=view_type.js.map

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var application_tokens_1 = __webpack_require__(39);
	var change_detection_1 = __webpack_require__(40);
	var change_detection_util_1 = __webpack_require__(62);
	var decorators_1 = __webpack_require__(25);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var api_1 = __webpack_require__(75);
	var security_1 = __webpack_require__(124);
	var element_1 = __webpack_require__(71);
	var exceptions_2 = __webpack_require__(72);
	var ViewUtils = (function () {
	    function ViewUtils(_renderer, _appId, sanitizer) {
	        this._renderer = _renderer;
	        this._appId = _appId;
	        this._nextCompTypeId = 0;
	        this.sanitizer = sanitizer;
	    }
	    /**
	     * Used by the generated code
	     */
	    ViewUtils.prototype.createRenderComponentType = function (templateUrl, slotCount, encapsulation, styles) {
	        return new api_1.RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles);
	    };
	    /** @internal */
	    ViewUtils.prototype.renderComponent = function (renderComponentType) {
	        return this._renderer.renderComponent(renderComponentType);
	    };
	    /** @nocollapse */
	    ViewUtils.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    ViewUtils.ctorParameters = [
	        { type: api_1.RootRenderer, },
	        { type: undefined, decorators: [{ type: decorators_1.Inject, args: [application_tokens_1.APP_ID,] },] },
	        { type: security_1.SanitizationService, },
	    ];
	    return ViewUtils;
	}());
	exports.ViewUtils = ViewUtils;
	function flattenNestedViewRenderNodes(nodes) {
	    return _flattenNestedViewRenderNodes(nodes, []);
	}
	exports.flattenNestedViewRenderNodes = flattenNestedViewRenderNodes;
	function _flattenNestedViewRenderNodes(nodes, renderNodes) {
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node instanceof element_1.AppElement) {
	            var appEl = node;
	            renderNodes.push(appEl.nativeElement);
	            if (lang_1.isPresent(appEl.nestedViews)) {
	                for (var k = 0; k < appEl.nestedViews.length; k++) {
	                    _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
	                }
	            }
	        }
	        else {
	            renderNodes.push(node);
	        }
	    }
	    return renderNodes;
	}
	var EMPTY_ARR = [];
	function ensureSlotCount(projectableNodes, expectedSlotCount) {
	    var res;
	    if (lang_1.isBlank(projectableNodes)) {
	        res = EMPTY_ARR;
	    }
	    else if (projectableNodes.length < expectedSlotCount) {
	        var givenSlotCount = projectableNodes.length;
	        res = collection_1.ListWrapper.createFixedSize(expectedSlotCount);
	        for (var i = 0; i < expectedSlotCount; i++) {
	            res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
	        }
	    }
	    else {
	        res = projectableNodes;
	    }
	    return res;
	}
	exports.ensureSlotCount = ensureSlotCount;
	exports.MAX_INTERPOLATION_VALUES = 9;
	function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	    switch (valueCount) {
	        case 1:
	            return c0 + _toStringWithNull(a1) + c1;
	        case 2:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	        case 3:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3;
	        case 4:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4;
	        case 5:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	        case 6:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	        case 7:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7;
	        case 8:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	        case 9:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	        default:
	            throw new exceptions_1.BaseException("Does not support more than 9 expressions");
	    }
	}
	exports.interpolate = interpolate;
	function _toStringWithNull(v) {
	    return v != null ? v.toString() : '';
	}
	function checkBinding(throwOnChange, oldValue, newValue) {
	    if (throwOnChange) {
	        if (!change_detection_1.devModeEqual(oldValue, newValue)) {
	            throw new exceptions_2.ExpressionChangedAfterItHasBeenCheckedException(oldValue, newValue, null);
	        }
	        return false;
	    }
	    else {
	        return !lang_1.looseIdentical(oldValue, newValue);
	    }
	}
	exports.checkBinding = checkBinding;
	function arrayLooseIdentical(a, b) {
	    if (a.length != b.length)
	        return false;
	    for (var i = 0; i < a.length; ++i) {
	        if (!lang_1.looseIdentical(a[i], b[i]))
	            return false;
	    }
	    return true;
	}
	exports.arrayLooseIdentical = arrayLooseIdentical;
	function mapLooseIdentical(m1, m2) {
	    var k1 = collection_1.StringMapWrapper.keys(m1);
	    var k2 = collection_1.StringMapWrapper.keys(m2);
	    if (k1.length != k2.length) {
	        return false;
	    }
	    var key;
	    for (var i = 0; i < k1.length; i++) {
	        key = k1[i];
	        if (!lang_1.looseIdentical(m1[key], m2[key])) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.mapLooseIdentical = mapLooseIdentical;
	function castByValue(input, value) {
	    return input;
	}
	exports.castByValue = castByValue;
	exports.EMPTY_ARRAY = [];
	exports.EMPTY_MAP = {};
	function pureProxy1(fn) {
	    var result;
	    var v0;
	    v0 = change_detection_util_1.uninitialized;
	    return function (p0) {
	        if (!lang_1.looseIdentical(v0, p0)) {
	            v0 = p0;
	            result = fn(p0);
	        }
	        return result;
	    };
	}
	exports.pureProxy1 = pureProxy1;
	function pureProxy2(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1;
	    v0 = v1 = change_detection_util_1.uninitialized;
	    return function (p0, p1) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1)) {
	            v0 = p0;
	            v1 = p1;
	            result = fn(p0, p1);
	        }
	        return result;
	    };
	}
	exports.pureProxy2 = pureProxy2;
	function pureProxy3(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2;
	    v0 = v1 = v2 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            result = fn(p0, p1, p2);
	        }
	        return result;
	    };
	}
	exports.pureProxy3 = pureProxy3;
	function pureProxy4(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3;
	    v0 = v1 = v2 = v3 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2, p3) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            result = fn(p0, p1, p2, p3);
	        }
	        return result;
	    };
	}
	exports.pureProxy4 = pureProxy4;
	function pureProxy5(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4;
	    v0 = v1 = v2 = v3 = v4 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2, p3, p4) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            result = fn(p0, p1, p2, p3, p4);
	        }
	        return result;
	    };
	}
	exports.pureProxy5 = pureProxy5;
	function pureProxy6(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5;
	    v0 = v1 = v2 = v3 = v4 = v5 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2, p3, p4, p5) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            result = fn(p0, p1, p2, p3, p4, p5);
	        }
	        return result;
	    };
	}
	exports.pureProxy6 = pureProxy6;
	function pureProxy7(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            result = fn(p0, p1, p2, p3, p4, p5, p6);
	        }
	        return result;
	    };
	}
	exports.pureProxy7 = pureProxy7;
	function pureProxy8(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6 /** TODO #9100 */, v7;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
	        }
	        return result;
	    };
	}
	exports.pureProxy8 = pureProxy8;
	function pureProxy9(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6 /** TODO #9100 */, v7 /** TODO #9100 */, v8;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            v8 = p8;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
	        }
	        return result;
	    };
	}
	exports.pureProxy9 = pureProxy9;
	function pureProxy10(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6 /** TODO #9100 */, v7 /** TODO #9100 */, v8 /** TODO #9100 */, v9;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = change_detection_util_1.uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8) ||
	            !lang_1.looseIdentical(v9, p9)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            v8 = p8;
	            v9 = p9;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	        }
	        return result;
	    };
	}
	exports.pureProxy10 = pureProxy10;
	//# sourceMappingURL=view_utils.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var wtf_impl_1 = __webpack_require__(213);
	// Change exports to const once https://github.com/angular/ts2dart/issues/150
	/**
	 * True if WTF is enabled.
	 */
	exports.wtfEnabled = wtf_impl_1.detectWTF();
	function noopScope(arg0, arg1) {
	    return null;
	}
	/**
	 * Create trace scope.
	 *
	 * Scopes must be strictly nested and are analogous to stack frames, but
	 * do not have to follow the stack frames. Instead it is recommended that they follow logical
	 * nesting. You may want to use
	 * [Event
	 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	 * as they are defined in WTF.
	 *
	 * Used to mark scope entry. The return value is used to leave the scope.
	 *
	 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	 *
	 *     someMethod() {
	 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	 *        // DO SOME WORK HERE
	 *        return wtfLeave(s, 123); // Return value 123
	 *     }
	 *
	 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	 * negatively impact the performance of your application. For this reason we recommend that
	 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	 * exception, will produce incorrect trace, but presence of exception signifies logic error which
	 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	 * an exception is expected during normal execution while profiling.
	 *
	 * @experimental
	 */
	exports.wtfCreateScope = exports.wtfEnabled ? wtf_impl_1.createScope : function (signature, flags) { return noopScope; };
	/**
	 * Used to mark end of Scope.
	 *
	 * - `scope` to end.
	 * - `returnValue` (optional) to be passed to the WTF.
	 *
	 * Returns the `returnValue for easy chaining.
	 * @experimental
	 */
	exports.wtfLeave = exports.wtfEnabled ? wtf_impl_1.leave : function (s, r) { return r; };
	/**
	 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	 * enabled.
	 *
	 *     someMethod() {
	 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	 *        var future = new Future.delay(5).then((_) {
	 *          wtfEndTimeRange(s);
	 *        });
	 *     }
	 * @experimental
	 */
	exports.wtfStartTimeRange = exports.wtfEnabled ? wtf_impl_1.startTimeRange : function (rangeType, action) { return null; };
	/**
	 * Ends a async time range operation.
	 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	 * enabled.
	 * @experimental
	 */
	exports.wtfEndTimeRange = exports.wtfEnabled ? wtf_impl_1.endTimeRange : function (r) { return null; };
	//# sourceMappingURL=profile.js.map

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var reflection_capabilities_1 = __webpack_require__(122);
	var reflector_1 = __webpack_require__(123);
	var reflector_2 = __webpack_require__(123);
	exports.ReflectionInfo = reflector_2.ReflectionInfo;
	exports.Reflector = reflector_2.Reflector;
	/**
	 * The {@link Reflector} used internally in Angular to access metadata
	 * about symbols.
	 */
	exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());
	//# sourceMappingURL=reflection.js.map

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var _nextClassId = 0;
	function extractAnnotation(annotation) {
	    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
	        // it is a decorator, extract annotation
	        annotation = annotation.annotation;
	    }
	    return annotation;
	}
	function applyParams(fnOrArray, key) {
	    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	        fnOrArray === Number || fnOrArray === Array) {
	        throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
	    }
	    if (lang_1.isFunction(fnOrArray)) {
	        return fnOrArray;
	    }
	    else if (fnOrArray instanceof Array) {
	        var annotations = fnOrArray;
	        var fn = fnOrArray[fnOrArray.length - 1];
	        if (!lang_1.isFunction(fn)) {
	            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
	        }
	        var annoLength = annotations.length - 1;
	        if (annoLength != fn.length) {
	            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
	        }
	        var paramsAnnotations = [];
	        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
	            var paramAnnotations = [];
	            paramsAnnotations.push(paramAnnotations);
	            var annotation = annotations[i];
	            if (annotation instanceof Array) {
	                for (var j = 0; j < annotation.length; j++) {
	                    paramAnnotations.push(extractAnnotation(annotation[j]));
	                }
	            }
	            else if (lang_1.isFunction(annotation)) {
	                paramAnnotations.push(extractAnnotation(annotation));
	            }
	            else {
	                paramAnnotations.push(annotation);
	            }
	        }
	        Reflect.defineMetadata('parameters', paramsAnnotations, fn);
	        return fn;
	    }
	    else {
	        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
	    }
	}
	/**
	 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	 *
	 * ## Basic Example
	 *
	 * ```
	 * var Greeter = ng.Class({
	 *   constructor: function(name) {
	 *     this.name = name;
	 *   },
	 *
	 *   greet: function() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class Greeter {
	 *   constructor(name) {
	 *     this.name = name;
	 *   }
	 *
	 *   greet() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * }
	 * ```
	 *
	 * or equivalent to ES5:
	 *
	 * ```
	 * var Greeter = function (name) {
	 *   this.name = name;
	 * }
	 *
	 * Greeter.prototype.greet = function () {
	 *   alert('Hello ' + this.name + '!');
	 * }
	 * ```
	 *
	 * ### Example with parameter annotations
	 *
	 * ```
	 * var MyService = ng.Class({
	 *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
	 *     ...
	 *   }]
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class MyService {
	 *   constructor(name: string, @Query() queryList: QueryList) {
	 *     ...
	 *   }
	 * }
	 * ```
	 *
	 * ### Example with inheritance
	 *
	 * ```
	 * var Shape = ng.Class({
	 *   constructor: (color) {
	 *     this.color = color;
	 *   }
	 * });
	 *
	 * var Square = ng.Class({
	 *   extends: Shape,
	 *   constructor: function(color, size) {
	 *     Shape.call(this, color);
	 *     this.size = size;
	 *   }
	 * });
	 * ```
	 * @stable
	 */
	function Class(clsDef) {
	    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	    var proto = constructor.prototype;
	    if (clsDef.hasOwnProperty('extends')) {
	        if (lang_1.isFunction(clsDef.extends)) {
	            constructor.prototype = proto =
	                Object.create(clsDef.extends.prototype);
	        }
	        else {
	            throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
	        }
	    }
	    for (var key in clsDef) {
	        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
	            proto[key] = applyParams(clsDef[key], key);
	        }
	    }
	    if (this && this.annotations instanceof Array) {
	        Reflect.defineMetadata('annotations', this.annotations, constructor);
	    }
	    if (!constructor['name']) {
	        constructor['overriddenName'] = "class" + _nextClassId++;
	    }
	    return constructor;
	}
	exports.Class = Class;
	var Reflect = lang_1.global.Reflect;
	// Throw statement at top-level is disallowed by closure compiler in ES6 input.
	// Wrap in an IIFE as a work-around.
	(function checkReflect() {
	    if (!(Reflect && Reflect.getMetadata)) {
	        throw 'reflect-metadata shim is required when using class decorators';
	    }
	})();
	function makeDecorator(annotationCls /* TODO #9100 */, chainFn) {
	    if (chainFn === void 0) { chainFn = null; }
	    function DecoratorFactory(objOrType /** TODO #9100 */) {
	        var annotationInstance = new annotationCls(objOrType);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        }
	        else {
	            var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
	            chainAnnotation.push(annotationInstance);
	            var TypeDecorator = function TypeDecorator(cls /** TODO #9100 */) {
	                var annotations = Reflect.getOwnMetadata('annotations', cls);
	                annotations = annotations || [];
	                annotations.push(annotationInstance);
	                Reflect.defineMetadata('annotations', annotations, cls);
	                return cls;
	            };
	            TypeDecorator.annotations = chainAnnotation;
	            TypeDecorator.Class = Class;
	            if (chainFn)
	                chainFn(TypeDecorator);
	            return TypeDecorator;
	        }
	    }
	    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    DecoratorFactory.annotationCls = annotationCls;
	    return DecoratorFactory;
	}
	exports.makeDecorator = makeDecorator;
	function makeParamDecorator(annotationCls /** TODO #9100 */) {
	    function ParamDecoratorFactory() {
	        var args = []; /** TODO #9100 */
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var annotationInstance = Object.create(annotationCls.prototype);
	        annotationCls.apply(annotationInstance, args);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        }
	        else {
	            ParamDecorator.annotation = annotationInstance;
	            return ParamDecorator;
	        }
	        function ParamDecorator(cls /** TODO #9100 */, unusedKey /** TODO #9100 */, index /** TODO #9100 */) {
	            var parameters = Reflect.getMetadata('parameters', cls);
	            parameters = parameters || [];
	            // there might be gaps if some in between parameters do not have annotations.
	            // we pad with nulls.
	            while (parameters.length <= index) {
	                parameters.push(null);
	            }
	            parameters[index] = parameters[index] || [];
	            var annotationsForParam = parameters[index];
	            annotationsForParam.push(annotationInstance);
	            Reflect.defineMetadata('parameters', parameters, cls);
	            return cls;
	        }
	    }
	    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    ParamDecoratorFactory.annotationCls = annotationCls;
	    return ParamDecoratorFactory;
	}
	exports.makeParamDecorator = makeParamDecorator;
	function makePropDecorator(annotationCls /** TODO #9100 */) {
	    function PropDecoratorFactory() {
	        var args = []; /** TODO #9100 */
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var decoratorInstance = Object.create(annotationCls.prototype);
	        annotationCls.apply(decoratorInstance, args);
	        if (this instanceof annotationCls) {
	            return decoratorInstance;
	        }
	        else {
	            return function PropDecorator(target, name) {
	                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor);
	                meta = meta || {};
	                meta[name] = meta[name] || [];
	                meta[name].unshift(decoratorInstance);
	                Reflect.defineMetadata('propMetadata', meta, target.constructor);
	            };
	        }
	    }
	    PropDecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    PropDecoratorFactory.annotationCls = annotationCls;
	    return PropDecoratorFactory;
	}
	exports.makePropDecorator = makePropDecorator;
	//# sourceMappingURL=decorators.js.map

/***/ },
/* 48 */,
/* 49 */,
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(21);
	var Observable_1 = __webpack_require__(12);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = (function (_super) {
	    __extends(PromiseObservable, _super);
	    function PromiseObservable(promise, scheduler) {
	        if (scheduler === void 0) { scheduler = null; }
	        _super.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	    }
	    /**
	     * @param promise
	     * @param scheduler
	     * @return {PromiseObservable}
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */
	    PromiseObservable.create = function (promise, scheduler) {
	        if (scheduler === void 0) { scheduler = null; }
	        return new PromiseObservable(promise, scheduler);
	    };
	    PromiseObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var promise = this.promise;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            if (this._isScalar) {
	                if (!subscriber.isUnsubscribed) {
	                    subscriber.next(this.value);
	                    subscriber.complete();
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.next(value);
	                        subscriber.complete();
	                    }
	                }, function (err) {
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.error(err);
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	        else {
	            if (this._isScalar) {
	                if (!subscriber.isUnsubscribed) {
	                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }
	                }, function (err) {
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	    };
	    return PromiseObservable;
	}(Observable_1.Observable));
	exports.PromiseObservable = PromiseObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subscriber = arg.subscriber;
	    if (!subscriber.isUnsubscribed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError(arg) {
	    var err = arg.err, subscriber = arg.subscriber;
	    if (!subscriber.isUnsubscribed) {
	        subscriber.error(err);
	    }
	}
	//# sourceMappingURL=PromiseObservable.js.map

/***/ },
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(132);
	var isObject_1 = __webpack_require__(160);
	var isFunction_1 = __webpack_require__(85);
	var tryCatch_1 = __webpack_require__(161);
	var errorObject_1 = __webpack_require__(97);
	var UnsubscriptionError_1 = __webpack_require__(257);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.isUnsubscribed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `isUnsubscribed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
	            return;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.isUnsubscribed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.isUnsubscribed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(21);
	/**
	 * @param PromiseCtor
	 * @return {Promise<T>}
	 * @method toPromise
	 * @owner Observable
	 */
	function toPromise(PromiseCtor) {
	    var _this = this;
	    if (!PromiseCtor) {
	        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	            PromiseCtor = root_1.root.Rx.config.Promise;
	        }
	        else if (root_1.root.Promise) {
	            PromiseCtor = root_1.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value;
	        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	    });
	}
	exports.toPromise = toPromise;
	//# sourceMappingURL=toPromise.js.map

/***/ },
/* 60 */,
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(18);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var application_tokens_1 = __webpack_require__(39);
	var console_1 = __webpack_require__(64);
	var di_1 = __webpack_require__(24);
	var component_resolver_1 = __webpack_require__(30);
	var profile_1 = __webpack_require__(45);
	var testability_1 = __webpack_require__(76);
	var ng_zone_1 = __webpack_require__(77);
	/**
	 * Create an Angular zone.
	 * @experimental
	 */
	function createNgZone() {
	    return new ng_zone_1.NgZone({ enableLongStackTrace: isDevMode() });
	}
	exports.createNgZone = createNgZone;
	var _devMode = true;
	var _runModeLocked = false;
	var _platform;
	var _inPlatformCreate = false;
	/**
	 * Disable Angular's development mode, which turns off assertions and other
	 * checks within the framework.
	 *
	 * One important assertion this disables verifies that a change detection pass
	 * does not result in additional changes to any bindings (also known as
	 * unidirectional data flow).
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function enableProdMode() {
	    if (_runModeLocked) {
	        // Cannot use BaseException as that ends up importing from facade/lang.
	        throw new exceptions_1.BaseException('Cannot enable prod mode after platform setup.');
	    }
	    _devMode = false;
	}
	exports.enableProdMode = enableProdMode;
	/**
	 * Returns whether Angular is in development mode.
	 * This can only be read after `lockRunMode` has been called.
	 *
	 * By default, this is true, unless a user calls `enableProdMode`.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function isDevMode() {
	    if (!_runModeLocked) {
	        throw new exceptions_1.BaseException("Dev mode can't be read before bootstrap!");
	    }
	    return _devMode;
	}
	exports.isDevMode = isDevMode;
	/**
	 * Locks the run mode of Angular. After this has been called,
	 * it can't be changed any more. I.e. `isDevMode()` will always
	 * return the same value.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function lockRunMode() {
	    _runModeLocked = true;
	}
	exports.lockRunMode = lockRunMode;
	/**
	 * Creates a platform.
	 * Platforms have to be eagerly created via this function.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function createPlatform(injector) {
	    if (_inPlatformCreate) {
	        throw new exceptions_1.BaseException('Already creating a platform...');
	    }
	    if (lang_1.isPresent(_platform) && !_platform.disposed) {
	        throw new exceptions_1.BaseException('There can be only one platform. Destroy the previous one to create a new one.');
	    }
	    lockRunMode();
	    _inPlatformCreate = true;
	    try {
	        _platform = injector.get(PlatformRef);
	    }
	    finally {
	        _inPlatformCreate = false;
	    }
	    return _platform;
	}
	exports.createPlatform = createPlatform;
	/**
	 * Checks that there currently is a platform
	 * which contains the given token as a provider.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function assertPlatform(requiredToken) {
	    var platform = getPlatform();
	    if (lang_1.isBlank(platform)) {
	        throw new exceptions_1.BaseException('No platform exists!');
	    }
	    if (lang_1.isPresent(platform) && lang_1.isBlank(platform.injector.get(requiredToken, null))) {
	        throw new exceptions_1.BaseException('A platform with a different configuration has been created. Please destroy it first.');
	    }
	    return platform;
	}
	exports.assertPlatform = assertPlatform;
	/**
	 * Dispose the existing platform.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function disposePlatform() {
	    if (lang_1.isPresent(_platform) && !_platform.disposed) {
	        _platform.dispose();
	    }
	}
	exports.disposePlatform = disposePlatform;
	/**
	 * Returns the current platform.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function getPlatform() {
	    return lang_1.isPresent(_platform) && !_platform.disposed ? _platform : null;
	}
	exports.getPlatform = getPlatform;
	/**
	 * Shortcut for ApplicationRef.bootstrap.
	 * Requires a platform to be created first.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function coreBootstrap(componentFactory, injector) {
	    var appRef = injector.get(ApplicationRef);
	    return appRef.bootstrap(componentFactory);
	}
	exports.coreBootstrap = coreBootstrap;
	/**
	 * Resolves the componentFactory for the given component,
	 * waits for asynchronous initializers and bootstraps the component.
	 * Requires a platform to be created first.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function coreLoadAndBootstrap(componentType, injector) {
	    var appRef = injector.get(ApplicationRef);
	    return appRef.run(function () {
	        var componentResolver = injector.get(component_resolver_1.ComponentResolver);
	        return async_1.PromiseWrapper
	            .all([componentResolver.resolveComponent(componentType), appRef.waitForAsyncInitializers()])
	            .then(function (arr) { return appRef.bootstrap(arr[0]); });
	    });
	}
	exports.coreLoadAndBootstrap = coreLoadAndBootstrap;
	/**
	 * The Angular platform is the entry point for Angular on a web page. Each page
	 * has exactly one platform, and services (such as reflection) which are common
	 * to every Angular application running on the page are bound in its scope.
	 *
	 * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
	 * explicitly by calling {@link createPlatform}().
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	var PlatformRef = (function () {
	    function PlatformRef() {
	    }
	    Object.defineProperty(PlatformRef.prototype, "injector", {
	        /**
	         * Retrieve the platform {@link Injector}, which is the parent injector for
	         * every Angular application on the page and provides singleton providers.
	         */
	        get: function () { throw exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(PlatformRef.prototype, "disposed", {
	        get: function () { throw exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return PlatformRef;
	}());
	exports.PlatformRef = PlatformRef;
	var PlatformRef_ = (function (_super) {
	    __extends(PlatformRef_, _super);
	    function PlatformRef_(_injector) {
	        _super.call(this);
	        this._injector = _injector;
	        /** @internal */
	        this._applications = [];
	        /** @internal */
	        this._disposeListeners = [];
	        this._disposed = false;
	        if (!_inPlatformCreate) {
	            throw new exceptions_1.BaseException('Platforms have to be created via `createPlatform`!');
	        }
	        var inits = _injector.get(application_tokens_1.PLATFORM_INITIALIZER, null);
	        if (lang_1.isPresent(inits))
	            inits.forEach(function (init) { return init(); });
	    }
	    PlatformRef_.prototype.registerDisposeListener = function (dispose) { this._disposeListeners.push(dispose); };
	    Object.defineProperty(PlatformRef_.prototype, "injector", {
	        get: function () { return this._injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformRef_.prototype, "disposed", {
	        get: function () { return this._disposed; },
	        enumerable: true,
	        configurable: true
	    });
	    PlatformRef_.prototype.addApplication = function (appRef) { this._applications.push(appRef); };
	    PlatformRef_.prototype.dispose = function () {
	        collection_1.ListWrapper.clone(this._applications).forEach(function (app) { return app.dispose(); });
	        this._disposeListeners.forEach(function (dispose) { return dispose(); });
	        this._disposed = true;
	    };
	    /** @internal */
	    PlatformRef_.prototype._applicationDisposed = function (app) { collection_1.ListWrapper.remove(this._applications, app); };
	    /** @nocollapse */
	    PlatformRef_.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    PlatformRef_.ctorParameters = [
	        { type: di_1.Injector, },
	    ];
	    return PlatformRef_;
	}(PlatformRef));
	exports.PlatformRef_ = PlatformRef_;
	/**
	 * A reference to an Angular application running on a page.
	 *
	 * For more about Angular applications, see the documentation for {@link bootstrap}.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	var ApplicationRef = (function () {
	    function ApplicationRef() {
	    }
	    Object.defineProperty(ApplicationRef.prototype, "injector", {
	        /**
	         * Retrieve the application {@link Injector}.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ApplicationRef.prototype, "zone", {
	        /**
	         * Retrieve the application {@link NgZone}.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
	        /**
	         * Get a list of component types registered to this application.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    return ApplicationRef;
	}());
	exports.ApplicationRef = ApplicationRef;
	var ApplicationRef_ = (function (_super) {
	    __extends(ApplicationRef_, _super);
	    function ApplicationRef_(_platform, _zone, _injector) {
	        var _this = this;
	        _super.call(this);
	        this._platform = _platform;
	        this._zone = _zone;
	        this._injector = _injector;
	        /** @internal */
	        this._bootstrapListeners = [];
	        /** @internal */
	        this._disposeListeners = [];
	        /** @internal */
	        this._rootComponents = [];
	        /** @internal */
	        this._rootComponentTypes = [];
	        /** @internal */
	        this._changeDetectorRefs = [];
	        /** @internal */
	        this._runningTick = false;
	        /** @internal */
	        this._enforceNoNewChanges = false;
	        var zone = _injector.get(ng_zone_1.NgZone);
	        this._enforceNoNewChanges = isDevMode();
	        zone.run(function () { _this._exceptionHandler = _injector.get(exceptions_1.ExceptionHandler); });
	        this._asyncInitDonePromise = this.run(function () {
	            var inits = _injector.get(application_tokens_1.APP_INITIALIZER, null);
	            var asyncInitResults = [];
	            var asyncInitDonePromise;
	            if (lang_1.isPresent(inits)) {
	                for (var i = 0; i < inits.length; i++) {
	                    var initResult = inits[i]();
	                    if (lang_1.isPromise(initResult)) {
	                        asyncInitResults.push(initResult);
	                    }
	                }
	            }
	            if (asyncInitResults.length > 0) {
	                asyncInitDonePromise =
	                    async_1.PromiseWrapper.all(asyncInitResults).then(function (_) { return _this._asyncInitDone = true; });
	                _this._asyncInitDone = false;
	            }
	            else {
	                _this._asyncInitDone = true;
	                asyncInitDonePromise = async_1.PromiseWrapper.resolve(true);
	            }
	            return asyncInitDonePromise;
	        });
	        async_1.ObservableWrapper.subscribe(zone.onError, function (error) {
	            _this._exceptionHandler.call(error.error, error.stackTrace);
	        });
	        async_1.ObservableWrapper.subscribe(this._zone.onMicrotaskEmpty, function (_) { _this._zone.run(function () { _this.tick(); }); });
	    }
	    ApplicationRef_.prototype.registerBootstrapListener = function (listener) {
	        this._bootstrapListeners.push(listener);
	    };
	    ApplicationRef_.prototype.registerDisposeListener = function (dispose) { this._disposeListeners.push(dispose); };
	    ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {
	        this._changeDetectorRefs.push(changeDetector);
	    };
	    ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {
	        collection_1.ListWrapper.remove(this._changeDetectorRefs, changeDetector);
	    };
	    ApplicationRef_.prototype.waitForAsyncInitializers = function () { return this._asyncInitDonePromise; };
	    ApplicationRef_.prototype.run = function (callback) {
	        var _this = this;
	        var zone = this.injector.get(ng_zone_1.NgZone);
	        var result;
	        // Note: Don't use zone.runGuarded as we want to know about
	        // the thrown exception!
	        // Note: the completer needs to be created outside
	        // of `zone.run` as Dart swallows rejected promises
	        // via the onError callback of the promise.
	        var completer = async_1.PromiseWrapper.completer();
	        zone.run(function () {
	            try {
	                result = callback();
	                if (lang_1.isPromise(result)) {
	                    async_1.PromiseWrapper.then(result, function (ref) { completer.resolve(ref); }, function (err, stackTrace) {
	                        completer.reject(err, stackTrace);
	                        _this._exceptionHandler.call(err, stackTrace);
	                    });
	                }
	            }
	            catch (e) {
	                _this._exceptionHandler.call(e, e.stack);
	                throw e;
	            }
	        });
	        return lang_1.isPromise(result) ? completer.promise : result;
	    };
	    ApplicationRef_.prototype.bootstrap = function (componentFactory) {
	        var _this = this;
	        if (!this._asyncInitDone) {
	            throw new exceptions_1.BaseException('Cannot bootstrap as there are still asynchronous initializers running. Wait for them using waitForAsyncInitializers().');
	        }
	        return this.run(function () {
	            _this._rootComponentTypes.push(componentFactory.componentType);
	            var compRef = componentFactory.create(_this._injector, [], componentFactory.selector);
	            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
	            var testability = compRef.injector.get(testability_1.Testability, null);
	            if (lang_1.isPresent(testability)) {
	                compRef.injector.get(testability_1.TestabilityRegistry)
	                    .registerApplication(compRef.location.nativeElement, testability);
	            }
	            _this._loadComponent(compRef);
	            var c = _this._injector.get(console_1.Console);
	            if (isDevMode()) {
	                var prodDescription = lang_1.IS_DART ? 'Production mode is disabled in Dart.' :
	                    'Call enableProdMode() to enable the production mode.';
	                c.log("Angular 2 is running in the development mode. " + prodDescription);
	            }
	            return compRef;
	        });
	    };
	    /** @internal */
	    ApplicationRef_.prototype._loadComponent = function (componentRef) {
	        this._changeDetectorRefs.push(componentRef.changeDetectorRef);
	        this.tick();
	        this._rootComponents.push(componentRef);
	        this._bootstrapListeners.forEach(function (listener) { return listener(componentRef); });
	    };
	    /** @internal */
	    ApplicationRef_.prototype._unloadComponent = function (componentRef) {
	        if (!collection_1.ListWrapper.contains(this._rootComponents, componentRef)) {
	            return;
	        }
	        this.unregisterChangeDetector(componentRef.changeDetectorRef);
	        collection_1.ListWrapper.remove(this._rootComponents, componentRef);
	    };
	    Object.defineProperty(ApplicationRef_.prototype, "injector", {
	        get: function () { return this._injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "zone", {
	        get: function () { return this._zone; },
	        enumerable: true,
	        configurable: true
	    });
	    ApplicationRef_.prototype.tick = function () {
	        if (this._runningTick) {
	            throw new exceptions_1.BaseException('ApplicationRef.tick is called recursively');
	        }
	        var s = ApplicationRef_._tickScope();
	        try {
	            this._runningTick = true;
	            this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });
	            if (this._enforceNoNewChanges) {
	                this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });
	            }
	        }
	        finally {
	            this._runningTick = false;
	            profile_1.wtfLeave(s);
	        }
	    };
	    ApplicationRef_.prototype.dispose = function () {
	        // TODO(alxhub): Dispose of the NgZone.
	        collection_1.ListWrapper.clone(this._rootComponents).forEach(function (ref) { return ref.destroy(); });
	        this._disposeListeners.forEach(function (dispose) { return dispose(); });
	        this._platform._applicationDisposed(this);
	    };
	    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
	        get: function () { return this._rootComponentTypes; },
	        enumerable: true,
	        configurable: true
	    });
	    /** @internal */
	    ApplicationRef_._tickScope = profile_1.wtfCreateScope('ApplicationRef#tick()');
	    /** @nocollapse */
	    ApplicationRef_.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    ApplicationRef_.ctorParameters = [
	        { type: PlatformRef_, },
	        { type: ng_zone_1.NgZone, },
	        { type: di_1.Injector, },
	    ];
	    return ApplicationRef_;
	}(ApplicationRef));
	exports.ApplicationRef_ = ApplicationRef_;
	exports.PLATFORM_CORE_PROVIDERS = 
	/*@ts2dart_const*/ [
	    PlatformRef_,
	    /*@ts2dart_const*/ (
	    /* @ts2dart_Provider */ { provide: PlatformRef, useExisting: PlatformRef_ })
	];
	exports.APPLICATION_CORE_PROVIDERS = [
	    /* @ts2dart_Provider */ { provide: ng_zone_1.NgZone, useFactory: createNgZone, deps: [] },
	    ApplicationRef_,
	    /* @ts2dart_Provider */ { provide: ApplicationRef, useExisting: ApplicationRef_ },
	];
	//# sourceMappingURL=application_ref.js.map

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var lang_2 = __webpack_require__(2);
	exports.looseIdentical = lang_2.looseIdentical;
	exports.uninitialized = new Object();
	function devModeEqual(a, b) {
	    if (collection_1.isListLikeIterable(a) && collection_1.isListLikeIterable(b)) {
	        return collection_1.areIterablesEqual(a, b, devModeEqual);
	    }
	    else if (!collection_1.isListLikeIterable(a) && !lang_1.isPrimitive(a) && !collection_1.isListLikeIterable(b) && !lang_1.isPrimitive(b)) {
	        return true;
	    }
	    else {
	        return lang_1.looseIdentical(a, b);
	    }
	}
	exports.devModeEqual = devModeEqual;
	/**
	 * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
	 * reference
	 * has not changed.
	 *
	 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	 *
	 * Example:
	 *
	 * ```
	 * if (this._latestValue === this._latestReturnedValue) {
	 *    return this._latestReturnedValue;
	 *  } else {
	 *    this._latestReturnedValue = this._latestValue;
	 *    return WrappedValue.wrap(this._latestValue); // this will force update
	 *  }
	 * ```
	 * @stable
	 */
	var WrappedValue = (function () {
	    function WrappedValue(wrapped) {
	        this.wrapped = wrapped;
	    }
	    WrappedValue.wrap = function (value) { return new WrappedValue(value); };
	    return WrappedValue;
	}());
	exports.WrappedValue = WrappedValue;
	/**
	 * Helper class for unwrapping WrappedValue s
	 */
	var ValueUnwrapper = (function () {
	    function ValueUnwrapper() {
	        this.hasWrappedValue = false;
	    }
	    ValueUnwrapper.prototype.unwrap = function (value) {
	        if (value instanceof WrappedValue) {
	            this.hasWrappedValue = true;
	            return value.wrapped;
	        }
	        return value;
	    };
	    ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
	    return ValueUnwrapper;
	}());
	exports.ValueUnwrapper = ValueUnwrapper;
	/**
	 * Represents a basic change from a previous to a new value.
	 * @stable
	 */
	var SimpleChange = (function () {
	    function SimpleChange(previousValue, currentValue) {
	        this.previousValue = previousValue;
	        this.currentValue = currentValue;
	    }
	    /**
	     * Check whether the new value is the first value assigned.
	     */
	    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === exports.uninitialized; };
	    return SimpleChange;
	}());
	exports.SimpleChange = SimpleChange;
	//# sourceMappingURL=change_detection_util.js.map

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/* @ts2dart_const */
	var DefaultIterableDifferFactory = (function () {
	    function DefaultIterableDifferFactory() {
	    }
	    DefaultIterableDifferFactory.prototype.supports = function (obj) { return collection_1.isListLikeIterable(obj); };
	    DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
	        return new DefaultIterableDiffer(trackByFn);
	    };
	    return DefaultIterableDifferFactory;
	}());
	exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
	var trackByIdentity = function (index, item) { return item; };
	/**
	 * @stable
	 */
	var DefaultIterableDiffer = (function () {
	    function DefaultIterableDiffer(_trackByFn) {
	        this._trackByFn = _trackByFn;
	        this._length = null;
	        this._collection = null;
	        // Keeps track of the used records at any point in time (during & across `_check()` calls)
	        this._linkedRecords = null;
	        // Keeps track of the removed records at any point in time during `_check()` calls.
	        this._unlinkedRecords = null;
	        this._previousItHead = null;
	        this._itHead = null;
	        this._itTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._movesHead = null;
	        this._movesTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	        // Keeps track of records where custom track by is the same, but item identity has changed
	        this._identityChangesHead = null;
	        this._identityChangesTail = null;
	        this._trackByFn = lang_1.isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;
	    }
	    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	        get: function () { return this._collection; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	        get: function () { return this._length; },
	        enumerable: true,
	        configurable: true
	    });
	    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	        var record;
	        for (record = this._itHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	        var record;
	        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	        var record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	        var record;
	        for (record = this._movesHead; record !== null; record = record._nextMoved) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	        var record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
	        var record;
	        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.diff = function (collection) {
	        if (lang_1.isBlank(collection))
	            collection = [];
	        if (!collection_1.isListLikeIterable(collection)) {
	            throw new exceptions_1.BaseException("Error trying to diff '" + collection + "'");
	        }
	        if (this.check(collection)) {
	            return this;
	        }
	        else {
	            return null;
	        }
	    };
	    DefaultIterableDiffer.prototype.onDestroy = function () { };
	    // todo(vicb): optim for UnmodifiableListView (frozen arrays)
	    DefaultIterableDiffer.prototype.check = function (collection) {
	        var _this = this;
	        this._reset();
	        var record = this._itHead;
	        var mayBeDirty = false;
	        var index;
	        var item;
	        var itemTrackBy;
	        if (lang_1.isArray(collection)) {
	            var list = collection;
	            this._length = collection.length;
	            for (index = 0; index < this._length; index++) {
	                item = list[index];
	                itemTrackBy = this._trackByFn(index, item);
	                if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
	                    record = this._mismatch(record, item, itemTrackBy, index);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = this._verifyReinsertion(record, item, itemTrackBy, index);
	                    }
	                    if (!lang_1.looseIdentical(record.item, item))
	                        this._addIdentityChange(record, item);
	                }
	                record = record._next;
	            }
	        }
	        else {
	            index = 0;
	            collection_1.iterateListLike(collection, function (item /** TODO #9100 */) {
	                itemTrackBy = _this._trackByFn(index, item);
	                if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
	                    record = _this._mismatch(record, item, itemTrackBy, index);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                    }
	                    if (!lang_1.looseIdentical(record.item, item))
	                        _this._addIdentityChange(record, item);
	                }
	                record = record._next;
	                index++;
	            });
	            this._length = index;
	        }
	        this._truncate(record);
	        this._collection = collection;
	        return this.isDirty;
	    };
	    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	        /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
	         * changes.
	         */
	        get: function () {
	            return this._additionsHead !== null || this._movesHead !== null ||
	                this._removalsHead !== null || this._identityChangesHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Reset the state of the change objects to show no changes. This means set previousKey to
	     * currentKey, and clear all of the queues (additions, moves, removals).
	     * Set the previousIndexes of moved and added items to their currentIndexes
	     * Reset the list of additions, moves and removals
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var record;
	            var nextRecord;
	            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                record.previousIndex = record.currentIndex;
	            }
	            this._additionsHead = this._additionsTail = null;
	            for (record = this._movesHead; record !== null; record = nextRecord) {
	                record.previousIndex = record.currentIndex;
	                nextRecord = record._nextMoved;
	            }
	            this._movesHead = this._movesTail = null;
	            this._removalsHead = this._removalsTail = null;
	            this._identityChangesHead = this._identityChangesTail = null;
	        }
	    };
	    /**
	     * This is the core function which handles differences between collections.
	     *
	     * - `record` is the record which we saw at this position last time. If null then it is a new
	     *   item.
	     * - `item` is the current item in the collection
	     * - `index` is the position of the item in the collection
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
	        // The previous record after which we will append the current one.
	        var previousRecord;
	        if (record === null) {
	            previousRecord = this._itTail;
	        }
	        else {
	            previousRecord = record._prev;
	            // Remove the record from the collection since we know it does not match the item.
	            this._remove(record);
	        }
	        // Attempt to see if we have seen the item before.
	        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	        if (record !== null) {
	            // We have seen this before, we need to move it forward in the collection.
	            // But first we need to check if identity changed, so we can update in view if necessary
	            if (!lang_1.looseIdentical(record.item, item))
	                this._addIdentityChange(record, item);
	            this._moveAfter(record, previousRecord, index);
	        }
	        else {
	            // Never seen it, check evicted list.
	            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	            if (record !== null) {
	                // It is an item which we have evicted earlier: reinsert it back into the list.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!lang_1.looseIdentical(record.item, item))
	                    this._addIdentityChange(record, item);
	                this._reinsertAfter(record, previousRecord, index);
	            }
	            else {
	                // It is a new item: add it.
	                record =
	                    this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
	            }
	        }
	        return record;
	    };
	    /**
	     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	     *
	     * Use case: `[a, a]` => `[b, a, a]`
	     *
	     * If we did not have this check then the insertion of `b` would:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) leave `a` at index `1` as is. <-- this is wrong!
	     *   3) reinsert `a` at index 2. <-- this is wrong!
	     *
	     * The correct behavior is:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) reinsert `a` at index 1.
	     *   3) move `a` at from `1` to `2`.
	     *
	     *
	     * Double check that we have not evicted a duplicate item. We need to check if the item type may
	     * have already been removed:
	     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	     * at the end.
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
	        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	        if (reinsertRecord !== null) {
	            record = this._reinsertAfter(reinsertRecord, record._prev, index);
	        }
	        else if (record.currentIndex != index) {
	            record.currentIndex = index;
	            this._addToMoves(record, index);
	        }
	        return record;
	    };
	    /**
	     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
	     *
	     * - `record` The first excess {@link CollectionChangeRecord}.
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._truncate = function (record) {
	        // Anything after that needs to be removed;
	        while (record !== null) {
	            var nextRecord = record._next;
	            this._addToRemovals(this._unlink(record));
	            record = nextRecord;
	        }
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.clear();
	        }
	        if (this._additionsTail !== null) {
	            this._additionsTail._nextAdded = null;
	        }
	        if (this._movesTail !== null) {
	            this._movesTail._nextMoved = null;
	        }
	        if (this._itTail !== null) {
	            this._itTail._next = null;
	        }
	        if (this._removalsTail !== null) {
	            this._removalsTail._nextRemoved = null;
	        }
	        if (this._identityChangesTail !== null) {
	            this._identityChangesTail._nextIdentityChange = null;
	        }
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.remove(record);
	        }
	        var prev = record._prevRemoved;
	        var next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	        this._unlink(record);
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	        this._insertAfter(record, prevRecord, index);
	        if (this._additionsTail === null) {
	            // todo(vicb)
	            // assert(this._additionsHead === null);
	            this._additionsTail = this._additionsHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_additionsTail._nextAdded === null);
	            // assert(record._nextAdded === null);
	            this._additionsTail = this._additionsTail._nextAdded = record;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	        // todo(vicb)
	        // assert(record != prevRecord);
	        // assert(record._next === null);
	        // assert(record._prev === null);
	        var next = prevRecord === null ? this._itHead : prevRecord._next;
	        // todo(vicb)
	        // assert(next != record);
	        // assert(prevRecord != record);
	        record._next = next;
	        record._prev = prevRecord;
	        if (next === null) {
	            this._itTail = record;
	        }
	        else {
	            next._prev = record;
	        }
	        if (prevRecord === null) {
	            this._itHead = record;
	        }
	        else {
	            prevRecord._next = record;
	        }
	        if (this._linkedRecords === null) {
	            this._linkedRecords = new _DuplicateMap();
	        }
	        this._linkedRecords.put(record);
	        record.currentIndex = index;
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._remove = function (record) {
	        return this._addToRemovals(this._unlink(record));
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._unlink = function (record) {
	        if (this._linkedRecords !== null) {
	            this._linkedRecords.remove(record);
	        }
	        var prev = record._prev;
	        var next = record._next;
	        // todo(vicb)
	        // assert((record._prev = null) === null);
	        // assert((record._next = null) === null);
	        if (prev === null) {
	            this._itHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        if (next === null) {
	            this._itTail = prev;
	        }
	        else {
	            next._prev = prev;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	        // todo(vicb)
	        // assert(record._nextMoved === null);
	        if (record.previousIndex === toIndex) {
	            return record;
	        }
	        if (this._movesTail === null) {
	            // todo(vicb)
	            // assert(_movesHead === null);
	            this._movesTail = this._movesHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_movesTail._nextMoved === null);
	            this._movesTail = this._movesTail._nextMoved = record;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	        if (this._unlinkedRecords === null) {
	            this._unlinkedRecords = new _DuplicateMap();
	        }
	        this._unlinkedRecords.put(record);
	        record.currentIndex = null;
	        record._nextRemoved = null;
	        if (this._removalsTail === null) {
	            // todo(vicb)
	            // assert(_removalsHead === null);
	            this._removalsTail = this._removalsHead = record;
	            record._prevRemoved = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(_removalsTail._nextRemoved === null);
	            // assert(record._nextRemoved === null);
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = this._removalsTail._nextRemoved = record;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
	        record.item = item;
	        if (this._identityChangesTail === null) {
	            this._identityChangesTail = this._identityChangesHead = record;
	        }
	        else {
	            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	        }
	        return record;
	    };
	    DefaultIterableDiffer.prototype.toString = function () {
	        var list = [];
	        this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
	        var previous = [];
	        this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
	        var additions = [];
	        this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
	        var moves = [];
	        this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
	        var removals = [];
	        this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
	        var identityChanges = [];
	        this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
	        return 'collection: ' + list.join(', ') + '\n' +
	            'previous: ' + previous.join(', ') + '\n' +
	            'additions: ' + additions.join(', ') + '\n' +
	            'moves: ' + moves.join(', ') + '\n' +
	            'removals: ' + removals.join(', ') + '\n' +
	            'identityChanges: ' + identityChanges.join(', ') + '\n';
	    };
	    return DefaultIterableDiffer;
	}());
	exports.DefaultIterableDiffer = DefaultIterableDiffer;
	/**
	 * @stable
	 */
	var CollectionChangeRecord = (function () {
	    function CollectionChangeRecord(item, trackById) {
	        this.item = item;
	        this.trackById = trackById;
	        this.currentIndex = null;
	        this.previousIndex = null;
	        /** @internal */
	        this._nextPrevious = null;
	        /** @internal */
	        this._prev = null;
	        /** @internal */
	        this._next = null;
	        /** @internal */
	        this._prevDup = null;
	        /** @internal */
	        this._nextDup = null;
	        /** @internal */
	        this._prevRemoved = null;
	        /** @internal */
	        this._nextRemoved = null;
	        /** @internal */
	        this._nextAdded = null;
	        /** @internal */
	        this._nextMoved = null;
	        /** @internal */
	        this._nextIdentityChange = null;
	    }
	    CollectionChangeRecord.prototype.toString = function () {
	        return this.previousIndex === this.currentIndex ? lang_1.stringify(this.item) :
	            lang_1.stringify(this.item) + '[' +
	                lang_1.stringify(this.previousIndex) + '->' + lang_1.stringify(this.currentIndex) + ']';
	    };
	    return CollectionChangeRecord;
	}());
	exports.CollectionChangeRecord = CollectionChangeRecord;
	// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
	var _DuplicateItemRecordList = (function () {
	    function _DuplicateItemRecordList() {
	        /** @internal */
	        this._head = null;
	        /** @internal */
	        this._tail = null;
	    }
	    /**
	     * Append the record to the list of duplicates.
	     *
	     * Note: by design all records in the list of duplicates hold the same value in record.item.
	     */
	    _DuplicateItemRecordList.prototype.add = function (record) {
	        if (this._head === null) {
	            this._head = this._tail = record;
	            record._nextDup = null;
	            record._prevDup = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(record.item ==  _head.item ||
	            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	            this._tail._nextDup = record;
	            record._prevDup = this._tail;
	            record._nextDup = null;
	            this._tail = record;
	        }
	    };
	    // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and
	    // CollectionChangeRecord.currentIndex >= afterIndex
	    _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
	        var record;
	        for (record = this._head; record !== null; record = record._nextDup) {
	            if ((afterIndex === null || afterIndex < record.currentIndex) &&
	                lang_1.looseIdentical(record.trackById, trackById)) {
	                return record;
	            }
	        }
	        return null;
	    };
	    /**
	     * Remove one {@link CollectionChangeRecord} from the list of duplicates.
	     *
	     * Returns whether the list of duplicates is empty.
	     */
	    _DuplicateItemRecordList.prototype.remove = function (record) {
	        // todo(vicb)
	        // assert(() {
	        //  // verify that the record being removed is in the list.
	        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
	        //    if (identical(cursor, record)) return true;
	        //  }
	        //  return false;
	        //});
	        var prev = record._prevDup;
	        var next = record._nextDup;
	        if (prev === null) {
	            this._head = next;
	        }
	        else {
	            prev._nextDup = next;
	        }
	        if (next === null) {
	            this._tail = prev;
	        }
	        else {
	            next._prevDup = prev;
	        }
	        return this._head === null;
	    };
	    return _DuplicateItemRecordList;
	}());
	var _DuplicateMap = (function () {
	    function _DuplicateMap() {
	        this.map = new Map();
	    }
	    _DuplicateMap.prototype.put = function (record) {
	        // todo(vicb) handle corner cases
	        var key = lang_1.getMapKey(record.trackById);
	        var duplicates = this.map.get(key);
	        if (!lang_1.isPresent(duplicates)) {
	            duplicates = new _DuplicateItemRecordList();
	            this.map.set(key, duplicates);
	        }
	        duplicates.add(record);
	    };
	    /**
	     * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
	     * have already iterated over, we use the afterIndex to pretend it is not there.
	     *
	     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	     * have any more `a`s needs to return the last `a` not the first or second.
	     */
	    _DuplicateMap.prototype.get = function (trackById, afterIndex) {
	        if (afterIndex === void 0) { afterIndex = null; }
	        var key = lang_1.getMapKey(trackById);
	        var recordList = this.map.get(key);
	        return lang_1.isBlank(recordList) ? null : recordList.get(trackById, afterIndex);
	    };
	    /**
	     * Removes a {@link CollectionChangeRecord} from the list of duplicates.
	     *
	     * The list of duplicates also is removed from the map if it gets empty.
	     */
	    _DuplicateMap.prototype.remove = function (record) {
	        var key = lang_1.getMapKey(record.trackById);
	        // todo(vicb)
	        // assert(this.map.containsKey(key));
	        var recordList = this.map.get(key);
	        // Remove the list of duplicates when it gets empty
	        if (recordList.remove(record)) {
	            this.map.delete(key);
	        }
	        return record;
	    };
	    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	        get: function () { return this.map.size === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + lang_1.stringify(this.map) + ')'; };
	    return _DuplicateMap;
	}());
	//# sourceMappingURL=default_iterable_differ.js.map

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var decorators_1 = __webpack_require__(25);
	var lang_1 = __webpack_require__(2);
	// Note: Need to rename warn as in Dart
	// class members and imports can't use the same name.
	var _warnImpl = lang_1.warn;
	var Console = (function () {
	    function Console() {
	    }
	    Console.prototype.log = function (message) { lang_1.print(message); };
	    // Note: for reporting errors use `DOM.logError()` as it is platform specific
	    Console.prototype.warn = function (message) { _warnImpl(message); };
	    /** @nocollapse */
	    Console.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    return Console;
	}());
	exports.Console = Console;
	//# sourceMappingURL=console.js.map

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(5);
	var _THROW_IF_NOT_FOUND = new Object();
	exports.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	/**
	 * @stable
	 */
	var Injector = (function () {
	    function Injector() {
	    }
	    /**
	     * Retrieves an instance from the injector based on the provided token.
	     * If not found:
	     * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
	     * Injector.THROW_IF_NOT_FOUND is given
	     * - Returns the `notFoundValue` otherwise
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/HeXSHg?p=preview))
	     *
	     * ```typescript
	     * var injector = ReflectiveInjector.resolveAndCreate([
	     *   {provide: "validToken", useValue: "Value"}
	     * ]);
	     * expect(injector.get("validToken")).toEqual("Value");
	     * expect(() => injector.get("invalidToken")).toThrowError();
	     * ```
	     *
	     * `Injector` returns itself when given `Injector` as a token.
	     *
	     * ```typescript
	     * var injector = ReflectiveInjector.resolveAndCreate([]);
	     * expect(injector.get(Injector)).toBe(injector);
	     * ```
	     */
	    Injector.prototype.get = function (token, notFoundValue) { return exceptions_1.unimplemented(); };
	    Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	    return Injector;
	}());
	exports.Injector = Injector;
	//# sourceMappingURL=injector.js.map

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/**
	 * Describes how the {@link Injector} should instantiate a given token.
	 *
	 * See {@link provide}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))
	 *
	 * ```javascript
	 * var injector = Injector.resolveAndCreate([
	 *   new Provider("message", { useValue: 'Hello' })
	 * ]);
	 *
	 * expect(injector.get("message")).toEqual('Hello');
	 * ```
	 * @ts2dart_const
	 * @deprecated
	 */
	var Provider = (function () {
	    function Provider(token, _a) {
	        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
	        this.token = token;
	        this.useClass = useClass;
	        this.useValue = useValue;
	        this.useExisting = useExisting;
	        this.useFactory = useFactory;
	        this.dependencies = deps;
	        this._multi = multi;
	    }
	    Object.defineProperty(Provider.prototype, "multi", {
	        // TODO: Provide a full working example after alpha38 is released.
	        /**
	         * Creates multiple providers matching the same token (a multi-provider).
	         *
	         * Multi-providers are used for creating pluggable service, where the system comes
	         * with some default providers, and the user can register additional providers.
	         * The combination of the default providers and the additional providers will be
	         * used to drive the behavior of the system.
	         *
	         * ### Example
	         *
	         * ```typescript
	         * var injector = Injector.resolveAndCreate([
	         *   new Provider("Strings", { useValue: "String1", multi: true}),
	         *   new Provider("Strings", { useValue: "String2", multi: true})
	         * ]);
	         *
	         * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
	         * ```
	         *
	         * Multi-providers and regular providers cannot be mixed. The following
	         * will throw an exception:
	         *
	         * ```typescript
	         * var injector = Injector.resolveAndCreate([
	         *   new Provider("Strings", { useValue: "String1", multi: true }),
	         *   new Provider("Strings", { useValue: "String2"})
	         * ]);
	         * ```
	         */
	        get: function () { return lang_1.normalizeBool(this._multi); },
	        enumerable: true,
	        configurable: true
	    });
	    return Provider;
	}());
	exports.Provider = Provider;
	/**
	 * See {@link Provider} instead.
	 *
	 * @deprecated
	 * @ts2dart_const
	 */
	var Binding = (function (_super) {
	    __extends(Binding, _super);
	    function Binding(token, _a) {
	        var toClass = _a.toClass, toValue = _a.toValue, toAlias = _a.toAlias, toFactory = _a.toFactory, deps = _a.deps, multi = _a.multi;
	        _super.call(this, token, {
	            useClass: toClass,
	            useValue: toValue,
	            useExisting: toAlias,
	            useFactory: toFactory,
	            deps: deps,
	            multi: multi
	        });
	    }
	    Object.defineProperty(Binding.prototype, "toClass", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useClass; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Binding.prototype, "toAlias", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useExisting; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Binding.prototype, "toFactory", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useFactory; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Binding.prototype, "toValue", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useValue; },
	        enumerable: true,
	        configurable: true
	    });
	    return Binding;
	}(Provider));
	exports.Binding = Binding;
	/**
	 * Creates a {@link Provider}.
	 *
	 * To construct a {@link Provider}, bind a `token` to either a class, a value, a factory function,
	 * or
	 * to an existing `token`.
	 * See {@link ProviderBuilder} for more details.
	 *
	 * The `token` is most commonly a class or {@link OpaqueToken-class.html}.
	 *
	 * @deprecated
	 */
	function bind(token) {
	    return new ProviderBuilder(token);
	}
	exports.bind = bind;
	/**
	 * Helper class for the {@link bind} function.
	 * @deprecated
	 */
	var ProviderBuilder = (function () {
	    function ProviderBuilder(token) {
	        this.token = token;
	    }
	    /**
	     * Binds a DI token to a class.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview))
	     *
	     * Because `toAlias` and `toClass` are often confused, the example contains
	     * both use cases for easy comparison.
	     *
	     * ```typescript
	     * class Vehicle {}
	     *
	     * class Car extends Vehicle {}
	     *
	     * var injectorClass = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useClass: Car}
	     * ]);
	     * var injectorAlias = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useExisting: Car}
	     * ]);
	     *
	     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	     *
	     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	     * ```
	     */
	    ProviderBuilder.prototype.toClass = function (type) {
	        if (!lang_1.isType(type)) {
	            throw new exceptions_1.BaseException("Trying to create a class provider but \"" + lang_1.stringify(type) + "\" is not a class!");
	        }
	        return new Provider(this.token, { useClass: type });
	    };
	    /**
	     * Binds a DI token to a value.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview))
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: 'message', useValue: 'Hello'}
	     * ]);
	     *
	     * expect(injector.get('message')).toEqual('Hello');
	     * ```
	     */
	    ProviderBuilder.prototype.toValue = function (value) { return new Provider(this.token, { useValue: value }); };
	    /**
	     * Binds a DI token to an existing token.
	     *
	     * Angular will return the same instance as if the provided token was used. (This is
	     * in contrast to `useClass` where a separate instance of `useClass` will be returned.)
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview))
	     *
	     * Because `toAlias` and `toClass` are often confused, the example contains
	     * both use cases for easy comparison.
	     *
	     * ```typescript
	     * class Vehicle {}
	     *
	     * class Car extends Vehicle {}
	     *
	     * var injectorAlias = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useExisting: Car}
	     * ]);
	     * var injectorClass = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useClass: Car})
	     * ]);
	     *
	     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	     *
	     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	     * ```
	     */
	    ProviderBuilder.prototype.toAlias = function (aliasToken) {
	        if (lang_1.isBlank(aliasToken)) {
	            throw new exceptions_1.BaseException("Can not alias " + lang_1.stringify(this.token) + " to a blank value!");
	        }
	        return new Provider(this.token, { useExisting: aliasToken });
	    };
	    /**
	     * Binds a DI token to a function which computes the value.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview))
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: Number, useFactory: () => { return 1+2; }},
	     *   {provide: String, useFactory: (v) => { return "Value: " + v; }, deps: [Number]}
	     * ]);
	     *
	     * expect(injector.get(Number)).toEqual(3);
	     * expect(injector.get(String)).toEqual('Value: 3');
	     * ```
	     */
	    ProviderBuilder.prototype.toFactory = function (factory, dependencies) {
	        if (!lang_1.isFunction(factory)) {
	            throw new exceptions_1.BaseException("Trying to create a factory provider but \"" + lang_1.stringify(factory) + "\" is not a function!");
	        }
	        return new Provider(this.token, { useFactory: factory, deps: dependencies });
	    };
	    return ProviderBuilder;
	}());
	exports.ProviderBuilder = ProviderBuilder;
	/**
	 * Creates a {@link Provider}.
	 *
	 * See {@link Provider} for more details.
	 *
	 * <!-- TODO: improve the docs -->
	 * @deprecated
	 */
	function provide(token, _a) {
	    var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
	    return new Provider(token, {
	        useClass: useClass,
	        useValue: useValue,
	        useExisting: useExisting,
	        useFactory: useFactory,
	        deps: deps,
	        multi: multi
	    });
	}
	exports.provide = provide;
	//# sourceMappingURL=provider.js.map

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	function findFirstClosedCycle(keys) {
	    var res = [];
	    for (var i = 0; i < keys.length; ++i) {
	        if (collection_1.ListWrapper.contains(res, keys[i])) {
	            res.push(keys[i]);
	            return res;
	        }
	        res.push(keys[i]);
	    }
	    return res;
	}
	function constructResolvingPath(keys) {
	    if (keys.length > 1) {
	        var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));
	        var tokenStrs = reversed.map(function (k) { return lang_1.stringify(k.token); });
	        return ' (' + tokenStrs.join(' -> ') + ')';
	    }
	    return '';
	}
	/**
	 * Base class for all errors arising from misconfigured providers.
	 * @stable
	 */
	var AbstractProviderError = (function (_super) {
	    __extends(AbstractProviderError, _super);
	    function AbstractProviderError(injector, key, constructResolvingMessage) {
	        _super.call(this, 'DI Exception');
	        this.keys = [key];
	        this.injectors = [injector];
	        this.constructResolvingMessage = constructResolvingMessage;
	        this.message = this.constructResolvingMessage(this.keys);
	    }
	    AbstractProviderError.prototype.addKey = function (injector, key) {
	        this.injectors.push(injector);
	        this.keys.push(key);
	        this.message = this.constructResolvingMessage(this.keys);
	    };
	    Object.defineProperty(AbstractProviderError.prototype, "context", {
	        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
	        enumerable: true,
	        configurable: true
	    });
	    return AbstractProviderError;
	}(exceptions_1.BaseException));
	exports.AbstractProviderError = AbstractProviderError;
	/**
	 * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
	 * {@link Injector} does not have a {@link Provider} for {@link Key}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b:B) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 * @stable
	 */
	var NoProviderError = (function (_super) {
	    __extends(NoProviderError, _super);
	    function NoProviderError(injector, key) {
	        _super.call(this, injector, key, function (keys) {
	            var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);
	            return "No provider for " + first + "!" + constructResolvingPath(keys);
	        });
	    }
	    return NoProviderError;
	}(AbstractProviderError));
	exports.NoProviderError = NoProviderError;
	/**
	 * Thrown when dependencies form a cycle.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	 *
	 * ```typescript
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	 *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	 * ]);
	 *
	 * expect(() => injector.get("one")).toThrowError();
	 * ```
	 *
	 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	 * @stable
	 */
	var CyclicDependencyError = (function (_super) {
	    __extends(CyclicDependencyError, _super);
	    function CyclicDependencyError(injector, key) {
	        _super.call(this, injector, key, function (keys) {
	            return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
	        });
	    }
	    return CyclicDependencyError;
	}(AbstractProviderError));
	exports.CyclicDependencyError = CyclicDependencyError;
	/**
	 * Thrown when a constructing type returns with an Error.
	 *
	 * The `InstantiationError` class contains the original error plus the dependency graph which caused
	 * this object to be instantiated.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor() {
	 *     throw new Error('message');
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	
	 * try {
	 *   injector.get(A);
	 * } catch (e) {
	 *   expect(e instanceof InstantiationError).toBe(true);
	 *   expect(e.originalException.message).toEqual("message");
	 *   expect(e.originalStack).toBeDefined();
	 * }
	 * ```
	 * @stable
	 */
	var InstantiationError = (function (_super) {
	    __extends(InstantiationError, _super);
	    function InstantiationError(injector, originalException, originalStack, key) {
	        _super.call(this, 'DI Exception', originalException, originalStack, null);
	        this.keys = [key];
	        this.injectors = [injector];
	    }
	    InstantiationError.prototype.addKey = function (injector, key) {
	        this.injectors.push(injector);
	        this.keys.push(key);
	    };
	    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
	        get: function () {
	            var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);
	            return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InstantiationError.prototype, "causeKey", {
	        get: function () { return this.keys[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InstantiationError.prototype, "context", {
	        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
	        enumerable: true,
	        configurable: true
	    });
	    return InstantiationError;
	}(exceptions_1.WrappedException));
	exports.InstantiationError = InstantiationError;
	/**
	 * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
	 * creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	 * ```
	 * @stable
	 */
	var InvalidProviderError = (function (_super) {
	    __extends(InvalidProviderError, _super);
	    function InvalidProviderError(provider) {
	        _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
	    }
	    return InvalidProviderError;
	}(exceptions_1.BaseException));
	exports.InvalidProviderError = InvalidProviderError;
	/**
	 * Thrown when the class has no annotation information.
	 *
	 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
	 * need to be injected into the constructor.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 *
	 * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
	 *
	 * ```typescript
	 * class B {}
	 *
	 * class A {
	 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	 * ```
	 * @stable
	 */
	var NoAnnotationError = (function (_super) {
	    __extends(NoAnnotationError, _super);
	    function NoAnnotationError(typeOrFunc, params) {
	        _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
	    }
	    NoAnnotationError._genMessage = function (typeOrFunc, params) {
	        var signature = [];
	        for (var i = 0, ii = params.length; i < ii; i++) {
	            var parameter = params[i];
	            if (lang_1.isBlank(parameter) || parameter.length == 0) {
	                signature.push('?');
	            }
	            else {
	                signature.push(parameter.map(lang_1.stringify).join(' '));
	            }
	        }
	        return 'Cannot resolve all parameters for \'' + lang_1.stringify(typeOrFunc) + '\'(' +
	            signature.join(', ') + '). ' +
	            'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
	            lang_1.stringify(typeOrFunc) + '\' is decorated with Injectable.';
	    };
	    return NoAnnotationError;
	}(exceptions_1.BaseException));
	exports.NoAnnotationError = NoAnnotationError;
	/**
	 * Thrown when getting an object by index.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	 *
	 * ```typescript
	 * class A {}
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 *
	 * expect(() => injector.getAt(100)).toThrowError();
	 * ```
	 * @stable
	 */
	var OutOfBoundsError = (function (_super) {
	    __extends(OutOfBoundsError, _super);
	    function OutOfBoundsError(index) {
	        _super.call(this, "Index " + index + " is out-of-bounds.");
	    }
	    return OutOfBoundsError;
	}(exceptions_1.BaseException));
	exports.OutOfBoundsError = OutOfBoundsError;
	// TODO: add a working example after alpha38 is released
	/**
	 * Thrown when a multi provider and a regular provider are bound to the same token.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate([
	 *   new Provider("Strings", {useValue: "string1", multi: true}),
	 *   new Provider("Strings", {useValue: "string2", multi: false})
	 * ])).toThrowError();
	 * ```
	 */
	var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
	    __extends(MixingMultiProvidersWithRegularProvidersError, _super);
	    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	        _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
	            provider2.toString());
	    }
	    return MixingMultiProvidersWithRegularProvidersError;
	}(exceptions_1.BaseException));
	exports.MixingMultiProvidersWithRegularProvidersError = MixingMultiProvidersWithRegularProvidersError;
	//# sourceMappingURL=reflective_exceptions.js.map

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var forward_ref_1 = __webpack_require__(42);
	/**
	 * A unique object used for retrieving items from the {@link ReflectiveInjector}.
	 *
	 * Keys have:
	 * - a system-wide unique `id`.
	 * - a `token`.
	 *
	 * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
	 * the
	 * injector to store created objects in a more efficient way.
	 *
	 * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
	 * resolving
	 * providers.
	 * @experimental
	 */
	var ReflectiveKey = (function () {
	    /**
	     * Private
	     */
	    function ReflectiveKey(token, id) {
	        this.token = token;
	        this.id = id;
	        if (lang_1.isBlank(token)) {
	            throw new exceptions_1.BaseException('Token must be defined!');
	        }
	    }
	    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
	        /**
	         * Returns a stringified token.
	         */
	        get: function () { return lang_1.stringify(this.token); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Retrieves a `Key` for a token.
	     */
	    ReflectiveKey.get = function (token) {
	        return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token));
	    };
	    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
	        /**
	         * @returns the number of keys registered in the system.
	         */
	        get: function () { return _globalKeyRegistry.numberOfKeys; },
	        enumerable: true,
	        configurable: true
	    });
	    return ReflectiveKey;
	}());
	exports.ReflectiveKey = ReflectiveKey;
	/**
	 * @internal
	 */
	var KeyRegistry = (function () {
	    function KeyRegistry() {
	        this._allKeys = new Map();
	    }
	    KeyRegistry.prototype.get = function (token) {
	        if (token instanceof ReflectiveKey)
	            return token;
	        if (this._allKeys.has(token)) {
	            return this._allKeys.get(token);
	        }
	        var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	        this._allKeys.set(token, newKey);
	        return newKey;
	    };
	    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	        get: function () { return this._allKeys.size; },
	        enumerable: true,
	        configurable: true
	    });
	    return KeyRegistry;
	}());
	exports.KeyRegistry = KeyRegistry;
	var _globalKeyRegistry = new KeyRegistry();
	//# sourceMappingURL=reflective_key.js.map

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var collection_1 = __webpack_require__(6);
	var reflection_1 = __webpack_require__(46);
	var reflective_key_1 = __webpack_require__(68);
	var metadata_1 = __webpack_require__(26);
	var reflective_exceptions_1 = __webpack_require__(67);
	var forward_ref_1 = __webpack_require__(42);
	var provider_1 = __webpack_require__(66);
	var provider_util_1 = __webpack_require__(108);
	/**
	 * `Dependency` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 */
	var ReflectiveDependency = (function () {
	    function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
	        this.key = key;
	        this.optional = optional;
	        this.lowerBoundVisibility = lowerBoundVisibility;
	        this.upperBoundVisibility = upperBoundVisibility;
	        this.properties = properties;
	    }
	    ReflectiveDependency.fromKey = function (key) {
	        return new ReflectiveDependency(key, false, null, null, []);
	    };
	    return ReflectiveDependency;
	}());
	exports.ReflectiveDependency = ReflectiveDependency;
	var _EMPTY_LIST = [];
	var ResolvedReflectiveProvider_ = (function () {
	    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	        this.key = key;
	        this.resolvedFactories = resolvedFactories;
	        this.multiProvider = multiProvider;
	    }
	    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
	        get: function () { return this.resolvedFactories[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    return ResolvedReflectiveProvider_;
	}());
	exports.ResolvedReflectiveProvider_ = ResolvedReflectiveProvider_;
	/**
	 * An internal resolved representation of a factory function created by resolving {@link Provider}.
	 * @experimental
	 */
	var ResolvedReflectiveFactory = (function () {
	    function ResolvedReflectiveFactory(
	        /**
	         * Factory function which can return an instance of an object represented by a key.
	         */
	        factory, 
	        /**
	         * Arguments (dependencies) to the `factory` function.
	         */
	        dependencies) {
	        this.factory = factory;
	        this.dependencies = dependencies;
	    }
	    return ResolvedReflectiveFactory;
	}());
	exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
	/**
	 * Resolve a single provider.
	 */
	function resolveReflectiveFactory(provider) {
	    var factoryFn;
	    var resolvedDeps;
	    if (lang_1.isPresent(provider.useClass)) {
	        var useClass = forward_ref_1.resolveForwardRef(provider.useClass);
	        factoryFn = reflection_1.reflector.factory(useClass);
	        resolvedDeps = _dependenciesFor(useClass);
	    }
	    else if (lang_1.isPresent(provider.useExisting)) {
	        factoryFn = function (aliasInstance) { return aliasInstance; };
	        resolvedDeps = [ReflectiveDependency.fromKey(reflective_key_1.ReflectiveKey.get(provider.useExisting))];
	    }
	    else if (lang_1.isPresent(provider.useFactory)) {
	        factoryFn = provider.useFactory;
	        resolvedDeps = constructDependencies(provider.useFactory, provider.dependencies);
	    }
	    else {
	        factoryFn = function () { return provider.useValue; };
	        resolvedDeps = _EMPTY_LIST;
	    }
	    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	}
	exports.resolveReflectiveFactory = resolveReflectiveFactory;
	/**
	 * Converts the {@link Provider} into {@link ResolvedProvider}.
	 *
	 * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
	 * convenience provider syntax.
	 */
	function resolveReflectiveProvider(provider) {
	    return new ResolvedReflectiveProvider_(reflective_key_1.ReflectiveKey.get(provider.token), [resolveReflectiveFactory(provider)], provider.multi);
	}
	exports.resolveReflectiveProvider = resolveReflectiveProvider;
	/**
	 * Resolve a list of Providers.
	 */
	function resolveReflectiveProviders(providers) {
	    var normalized = _normalizeProviders(providers, []);
	    var resolved = normalized.map(resolveReflectiveProvider);
	    return collection_1.MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
	}
	exports.resolveReflectiveProviders = resolveReflectiveProviders;
	/**
	 * Merges a list of ResolvedProviders into a list where
	 * each key is contained exactly once and multi providers
	 * have been merged.
	 */
	function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	    for (var i = 0; i < providers.length; i++) {
	        var provider = providers[i];
	        var existing = normalizedProvidersMap.get(provider.key.id);
	        if (lang_1.isPresent(existing)) {
	            if (provider.multiProvider !== existing.multiProvider) {
	                throw new reflective_exceptions_1.MixingMultiProvidersWithRegularProvidersError(existing, provider);
	            }
	            if (provider.multiProvider) {
	                for (var j = 0; j < provider.resolvedFactories.length; j++) {
	                    existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                }
	            }
	            else {
	                normalizedProvidersMap.set(provider.key.id, provider);
	            }
	        }
	        else {
	            var resolvedProvider;
	            if (provider.multiProvider) {
	                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, collection_1.ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
	            }
	            else {
	                resolvedProvider = provider;
	            }
	            normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	        }
	    }
	    return normalizedProvidersMap;
	}
	exports.mergeResolvedReflectiveProviders = mergeResolvedReflectiveProviders;
	function _normalizeProviders(providers, res) {
	    providers.forEach(function (b) {
	        if (b instanceof lang_1.Type) {
	            res.push(provider_1.provide(b, { useClass: b }));
	        }
	        else if (b instanceof provider_1.Provider) {
	            res.push(b);
	        }
	        else if (provider_util_1.isProviderLiteral(b)) {
	            res.push(provider_util_1.createProvider(b));
	        }
	        else if (b instanceof Array) {
	            _normalizeProviders(b, res);
	        }
	        else if (b instanceof provider_1.ProviderBuilder) {
	            throw new reflective_exceptions_1.InvalidProviderError(b.token);
	        }
	        else {
	            throw new reflective_exceptions_1.InvalidProviderError(b);
	        }
	    });
	    return res;
	}
	function constructDependencies(typeOrFunc, dependencies) {
	    if (lang_1.isBlank(dependencies)) {
	        return _dependenciesFor(typeOrFunc);
	    }
	    else {
	        var params = dependencies.map(function (t) { return [t]; });
	        return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params); });
	    }
	}
	exports.constructDependencies = constructDependencies;
	function _dependenciesFor(typeOrFunc) {
	    var params = reflection_1.reflector.parameters(typeOrFunc);
	    if (lang_1.isBlank(params))
	        return [];
	    if (params.some(lang_1.isBlank)) {
	        throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
	    }
	    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
	}
	function _extractToken(typeOrFunc /** TODO #9100 */, metadata /** TODO #9100 */ /*any[] | any*/, params) {
	    var depProps = [];
	    var token = null;
	    var optional = false;
	    if (!lang_1.isArray(metadata)) {
	        if (metadata instanceof metadata_1.InjectMetadata) {
	            return _createDependency(metadata.token, optional, null, null, depProps);
	        }
	        else {
	            return _createDependency(metadata, optional, null, null, depProps);
	        }
	    }
	    var lowerBoundVisibility = null;
	    var upperBoundVisibility = null;
	    for (var i = 0; i < metadata.length; ++i) {
	        var paramMetadata = metadata[i];
	        if (paramMetadata instanceof lang_1.Type) {
	            token = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.InjectMetadata) {
	            token = paramMetadata.token;
	        }
	        else if (paramMetadata instanceof metadata_1.OptionalMetadata) {
	            optional = true;
	        }
	        else if (paramMetadata instanceof metadata_1.SelfMetadata) {
	            upperBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.HostMetadata) {
	            upperBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {
	            lowerBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.DependencyMetadata) {
	            if (lang_1.isPresent(paramMetadata.token)) {
	                token = paramMetadata.token;
	            }
	            depProps.push(paramMetadata);
	        }
	    }
	    token = forward_ref_1.resolveForwardRef(token);
	    if (lang_1.isPresent(token)) {
	        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	    }
	    else {
	        throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
	    }
	}
	function _createDependency(token /** TODO #9100 */, optional /** TODO #9100 */, lowerBoundVisibility /** TODO #9100 */, upperBoundVisibility /** TODO #9100 */, depProps /** TODO #9100 */) {
	    return new ReflectiveDependency(reflective_key_1.ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	}
	//# sourceMappingURL=reflective_provider.js.map

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/**
	 * @stable
	 */
	var NoComponentFactoryError = (function (_super) {
	    __extends(NoComponentFactoryError, _super);
	    function NoComponentFactoryError(component) {
	        _super.call(this, "No component factory found for " + lang_1.stringify(component));
	        this.component = component;
	    }
	    return NoComponentFactoryError;
	}(exceptions_1.BaseException));
	exports.NoComponentFactoryError = NoComponentFactoryError;
	var _NullComponentFactoryResolver = (function () {
	    function _NullComponentFactoryResolver() {
	    }
	    _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        throw new NoComponentFactoryError(component);
	    };
	    return _NullComponentFactoryResolver;
	}());
	/**
	 * @stable
	 */
	var ComponentFactoryResolver = (function () {
	    function ComponentFactoryResolver() {
	    }
	    ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	    return ComponentFactoryResolver;
	}());
	exports.ComponentFactoryResolver = ComponentFactoryResolver;
	var CodegenComponentFactoryResolver = (function () {
	    function CodegenComponentFactoryResolver(factories, _parent) {
	        this._parent = _parent;
	        this._factories = new Map();
	        for (var i = 0; i < factories.length; i++) {
	            var factory = factories[i];
	            this._factories.set(factory.componentType, factory);
	        }
	    }
	    CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        var result = this._factories.get(component);
	        if (!result) {
	            result = this._parent.resolveComponentFactory(component);
	        }
	        return result;
	    };
	    return CodegenComponentFactoryResolver;
	}());
	exports.CodegenComponentFactoryResolver = CodegenComponentFactoryResolver;
	//# sourceMappingURL=component_factory_resolver.js.map

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var element_ref_1 = __webpack_require__(115);
	var view_container_ref_1 = __webpack_require__(117);
	var view_type_1 = __webpack_require__(43);
	/**
	 * An AppElement is created for elements that have a ViewContainerRef,
	 * a nested component or a <template> element to keep data around
	 * that is needed for later instantiations.
	 */
	var AppElement = (function () {
	    function AppElement(index, parentIndex, parentView, nativeElement) {
	        this.index = index;
	        this.parentIndex = parentIndex;
	        this.parentView = parentView;
	        this.nativeElement = nativeElement;
	        this.nestedViews = null;
	        this.componentView = null;
	    }
	    Object.defineProperty(AppElement.prototype, "elementRef", {
	        get: function () { return new element_ref_1.ElementRef(this.nativeElement); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppElement.prototype, "vcRef", {
	        get: function () { return new view_container_ref_1.ViewContainerRef_(this); },
	        enumerable: true,
	        configurable: true
	    });
	    AppElement.prototype.initComponent = function (component, componentConstructorViewQueries, view) {
	        this.component = component;
	        this.componentConstructorViewQueries = componentConstructorViewQueries;
	        this.componentView = view;
	    };
	    Object.defineProperty(AppElement.prototype, "parentInjector", {
	        get: function () { return this.parentView.injector(this.parentIndex); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppElement.prototype, "injector", {
	        get: function () { return this.parentView.injector(this.index); },
	        enumerable: true,
	        configurable: true
	    });
	    AppElement.prototype.mapNestedViews = function (nestedViewClass, callback) {
	        var result = [];
	        if (lang_1.isPresent(this.nestedViews)) {
	            this.nestedViews.forEach(function (nestedView) {
	                if (nestedView.clazz === nestedViewClass) {
	                    result.push(callback(nestedView));
	                }
	            });
	        }
	        return result;
	    };
	    AppElement.prototype.attachView = function (view, viewIndex) {
	        if (view.type === view_type_1.ViewType.COMPONENT) {
	            throw new exceptions_1.BaseException("Component views can't be moved!");
	        }
	        var nestedViews = this.nestedViews;
	        if (nestedViews == null) {
	            nestedViews = [];
	            this.nestedViews = nestedViews;
	        }
	        collection_1.ListWrapper.insert(nestedViews, viewIndex, view);
	        var refRenderNode;
	        if (viewIndex > 0) {
	            var prevView = nestedViews[viewIndex - 1];
	            refRenderNode = prevView.lastRootNode;
	        }
	        else {
	            refRenderNode = this.nativeElement;
	        }
	        if (lang_1.isPresent(refRenderNode)) {
	            view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
	        }
	        view.addToContentChildren(this);
	    };
	    AppElement.prototype.detachView = function (viewIndex) {
	        var view = collection_1.ListWrapper.removeAt(this.nestedViews, viewIndex);
	        if (view.type === view_type_1.ViewType.COMPONENT) {
	            throw new exceptions_1.BaseException("Component views can't be moved!");
	        }
	        view.detach();
	        view.removeFromContentChildren(this);
	        return view;
	    };
	    return AppElement;
	}());
	exports.AppElement = AppElement;
	//# sourceMappingURL=element.js.map

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(5);
	/**
	 * An error thrown if application changes model breaking the top-down data flow.
	 *
	 * This exception is only thrown in dev mode.
	 *
	 * <!-- TODO: Add a link once the dev mode option is configurable -->
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'parent',
	 *   template: `
	 *     <child [prop]="parentProp"></child>
	 *   `,
	 *   directives: [forwardRef(() => Child)]
	 * })
	 * class Parent {
	 *   parentProp = "init";
	 * }
	 *
	 * @Directive({selector: 'child', inputs: ['prop']})
	 * class Child {
	 *   constructor(public parent: Parent) {}
	 *
	 *   set prop(v) {
	 *     // this updates the parent property, which is disallowed during change detection
	 *     // this will result in ExpressionChangedAfterItHasBeenCheckedException
	 *     this.parent.parentProp = "updated";
	 *   }
	 * }
	 * ```
	 * @stable
	 */
	var ExpressionChangedAfterItHasBeenCheckedException = (function (_super) {
	    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
	    function ExpressionChangedAfterItHasBeenCheckedException(oldValue, currValue, context) {
	        _super.call(this, "Expression has changed after it was checked. " +
	            ("Previous value: '" + oldValue + "'. Current value: '" + currValue + "'"));
	    }
	    return ExpressionChangedAfterItHasBeenCheckedException;
	}(exceptions_1.BaseException));
	exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
	/**
	 * Thrown when an exception was raised during view creation, change detection or destruction.
	 *
	 * This error wraps the original exception to attach additional contextual information that can
	 * be useful for debugging.
	 * @stable
	 */
	var ViewWrappedException = (function (_super) {
	    __extends(ViewWrappedException, _super);
	    function ViewWrappedException(originalException, originalStack, context) {
	        _super.call(this, "Error in " + context.source, originalException, originalStack, context);
	    }
	    return ViewWrappedException;
	}(exceptions_1.WrappedException));
	exports.ViewWrappedException = ViewWrappedException;
	/**
	 * Thrown when a destroyed view is used.
	 *
	 * This error indicates a bug in the framework.
	 *
	 * This is an internal Angular error.
	 * @stable
	 */
	var ViewDestroyedException = (function (_super) {
	    __extends(ViewDestroyedException, _super);
	    function ViewDestroyedException(details) {
	        _super.call(this, "Attempt to use a destroyed view: " + details);
	    }
	    return ViewDestroyedException;
	}(exceptions_1.BaseException));
	exports.ViewDestroyedException = ViewDestroyedException;
	//# sourceMappingURL=exceptions.js.map

/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Defines template and style encapsulation options available for Component's {@link View}.
	 *
	 * See {@link ViewMetadata#encapsulation}.
	 * @stable
	 */
	(function (ViewEncapsulation) {
	    /**
	     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
	     * Element and pre-processing the style rules provided via
	     * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
	     * attribute to all selectors.
	     *
	     * This is the default option.
	     */
	    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
	    /**
	     * Use the native encapsulation mechanism of the renderer.
	     *
	     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
	     * creating a ShadowRoot for Component's Host Element.
	     */
	    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
	    /**
	     * Don't provide any template or style encapsulation.
	     */
	    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
	})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
	var ViewEncapsulation = exports.ViewEncapsulation;
	exports.VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];
	/**
	 * Metadata properties available for configuring Views.
	 *
	 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
	 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
	 * within the template.
	 *
	 * When a component is instantiated, the template is loaded into the component's shadow root, and
	 * the expressions and statements in the template are evaluated against the component.
	 *
	 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
	 *
	 * ### Example
	 *
	 * ```
	 * @Component({
	 *   selector: 'greet',
	 *   template: 'Hello {{name}}!',
	 *   directives: [GreetUser, Bold]
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 *
	 * @experimental You should most likely be using ComponentMetadata instead.
	 */
	var ViewMetadata = (function () {
	    function ViewMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
	        this.templateUrl = templateUrl;
	        this.template = template;
	        this.styleUrls = styleUrls;
	        this.styles = styles;
	        this.directives = directives;
	        this.pipes = pipes;
	        this.encapsulation = encapsulation;
	        this.animations = animations;
	        this.interpolation = interpolation;
	    }
	    return ViewMetadata;
	}());
	exports.ViewMetadata = ViewMetadata;
	//# sourceMappingURL=view.js.map

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Provides read-only access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var ReflectorReader = (function () {
	    function ReflectorReader() {
	    }
	    return ReflectorReader;
	}());
	exports.ReflectorReader = ReflectorReader;
	//# sourceMappingURL=reflector_reader.js.map

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(5);
	/**
	 * @experimental
	 */
	var RenderComponentType = (function () {
	    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles) {
	        this.id = id;
	        this.templateUrl = templateUrl;
	        this.slotCount = slotCount;
	        this.encapsulation = encapsulation;
	        this.styles = styles;
	    }
	    return RenderComponentType;
	}());
	exports.RenderComponentType = RenderComponentType;
	var RenderDebugInfo = (function () {
	    function RenderDebugInfo() {
	    }
	    Object.defineProperty(RenderDebugInfo.prototype, "injector", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "component", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "references", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "context", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "source", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return RenderDebugInfo;
	}());
	exports.RenderDebugInfo = RenderDebugInfo;
	/**
	 * @experimental
	 */
	var Renderer = (function () {
	    function Renderer() {
	    }
	    return Renderer;
	}());
	exports.Renderer = Renderer;
	/**
	 * Injectable service that provides a low-level interface for modifying the UI.
	 *
	 * Use this service to bypass Angular's templating and make custom UI changes that can't be
	 * expressed declaratively. For example if you need to set a property or an attribute whose name is
	 * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
	 * respectively.
	 *
	 * If you are implementing a custom renderer, you must implement this interface.
	 *
	 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	 * @experimental
	 */
	var RootRenderer = (function () {
	    function RootRenderer() {
	    }
	    return RootRenderer;
	}());
	exports.RootRenderer = RootRenderer;
	//# sourceMappingURL=api.js.map

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var decorators_1 = __webpack_require__(25);
	var async_1 = __webpack_require__(18);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var ng_zone_1 = __webpack_require__(77);
	var Testability = (function () {
	    function Testability(_ngZone) {
	        this._ngZone = _ngZone;
	        /** @internal */
	        this._pendingCount = 0;
	        /** @internal */
	        this._isZoneStable = true;
	        /**
	         * Whether any work was done since the last 'whenStable' callback. This is
	         * useful to detect if this could have potentially destabilized another
	         * component while it is stabilizing.
	         * @internal
	         */
	        this._didWork = false;
	        /** @internal */
	        this._callbacks = [];
	        this._watchAngularEvents();
	    }
	    /** @internal */
	    Testability.prototype._watchAngularEvents = function () {
	        var _this = this;
	        async_1.ObservableWrapper.subscribe(this._ngZone.onUnstable, function (_) {
	            _this._didWork = true;
	            _this._isZoneStable = false;
	        });
	        this._ngZone.runOutsideAngular(function () {
	            async_1.ObservableWrapper.subscribe(_this._ngZone.onStable, function (_) {
	                ng_zone_1.NgZone.assertNotInAngularZone();
	                lang_1.scheduleMicroTask(function () {
	                    _this._isZoneStable = true;
	                    _this._runCallbacksIfReady();
	                });
	            });
	        });
	    };
	    Testability.prototype.increasePendingRequestCount = function () {
	        this._pendingCount += 1;
	        this._didWork = true;
	        return this._pendingCount;
	    };
	    Testability.prototype.decreasePendingRequestCount = function () {
	        this._pendingCount -= 1;
	        if (this._pendingCount < 0) {
	            throw new exceptions_1.BaseException('pending async requests below zero');
	        }
	        this._runCallbacksIfReady();
	        return this._pendingCount;
	    };
	    Testability.prototype.isStable = function () {
	        return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	    };
	    /** @internal */
	    Testability.prototype._runCallbacksIfReady = function () {
	        var _this = this;
	        if (this.isStable()) {
	            // Schedules the call backs in a new frame so that it is always async.
	            lang_1.scheduleMicroTask(function () {
	                while (_this._callbacks.length !== 0) {
	                    (_this._callbacks.pop())(_this._didWork);
	                }
	                _this._didWork = false;
	            });
	        }
	        else {
	            // Not Ready
	            this._didWork = true;
	        }
	    };
	    Testability.prototype.whenStable = function (callback) {
	        this._callbacks.push(callback);
	        this._runCallbacksIfReady();
	    };
	    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	    Testability.prototype.findBindings = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    Testability.prototype.findProviders = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    /** @nocollapse */
	    Testability.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    Testability.ctorParameters = [
	        { type: ng_zone_1.NgZone, },
	    ];
	    return Testability;
	}());
	exports.Testability = Testability;
	var TestabilityRegistry = (function () {
	    function TestabilityRegistry() {
	        /** @internal */
	        this._applications = new collection_1.Map();
	        _testabilityGetter.addToWindow(this);
	    }
	    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	        this._applications.set(token, testability);
	    };
	    TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
	    TestabilityRegistry.prototype.getAllTestabilities = function () { return collection_1.MapWrapper.values(this._applications); };
	    TestabilityRegistry.prototype.getAllRootElements = function () { return collection_1.MapWrapper.keys(this._applications); };
	    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	        if (findInAncestors === void 0) { findInAncestors = true; }
	        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	    };
	    /** @nocollapse */
	    TestabilityRegistry.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    TestabilityRegistry.ctorParameters = [];
	    return TestabilityRegistry;
	}());
	exports.TestabilityRegistry = TestabilityRegistry;
	/* @ts2dart_const */
	var _NoopGetTestability = (function () {
	    function _NoopGetTestability() {
	    }
	    _NoopGetTestability.prototype.addToWindow = function (registry) { };
	    _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	        return null;
	    };
	    return _NoopGetTestability;
	}());
	/**
	 * Set the {@link GetTestability} implementation used by the Angular testing framework.
	 * @experimental
	 */
	function setTestabilityGetter(getter) {
	    _testabilityGetter = getter;
	}
	exports.setTestabilityGetter = setTestabilityGetter;
	var _testabilityGetter = new _NoopGetTestability();
	//# sourceMappingURL=testability.js.map

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var async_1 = __webpack_require__(18);
	var exceptions_1 = __webpack_require__(5);
	var ng_zone_impl_1 = __webpack_require__(125);
	var ng_zone_impl_2 = __webpack_require__(125);
	exports.NgZoneError = ng_zone_impl_2.NgZoneError;
	/**
	 * An injectable service for executing work inside or outside of the Angular zone.
	 *
	 * The most common use of this service is to optimize performance when starting a work consisting of
	 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
	 * can reenter the Angular zone via {@link #run}.
	 *
	 * <!-- TODO: add/fix links to:
	 *   - docs explaining zones and the use of zones in Angular and change-detection
	 *   - link to runOutsideAngular/run (throughout this file!)
	 *   -->
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 * ```
	 * import {Component, View, NgZone} from '@angular/core';
	 * import {NgIf} from '@angular/common';
	 *
	 * @Component({
	 *   selector: 'ng-zone-demo'.
	 *   template: `
	 *     <h2>Demo: NgZone</h2>
	 *
	 *     <p>Progress: {{progress}}%</p>
	 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	 *
	 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	 *   `,
	 *   directives: [NgIf]
	 * })
	 * export class NgZoneDemo {
	 *   progress: number = 0;
	 *   label: string;
	 *
	 *   constructor(private _ngZone: NgZone) {}
	 *
	 *   // Loop inside the Angular zone
	 *   // so the UI DOES refresh after each setTimeout cycle
	 *   processWithinAngularZone() {
	 *     this.label = 'inside';
	 *     this.progress = 0;
	 *     this._increaseProgress(() => console.log('Inside Done!'));
	 *   }
	 *
	 *   // Loop outside of the Angular zone
	 *   // so the UI DOES NOT refresh after each setTimeout cycle
	 *   processOutsideOfAngularZone() {
	 *     this.label = 'outside';
	 *     this.progress = 0;
	 *     this._ngZone.runOutsideAngular(() => {
	 *       this._increaseProgress(() => {
	 *       // reenter the Angular zone and display done
	 *       this._ngZone.run(() => {console.log('Outside Done!') });
	 *     }}));
	 *   }
	 *
	 *
	 *   _increaseProgress(doneCallback: () => void) {
	 *     this.progress += 1;
	 *     console.log(`Current progress: ${this.progress}%`);
	 *
	 *     if (this.progress < 100) {
	 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	 *     } else {
	 *       doneCallback();
	 *     }
	 *   }
	 * }
	 * ```
	 * @experimental
	 */
	var NgZone = (function () {
	    function NgZone(_a) {
	        var _this = this;
	        var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
	        this._hasPendingMicrotasks = false;
	        this._hasPendingMacrotasks = false;
	        /** @internal */
	        this._isStable = true;
	        /** @internal */
	        this._nesting = 0;
	        /** @internal */
	        this._onUnstable = new async_1.EventEmitter(false);
	        /** @internal */
	        this._onMicrotaskEmpty = new async_1.EventEmitter(false);
	        /** @internal */
	        this._onStable = new async_1.EventEmitter(false);
	        /** @internal */
	        this._onErrorEvents = new async_1.EventEmitter(false);
	        this._zoneImpl = new ng_zone_impl_1.NgZoneImpl({
	            trace: enableLongStackTrace,
	            onEnter: function () {
	                // console.log('ZONE.enter', this._nesting, this._isStable);
	                _this._nesting++;
	                if (_this._isStable) {
	                    _this._isStable = false;
	                    _this._onUnstable.emit(null);
	                }
	            },
	            onLeave: function () {
	                _this._nesting--;
	                // console.log('ZONE.leave', this._nesting, this._isStable);
	                _this._checkStable();
	            },
	            setMicrotask: function (hasMicrotasks) {
	                _this._hasPendingMicrotasks = hasMicrotasks;
	                _this._checkStable();
	            },
	            setMacrotask: function (hasMacrotasks) { _this._hasPendingMacrotasks = hasMacrotasks; },
	            onError: function (error) { return _this._onErrorEvents.emit(error); }
	        });
	    }
	    NgZone.isInAngularZone = function () { return ng_zone_impl_1.NgZoneImpl.isInAngularZone(); };
	    NgZone.assertInAngularZone = function () {
	        if (!ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
	            throw new exceptions_1.BaseException('Expected to be in Angular Zone, but it is not!');
	        }
	    };
	    NgZone.assertNotInAngularZone = function () {
	        if (ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
	            throw new exceptions_1.BaseException('Expected to not be in Angular Zone, but it is!');
	        }
	    };
	    NgZone.prototype._checkStable = function () {
	        var _this = this;
	        if (this._nesting == 0) {
	            if (!this._hasPendingMicrotasks && !this._isStable) {
	                try {
	                    // console.log('ZONE.microtaskEmpty');
	                    this._nesting++;
	                    this._onMicrotaskEmpty.emit(null);
	                }
	                finally {
	                    this._nesting--;
	                    if (!this._hasPendingMicrotasks) {
	                        try {
	                            // console.log('ZONE.stable', this._nesting, this._isStable);
	                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
	                        }
	                        finally {
	                            this._isStable = true;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    ;
	    Object.defineProperty(NgZone.prototype, "onUnstable", {
	        /**
	         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	         */
	        get: function () { return this._onUnstable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
	        /**
	         * Notifies when there is no more microtasks enqueue in the current VM Turn.
	         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	         * For this reason this event can fire multiple times per VM Turn.
	         */
	        get: function () { return this._onMicrotaskEmpty; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onStable", {
	        /**
	         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	         * implies we are about to relinquish VM turn.
	         * This event gets called just once.
	         */
	        get: function () { return this._onStable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onError", {
	        /**
	         * Notify that an error has been delivered.
	         */
	        get: function () { return this._onErrorEvents; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "isStable", {
	        /**
	         * Whether there are no outstanding microtasks or microtasks.
	         */
	        get: function () { return this._isStable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
	        /**
	         * Whether there are any outstanding microtasks.
	         */
	        get: function () { return this._hasPendingMicrotasks; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
	        /**
	         * Whether there are any outstanding microtasks.
	         */
	        get: function () { return this._hasPendingMacrotasks; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * within the Angular zone.
	     *
	     * If a synchronous error happens it will be rethrown and not reported via `onError`.
	     */
	    NgZone.prototype.run = function (fn) { return this._zoneImpl.runInner(fn); };
	    /**
	     * Same as #run, except that synchronous errors are caught and forwarded
	     * via `onError` and not rethrown.
	     */
	    NgZone.prototype.runGuarded = function (fn) { return this._zoneImpl.runInnerGuarded(fn); };
	    /**
	     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * outside of the Angular zone.
	     *
	     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
	     */
	    NgZone.prototype.runOutsideAngular = function (fn) { return this._zoneImpl.runOuter(fn); };
	    return NgZone;
	}());
	exports.NgZone = NgZone;
	//# sourceMappingURL=ng_zone.js.map

/***/ },
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(21);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 85 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	exports.FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
	exports.ANY_STATE = '*';
	exports.DEFAULT_STATE = '*';
	exports.EMPTY_STATE = 'void';
	//# sourceMappingURL=animation_constants.js.map

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var math_1 = __webpack_require__(202);
	var AnimationGroupPlayer = (function () {
	    function AnimationGroupPlayer(_players) {
	        var _this = this;
	        this._players = _players;
	        this._subscriptions = [];
	        this._finished = false;
	        this.parentPlayer = null;
	        var count = 0;
	        var total = this._players.length;
	        if (total == 0) {
	            lang_1.scheduleMicroTask(function () { return _this._onFinish(); });
	        }
	        else {
	            this._players.forEach(function (player) {
	                player.parentPlayer = _this;
	                player.onDone(function () {
	                    if (++count >= total) {
	                        _this._onFinish();
	                    }
	                });
	            });
	        }
	    }
	    AnimationGroupPlayer.prototype._onFinish = function () {
	        if (!this._finished) {
	            this._finished = true;
	            if (!lang_1.isPresent(this.parentPlayer)) {
	                this.destroy();
	            }
	            this._subscriptions.forEach(function (subscription) { return subscription(); });
	            this._subscriptions = [];
	        }
	    };
	    AnimationGroupPlayer.prototype.onDone = function (fn) { this._subscriptions.push(fn); };
	    AnimationGroupPlayer.prototype.play = function () { this._players.forEach(function (player) { return player.play(); }); };
	    AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
	    AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
	    AnimationGroupPlayer.prototype.finish = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.finish(); });
	    };
	    AnimationGroupPlayer.prototype.destroy = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.destroy(); });
	    };
	    AnimationGroupPlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
	    AnimationGroupPlayer.prototype.setPosition = function (p /** TODO #9100 */) {
	        this._players.forEach(function (player) { player.setPosition(p); });
	    };
	    AnimationGroupPlayer.prototype.getPosition = function () {
	        var min = 0;
	        this._players.forEach(function (player) {
	            var p = player.getPosition();
	            min = math_1.Math.min(p, min);
	        });
	        return min;
	    };
	    return AnimationGroupPlayer;
	}());
	exports.AnimationGroupPlayer = AnimationGroupPlayer;
	//# sourceMappingURL=animation_group_player.js.map

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/**
	 * @experimental Animation support is experimental.
	 */
	exports.AUTO_STYLE = '*';
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link trigger trigger
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationEntryMetadata = (function () {
	    function AnimationEntryMetadata(name, definitions) {
	        this.name = name;
	        this.definitions = definitions;
	    }
	    return AnimationEntryMetadata;
	}());
	exports.AnimationEntryMetadata = AnimationEntryMetadata;
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateMetadata = (function () {
	    function AnimationStateMetadata() {
	    }
	    return AnimationStateMetadata;
	}());
	exports.AnimationStateMetadata = AnimationStateMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link state state animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateDeclarationMetadata = (function (_super) {
	    __extends(AnimationStateDeclarationMetadata, _super);
	    function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
	        _super.call(this);
	        this.stateNameExpr = stateNameExpr;
	        this.styles = styles;
	    }
	    return AnimationStateDeclarationMetadata;
	}(AnimationStateMetadata));
	exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the
	 * {@link transition transition animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateTransitionMetadata = (function (_super) {
	    __extends(AnimationStateTransitionMetadata, _super);
	    function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
	        _super.call(this);
	        this.stateChangeExpr = stateChangeExpr;
	        this.steps = steps;
	    }
	    return AnimationStateTransitionMetadata;
	}(AnimationStateMetadata));
	exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationMetadata = (function () {
	    function AnimationMetadata() {
	    }
	    return AnimationMetadata;
	}());
	exports.AnimationMetadata = AnimationMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationKeyframesSequenceMetadata = (function (_super) {
	    __extends(AnimationKeyframesSequenceMetadata, _super);
	    function AnimationKeyframesSequenceMetadata(steps) {
	        _super.call(this);
	        this.steps = steps;
	    }
	    return AnimationKeyframesSequenceMetadata;
	}(AnimationMetadata));
	exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link style style animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStyleMetadata = (function (_super) {
	    __extends(AnimationStyleMetadata, _super);
	    function AnimationStyleMetadata(styles, offset) {
	        if (offset === void 0) { offset = null; }
	        _super.call(this);
	        this.styles = styles;
	        this.offset = offset;
	    }
	    return AnimationStyleMetadata;
	}(AnimationMetadata));
	exports.AnimationStyleMetadata = AnimationStyleMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link animate animate
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationAnimateMetadata = (function (_super) {
	    __extends(AnimationAnimateMetadata, _super);
	    function AnimationAnimateMetadata(timings, styles) {
	        _super.call(this);
	        this.timings = timings;
	        this.styles = styles;
	    }
	    return AnimationAnimateMetadata;
	}(AnimationMetadata));
	exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationWithStepsMetadata = (function (_super) {
	    __extends(AnimationWithStepsMetadata, _super);
	    function AnimationWithStepsMetadata() {
	        _super.call(this);
	    }
	    Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
	        get: function () { throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class'); },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationWithStepsMetadata;
	}(AnimationMetadata));
	exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link sequence sequence
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationSequenceMetadata = (function (_super) {
	    __extends(AnimationSequenceMetadata, _super);
	    function AnimationSequenceMetadata(_steps) {
	        _super.call(this);
	        this._steps = _steps;
	    }
	    Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
	        get: function () { return this._steps; },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationSequenceMetadata;
	}(AnimationWithStepsMetadata));
	exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link group group animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationGroupMetadata = (function (_super) {
	    __extends(AnimationGroupMetadata, _super);
	    function AnimationGroupMetadata(_steps) {
	        _super.call(this);
	        this._steps = _steps;
	    }
	    Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
	        get: function () { return this._steps; },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationGroupMetadata;
	}(AnimationWithStepsMetadata));
	exports.AnimationGroupMetadata = AnimationGroupMetadata;
	/**
	 * `animate` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `animate` specifies an animation step that will apply the provided `styles` data for a given
	 * amount of
	 * time based on the provided `timing` expression value. Calls to `animate` are expected to be
	 * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition
	 * transition}.
	 *
	 * ### Usage
	 *
	 * The `animate` function accepts two input parameters: `timing` and `styles`:
	 *
	 * - `timing` is a string based value that can be a combination of a duration with optional
	 * delay and easing values. The format for the expression breaks down to `duration delay easing`
	 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
	 * delay=100, easing=ease-out`.
	 * If a numeric value is provided then that will be used as the `duration` value in millisecond
	 * form.
	 * - `styles` is the style input data which can either be a call to {@link style style} or {@link
	 * keyframes keyframes}.
	 * If left empty then the styles from the destination state will be collected and used (this is
	 * useful when
	 * describing an animation step that will complete an animation by {@link
	 * transition#the-final-animate-call animating to the final state}).
	 *
	 * ```typescript
	 * // various functions for specifying timing data
	 * animate(500, style(...))
	 * animate("1s", style(...))
	 * animate("100ms 0.5s", style(...))
	 * animate("5s ease", style(...))
	 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
	 *
	 * // either style() of keyframes() can be used
	 * animate(500, style({ background: "red" }))
	 * animate(500, keyframes([
	 *   style({ background: "blue" })),
	 *   style({ background: "red" }))
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function animate(timing, styles) {
	    if (styles === void 0) { styles = null; }
	    var stylesEntry = styles;
	    if (!lang_1.isPresent(stylesEntry)) {
	        var EMPTY_STYLE = {};
	        stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
	    }
	    return new AnimationAnimateMetadata(timing, stylesEntry);
	}
	exports.animate = animate;
	/**
	 * `group` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
	 * are useful when a series of styles must be animated/closed off
	 * at different statrting/ending times.
	 *
	 * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
	 * transition}
	 * and it will only continue to the next instruction once all of the inner animation steps
	 * have completed.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `group` animation function can either consist
	 * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or
	 * `animate()`
	 * within a group will be executed instantly (use {@link keyframes keyframes} or a
	 * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later
	 * time).
	 *
	 * ```typescript
	 * group([
	 *   animate("1s", { background: "black" }))
	 *   animate("2s", { color: "white" }))
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function group(steps) {
	    return new AnimationGroupMetadata(steps);
	}
	exports.group = group;
	/**
	 * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
	 * by default when an array is passed as animation data into {@link transition transition}.)
	 *
	 * The `sequence` function can either be used within a {@link group group} or a {@link transition
	 * transition}
	 * and it will only continue to the next instruction once each of the inner animation steps
	 * have completed.
	 *
	 * To perform animation styling in parallel with other animation steps then
	 * have a look at the {@link group group} animation function.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `sequence` animation function can either consist
	 * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply
	 * the
	 * provided styling data immediately while a call to `animate()` will apply its styling
	 * data over a given time depending on its timing data.
	 *
	 * ```typescript
	 * sequence([
	 *   style({ opacity: 0 })),
	 *   animate("1s", { opacity: 1 }))
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function sequence(steps) {
	    return new AnimationSequenceMetadata(steps);
	}
	exports.sequence = sequence;
	/**
	 * `style` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `style` declares a key/value object containing CSS properties/styles that can then
	 * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as
	 * styling data for both {@link animate animate} and {@link keyframes keyframes}.
	 *
	 * ### Usage
	 *
	 * `style` takes in a key/value string map as data and expects one or more CSS property/value
	 * pairs to be defined.
	 *
	 * ```typescript
	 * // string values are used for css properties
	 * style({ background: "red", color: "blue" })
	 *
	 * // numerical (pixel) values are also supported
	 * style({ width: 100, height: 0 })
	 * ```
	 *
	 * #### Auto-styles (using `*`)
	 *
	 * When an asterix (`*`) character is used as a value then it will be detected from the element
	 * being animated
	 * and applied as animation data when the animation starts.
	 *
	 * This feature proves useful for a state depending on layout and/or environment factors; in such
	 * cases
	 * the styles are calculated just before the animation starts.
	 *
	 * ```typescript
	 * // the steps below will animate from 0 to the
	 * // actual height of the element
	 * style({ height: 0 }),
	 * animate("1s", style({ height: "*" }))
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function style(tokens) {
	    var input;
	    var offset = null;
	    if (lang_1.isString(tokens)) {
	        input = [tokens];
	    }
	    else {
	        if (lang_1.isArray(tokens)) {
	            input = tokens;
	        }
	        else {
	            input = [tokens];
	        }
	        input.forEach(function (entry) {
	            var entryOffset = entry['offset'];
	            if (lang_1.isPresent(entryOffset)) {
	                offset = offset == null ? lang_1.NumberWrapper.parseFloat(entryOffset) : offset;
	            }
	        });
	    }
	    return new AnimationStyleMetadata(input, offset);
	}
	exports.style = style;
	/**
	 * `state` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `state` declares an animation state within the given trigger. When a state is
	 * active within a component then its associated styles will persist on
	 * the element that the trigger is attached to (even when the animation ends).
	 *
	 * To animate between states, have a look at the animation {@link transition transition}
	 * DSL function. To register states to an animation trigger please have a look
	 * at the {@link trigger trigger} function.
	 *
	 * #### The `void` state
	 *
	 * The `void` state value is a reserved word that angular uses to determine when the element is not
	 * apart
	 * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
	 * associated element
	 * is void).
	 *
	 * #### The `*` (default) state
	 *
	 * The `*` state (when styled) is a fallback state that will be used if
	 * the state that is being animated is not declared within the trigger.
	 *
	 * ### Usage
	 *
	 * `state` will declare an animation state with its associated styles
	 * within the given trigger.
	 *
	 * - `stateNameExpr` can be one or more state names separated by commas.
	 * - `styles` refers to the {@link style styling data} that will be persisted on the element once
	 * the state
	 * has been reached.
	 *
	 * ```typescript
	 * // "void" is a reserved name for a state and is used to represent
	 * // the state in which an element is detached from from the application.
	 * state("void", style({ height: 0 }))
	 *
	 * // user-defined states
	 * state("closed", style({ height: 0 }))
	 * state("open, visible", style({ height: "*" }))
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function state(stateNameExpr, styles) {
	    return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
	}
	exports.state = state;
	/**
	 * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
	 * by an `offset` value.
	 *
	 * ### Usage
	 *
	 * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
	 * animation function. Instead of applying animations from where they are
	 * currently to their destination, keyframes can describe how each style entry is applied
	 * and at what point within the animation arc (much like CSS Keyframe Animations do).
	 *
	 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
	 * what percentage of the animate time the styles will be applied.
	 *
	 * ```typescript
	 * // the provided offset values describe when each backgroundColor value is applied.
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red", offset: 0 }),
	 *   style({ backgroundColor: "blue", offset: 0.2 }),
	 *   style({ backgroundColor: "orange", offset: 0.3 }),
	 *   style({ backgroundColor: "black", offset: 1 })
	 * ]))
	 * ```
	 *
	 * Alternatively, if there are no `offset` values used within the style entries then the offsets
	 * will
	 * be calculated automatically.
	 *
	 * ```typescript
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red" }) // offset = 0
	 *   style({ backgroundColor: "blue" }) // offset = 0.33
	 *   style({ backgroundColor: "orange" }) // offset = 0.66
	 *   style({ backgroundColor: "black" }) // offset = 1
	 * ]))
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function keyframes(steps) {
	    return new AnimationKeyframesSequenceMetadata(steps);
	}
	exports.keyframes = keyframes;
	/**
	 * `transition` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
	 * provided
	 * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
	 * which consists
	 * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
	 *
	 * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
	 * to animate to
	 * a state value and persist its styles then one or more {@link state animation states} is expected
	 * to be defined.
	 *
	 * ### Usage
	 *
	 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
	 * what the
	 * previous state is and what the current state has become. In other words, if a transition is
	 * defined that
	 * matches the old/current state criteria then the associated animation will be triggered.
	 *
	 * ```typescript
	 * // all transition/state changes are defined within an animation trigger
	 * trigger("myAnimationTrigger", [
	 *   // if a state is defined then its styles will be persisted when the
	 *   // animation has fully completed itself
	 *   state("on", style({ background: "green" })),
	 *   state("off", style({ background: "grey" })),
	 *
	 *   // a transition animation that will be kicked off when the state value
	 *   // bound to "myAnimationTrigger" changes from "on" to "off"
	 *   transition("on => off", animate(500)),
	 *
	 *   // it is also possible to do run the same animation for both directions
	 *   transition("on <=> off", animate(500)),
	 *
	 *   // or to define multiple states pairs separated by commas
	 *   transition("on => off, off => void", animate(500)),
	 *
	 *   // this is a catch-all state change for when an element is inserted into
	 *   // the page and the destination state is unknown
	 *   transition("void => *", [
	 *     style({ opacity: 0 }),
	 *     animate(500)
	 *   ]),
	 *
	 *   // this will capture a state change between any states
	 *   transition("* => *", animate("1s 0s")),
	 * ])
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger`
	 * animation trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div @myAnimationTrigger="myStatusExp">...</div>
	 * ```
	 *
	 * #### The final `animate` call
	 *
	 * If the final step within the transition steps is a call to `animate()` that **only**
	 * uses a timing value with **no style data** then it will be automatically used as the final
	 * animation
	 * arc for the element to animate itself to the final state. This involves an automatic mix of
	 * adding/removing CSS styles so that the element will be in the exact state it should be for the
	 * applied state to be presented correctly.
	 *
	 * ```
	 * // start off by hiding the element, but make sure that it animates properly to whatever state
	 * // is currently active for "myAnimationTrigger"
	 * transition("void => *", [
	 *   style({ opacity: 0 }),
	 *   animate(500)
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function transition(stateChangeExpr, steps) {
	    var animationData = lang_1.isArray(steps) ? new AnimationSequenceMetadata(steps) :
	        steps;
	    return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
	}
	exports.transition = transition;
	/**
	 * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
	 * transition transition}
	 * entries that will be evaluated when the expression bound to the trigger changes.
	 *
	 * Triggers are registered within the component annotation data under the
	 * {@link ComponentMetadata#animations-anchor animations section}. An animation trigger can
	 * be placed on an element within a template by referencing the name of the
	 * trigger followed by the expression value that the trigger is bound to
	 * (in the form of `@triggerName="expression"`.
	 *
	 * ### Usage
	 *
	 * `trigger` will create an animation trigger reference based on the provided `name` value.
	 * The provided `animation` value is expected to be an array consisting of {@link state state} and
	 * {@link transition transition}
	 * declarations.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'my-component-tpl.html',
	 *   animations: [
	 *     trigger("myAnimationTrigger", [
	 *       state(...),
	 *       state(...),
	 *       transition(...),
	 *       transition(...)
	 *     ])
	 *   ]
	 * })
	 * class MyComponent {
	 *   myStatusExp = "something";
	 * }
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger`
	 * animation trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div @myAnimationTrigger="myStatusExp">...</div>
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function trigger(name, animation) {
	    return new AnimationEntryMetadata(name, animation);
	}
	exports.trigger = trigger;
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/* @ts2dart_const */
	var DefaultKeyValueDifferFactory = (function () {
	    function DefaultKeyValueDifferFactory() {
	    }
	    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || lang_1.isJsObject(obj); };
	    DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
	    return DefaultKeyValueDifferFactory;
	}());
	exports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;
	var DefaultKeyValueDiffer = (function () {
	    function DefaultKeyValueDiffer() {
	        this._records = new Map();
	        this._mapHead = null;
	        this._previousMapHead = null;
	        this._changesHead = null;
	        this._changesTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	    }
	    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	        get: function () {
	            return this._additionsHead !== null || this._changesHead !== null ||
	                this._removalsHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	        var record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	        var record;
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	        var record;
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	        var record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	        var record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.diff = function (map) {
	        if (lang_1.isBlank(map))
	            map = collection_1.MapWrapper.createFromPairs([]);
	        if (!(map instanceof Map || lang_1.isJsObject(map))) {
	            throw new exceptions_1.BaseException("Error trying to diff '" + map + "'");
	        }
	        if (this.check(map)) {
	            return this;
	        }
	        else {
	            return null;
	        }
	    };
	    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	    DefaultKeyValueDiffer.prototype.check = function (map) {
	        var _this = this;
	        this._reset();
	        var records = this._records;
	        var oldSeqRecord = this._mapHead;
	        var lastOldSeqRecord = null;
	        var lastNewSeqRecord = null;
	        var seqChanged = false;
	        this._forEach(map, function (value /** TODO #9100 */, key /** TODO #9100 */) {
	            var newSeqRecord;
	            if (oldSeqRecord !== null && key === oldSeqRecord.key) {
	                newSeqRecord = oldSeqRecord;
	                if (!lang_1.looseIdentical(value, oldSeqRecord.currentValue)) {
	                    oldSeqRecord.previousValue = oldSeqRecord.currentValue;
	                    oldSeqRecord.currentValue = value;
	                    _this._addToChanges(oldSeqRecord);
	                }
	            }
	            else {
	                seqChanged = true;
	                if (oldSeqRecord !== null) {
	                    oldSeqRecord._next = null;
	                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
	                    _this._addToRemovals(oldSeqRecord);
	                }
	                if (records.has(key)) {
	                    newSeqRecord = records.get(key);
	                }
	                else {
	                    newSeqRecord = new KeyValueChangeRecord(key);
	                    records.set(key, newSeqRecord);
	                    newSeqRecord.currentValue = value;
	                    _this._addToAdditions(newSeqRecord);
	                }
	            }
	            if (seqChanged) {
	                if (_this._isInRemovals(newSeqRecord)) {
	                    _this._removeFromRemovals(newSeqRecord);
	                }
	                if (lastNewSeqRecord == null) {
	                    _this._mapHead = newSeqRecord;
	                }
	                else {
	                    lastNewSeqRecord._next = newSeqRecord;
	                }
	            }
	            lastOldSeqRecord = oldSeqRecord;
	            lastNewSeqRecord = newSeqRecord;
	            oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
	        });
	        this._truncate(lastOldSeqRecord, oldSeqRecord);
	        return this.isDirty;
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var record;
	            // Record the state of the mapping
	            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                record.previousValue = record.currentValue;
	            }
	            for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                record.previousValue = record.currentValue;
	            }
	            // todo(vicb) once assert is supported
	            // assert(() {
	            //  var r = _changesHead;
	            //  while (r != null) {
	            //    var nextRecord = r._nextChanged;
	            //    r._nextChanged = null;
	            //    r = nextRecord;
	            //  }
	            //
	            //  r = _additionsHead;
	            //  while (r != null) {
	            //    var nextRecord = r._nextAdded;
	            //    r._nextAdded = null;
	            //    r = nextRecord;
	            //  }
	            //
	            //  r = _removalsHead;
	            //  while (r != null) {
	            //    var nextRecord = r._nextRemoved;
	            //    r._nextRemoved = null;
	            //    r = nextRecord;
	            //  }
	            //
	            //  return true;
	            //});
	            this._changesHead = this._changesTail = null;
	            this._additionsHead = this._additionsTail = null;
	            this._removalsHead = this._removalsTail = null;
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
	        while (record !== null) {
	            if (lastRecord === null) {
	                this._mapHead = null;
	            }
	            else {
	                lastRecord._next = null;
	            }
	            var nextRecord = record._next;
	            // todo(vicb) assert
	            // assert((() {
	            //  record._next = null;
	            //  return true;
	            //}));
	            this._addToRemovals(record);
	            lastRecord = record;
	            record = nextRecord;
	        }
	        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
	            rec.previousValue = rec.currentValue;
	            rec.currentValue = null;
	            this._records.delete(rec.key);
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
	        return record === this._removalsHead || record._nextRemoved !== null ||
	            record._prevRemoved !== null;
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
	        // todo(vicb) assert
	        // assert(record._next == null);
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        // assert(record._nextRemoved == null);
	        // assert(record._prevRemoved == null);
	        if (this._removalsHead === null) {
	            this._removalsHead = this._removalsTail = record;
	        }
	        else {
	            this._removalsTail._nextRemoved = record;
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = record;
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
	        var next = record._next;
	        if (prev === null) {
	            this._mapHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        // todo(vicb) assert
	        // assert((() {
	        //  record._next = null;
	        //  return true;
	        //})());
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
	        // todo(vicb) assert
	        // assert(record._next == null);
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        var prev = record._prevRemoved;
	        var next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        record._prevRemoved = record._nextRemoved = null;
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	        // todo(vicb): assert
	        // assert(record._next == null);
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        // assert(record._nextRemoved == null);
	        // assert(record._prevRemoved == null);
	        if (this._additionsHead === null) {
	            this._additionsHead = this._additionsTail = record;
	        }
	        else {
	            this._additionsTail._nextAdded = record;
	            this._additionsTail = record;
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	        // todo(vicb) assert
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        // assert(record._nextRemoved == null);
	        // assert(record._prevRemoved == null);
	        if (this._changesHead === null) {
	            this._changesHead = this._changesTail = record;
	        }
	        else {
	            this._changesTail._nextChanged = record;
	            this._changesTail = record;
	        }
	    };
	    DefaultKeyValueDiffer.prototype.toString = function () {
	        var items = [];
	        var previous = [];
	        var changes = [];
	        var additions = [];
	        var removals = [];
	        var record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            items.push(lang_1.stringify(record));
	        }
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            previous.push(lang_1.stringify(record));
	        }
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            changes.push(lang_1.stringify(record));
	        }
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            additions.push(lang_1.stringify(record));
	        }
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            removals.push(lang_1.stringify(record));
	        }
	        return 'map: ' + items.join(', ') + '\n' +
	            'previous: ' + previous.join(', ') + '\n' +
	            'additions: ' + additions.join(', ') + '\n' +
	            'changes: ' + changes.join(', ') + '\n' +
	            'removals: ' + removals.join(', ') + '\n';
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._forEach = function (obj /** TODO #9100 */, fn) {
	        if (obj instanceof Map) {
	            obj.forEach(fn);
	        }
	        else {
	            collection_1.StringMapWrapper.forEach(obj, fn);
	        }
	    };
	    return DefaultKeyValueDiffer;
	}());
	exports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;
	/**
	 * @stable
	 */
	var KeyValueChangeRecord = (function () {
	    function KeyValueChangeRecord(key) {
	        this.key = key;
	        this.previousValue = null;
	        this.currentValue = null;
	        /** @internal */
	        this._nextPrevious = null;
	        /** @internal */
	        this._next = null;
	        /** @internal */
	        this._nextAdded = null;
	        /** @internal */
	        this._nextRemoved = null;
	        /** @internal */
	        this._prevRemoved = null;
	        /** @internal */
	        this._nextChanged = null;
	    }
	    KeyValueChangeRecord.prototype.toString = function () {
	        return lang_1.looseIdentical(this.previousValue, this.currentValue) ?
	            lang_1.stringify(this.key) :
	            (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' +
	                lang_1.stringify(this.currentValue) + ']');
	    };
	    return KeyValueChangeRecord;
	}());
	exports.KeyValueChangeRecord = KeyValueChangeRecord;
	//# sourceMappingURL=default_keyvalue_differ.js.map

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(24);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/**
	 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	 * @ts2dart_const
	 * @stable
	 */
	var IterableDiffers = (function () {
	    /*@ts2dart_const*/
	    function IterableDiffers(factories) {
	        this.factories = factories;
	    }
	    IterableDiffers.create = function (factories, parent) {
	        if (lang_1.isPresent(parent)) {
	            var copied = collection_1.ListWrapper.clone(parent.factories);
	            factories = factories.concat(copied);
	            return new IterableDiffers(factories);
	        }
	        else {
	            return new IterableDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
	     * inherited {@link IterableDiffers} instance with the provided factories and return a new
	     * {@link IterableDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	           * which will only be applied to the injector for this component and its children.
	           * This step is all that's required to make a new {@link IterableDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * @Component({
	     *   viewProviders: [
	     *     IterableDiffers.extend([new ImmutableListDiffer()])
	     *   ]
	     * })
	     * ```
	     */
	    IterableDiffers.extend = function (factories) {
	        return new di_1.Provider(IterableDiffers, {
	            useFactory: function (parent) {
	                if (lang_1.isBlank(parent)) {
	                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');
	                }
	                return IterableDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
	        });
	    };
	    IterableDiffers.prototype.find = function (iterable) {
	        var factory = this.factories.find(function (f) { return f.supports(iterable); });
	        if (lang_1.isPresent(factory)) {
	            return factory;
	        }
	        else {
	            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + iterable + "' of type '" + lang_1.getTypeNameForDebugging(iterable) + "'");
	        }
	    };
	    return IterableDiffers;
	}());
	exports.IterableDiffers = IterableDiffers;
	//# sourceMappingURL=iterable_differs.js.map

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(24);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/**
	 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	 * @ts2dart_const
	 * @stable
	 */
	var KeyValueDiffers = (function () {
	    /*@ts2dart_const*/
	    function KeyValueDiffers(factories) {
	        this.factories = factories;
	    }
	    KeyValueDiffers.create = function (factories, parent) {
	        if (lang_1.isPresent(parent)) {
	            var copied = collection_1.ListWrapper.clone(parent.factories);
	            factories = factories.concat(copied);
	            return new KeyValueDiffers(factories);
	        }
	        else {
	            return new KeyValueDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
	     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
	     * {@link KeyValueDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	           * which will only be applied to the injector for this component and its children.
	           * This step is all that's required to make a new {@link KeyValueDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * @Component({
	     *   viewProviders: [
	     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	     *   ]
	     * })
	     * ```
	     */
	    KeyValueDiffers.extend = function (factories) {
	        return new di_1.Provider(KeyValueDiffers, {
	            useFactory: function (parent) {
	                if (lang_1.isBlank(parent)) {
	                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');
	                }
	                return KeyValueDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
	        });
	    };
	    KeyValueDiffers.prototype.find = function (kv) {
	        var factory = this.factories.find(function (f) { return f.supports(kv); });
	        if (lang_1.isPresent(factory)) {
	            return factory;
	        }
	        else {
	            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + kv + "'");
	        }
	    };
	    return KeyValueDiffers;
	}());
	exports.KeyValueDiffers = KeyValueDiffers;
	//# sourceMappingURL=keyvalue_differs.js.map

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var EventListener = (function () {
	    function EventListener(name, callback) {
	        this.name = name;
	        this.callback = callback;
	    }
	    ;
	    return EventListener;
	}());
	exports.EventListener = EventListener;
	/**
	 * @experimental All debugging apis are currently experimental.
	 */
	var DebugNode = (function () {
	    function DebugNode(nativeNode, parent, _debugInfo) {
	        this._debugInfo = _debugInfo;
	        this.nativeNode = nativeNode;
	        if (lang_1.isPresent(parent) && parent instanceof DebugElement) {
	            parent.addChild(this);
	        }
	        else {
	            this.parent = null;
	        }
	        this.listeners = [];
	    }
	    Object.defineProperty(DebugNode.prototype, "injector", {
	        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.injector : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "componentInstance", {
	        get: function () {
	            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.component : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "context", {
	        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.context : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "references", {
	        get: function () {
	            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.references : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "providerTokens", {
	        get: function () {
	            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "source", {
	        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.source : null; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Use injector.get(token) instead.
	     *
	     * @deprecated
	     */
	    DebugNode.prototype.inject = function (token) { return this.injector.get(token); };
	    return DebugNode;
	}());
	exports.DebugNode = DebugNode;
	/**
	 * @experimental All debugging apis are currently experimental.
	 */
	var DebugElement = (function (_super) {
	    __extends(DebugElement, _super);
	    function DebugElement(nativeNode, parent, _debugInfo) {
	        _super.call(this, nativeNode, parent, _debugInfo);
	        this.properties = {};
	        this.attributes = {};
	        this.classes = {};
	        this.styles = {};
	        this.childNodes = [];
	        this.nativeElement = nativeNode;
	    }
	    DebugElement.prototype.addChild = function (child) {
	        if (lang_1.isPresent(child)) {
	            this.childNodes.push(child);
	            child.parent = this;
	        }
	    };
	    DebugElement.prototype.removeChild = function (child) {
	        var childIndex = this.childNodes.indexOf(child);
	        if (childIndex !== -1) {
	            child.parent = null;
	            this.childNodes.splice(childIndex, 1);
	        }
	    };
	    DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
	        var siblingIndex = this.childNodes.indexOf(child);
	        if (siblingIndex !== -1) {
	            var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
	            var nextChildren = this.childNodes.slice(siblingIndex + 1);
	            this.childNodes =
	                collection_1.ListWrapper.concat(collection_1.ListWrapper.concat(previousChildren, newChildren), nextChildren);
	            for (var i = 0; i < newChildren.length; ++i) {
	                var newChild = newChildren[i];
	                if (lang_1.isPresent(newChild.parent)) {
	                    newChild.parent.removeChild(newChild);
	                }
	                newChild.parent = this;
	            }
	        }
	    };
	    DebugElement.prototype.query = function (predicate) {
	        var results = this.queryAll(predicate);
	        return results.length > 0 ? results[0] : null;
	    };
	    DebugElement.prototype.queryAll = function (predicate) {
	        var matches = [];
	        _queryElementChildren(this, predicate, matches);
	        return matches;
	    };
	    DebugElement.prototype.queryAllNodes = function (predicate) {
	        var matches = [];
	        _queryNodeChildren(this, predicate, matches);
	        return matches;
	    };
	    Object.defineProperty(DebugElement.prototype, "children", {
	        get: function () {
	            var children = [];
	            this.childNodes.forEach(function (node) {
	                if (node instanceof DebugElement) {
	                    children.push(node);
	                }
	            });
	            return children;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	        this.listeners.forEach(function (listener) {
	            if (listener.name == eventName) {
	                listener.callback(eventObj);
	            }
	        });
	    };
	    return DebugElement;
	}(DebugNode));
	exports.DebugElement = DebugElement;
	/**
	 * @experimental
	 */
	function asNativeElements(debugEls) {
	    return debugEls.map(function (el) { return el.nativeElement; });
	}
	exports.asNativeElements = asNativeElements;
	function _queryElementChildren(element, predicate, matches) {
	    element.childNodes.forEach(function (node) {
	        if (node instanceof DebugElement) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            _queryElementChildren(node, predicate, matches);
	        }
	    });
	}
	function _queryNodeChildren(parentNode, predicate, matches) {
	    if (parentNode instanceof DebugElement) {
	        parentNode.childNodes.forEach(function (node) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            if (node instanceof DebugElement) {
	                _queryNodeChildren(node, predicate, matches);
	            }
	        });
	    }
	}
	// Need to keep the nodes in a global Map so that multiple angular apps are supported.
	var _nativeNodeToDebugNode = new Map();
	/**
	 * @experimental
	 */
	function getDebugNode(nativeNode) {
	    return _nativeNodeToDebugNode.get(nativeNode);
	}
	exports.getDebugNode = getDebugNode;
	function getAllDebugNodes() {
	    return collection_1.MapWrapper.values(_nativeNodeToDebugNode);
	}
	exports.getAllDebugNodes = getAllDebugNodes;
	function indexDebugNode(node) {
	    _nativeNodeToDebugNode.set(node.nativeNode, node);
	}
	exports.indexDebugNode = indexDebugNode;
	function removeDebugNodeFromIndex(node) {
	    _nativeNodeToDebugNode.delete(node.nativeNode);
	}
	exports.removeDebugNodeFromIndex = removeDebugNodeFromIndex;
	//# sourceMappingURL=debug_node.js.map

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var provider_1 = __webpack_require__(66);
	function isProviderLiteral(obj) {
	    return obj && typeof obj == 'object' && obj.provide;
	}
	exports.isProviderLiteral = isProviderLiteral;
	function createProvider(obj) {
	    return new provider_1.Provider(obj.provide, obj);
	}
	exports.createProvider = createProvider;
	//# sourceMappingURL=provider_util.js.map

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var injector_1 = __webpack_require__(65);
	var metadata_1 = __webpack_require__(26);
	var reflective_exceptions_1 = __webpack_require__(67);
	var reflective_key_1 = __webpack_require__(68);
	var reflective_provider_1 = __webpack_require__(69);
	var __unused; // avoid unused import when Type union types are erased
	// Threshold for the dynamic version
	var _MAX_CONSTRUCTION_COUNTER = 10;
	var UNDEFINED = new Object();
	var ReflectiveProtoInjectorInlineStrategy = (function () {
	    function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
	        this.provider0 = null;
	        this.provider1 = null;
	        this.provider2 = null;
	        this.provider3 = null;
	        this.provider4 = null;
	        this.provider5 = null;
	        this.provider6 = null;
	        this.provider7 = null;
	        this.provider8 = null;
	        this.provider9 = null;
	        this.keyId0 = null;
	        this.keyId1 = null;
	        this.keyId2 = null;
	        this.keyId3 = null;
	        this.keyId4 = null;
	        this.keyId5 = null;
	        this.keyId6 = null;
	        this.keyId7 = null;
	        this.keyId8 = null;
	        this.keyId9 = null;
	        var length = providers.length;
	        if (length > 0) {
	            this.provider0 = providers[0];
	            this.keyId0 = providers[0].key.id;
	        }
	        if (length > 1) {
	            this.provider1 = providers[1];
	            this.keyId1 = providers[1].key.id;
	        }
	        if (length > 2) {
	            this.provider2 = providers[2];
	            this.keyId2 = providers[2].key.id;
	        }
	        if (length > 3) {
	            this.provider3 = providers[3];
	            this.keyId3 = providers[3].key.id;
	        }
	        if (length > 4) {
	            this.provider4 = providers[4];
	            this.keyId4 = providers[4].key.id;
	        }
	        if (length > 5) {
	            this.provider5 = providers[5];
	            this.keyId5 = providers[5].key.id;
	        }
	        if (length > 6) {
	            this.provider6 = providers[6];
	            this.keyId6 = providers[6].key.id;
	        }
	        if (length > 7) {
	            this.provider7 = providers[7];
	            this.keyId7 = providers[7].key.id;
	        }
	        if (length > 8) {
	            this.provider8 = providers[8];
	            this.keyId8 = providers[8].key.id;
	        }
	        if (length > 9) {
	            this.provider9 = providers[9];
	            this.keyId9 = providers[9].key.id;
	        }
	    }
	    ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
	        if (index == 0)
	            return this.provider0;
	        if (index == 1)
	            return this.provider1;
	        if (index == 2)
	            return this.provider2;
	        if (index == 3)
	            return this.provider3;
	        if (index == 4)
	            return this.provider4;
	        if (index == 5)
	            return this.provider5;
	        if (index == 6)
	            return this.provider6;
	        if (index == 7)
	            return this.provider7;
	        if (index == 8)
	            return this.provider8;
	        if (index == 9)
	            return this.provider9;
	        throw new reflective_exceptions_1.OutOfBoundsError(index);
	    };
	    ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
	        return new ReflectiveInjectorInlineStrategy(injector, this);
	    };
	    return ReflectiveProtoInjectorInlineStrategy;
	}());
	exports.ReflectiveProtoInjectorInlineStrategy = ReflectiveProtoInjectorInlineStrategy;
	var ReflectiveProtoInjectorDynamicStrategy = (function () {
	    function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
	        this.providers = providers;
	        var len = providers.length;
	        this.keyIds = collection_1.ListWrapper.createFixedSize(len);
	        for (var i = 0; i < len; i++) {
	            this.keyIds[i] = providers[i].key.id;
	        }
	    }
	    ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
	        if (index < 0 || index >= this.providers.length) {
	            throw new reflective_exceptions_1.OutOfBoundsError(index);
	        }
	        return this.providers[index];
	    };
	    ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
	        return new ReflectiveInjectorDynamicStrategy(this, ei);
	    };
	    return ReflectiveProtoInjectorDynamicStrategy;
	}());
	exports.ReflectiveProtoInjectorDynamicStrategy = ReflectiveProtoInjectorDynamicStrategy;
	var ReflectiveProtoInjector = (function () {
	    function ReflectiveProtoInjector(providers) {
	        this.numberOfProviders = providers.length;
	        this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
	            new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
	            new ReflectiveProtoInjectorInlineStrategy(this, providers);
	    }
	    ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
	        return new ReflectiveProtoInjector(providers);
	    };
	    ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
	        return this._strategy.getProviderAtIndex(index);
	    };
	    return ReflectiveProtoInjector;
	}());
	exports.ReflectiveProtoInjector = ReflectiveProtoInjector;
	var ReflectiveInjectorInlineStrategy = (function () {
	    function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
	        this.injector = injector;
	        this.protoStrategy = protoStrategy;
	        this.obj0 = UNDEFINED;
	        this.obj1 = UNDEFINED;
	        this.obj2 = UNDEFINED;
	        this.obj3 = UNDEFINED;
	        this.obj4 = UNDEFINED;
	        this.obj5 = UNDEFINED;
	        this.obj6 = UNDEFINED;
	        this.obj7 = UNDEFINED;
	        this.obj8 = UNDEFINED;
	        this.obj9 = UNDEFINED;
	    }
	    ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	    ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
	        return this.injector._new(provider);
	    };
	    ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
	        var p = this.protoStrategy;
	        var inj = this.injector;
	        if (p.keyId0 === keyId) {
	            if (this.obj0 === UNDEFINED) {
	                this.obj0 = inj._new(p.provider0);
	            }
	            return this.obj0;
	        }
	        if (p.keyId1 === keyId) {
	            if (this.obj1 === UNDEFINED) {
	                this.obj1 = inj._new(p.provider1);
	            }
	            return this.obj1;
	        }
	        if (p.keyId2 === keyId) {
	            if (this.obj2 === UNDEFINED) {
	                this.obj2 = inj._new(p.provider2);
	            }
	            return this.obj2;
	        }
	        if (p.keyId3 === keyId) {
	            if (this.obj3 === UNDEFINED) {
	                this.obj3 = inj._new(p.provider3);
	            }
	            return this.obj3;
	        }
	        if (p.keyId4 === keyId) {
	            if (this.obj4 === UNDEFINED) {
	                this.obj4 = inj._new(p.provider4);
	            }
	            return this.obj4;
	        }
	        if (p.keyId5 === keyId) {
	            if (this.obj5 === UNDEFINED) {
	                this.obj5 = inj._new(p.provider5);
	            }
	            return this.obj5;
	        }
	        if (p.keyId6 === keyId) {
	            if (this.obj6 === UNDEFINED) {
	                this.obj6 = inj._new(p.provider6);
	            }
	            return this.obj6;
	        }
	        if (p.keyId7 === keyId) {
	            if (this.obj7 === UNDEFINED) {
	                this.obj7 = inj._new(p.provider7);
	            }
	            return this.obj7;
	        }
	        if (p.keyId8 === keyId) {
	            if (this.obj8 === UNDEFINED) {
	                this.obj8 = inj._new(p.provider8);
	            }
	            return this.obj8;
	        }
	        if (p.keyId9 === keyId) {
	            if (this.obj9 === UNDEFINED) {
	                this.obj9 = inj._new(p.provider9);
	            }
	            return this.obj9;
	        }
	        return UNDEFINED;
	    };
	    ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
	        if (index == 0)
	            return this.obj0;
	        if (index == 1)
	            return this.obj1;
	        if (index == 2)
	            return this.obj2;
	        if (index == 3)
	            return this.obj3;
	        if (index == 4)
	            return this.obj4;
	        if (index == 5)
	            return this.obj5;
	        if (index == 6)
	            return this.obj6;
	        if (index == 7)
	            return this.obj7;
	        if (index == 8)
	            return this.obj8;
	        if (index == 9)
	            return this.obj9;
	        throw new reflective_exceptions_1.OutOfBoundsError(index);
	    };
	    ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
	    return ReflectiveInjectorInlineStrategy;
	}());
	exports.ReflectiveInjectorInlineStrategy = ReflectiveInjectorInlineStrategy;
	var ReflectiveInjectorDynamicStrategy = (function () {
	    function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
	        this.protoStrategy = protoStrategy;
	        this.injector = injector;
	        this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.providers.length);
	        collection_1.ListWrapper.fill(this.objs, UNDEFINED);
	    }
	    ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	    ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
	        return this.injector._new(provider);
	    };
	    ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
	        var p = this.protoStrategy;
	        for (var i = 0; i < p.keyIds.length; i++) {
	            if (p.keyIds[i] === keyId) {
	                if (this.objs[i] === UNDEFINED) {
	                    this.objs[i] = this.injector._new(p.providers[i]);
	                }
	                return this.objs[i];
	            }
	        }
	        return UNDEFINED;
	    };
	    ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
	        if (index < 0 || index >= this.objs.length) {
	            throw new reflective_exceptions_1.OutOfBoundsError(index);
	        }
	        return this.objs[index];
	    };
	    ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
	    return ReflectiveInjectorDynamicStrategy;
	}());
	exports.ReflectiveInjectorDynamicStrategy = ReflectiveInjectorDynamicStrategy;
	/**
	 * A ReflectiveDependency injection container used for instantiating objects and resolving
	 * dependencies.
	 *
	 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	 * constructor dependencies.
	 *
	 * In typical use, application code asks for the dependencies in the constructor and they are
	 * resolved by the `Injector`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	 *
	 * The following example creates an `Injector` configured to create `Engine` and `Car`.
	 *
	 * ```typescript
	 * @Injectable()
	 * class Engine {
	 * }
	 *
	 * @Injectable()
	 * class Car {
	 *   constructor(public engine:Engine) {}
	 * }
	 *
	 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	 * var car = injector.get(Car);
	 * expect(car instanceof Car).toBe(true);
	 * expect(car.engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	 * resolve all of the object's dependencies automatically.
	 *
	 * @stable
	 */
	var ReflectiveInjector = (function () {
	    function ReflectiveInjector() {
	    }
	    /**
	     * Turns an array of provider definitions into an array of resolved providers.
	     *
	     * A resolution is a process of flattening multiple nested arrays and converting individual
	     * providers into an array of {@link ResolvedReflectiveProvider}s.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	     *
	     * expect(providers.length).toEqual(2);
	     *
	     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	     * expect(providers[0].key.displayName).toBe("Car");
	     * expect(providers[0].dependencies.length).toEqual(1);
	     * expect(providers[0].factory).toBeDefined();
	     *
	     * expect(providers[1].key.displayName).toBe("Engine");
	     * });
	     * ```
	     *
	     * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
	     */
	    ReflectiveInjector.resolve = function (providers) {
	        return reflective_provider_1.resolveReflectiveProviders(providers);
	    };
	    /**
	     * Resolves an array of providers and creates an injector from those providers.
	     *
	     * The passed-in providers can be an array of `Type`, {@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     *
	     * This function is slower than the corresponding `fromResolvedProviders`
	     * because it needs to resolve the passed-in providers first.
	     * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
	     */
	    ReflectiveInjector.resolveAndCreate = function (providers, parent) {
	        if (parent === void 0) { parent = null; }
	        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	    };
	    /**
	     * Creates an injector from previously resolved providers.
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, Engine]);
	     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     * @experimental
	     */
	    ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
	        if (parent === void 0) { parent = null; }
	        return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
	    };
	    /**
	     * @deprecated
	     */
	    ReflectiveInjector.fromResolvedBindings = function (providers) {
	        return ReflectiveInjector.fromResolvedProviders(providers);
	    };
	    Object.defineProperty(ReflectiveInjector.prototype, "parent", {
	        /**
	         * Parent of this injector.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	         *
	         * ```typescript
	         * var parent = ReflectiveInjector.resolveAndCreate([]);
	         * var child = parent.resolveAndCreateChild([]);
	         * expect(child.parent).toBe(parent);
	         * ```
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @internal
	     */
	    ReflectiveInjector.prototype.debugContext = function () { return null; };
	    /**
	     * Resolves an array of providers and creates a child injector from those providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * The passed-in providers can be an array of `Type`, {@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	     * var child = parent.resolveAndCreateChild([ChildProvider]);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     *
	     * This function is slower than the corresponding `createChildFromResolved`
	     * because it needs to resolve the passed-in providers first.
	     * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
	     */
	    ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) {
	        return exceptions_1.unimplemented();
	    };
	    /**
	     * Creates a child injector from previously resolved providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	     *
	     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	     * var child = parent.createChildFromResolved(childProviders);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     */
	    ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
	        return exceptions_1.unimplemented();
	    };
	    /**
	     * Resolves a provider and instantiates an object in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     *
	     * var car = injector.resolveAndInstantiate(Car);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	     * ```
	     */
	    ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return exceptions_1.unimplemented(); };
	    /**
	     * Instantiates an object using a resolved provider in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     * var carProvider = ReflectiveInjector.resolve([Car])[0];
	     * var car = injector.instantiateResolved(carProvider);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	     * ```
	     */
	    ReflectiveInjector.prototype.instantiateResolved = function (provider) { return exceptions_1.unimplemented(); };
	    return ReflectiveInjector;
	}());
	exports.ReflectiveInjector = ReflectiveInjector;
	var ReflectiveInjector_ = (function () {
	    /**
	     * Private
	     */
	    function ReflectiveInjector_(_proto /* ProtoInjector */, _parent, _debugContext) {
	        if (_parent === void 0) { _parent = null; }
	        if (_debugContext === void 0) { _debugContext = null; }
	        this._debugContext = _debugContext;
	        /** @internal */
	        this._constructionCounter = 0;
	        this._proto = _proto;
	        this._parent = _parent;
	        this._strategy = _proto._strategy.createInjectorStrategy(this);
	    }
	    /**
	     * @internal
	     */
	    ReflectiveInjector_.prototype.debugContext = function () { return this._debugContext(); };
	    ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = injector_1.THROW_IF_NOT_FOUND; }
	        return this._getByKey(reflective_key_1.ReflectiveKey.get(token), null, null, notFoundValue);
	    };
	    ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
	    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
	        get: function () { return this._parent; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
	        /**
	         * @internal
	         * Internal. Do not use.
	         * We return `any` not to export the InjectorStrategy type.
	         */
	        get: function () { return this._strategy; },
	        enumerable: true,
	        configurable: true
	    });
	    ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
	        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return this.createChildFromResolved(ResolvedReflectiveProviders);
	    };
	    ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
	        var proto = new ReflectiveProtoInjector(providers);
	        var inj = new ReflectiveInjector_(proto);
	        inj._parent = this;
	        return inj;
	    };
	    ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
	        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	    };
	    ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
	        return this._instantiateProvider(provider);
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._new = function (provider) {
	        if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
	            throw new reflective_exceptions_1.CyclicDependencyError(this, provider.key);
	        }
	        return this._instantiateProvider(provider);
	    };
	    ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
	        if (provider.multiProvider) {
	            var res = collection_1.ListWrapper.createFixedSize(provider.resolvedFactories.length);
	            for (var i = 0; i < provider.resolvedFactories.length; ++i) {
	                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	            }
	            return res;
	        }
	        else {
	            return this._instantiate(provider, provider.resolvedFactories[0]);
	        }
	    };
	    ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
	        var factory = ResolvedReflectiveFactory.factory;
	        var deps = ResolvedReflectiveFactory.dependencies;
	        var length = deps.length;
	        var d0;
	        var d1;
	        var d2;
	        var d3;
	        var d4;
	        var d5;
	        var d6;
	        var d7;
	        var d8;
	        var d9;
	        var d10;
	        var d11;
	        var d12;
	        var d13;
	        var d14;
	        var d15;
	        var d16;
	        var d17;
	        var d18;
	        var d19;
	        try {
	            d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
	            d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
	            d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
	            d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
	            d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
	            d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
	            d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
	            d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
	            d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
	            d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
	            d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
	            d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
	            d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
	            d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
	            d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
	            d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
	            d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
	            d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
	            d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
	            d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
	        }
	        catch (e) {
	            if (e instanceof reflective_exceptions_1.AbstractProviderError || e instanceof reflective_exceptions_1.InstantiationError) {
	                e.addKey(this, provider.key);
	            }
	            throw e;
	        }
	        var obj;
	        try {
	            switch (length) {
	                case 0:
	                    obj = factory();
	                    break;
	                case 1:
	                    obj = factory(d0);
	                    break;
	                case 2:
	                    obj = factory(d0, d1);
	                    break;
	                case 3:
	                    obj = factory(d0, d1, d2);
	                    break;
	                case 4:
	                    obj = factory(d0, d1, d2, d3);
	                    break;
	                case 5:
	                    obj = factory(d0, d1, d2, d3, d4);
	                    break;
	                case 6:
	                    obj = factory(d0, d1, d2, d3, d4, d5);
	                    break;
	                case 7:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6);
	                    break;
	                case 8:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
	                    break;
	                case 9:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
	                    break;
	                case 10:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
	                    break;
	                case 11:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
	                    break;
	                case 12:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
	                    break;
	                case 13:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
	                    break;
	                case 14:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
	                    break;
	                case 15:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
	                    break;
	                case 16:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
	                    break;
	                case 17:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
	                    break;
	                case 18:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
	                    break;
	                case 19:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
	                    break;
	                case 20:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
	                    break;
	                default:
	                    throw new exceptions_1.BaseException("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
	            }
	        }
	        catch (e) {
	            throw new reflective_exceptions_1.InstantiationError(this, e, e.stack, provider.key);
	        }
	        return obj;
	    };
	    ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
	        return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : injector_1.THROW_IF_NOT_FOUND);
	    };
	    ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
	        if (key === INJECTOR_KEY) {
	            return this;
	        }
	        if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {
	            return this._getByKeySelf(key, notFoundValue);
	        }
	        else {
	            return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
	        }
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
	        if (notFoundValue !== injector_1.THROW_IF_NOT_FOUND) {
	            return notFoundValue;
	        }
	        else {
	            throw new reflective_exceptions_1.NoProviderError(this, key);
	        }
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
	        var obj = this._strategy.getObjByKeyId(key.id);
	        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
	        var inj;
	        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
	            inj = this._parent;
	        }
	        else {
	            inj = this;
	        }
	        while (inj instanceof ReflectiveInjector_) {
	            var inj_ = inj;
	            var obj = inj_._strategy.getObjByKeyId(key.id);
	            if (obj !== UNDEFINED)
	                return obj;
	            inj = inj_._parent;
	        }
	        if (inj !== null) {
	            return inj.get(key.token, notFoundValue);
	        }
	        else {
	            return this._throwOrNull(key, notFoundValue);
	        }
	    };
	    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
	        get: function () {
	            var providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
	                .join(', ');
	            return "ReflectiveInjector(providers: [" + providers + "])";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
	    return ReflectiveInjector_;
	}());
	exports.ReflectiveInjector_ = ReflectiveInjector_;
	var INJECTOR_KEY = reflective_key_1.ReflectiveKey.get(injector_1.Injector);
	function _mapProviders(injector, fn) {
	    var res = new Array(injector._proto.numberOfProviders);
	    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
	        res[i] = fn(injector._proto.getProviderAtIndex(i));
	    }
	    return res;
	}
	//# sourceMappingURL=reflective_injector.js.map

/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException = (function (_super) {
	    __extends(BaseWrappedException, _super);
	    function BaseWrappedException(message) {
	        _super.call(this, message);
	    }
	    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
	        get: function () { return ''; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "context", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "message", {
	        get: function () { return ''; },
	        enumerable: true,
	        configurable: true
	    });
	    return BaseWrappedException;
	}(Error));
	exports.BaseWrappedException = BaseWrappedException;
	//# sourceMappingURL=base_wrapped_exception.js.map

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var base_wrapped_exception_1 = __webpack_require__(110);
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var _ArrayLogger = (function () {
	    function _ArrayLogger() {
	        this.res = [];
	    }
	    _ArrayLogger.prototype.log = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logError = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logGroup = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logGroupEnd = function () { };
	    ;
	    return _ArrayLogger;
	}());
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */
	var ExceptionHandler = (function () {
	    function ExceptionHandler(_logger, _rethrowException) {
	        if (_rethrowException === void 0) { _rethrowException = true; }
	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }
	    ExceptionHandler.exceptionToString = function (exception, stackTrace, reason) {
	        if (stackTrace === void 0) { stackTrace = null; }
	        if (reason === void 0) { reason = null; }
	        var l = new _ArrayLogger();
	        var e = new ExceptionHandler(l, false);
	        e.call(exception, stackTrace, reason);
	        return l.res.join('\n');
	    };
	    ExceptionHandler.prototype.call = function (exception, stackTrace, reason) {
	        if (stackTrace === void 0) { stackTrace = null; }
	        if (reason === void 0) { reason = null; }
	        var originalException = this._findOriginalException(exception);
	        var originalStack = this._findOriginalStack(exception);
	        var context = this._findContext(exception);
	        this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
	        if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
	            this._logger.logError('STACKTRACE:');
	            this._logger.logError(this._longStackTrace(stackTrace));
	        }
	        if (lang_1.isPresent(reason)) {
	            this._logger.logError("REASON: " + reason);
	        }
	        if (lang_1.isPresent(originalException)) {
	            this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
	        }
	        if (lang_1.isPresent(originalStack)) {
	            this._logger.logError('ORIGINAL STACKTRACE:');
	            this._logger.logError(this._longStackTrace(originalStack));
	        }
	        if (lang_1.isPresent(context)) {
	            this._logger.logError('ERROR CONTEXT:');
	            this._logger.logError(context);
	        }
	        this._logger.logGroupEnd();
	        // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	        // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	        if (this._rethrowException)
	            throw exception;
	    };
	    /** @internal */
	    ExceptionHandler.prototype._extractMessage = function (exception) {
	        return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage :
	            exception.toString();
	    };
	    /** @internal */
	    ExceptionHandler.prototype._longStackTrace = function (stackTrace) {
	        return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') :
	            stackTrace.toString();
	    };
	    /** @internal */
	    ExceptionHandler.prototype._findContext = function (exception) {
	        try {
	            if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
	                return null;
	            return lang_1.isPresent(exception.context) ? exception.context :
	                this._findContext(exception.originalException);
	        }
	        catch (e) {
	            // exception.context can throw an exception. if it happens, we ignore the context.
	            return null;
	        }
	    };
	    /** @internal */
	    ExceptionHandler.prototype._findOriginalException = function (exception) {
	        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
	            return null;
	        var e = exception.originalException;
	        while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
	            e = e.originalException;
	        }
	        return e;
	    };
	    /** @internal */
	    ExceptionHandler.prototype._findOriginalStack = function (exception) {
	        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
	            return null;
	        var e = exception;
	        var stack = exception.originalStack;
	        while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
	            e = e.originalException;
	            if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
	                stack = e.originalStack;
	            }
	        }
	        return stack;
	    };
	    return ExceptionHandler;
	}());
	exports.ExceptionHandler = ExceptionHandler;
	//# sourceMappingURL=exception_handler.js.map

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var view_utils_1 = __webpack_require__(44);
	/**
	 * Represents an instance of a Component created via a {@link ComponentFactory}.
	 *
	 * `ComponentRef` provides access to the Component Instance as well other objects related to this
	 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
	 * method.
	 * @stable
	 */
	var ComponentRef = (function () {
	    function ComponentRef() {
	    }
	    Object.defineProperty(ComponentRef.prototype, "location", {
	        /**
	         * Location of the Host Element of this Component Instance.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef.prototype, "injector", {
	        /**
	         * The injector on which the component instance exists.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef.prototype, "instance", {
	        /**
	         * The instance of the Component.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef.prototype, "hostView", {
	        /**
	         * The {@link ViewRef} of the Host View of this Component instance.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
	        /**
	         * The {@link ChangeDetectorRef} of the Component instance.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef.prototype, "componentType", {
	        /**
	         * The component type.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return ComponentRef;
	}());
	exports.ComponentRef = ComponentRef;
	var ComponentRef_ = (function (_super) {
	    __extends(ComponentRef_, _super);
	    function ComponentRef_(_hostElement, _componentType) {
	        _super.call(this);
	        this._hostElement = _hostElement;
	        this._componentType = _componentType;
	    }
	    Object.defineProperty(ComponentRef_.prototype, "location", {
	        get: function () { return this._hostElement.elementRef; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "injector", {
	        get: function () { return this._hostElement.injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "instance", {
	        get: function () { return this._hostElement.component; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef_.prototype, "hostView", {
	        get: function () { return this._hostElement.parentView.ref; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
	        get: function () { return this._hostElement.parentView.ref; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef_.prototype, "componentType", {
	        get: function () { return this._componentType; },
	        enumerable: true,
	        configurable: true
	    });
	    ComponentRef_.prototype.destroy = function () { this._hostElement.parentView.destroy(); };
	    ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
	    return ComponentRef_;
	}(ComponentRef));
	exports.ComponentRef_ = ComponentRef_;
	/**
	 * @experimental
	 * @ts2dart_const
	 */
	var EMPTY_CONTEXT = new Object();
	/**
	 * @stable
	 */
	var ComponentFactory = (function () {
	    function ComponentFactory(selector, _viewFactory, _componentType) {
	        this.selector = selector;
	        this._viewFactory = _viewFactory;
	        this._componentType = _componentType;
	    }
	    Object.defineProperty(ComponentFactory.prototype, "componentType", {
	        get: function () { return this._componentType; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates a new component.
	     */
	    ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
	        if (projectableNodes === void 0) { projectableNodes = null; }
	        if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
	        var vu = injector.get(view_utils_1.ViewUtils);
	        if (lang_1.isBlank(projectableNodes)) {
	            projectableNodes = [];
	        }
	        // Note: Host views don't need a declarationAppElement!
	        var hostView = this._viewFactory(vu, injector, null);
	        var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
	        return new ComponentRef_(hostElement, this._componentType);
	    };
	    return ComponentFactory;
	}());
	exports.ComponentFactory = ComponentFactory;
	//# sourceMappingURL=component_factory.js.map

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var view_type_1 = __webpack_require__(43);
	/* @ts2dart_const */
	var StaticNodeDebugInfo = (function () {
	    function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
	        this.providerTokens = providerTokens;
	        this.componentToken = componentToken;
	        this.refTokens = refTokens;
	    }
	    return StaticNodeDebugInfo;
	}());
	exports.StaticNodeDebugInfo = StaticNodeDebugInfo;
	var DebugContext = (function () {
	    function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
	        this._view = _view;
	        this._nodeIndex = _nodeIndex;
	        this._tplRow = _tplRow;
	        this._tplCol = _tplCol;
	    }
	    Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
	        get: function () {
	            return lang_1.isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "context", {
	        get: function () { return this._view.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "component", {
	        get: function () {
	            var staticNodeInfo = this._staticNodeInfo;
	            if (lang_1.isPresent(staticNodeInfo) && lang_1.isPresent(staticNodeInfo.componentToken)) {
	                return this.injector.get(staticNodeInfo.componentToken);
	            }
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
	        get: function () {
	            var componentView = this._view;
	            while (lang_1.isPresent(componentView.declarationAppElement) &&
	                componentView.type !== view_type_1.ViewType.COMPONENT) {
	                componentView = componentView.declarationAppElement.parentView;
	            }
	            return lang_1.isPresent(componentView.declarationAppElement) ?
	                componentView.declarationAppElement.nativeElement :
	                null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "injector", {
	        get: function () { return this._view.injector(this._nodeIndex); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "renderNode", {
	        get: function () {
	            if (lang_1.isPresent(this._nodeIndex) && lang_1.isPresent(this._view.allNodes)) {
	                return this._view.allNodes[this._nodeIndex];
	            }
	            else {
	                return null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "providerTokens", {
	        get: function () {
	            var staticNodeInfo = this._staticNodeInfo;
	            return lang_1.isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "source", {
	        get: function () {
	            return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "references", {
	        get: function () {
	            var _this = this;
	            var varValues = {};
	            var staticNodeInfo = this._staticNodeInfo;
	            if (lang_1.isPresent(staticNodeInfo)) {
	                var refs = staticNodeInfo.refTokens;
	                collection_1.StringMapWrapper.forEach(refs, function (refToken /** TODO #9100 */, refName /** TODO #9100 */) {
	                    var varValue;
	                    if (lang_1.isBlank(refToken)) {
	                        varValue =
	                            lang_1.isPresent(_this._view.allNodes) ? _this._view.allNodes[_this._nodeIndex] : null;
	                    }
	                    else {
	                        varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
	                    }
	                    varValues[refName] = varValue;
	                });
	            }
	            return varValues;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return DebugContext;
	}());
	exports.DebugContext = DebugContext;
	//# sourceMappingURL=debug_context.js.map

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var decorators_1 = __webpack_require__(25);
	var reflective_injector_1 = __webpack_require__(109);
	var lang_1 = __webpack_require__(2);
	var component_resolver_1 = __webpack_require__(30);
	/**
	 * Use ComponentResolver and ViewContainerRef directly.
	 *
	 * @deprecated
	 */
	var DynamicComponentLoader = (function () {
	    function DynamicComponentLoader() {
	    }
	    return DynamicComponentLoader;
	}());
	exports.DynamicComponentLoader = DynamicComponentLoader;
	var DynamicComponentLoader_ = (function (_super) {
	    __extends(DynamicComponentLoader_, _super);
	    function DynamicComponentLoader_(_compiler) {
	        _super.call(this);
	        this._compiler = _compiler;
	    }
	    DynamicComponentLoader_.prototype.loadAsRoot = function (type, overrideSelectorOrNode, injector, onDispose, projectableNodes) {
	        return this._compiler.resolveComponent(type).then(function (componentFactory) {
	            var componentRef = componentFactory.create(injector, projectableNodes, lang_1.isPresent(overrideSelectorOrNode) ? overrideSelectorOrNode : componentFactory.selector);
	            if (lang_1.isPresent(onDispose)) {
	                componentRef.onDestroy(onDispose);
	            }
	            return componentRef;
	        });
	    };
	    DynamicComponentLoader_.prototype.loadNextToLocation = function (type, location, providers, projectableNodes) {
	        if (providers === void 0) { providers = null; }
	        if (projectableNodes === void 0) { projectableNodes = null; }
	        return this._compiler.resolveComponent(type).then(function (componentFactory) {
	            var contextInjector = location.parentInjector;
	            var childInjector = lang_1.isPresent(providers) && providers.length > 0 ?
	                reflective_injector_1.ReflectiveInjector.fromResolvedProviders(providers, contextInjector) :
	                contextInjector;
	            return location.createComponent(componentFactory, location.length, childInjector, projectableNodes);
	        });
	    };
	    /** @nocollapse */
	    DynamicComponentLoader_.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    DynamicComponentLoader_.ctorParameters = [
	        { type: component_resolver_1.ComponentResolver, },
	    ];
	    return DynamicComponentLoader_;
	}(DynamicComponentLoader));
	exports.DynamicComponentLoader_ = DynamicComponentLoader_;
	//# sourceMappingURL=dynamic_component_loader.js.map

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * A wrapper around a native element inside of a View.
	 *
	 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
	 * element.
	 *
	 * @security Permitting direct access to the DOM can make your application more vulnerable to
	 * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
	 * [Security Guide](http://g.co/ng/security).
	 *
	 * @stable
	 */
	// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
	// i.e. users have to ask for what they need. With that, we can build better analysis tools
	// and could do better codegen in the future.
	var ElementRef = (function () {
	    function ElementRef(nativeElement) {
	        this.nativeElement = nativeElement;
	    }
	    return ElementRef;
	}());
	exports.ElementRef = ElementRef;
	//# sourceMappingURL=element_ref.js.map

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var lang_1 = __webpack_require__(2);
	var EMPTY_CONTEXT = new Object();
	/**
	 * Represents an Embedded Template that can be used to instantiate Embedded Views.
	 *
	 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
	 * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
	 * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
	 * `TemplateRef` from a Component or a Directive via {@link Query}.
	 *
	 * To instantiate Embedded Views based on a Template, use
	 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	 * View Container.
	 * @stable
	 */
	var TemplateRef = (function () {
	    function TemplateRef() {
	    }
	    Object.defineProperty(TemplateRef.prototype, "elementRef", {
	        /**
	         * The location in the View where the Embedded View logically belongs to.
	         *
	         * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
	         * inherit from the contexts of this location.
	         *
	         * Typically new Embedded Views are attached to the View Container of this location, but in
	         * advanced use-cases, the View can be attached to a different container while keeping the
	         * data-binding and injection context from the original location.
	         *
	         */
	        // TODO(i): rename to anchor or location
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return TemplateRef;
	}());
	exports.TemplateRef = TemplateRef;
	var TemplateRef_ = (function (_super) {
	    __extends(TemplateRef_, _super);
	    function TemplateRef_(_appElement, _viewFactory) {
	        _super.call(this);
	        this._appElement = _appElement;
	        this._viewFactory = _viewFactory;
	    }
	    TemplateRef_.prototype.createEmbeddedView = function (context) {
	        var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
	        if (lang_1.isBlank(context)) {
	            context = EMPTY_CONTEXT;
	        }
	        view.create(context, null, null);
	        return view.ref;
	    };
	    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
	        get: function () { return this._appElement.elementRef; },
	        enumerable: true,
	        configurable: true
	    });
	    return TemplateRef_;
	}(TemplateRef));
	exports.TemplateRef_ = TemplateRef_;
	//# sourceMappingURL=template_ref.js.map

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var profile_1 = __webpack_require__(45);
	/**
	 * Represents a container where one or more Views can be attached.
	 *
	 * The container can contain two kinds of Views. Host Views, created by instantiating a
	 * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
	 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
	 *
	 * The location of the View Container within the containing View is specified by the Anchor
	 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	 * have a single View Container.
	 *
	 * Root elements of Views attached to this container become siblings of the Anchor Element in
	 * the Rendered View.
	 *
	 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
	 * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
	 * @stable
	 */
	var ViewContainerRef = (function () {
	    function ViewContainerRef() {
	    }
	    Object.defineProperty(ViewContainerRef.prototype, "element", {
	        /**
	         * Anchor element that specifies the location of this container in the containing View.
	         * <!-- TODO: rename to anchorElement -->
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef.prototype, "injector", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef.prototype, "length", {
	        /**
	         * Returns the number of Views currently attached to this container.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    return ViewContainerRef;
	}());
	exports.ViewContainerRef = ViewContainerRef;
	var ViewContainerRef_ = (function () {
	    function ViewContainerRef_(_element) {
	        this._element = _element;
	        /** @internal */
	        this._createComponentInContainerScope = profile_1.wtfCreateScope('ViewContainerRef#createComponent()');
	        /** @internal */
	        this._insertScope = profile_1.wtfCreateScope('ViewContainerRef#insert()');
	        /** @internal */
	        this._removeScope = profile_1.wtfCreateScope('ViewContainerRef#remove()');
	        /** @internal */
	        this._detachScope = profile_1.wtfCreateScope('ViewContainerRef#detach()');
	    }
	    ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
	    Object.defineProperty(ViewContainerRef_.prototype, "length", {
	        get: function () {
	            var views = this._element.nestedViews;
	            return lang_1.isPresent(views) ? views.length : 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "element", {
	        get: function () { return this._element.elementRef; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
	        get: function () { return this._element.injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
	        get: function () { return this._element.parentInjector; },
	        enumerable: true,
	        configurable: true
	    });
	    // TODO(rado): profile and decide whether bounds checks should be added
	    // to the methods below.
	    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
	        if (context === void 0) { context = null; }
	        if (index === void 0) { index = -1; }
	        var viewRef = templateRef.createEmbeddedView(context);
	        this.insert(viewRef, index);
	        return viewRef;
	    };
	    ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
	        if (index === void 0) { index = -1; }
	        if (injector === void 0) { injector = null; }
	        if (projectableNodes === void 0) { projectableNodes = null; }
	        var s = this._createComponentInContainerScope();
	        var contextInjector = lang_1.isPresent(injector) ? injector : this._element.parentInjector;
	        var componentRef = componentFactory.create(contextInjector, projectableNodes);
	        this.insert(componentRef.hostView, index);
	        return profile_1.wtfLeave(s, componentRef);
	    };
	    // TODO(i): refactor insert+remove into move
	    ViewContainerRef_.prototype.insert = function (viewRef, index) {
	        if (index === void 0) { index = -1; }
	        var s = this._insertScope();
	        if (index == -1)
	            index = this.length;
	        var viewRef_ = viewRef;
	        this._element.attachView(viewRef_.internalView, index);
	        return profile_1.wtfLeave(s, viewRef_);
	    };
	    ViewContainerRef_.prototype.indexOf = function (viewRef) {
	        return collection_1.ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
	    };
	    // TODO(i): rename to destroy
	    ViewContainerRef_.prototype.remove = function (index) {
	        if (index === void 0) { index = -1; }
	        var s = this._removeScope();
	        if (index == -1)
	            index = this.length - 1;
	        var view = this._element.detachView(index);
	        view.destroy();
	        // view is intentionally not returned to the client.
	        profile_1.wtfLeave(s);
	    };
	    // TODO(i): refactor insert+remove into move
	    ViewContainerRef_.prototype.detach = function (index) {
	        if (index === void 0) { index = -1; }
	        var s = this._detachScope();
	        if (index == -1)
	            index = this.length - 1;
	        var view = this._element.detachView(index);
	        return profile_1.wtfLeave(s, view.ref);
	    };
	    ViewContainerRef_.prototype.clear = function () {
	        for (var i = this.length - 1; i >= 0; i--) {
	            this.remove(i);
	        }
	    };
	    return ViewContainerRef_;
	}());
	exports.ViewContainerRef_ = ViewContainerRef_;
	//# sourceMappingURL=view_container_ref.js.map

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var constants_1 = __webpack_require__(41);
	var exceptions_1 = __webpack_require__(5);
	/**
	 * @stable
	 */
	var ViewRef = (function () {
	    function ViewRef() {
	    }
	    Object.defineProperty(ViewRef.prototype, "destroyed", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return ViewRef;
	}());
	exports.ViewRef = ViewRef;
	/**
	 * Represents an Angular View.
	 *
	 * <!-- TODO: move the next two paragraphs to the dev guide -->
	 * A View is a fundamental building block of the application UI. It is the smallest grouping of
	 * Elements which are created and destroyed together.
	 *
	 * Properties of elements in a View can change, but the structure (number and order) of elements in
	 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	 * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
	 * <!-- /TODO -->
	 *
	 * ### Example
	 *
	 * Given this template...
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ngFor="let  item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * We have two {@link TemplateRef}s:
	 *
	 * Outer {@link TemplateRef}:
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <template ngFor let-item [ngForOf]="items"></template>
	 * </ul>
	 * ```
	 *
	 * Inner {@link TemplateRef}:
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * Notice that the original template is broken down into two separate {@link TemplateRef}s.
	 *
	 * The outer/inner {@link TemplateRef}s are then assembled into views like so:
	 *
	 * ```
	 * <!-- ViewRef: outer-0 -->
	 * Count: 2
	 * <ul>
	 *   <template view-container-ref></template>
	 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	 * </ul>
	 * <!-- /ViewRef: outer-0 -->
	 * ```
	 * @experimental
	 */
	var EmbeddedViewRef = (function (_super) {
	    __extends(EmbeddedViewRef, _super);
	    function EmbeddedViewRef() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(EmbeddedViewRef.prototype, "context", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    return EmbeddedViewRef;
	}(ViewRef));
	exports.EmbeddedViewRef = EmbeddedViewRef;
	var ViewRef_ = (function () {
	    function ViewRef_(_view) {
	        this._view = _view;
	        this._view = _view;
	        this._originalMode = this._view.cdMode;
	    }
	    Object.defineProperty(ViewRef_.prototype, "internalView", {
	        get: function () { return this._view; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
	        get: function () { return this._view.flatRootNodes; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "context", {
	        get: function () { return this._view.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "destroyed", {
	        get: function () { return this._view.destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
	    ViewRef_.prototype.detach = function () { this._view.cdMode = constants_1.ChangeDetectorStatus.Detached; };
	    ViewRef_.prototype.detectChanges = function () { this._view.detectChanges(false); };
	    ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
	    ViewRef_.prototype.reattach = function () {
	        this._view.cdMode = this._originalMode;
	        this.markForCheck();
	    };
	    ViewRef_.prototype.onDestroy = function (callback) { this._view.disposables.push(callback); };
	    ViewRef_.prototype.destroy = function () { this._view.destroy(); };
	    return ViewRef_;
	}());
	exports.ViewRef_ = ViewRef_;
	//# sourceMappingURL=view_ref.js.map

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var forward_ref_1 = __webpack_require__(42);
	var metadata_1 = __webpack_require__(26);
	var lang_1 = __webpack_require__(2);
	/**
	 * Specifies that a constant attribute value should be injected.
	 *
	 * The directive can inject constant string literals of host element attributes.
	 *
	 * ### Example
	 *
	 * Suppose we have an `<input>` element and want to know its `type`.
	 *
	 * ```html
	 * <input type="text">
	 * ```
	 *
	 * A decorator can inject string literal `text` like so:
	 *
	 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
	 * @ts2dart_const
	 * @stable
	 */
	var AttributeMetadata = (function (_super) {
	    __extends(AttributeMetadata, _super);
	    function AttributeMetadata(attributeName) {
	        _super.call(this);
	        this.attributeName = attributeName;
	    }
	    Object.defineProperty(AttributeMetadata.prototype, "token", {
	        get: function () {
	            // Normally one would default a token to a type of an injected value but here
	            // the type of a variable is "string" and we can't use primitive type as a return value
	            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
	            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
	            // account.
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AttributeMetadata.prototype.toString = function () { return "@Attribute(" + lang_1.stringify(this.attributeName) + ")"; };
	    return AttributeMetadata;
	}(metadata_1.DependencyMetadata));
	exports.AttributeMetadata = AttributeMetadata;
	/**
	 * Declares an injectable parameter to be a live list of directives or variable
	 * bindings from the content children of a directive.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 *
	 * Assume that `<tabs>` component would like to get a list its children `<pane>`
	 * components as shown in this example:
	 *
	 * ```html
	 * <tabs>
	 *   <pane title="Overview">...</pane>
	 *   <pane *ngFor="let o of objects" [title]="o.title">{{o.text}}</pane>
	 * </tabs>
	 * ```
	 *
	 * The preferred solution is to query for `Pane` directives using this decorator.
	 *
	 * ```javascript
	 * @Component({
	 *   selector: 'pane',
	 *   inputs: ['title']
	 * })
	 * class Pane {
	 *   title:string;
	 * }
	 *
	 * @Component({
	 *  selector: 'tabs',
	 *  template: `
	 *    <ul>
	 *      <li *ngFor="let pane of panes">{{pane.title}}</li>
	 *    </ul>
	 *    <ng-content></ng-content>
	 *  `
	 * })
	 * class Tabs {
	 *   panes: QueryList<Pane>;
	 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
	  *    this.panes = panes;
	  *  }
	 * }
	 * ```
	 *
	 * A query can look for variable bindings by passing in a string with desired binding symbol.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
	 * ```html
	 * <seeker>
	 *   <div #findme>...</div>
	 * </seeker>
	 *
	 * @Component({ selector: 'seeker' })
	 * class Seeker {
	 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * In this case the object that is injected depend on the type of the variable
	 * binding. It can be an ElementRef, a directive or a component.
	 *
	 * Passing in a comma separated list of variable bindings will query for all of them.
	 *
	 * ```html
	 * <seeker>
	 *   <div #find-me>...</div>
	 *   <div #find-me-too>...</div>
	 * </seeker>
	 *
	 *  @Component({
	 *   selector: 'seeker'
	 * })
	 * class Seeker {
	 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * Configure whether query looks for direct children or all descendants
	 * of the querying element, by using the `descendants` parameter.
	 * It is set to `false` by default.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
	 * ```html
	 * <container #first>
	 *   <item>a</item>
	 *   <item>b</item>
	 *   <container #second>
	 *     <item>c</item>
	 *   </container>
	 * </container>
	 * ```
	 *
	 * When querying for items, the first container will see only `a` and `b` by default,
	 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
	 *
	 * The queried directives are kept in a depth-first pre-order with respect to their
	 * positions in the DOM.
	 *
	 * Query does not look deep into any subcomponent views.
	 *
	 * Query is updated as part of the change-detection cycle. Since change detection
	 * happens after construction of a directive, QueryList will always be empty when observed in the
	 * constructor.
	 *
	 * The injected object is an unmodifiable live list.
	 * See {@link QueryList} for more details.
	 * @ts2dart_const
	 * @deprecated
	 */
	var QueryMetadata = (function (_super) {
	    __extends(QueryMetadata, _super);
	    function QueryMetadata(_selector, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d, _e = _b.read, read = _e === void 0 ? null : _e;
	        _super.call(this);
	        this._selector = _selector;
	        this.descendants = descendants;
	        this.first = first;
	        this.read = read;
	    }
	    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
	        /**
	         * always `false` to differentiate it with {@link ViewQueryMetadata}.
	         */
	        get: function () { return false; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "selector", {
	        /**
	         * what this is querying for.
	         */
	        get: function () { return forward_ref_1.resolveForwardRef(this._selector); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
	        /**
	         * whether this is querying for a variable binding or a directive.
	         */
	        get: function () { return lang_1.isString(this.selector); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
	        /**
	         * returns a list of variable bindings this is querying for.
	         * Only applicable if this is a variable bindings query.
	         */
	        get: function () { return lang_1.StringWrapper.split(this.selector, /\s*,\s*/g); },
	        enumerable: true,
	        configurable: true
	    });
	    QueryMetadata.prototype.toString = function () { return "@Query(" + lang_1.stringify(this.selector) + ")"; };
	    return QueryMetadata;
	}(metadata_1.DependencyMetadata));
	exports.QueryMetadata = QueryMetadata;
	// TODO: add an example after ContentChildren and ViewChildren are in master
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChildren is set
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ContentChildrenMetadata = (function (_super) {
	    __extends(ContentChildrenMetadata, _super);
	    function ContentChildrenMetadata(_selector, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.read, read = _d === void 0 ? null : _d;
	        _super.call(this, _selector, { descendants: descendants, read: read });
	    }
	    return ContentChildrenMetadata;
	}(QueryMetadata));
	exports.ContentChildrenMetadata = ContentChildrenMetadata;
	// TODO: add an example after ContentChild and ViewChild are in master
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChild(ChildDirective) contentChild;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is set
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ContentChildMetadata = (function (_super) {
	    __extends(ContentChildMetadata, _super);
	    function ContentChildMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
	        _super.call(this, _selector, { descendants: true, first: true, read: read });
	    }
	    return ContentChildMetadata;
	}(QueryMetadata));
	exports.ContentChildMetadata = ContentChildMetadata;
	/**
	 * Similar to {@link QueryMetadata}, but querying the component view, instead of
	 * the content children.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
	 *
	 * ```javascript
	 * @Component({
	 *   ...,
	 *   template: `
	 *     <item> a </item>
	 *     <item> b </item>
	 *     <item> c </item>
	 *   `
	 * })
	 * class MyComponent {
	 *   shown: boolean;
	 *
	 *   constructor(private @ViewQuery(Item) items:QueryList<Item>) {
	 *     items.changes.subscribe(() => console.log(items.length));
	 *   }
	 * }
	 * ```
	 *
	 * Supports the same querying parameters as {@link QueryMetadata}, except
	 * `descendants`. This always queries the whole view.
	 *
	 * As `shown` is flipped between true and false, items will contain zero of one
	 * items.
	 *
	 * Specifies that a {@link QueryList} should be injected.
	 *
	 * The injected object is an iterable and observable live list.
	 * See {@link QueryList} for more details.
	 * @ts2dart_const
	 * @deprecated
	 */
	var ViewQueryMetadata = (function (_super) {
	    __extends(ViewQueryMetadata, _super);
	    function ViewQueryMetadata(_selector, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d, _e = _b.read, read = _e === void 0 ? null : _e;
	        _super.call(this, _selector, { descendants: descendants, first: first, read: read });
	    }
	    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
	        /**
	         * always `true` to differentiate it with {@link QueryMetadata}.
	         */
	        get: function () { return true; },
	        enumerable: true,
	        configurable: true
	    });
	    ViewQueryMetadata.prototype.toString = function () { return "@ViewQuery(" + lang_1.stringify(this.selector) + ")"; };
	    return ViewQueryMetadata;
	}(QueryMetadata));
	exports.ViewQueryMetadata = ViewQueryMetadata;
	/**
	 * Declares a list of child element references.
	 *
	 * Angular automatically updates the list when the DOM is updated.
	 *
	 * `ViewChildren` takes an argument to select elements.
	 *
	 * - If the argument is a type, directives or components with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
	 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
	 * bound.
	 *
	 * View children are set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp #child1></child-cmp>
	 *     <child-cmp #child2></child-cmp>
	 *     <child-cmp #child3></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ViewChildrenMetadata = (function (_super) {
	    __extends(ViewChildrenMetadata, _super);
	    function ViewChildrenMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
	        _super.call(this, _selector, { descendants: true, read: read });
	    }
	    return ViewChildrenMetadata;
	}(ViewQueryMetadata));
	exports.ViewChildrenMetadata = ViewChildrenMetadata;
	/**
	 *
	 * Declares a reference of child element.
	 *
	 * `ViewChildren` takes an argument to select elements.
	 *
	 * - If the argument is a type, a directive or a component with the type will be bound.
	 *
	 If the argument is a string, the string is interpreted as a selector. An element containing the
	 matching template variable (e.g. `#child`) will be bound.
	 *
	 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
	 multiple matches.
	 *
	 * View child is set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild(ChildCmp) child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp #child></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild('child') child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ViewChildMetadata = (function (_super) {
	    __extends(ViewChildMetadata, _super);
	    function ViewChildMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
	        _super.call(this, _selector, { descendants: true, first: true, read: read });
	    }
	    return ViewChildMetadata;
	}(ViewQueryMetadata));
	exports.ViewChildMetadata = ViewChildMetadata;
	//# sourceMappingURL=di.js.map

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var constants_1 = __webpack_require__(41);
	var metadata_1 = __webpack_require__(26);
	var lang_1 = __webpack_require__(2);
	/**
	 * Directives allow you to attach behavior to elements in the DOM.
	 *
	 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
	 *
	 * A directive consists of a single directive annotation and a controller class. When the
	 * directive's `selector` matches
	 * elements in the DOM, the following steps occur:
	 *
	 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
	 * arguments.
	 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
	 * depth-first order,
	 *    as declared in the HTML.
	 *
	 * ## Understanding How Injection Works
	 *
	 * There are three stages of injection resolution.
	 * - *Pre-existing Injectors*:
	 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
	 * the dependency was
	 *     specified as `@Optional`, returns `null`.
	 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
	 * location, and others.
	 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
	 * the same parent-child hierarchy
	 *     as the component instances in the DOM.
	 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
	 * element has an `ElementInjector`
	 *     which follow the same parent-child hierarchy as the DOM elements themselves.
	 *
	 * When a template is instantiated, it also must instantiate the corresponding directives in a
	 * depth-first order. The
	 * current `ElementInjector` resolves the constructor dependencies for each directive.
	 *
	 * Angular then resolves dependencies as follows, according to the order in which they appear in the
	 * {@link ViewMetadata}:
	 *
	 * 1. Dependencies on the current element
	 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
	 * 3. Dependencies on component injectors and their parents until it encounters the root component
	 * 4. Dependencies on pre-existing injectors
	 *
	 *
	 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
	 * delegate to the parent
	 * injector.
	 *
	 * To inject other directives, declare the constructor parameter as:
	 * - `directive:DirectiveType`: a directive on the current element only
	 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
	 * element and the
	 *    Shadow DOM root.
	 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
	 * directives.
	 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
	 * child directives.
	 *
	 * To inject element-specific special objects, declare the constructor parameter as:
	 * - `element: ElementRef` to obtain a reference to logical element in the view.
	 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
	 * {@link DirectiveMetadata} directives only
	 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
	 *
	 * ### Example
	 *
	 * The following example demonstrates how dependency injection resolves constructor arguments in
	 * practice.
	 *
	 *
	 * Assume this HTML template:
	 *
	 * ```
	 * <div dependency="1">
	 *   <div dependency="2">
	 *     <div dependency="3" my-directive>
	 *       <div dependency="4">
	 *         <div dependency="5"></div>
	 *       </div>
	 *       <div dependency="6"></div>
	 *     </div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * With the following `dependency` decorator and `SomeService` injectable class.
	 *
	 * ```
	 * @Injectable()
	 * class SomeService {
	 * }
	 *
	 * @Directive({
	 *   selector: '[dependency]',
	 *   inputs: [
	 *     'id: dependency'
	 *   ]
	 * })
	 * class Dependency {
	 *   id:string;
	 * }
	 * ```
	 *
	 * Let's step through the different ways in which `MyDirective` could be declared...
	 *
	 *
	 * ### No injection
	 *
	 * Here the constructor is declared with no arguments, therefore nothing is injected into
	 * `MyDirective`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor() {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with no dependencies.
	 *
	 *
	 * ### Component-level injection
	 *
	 * Directives can inject any injectable instance from the closest component injector or any of its
	 * parents.
	 *
	 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
	 * from the parent
	 * component's injector.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(someService: SomeService) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a dependency on `SomeService`.
	 *
	 *
	 * ### Injecting a directive from the current element
	 *
	 * Directives can inject other directives declared on the current element.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(dependency: Dependency) {
	 *     expect(dependency.id).toEqual(3);
	 *   }
	 * }
	 * ```
	 * This directive would be instantiated with `Dependency` declared at the same element, in this case
	 * `dependency="3"`.
	 *
	 * ### Injecting a directive from any ancestor elements
	 *
	 * Directives can inject other directives declared on any ancestor element (in the current Shadow
	 * DOM), i.e. on the current element, the
	 * parent element, or its parents.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Host() dependency: Dependency) {
	 *     expect(dependency.id).toEqual(2);
	 *   }
	 * }
	 * ```
	 *
	 * `@Host` checks the current element, the parent, as well as its parents recursively. If
	 * `dependency="2"` didn't
	 * exist on the direct parent, this injection would
	 * have returned
	 * `dependency="1"`.
	 *
	 *
	 * ### Injecting a live collection of direct child directives
	 *
	 *
	 * A directive can also query for other child directives. Since parent directives are instantiated
	 * before child directives, a directive can't simply inject the list of child directives. Instead,
	 * the directive injects a {@link QueryList}, which updates its contents as children are added,
	 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
	 * `ngIf`, or an `ngSwitch`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
	 * `Dependency` 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
	 *
	 * ### Injecting a live collection of descendant directives
	 *
	 * By passing the descendant flag to `@Query` above, we can include the children of the child
	 * elements.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
	 *
	 * ### Optional injection
	 *
	 * The normal behavior of directives is to return an error when a specified dependency cannot be
	 * resolved. If you
	 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
	 * with `@Optional()`.
	 * This explicitly permits the author of a template to treat some of the surrounding directives as
	 * optional.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Optional() dependency:Dependency) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a `Dependency` directive found on the current element.
	 * If none can be
	 * found, the injector supplies `null` instead of throwing an error.
	 *
	 * ### Example
	 *
	 * Here we use a decorator directive to simply define basic tool-tip behavior.
	 *
	 * ```
	 * @Directive({
	 *   selector: '[tooltip]',
	 *   inputs: [
	 *     'text: tooltip'
	 *   ],
	 *   host: {
	 *     '(mouseenter)': 'onMouseEnter()',
	 *     '(mouseleave)': 'onMouseLeave()'
	 *   }
	 * })
	 * class Tooltip{
	 *   text:string;
	 *   overlay:Overlay; // NOT YET IMPLEMENTED
	 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
	 *
	 *   constructor(overlayManager:OverlayManager) {
	 *     this.overlay = overlay;
	 *   }
	 *
	 *   onMouseEnter() {
	 *     // exact signature to be determined
	 *     this.overlay = this.overlayManager.open(text, ...);
	 *   }
	 *
	 *   onMouseLeave() {
	 *     this.overlay.close();
	 *     this.overlay = null;
	 *   }
	 * }
	 * ```
	 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
	 * `tooltip` selector,
	 * like so:
	 *
	 * ```
	 * <div tooltip="some text here"></div>
	 * ```
	 *
	 * Directives can also control the instantiation, destruction, and positioning of inline template
	 * elements:
	 *
	 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
	 * runtime.
	 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
	 * location in the current view
	 * where these actions are performed.
	 *
	 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
	 * `<template>` element. Thus a
	 * directive in a child view cannot inject the directive that created it.
	 *
	 * Since directives that create views via ViewContainers are common in Angular, and using the full
	 * `<template>` element syntax is wordy, Angular
	 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
	 * equivalent.
	 *
	 * Thus,
	 *
	 * ```
	 * <ul>
	 *   <li *foo="bar" title="text"></li>
	 * </ul>
	 * ```
	 *
	 * Expands in use to:
	 *
	 * ```
	 * <ul>
	 *   <template [foo]="bar">
	 *     <li title="text"></li>
	 *   </template>
	 * </ul>
	 * ```
	 *
	 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
	 * the directive
	 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the directive class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the directive.
	 *
	 * ### Example
	 *
	 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
	 *
	 * Here is a simple directive that triggers on an `unless` selector:
	 *
	 * ```
	 * @Directive({
	 *   selector: '[unless]',
	 *   inputs: ['unless']
	 * })
	 * export class Unless {
	 *   viewContainer: ViewContainerRef;
	 *   templateRef: TemplateRef;
	 *   prevCondition: boolean;
	 *
	 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
	 *     this.viewContainer = viewContainer;
	 *     this.templateRef = templateRef;
	 *     this.prevCondition = null;
	 *   }
	 *
	 *   set unless(newCondition) {
	 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
	 *       this.prevCondition = true;
	 *       this.viewContainer.clear();
	 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
	 *       this.prevCondition = false;
	 *       this.viewContainer.create(this.templateRef);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * We can then use this `unless` selector in a template:
	 * ```
	 * <ul>
	 *   <li *unless="expr"></li>
	 * </ul>
	 * ```
	 *
	 * Once the directive instantiates the child view, the shorthand notation for the template expands
	 * and the result is:
	 *
	 * ```
	 * <ul>
	 *   <template [unless]="exp">
	 *     <li></li>
	 *   </template>
	 *   <li></li>
	 * </ul>
	 * ```
	 *
	 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
	 * the instantiated
	 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
	 * @ts2dart_const
	 * @stable
	 */
	var DirectiveMetadata = (function (_super) {
	    __extends(DirectiveMetadata, _super);
	    function DirectiveMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, providers = _b.providers, exportAs = _b.exportAs, queries = _b.queries;
	        _super.call(this);
	        this.selector = selector;
	        this._inputs = inputs;
	        this._properties = properties;
	        this._outputs = outputs;
	        this._events = events;
	        this.host = host;
	        this.exportAs = exportAs;
	        this.queries = queries;
	        this._providers = providers;
	    }
	    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
	        /**
	         * Enumerates the set of data-bound input properties for a directive
	         *
	         * Angular automatically updates input properties during change detection.
	         *
	         * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
	         * configuration:
	         *
	         * - `directiveProperty` specifies the component property where the value is written.
	         * - `bindingProperty` specifies the DOM property where the value is read from.
	         *
	         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
	         *
	         * The following example creates a component with two data-bound properties.
	         *
	         * ```typescript
	         * @Component({
	         *   selector: 'bank-account',
	         *   inputs: ['bankName', 'id: account-id'],
	         *   template: `
	         *     Bank Name: {{bankName}}
	         *     Account Id: {{id}}
	         *   `
	         * })
	         * class BankAccount {
	         *   bankName: string;
	         *   id: string;
	         *
	         *   // this property is not bound, and won't be automatically updated by Angular
	         *   normalizedBankName: string;
	         * }
	         *
	         * @Component({
	         *   selector: 'app',
	         *   template: `
	         *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	         *   `,
	         *   directives: [BankAccount]
	         * })
	         * class App {}
	         *
	         * bootstrap(App);
	         * ```
	         *
	         */
	        get: function () {
	            return lang_1.isPresent(this._properties) && this._properties.length > 0 ? this._properties :
	                this._inputs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "properties", {
	        /**
	         * Use `inputs` instead
	         *
	         * @deprecated
	         */
	        get: function () { return this.inputs; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
	        /**
	         * Enumerates the set of event-bound output properties.
	         *
	         * When an output property emits an event, an event handler attached to that event
	         * the template is invoked.
	         *
	         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
	         * configuration:
	         *
	         * - `directiveProperty` specifies the component property that emits events.
	         * - `bindingProperty` specifies the DOM property the event handler is attached to.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
	         *
	         * ```typescript
	         * @Directive({
	         *   selector: 'interval-dir',
	         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
	         * })
	         * class IntervalDir {
	         *   everySecond = new EventEmitter();
	         *   five5Secs = new EventEmitter();
	         *
	         *   constructor() {
	         *     setInterval(() => this.everySecond.emit("event"), 1000);
	         *     setInterval(() => this.five5Secs.emit("event"), 5000);
	         *   }
	         * }
	         *
	         * @Component({
	         *   selector: 'app',
	         *   template: `
	         *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	         *     </interval-dir>
	         *   `,
	         *   directives: [IntervalDir]
	         * })
	         * class App {
	         *   everySecond() { console.log('second'); }
	         *   everyFiveSeconds() { console.log('five seconds'); }
	         * }
	         * bootstrap(App);
	         * ```
	         *
	         */
	        get: function () {
	            return lang_1.isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "events", {
	        /**
	         * Use `outputs` instead
	         *
	         * @deprecated
	         */
	        get: function () { return this.outputs; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
	        /**
	         * Defines the set of injectable objects that are visible to a Directive and its light DOM
	         * children.
	         *
	         * ## Simple Example
	         *
	         * Here is an example of a class that can be injected:
	         *
	         * ```
	         * class Greeter {
	         *    greet(name:string) {
	         *      return 'Hello ' + name + '!';
	         *    }
	         * }
	         *
	         * @Directive({
	         *   selector: 'greet',
	         *   providers: [
	         *     Greeter
	         *   ]
	         * })
	         * class HelloWorld {
	         *   greeter:Greeter;
	         *
	         *   constructor(greeter:Greeter) {
	         *     this.greeter = greeter;
	         *   }
	         * }
	         * ```
	         */
	        get: function () { return this._providers; },
	        enumerable: true,
	        configurable: true
	    });
	    return DirectiveMetadata;
	}(metadata_1.InjectableMetadata));
	exports.DirectiveMetadata = DirectiveMetadata;
	/**
	 * Declare reusable UI building blocks for an application.
	 *
	 * Each Angular component requires a single `@Component` annotation. The
	 * `@Component`
	 * annotation specifies when a component is instantiated, and which properties and hostListeners it
	 * binds to.
	 *
	 * When a component is instantiated, Angular
	 * - creates a shadow DOM for the component.
	 * - loads the selected template into the shadow DOM.
	 * - creates all the injectable objects configured with `providers` and `viewProviders`.
	 *
	 * All template expressions and statements are then evaluated against the component instance.
	 *
	 * For details on the `@View` annotation, see {@link ViewMetadata}.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the component class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the component.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='component'}
	 * @ts2dart_const
	 * @stable
	 */
	var ComponentMetadata = (function (_super) {
	    __extends(ComponentMetadata, _super);
	    function ComponentMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, exportAs = _b.exportAs, moduleId = _b.moduleId, providers = _b.providers, viewProviders = _b.viewProviders, _c = _b.changeDetection, changeDetection = _c === void 0 ? constants_1.ChangeDetectionStrategy.Default : _c, queries = _b.queries, templateUrl = _b.templateUrl, template = _b.template, styleUrls = _b.styleUrls, styles = _b.styles, animations = _b.animations, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, interpolation = _b.interpolation, precompile = _b.precompile;
	        _super.call(this, {
	            selector: selector,
	            inputs: inputs,
	            outputs: outputs,
	            properties: properties,
	            events: events,
	            host: host,
	            exportAs: exportAs,
	            providers: providers,
	            queries: queries
	        });
	        this.changeDetection = changeDetection;
	        this._viewProviders = viewProviders;
	        this.templateUrl = templateUrl;
	        this.template = template;
	        this.styleUrls = styleUrls;
	        this.styles = styles;
	        this.directives = directives;
	        this.pipes = pipes;
	        this.encapsulation = encapsulation;
	        this.moduleId = moduleId;
	        this.animations = animations;
	        this.interpolation = interpolation;
	        this.precompile = precompile;
	    }
	    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
	        /**
	         * Defines the set of injectable objects that are visible to its view DOM children.
	         *
	         * ## Simple Example
	         *
	         * Here is an example of a class that can be injected:
	         *
	         * ```
	         * class Greeter {
	         *    greet(name:string) {
	         *      return 'Hello ' + name + '!';
	         *    }
	         * }
	         *
	         * @Directive({
	         *   selector: 'needs-greeter'
	         * })
	         * class NeedsGreeter {
	         *   greeter:Greeter;
	         *
	         *   constructor(greeter:Greeter) {
	         *     this.greeter = greeter;
	         *   }
	         * }
	         *
	         * @Component({
	         *   selector: 'greet',
	         *   viewProviders: [
	         *     Greeter
	         *   ],
	         *   template: `<needs-greeter></needs-greeter>`,
	         *   directives: [NeedsGreeter]
	         * })
	         * class HelloWorld {
	         * }
	         *
	         * ```
	         */
	        get: function () { return this._viewProviders; },
	        enumerable: true,
	        configurable: true
	    });
	    return ComponentMetadata;
	}(DirectiveMetadata));
	exports.ComponentMetadata = ComponentMetadata;
	/**
	 * Declare reusable pipe function.
	 *
	 * A "pure" pipe is only re-evaluated when either the input or any of the arguments change.
	 *
	 * When not specified, pipes default to being pure.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='pipe'}
	 * @ts2dart_const
	 * @stable
	 */
	var PipeMetadata = (function (_super) {
	    __extends(PipeMetadata, _super);
	    function PipeMetadata(_a) {
	        var name = _a.name, pure = _a.pure;
	        _super.call(this);
	        this.name = name;
	        this._pure = pure;
	    }
	    Object.defineProperty(PipeMetadata.prototype, "pure", {
	        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },
	        enumerable: true,
	        configurable: true
	    });
	    return PipeMetadata;
	}(metadata_1.InjectableMetadata));
	exports.PipeMetadata = PipeMetadata;
	/**
	 * Declares a data-bound input property.
	 *
	 * Angular automatically updates data-bound properties during change detection.
	 *
	 * `InputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * The following example creates a component with two input properties.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'bank-account',
	 *   template: `
	 *     Bank Name: {{bankName}}
	 *     Account Id: {{id}}
	 *   `
	 * })
	 * class BankAccount {
	 *   @Input() bankName: string;
	 *   @Input('account-id') id: string;
	 *
	 *   // this property is not bound, and won't be automatically updated by Angular
	 *   normalizedBankName: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	 *   `,
	 *   directives: [BankAccount]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var InputMetadata = (function () {
	    function InputMetadata(
	        /**
	         * Name used when instantiating a component in the template.
	         */
	        bindingPropertyName) {
	        this.bindingPropertyName = bindingPropertyName;
	    }
	    return InputMetadata;
	}());
	exports.InputMetadata = InputMetadata;
	/**
	 * Declares an event-bound output property.
	 *
	 * When an output property emits an event, an event handler attached to that event
	 * the template is invoked.
	 *
	 * `OutputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Directive({
	 *   selector: 'interval-dir',
	 * })
	 * class IntervalDir {
	 *   @Output() everySecond = new EventEmitter();
	 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
	 *
	 *   constructor() {
	 *     setInterval(() => this.everySecond.emit("event"), 1000);
	 *     setInterval(() => this.five5Secs.emit("event"), 5000);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	 *     </interval-dir>
	 *   `,
	 *   directives: [IntervalDir]
	 * })
	 * class App {
	 *   everySecond() { console.log('second'); }
	 *   everyFiveSeconds() { console.log('five seconds'); }
	 * }
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var OutputMetadata = (function () {
	    function OutputMetadata(bindingPropertyName) {
	        this.bindingPropertyName = bindingPropertyName;
	    }
	    return OutputMetadata;
	}());
	exports.OutputMetadata = OutputMetadata;
	/**
	 * Declares a host property binding.
	 *
	 * Angular automatically checks host property bindings during change detection.
	 * If a binding changes, it will update the host element of the directive.
	 *
	 * `HostBindingMetadata` takes an optional parameter that specifies the property
	 * name of the host element that will be updated. When not provided,
	 * the class property name is used.
	 *
	 * ### Example
	 *
	 * The following example creates a directive that sets the `valid` and `invalid` classes
	 * on the DOM element that has ngModel directive on it.
	 *
	 * ```typescript
	 * @Directive({selector: '[ngModel]'})
	 * class NgModelStatus {
	 *   constructor(public control:NgModel) {}
	 *   @HostBinding('class.valid') get valid { return this.control.valid; }
	 *   @HostBinding('class.invalid') get invalid { return this.control.invalid; }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<input [(ngModel)]="prop">`,
	 *   directives: [FORM_DIRECTIVES, NgModelStatus]
	 * })
	 * class App {
	 *   prop;
	 * }
	 *
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var HostBindingMetadata = (function () {
	    function HostBindingMetadata(hostPropertyName) {
	        this.hostPropertyName = hostPropertyName;
	    }
	    return HostBindingMetadata;
	}());
	exports.HostBindingMetadata = HostBindingMetadata;
	/**
	 * Declares a host listener.
	 *
	 * Angular will invoke the decorated method when the host element emits the specified event.
	 *
	 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
	 * event.
	 *
	 * ### Example
	 *
	 * The following example declares a directive that attaches a click listener to the button and
	 * counts clicks.
	 *
	 * ```typescript
	 * @Directive({selector: 'button[counting]'})
	 * class CountClicks {
	 *   numberOfClicks = 0;
	 *
	 *   @HostListener('click', ['$event.target'])
	 *   onClick(btn) {
	 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<button counting>Increment</button>`,
	 *   directives: [CountClicks]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var HostListenerMetadata = (function () {
	    function HostListenerMetadata(eventName, args) {
	        this.eventName = eventName;
	        this.args = args;
	    }
	    return HostListenerMetadata;
	}());
	exports.HostListenerMetadata = HostListenerMetadata;
	//# sourceMappingURL=directives.js.map

/***/ },
/* 121 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @stable
	 */
	(function (LifecycleHooks) {
	    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
	    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
	    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
	    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
	    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
	    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
	    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
	    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
	})(exports.LifecycleHooks || (exports.LifecycleHooks = {}));
	var LifecycleHooks = exports.LifecycleHooks;
	exports.LIFECYCLE_HOOKS_VALUES = [
	    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
	    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
	    LifecycleHooks.AfterViewChecked
	];
	/**
	 * Lifecycle hooks are guaranteed to be called in the following order:
	 * - `OnChanges` (if any bindings have changed),
	 * - `OnInit` (after the first check only),
	 * - `DoCheck`,
	 * - `AfterContentInit`,
	 * - `AfterContentChecked`,
	 * - `AfterViewInit`,
	 * - `AfterViewChecked`,
	 * - `OnDestroy` (at the very end before destruction)
	 */
	/**
	 * Implement this interface to get notified when any data-bound property of your directive changes.
	 *
	 * `ngOnChanges` is called right after the data-bound properties have been checked and before view
	 * and content children are checked if at least one of them has changed.
	 *
	 * The `changes` parameter contains an entry for each of the changed data-bound property. The key is
	 * the property name and the value is an instance of {@link SimpleChange}.
	 *
	 * ### Example ([live example](http://plnkr.co/edit/AHrB6opLqHDBPkt4KpdT?p=preview)):
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>myProp = {{myProp}}</p>`
	 * })
	 * class MyComponent implements OnChanges {
	 *   @Input() myProp: any;
	 *
	 *   ngOnChanges(changes: SimpleChanges) {
	 *     console.log('ngOnChanges - myProp = ' + changes['myProp'].currentValue);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="value = value + 1">Change MyComponent</button>
	 *     <my-cmp [my-prop]="value"></my-cmp>`,
	 *   directives: [MyComponent]
	 * })
	 * export class App {
	 *   value = 0;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var OnChanges = (function () {
	    function OnChanges() {
	    }
	    return OnChanges;
	}());
	exports.OnChanges = OnChanges;
	/**
	 * Implement this interface to execute custom initialization logic after your directive's
	 * data-bound properties have been initialized.
	 *
	 * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
	 * first time, and before any of its children have been checked. It is invoked only once when the
	 * directive is instantiated.
	 *
	 * ### Example ([live example](http://plnkr.co/edit/1MBypRryXd64v4pV03Yn?p=preview))
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>my-component</p>`
	 * })
	 * class MyComponent implements OnInit, OnDestroy {
	 *   ngOnInit() {
	 *     console.log('ngOnInit');
	 *   }
	 *
	 *   ngOnDestroy() {
	 *     console.log('ngOnDestroy');
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="hasChild = !hasChild">
	 *       {{hasChild ? 'Destroy' : 'Create'}} MyComponent
	 *     </button>
	 *     <my-cmp *ngIf="hasChild"></my-cmp>`,
	 *   directives: [MyComponent, NgIf]
	 * })
	 * export class App {
	 *   hasChild = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 *  ```
	 * @stable
	 */
	var OnInit = (function () {
	    function OnInit() {
	    }
	    return OnInit;
	}());
	exports.OnInit = OnInit;
	/**
	 * Implement this interface to supplement the default change detection algorithm in your directive.
	 *
	 * `ngDoCheck` gets called to check the changes in the directives in addition to the default
	 * algorithm.
	 *
	 * The default change detection algorithm looks for differences by comparing bound-property values
	 * by reference across change detection runs.
	 *
	 * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
	 * changes on the same input. `ngOnChanges` will continue to be called when the default change
	 * detector
	 * detects changes, so it is usually unnecessary to respond to changes on the same input in both
	 * hooks.
	 * Reaction to the changes have to be handled from within the `ngDoCheck` callback.
	 *
	 * You can use {@link KeyValueDiffers} and {@link IterableDiffers} to help add your custom check
	 * mechanisms.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/QpnIlF0CR2i5bcYbHEUJ?p=preview))
	 *
	 * In the following example `ngDoCheck` uses an {@link IterableDiffers} to detect the updates to the
	 * array `list`:
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'custom-check',
	 *   template: `
	 *     <p>Changes:</p>
	 *     <ul>
	 *       <li *ngFor="let line of logs">{{line}}</li>
	 *     </ul>`,
	 *   directives: [NgFor]
	 * })
	 * class CustomCheckComponent implements DoCheck {
	 *   @Input() list: any[];
	 *   differ: any;
	 *   logs = [];
	 *
	 *   constructor(differs: IterableDiffers) {
	 *     this.differ = differs.find([]).create(null);
	 *   }
	 *
	 *   ngDoCheck() {
	 *     var changes = this.differ.diff(this.list);
	 *
	 *     if (changes) {
	 *       changes.forEachAddedItem(r => this.logs.push('added ' + r.item));
	 *       changes.forEachRemovedItem(r => this.logs.push('removed ' + r.item))
	 *     }
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="list.push(list.length)">Push</button>
	 *     <button (click)="list.pop()">Pop</button>
	 *     <custom-check [list]="list"></custom-check>`,
	 *   directives: [CustomCheckComponent]
	 * })
	 * export class App {
	 *   list = [];
	 * }
	 * ```
	 * @stable
	 */
	var DoCheck = (function () {
	    function DoCheck() {
	    }
	    return DoCheck;
	}());
	exports.DoCheck = DoCheck;
	/**
	 * Implement this interface to get notified when your directive is destroyed.
	 *
	 * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
	 * instance is destroyed
	 *
	 * ### Example ([live example](http://plnkr.co/edit/1MBypRryXd64v4pV03Yn?p=preview))
	 *
	 * ```typesript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>my-component</p>`
	 * })
	 * class MyComponent implements OnInit, OnDestroy {
	 *   ngOnInit() {
	 *     console.log('ngOnInit');
	 *   }
	 *
	 *   ngOnDestroy() {
	 *     console.log('ngOnDestroy');
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="hasChild = !hasChild">
	 *       {{hasChild ? 'Destroy' : 'Create'}} MyComponent
	 *     </button>
	 *     <my-cmp *ngIf="hasChild"></my-cmp>`,
	 *   directives: [MyComponent, NgIf]
	 * })
	 * export class App {
	 *   hasChild = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 *
	 *
	 * To create a stateful Pipe, you should implement this interface and set the `pure`
	 * parameter to `false` in the {@link PipeMetadata}.
	 *
	 * A stateful pipe may produce different output, given the same input. It is
	 * likely that a stateful pipe may contain state that should be cleaned up when
	 * a binding is destroyed. For example, a subscription to a stream of data may need to
	 * be disposed, or an interval may need to be cleared.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/i8pm5brO4sPaLxBx56MR?p=preview))
	 *
	 * In this example, a pipe is created to countdown its input value, updating it every
	 * 50ms. Because it maintains an internal interval, it automatically clears
	 * the interval when the binding is destroyed or the countdown completes.
	 *
	 * ```
	 * import {OnDestroy, Pipe, PipeTransform} from '@angular/core'
	 * @Pipe({name: 'countdown', pure: false})
	 * class CountDown implements PipeTransform, OnDestroy {
	 *   remainingTime:Number;
	 *   interval:SetInterval;
	 *   ngOnDestroy() {
	 *     if (this.interval) {
	 *       clearInterval(this.interval);
	 *     }
	 *   }
	 *   transform(value: any, args: any[] = []) {
	 *     if (!parseInt(value, 10)) return null;
	 *     if (typeof this.remainingTime !== 'number') {
	 *       this.remainingTime = parseInt(value, 10);
	 *     }
	 *     if (!this.interval) {
	 *       this.interval = setInterval(() => {
	 *         this.remainingTime-=50;
	 *         if (this.remainingTime <= 0) {
	 *           this.remainingTime = 0;
	 *           clearInterval(this.interval);
	 *           delete this.interval;
	 *         }
	 *       }, 50);
	 *     }
	 *     return this.remainingTime;
	 *   }
	 * }
	 * ```
	 *
	 * Invoking `{{ 10000 | countdown }}` would cause the value to be decremented by 50,
	 * every 50ms, until it reaches 0.
	 *
	 * @stable
	 */
	var OnDestroy = (function () {
	    function OnDestroy() {
	    }
	    return OnDestroy;
	}());
	exports.OnDestroy = OnDestroy;
	/**
	 * Implement this interface to get notified when your directive's content has been fully
	 * initialized.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/plamXUpsLQbIXpViZhUO?p=preview))
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: `{{where}} child`
	 * })
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `<ng-content></ng-content>`
	 * })
	 * class ParentComponent implements AfterContentInit {
	 *   @ContentChild(ChildComponent) contentChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // contentChild is not initialized yet
	 *     console.log(this.getMessage(this.contentChild));
	 *   }
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is updated after the content has been checked
	 *     console.log('AfterContentInit: ' + this.getMessage(this.contentChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <parent-cmp>
	 *       <child-cmp where="content"></child-cmp>
	 *     </parent-cmp>`,
	 *   directives: [ParentComponent, ChildComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterContentInit = (function () {
	    function AfterContentInit() {
	    }
	    return AfterContentInit;
	}());
	exports.AfterContentInit = AfterContentInit;
	/**
	 * Implement this interface to get notified after every check of your directive's content.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/tGdrytNEKQnecIPkD7NU?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({selector: 'parent-cmp', template: `<ng-content></ng-content>`})
	 * class ParentComponent implements AfterContentChecked {
	 *   @ContentChild(ChildComponent) contentChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // contentChild is not initialized yet
	 *     console.log(this.getMessage(this.contentChild));
	 *   }
	 *
	 *   ngAfterContentChecked() {
	 *     // contentChild is updated after the content has been checked
	 *     console.log('AfterContentChecked: ' + this.getMessage(this.contentChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <parent-cmp>
	 *       <button (click)="hasContent = !hasContent">Toggle content child</button>
	 *       <child-cmp *ngIf="hasContent" where="content"></child-cmp>
	 *     </parent-cmp>`,
	 *   directives: [NgIf, ParentComponent, ChildComponent]
	 * })
	 * export class App {
	 *   hasContent = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterContentChecked = (function () {
	    function AfterContentChecked() {
	    }
	    return AfterContentChecked;
	}());
	exports.AfterContentChecked = AfterContentChecked;
	/**
	 * Implement this interface to get notified when your component's view has been fully initialized.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/LhTKVMEM0fkJgyp4CI1W?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `<child-cmp where="view"></child-cmp>`,
	 *   directives: [ChildComponent]
	 * })
	 * class ParentComponent implements AfterViewInit {
	 *   @ViewChild(ChildComponent) viewChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // viewChild is not initialized yet
	 *     console.log(this.getMessage(this.viewChild));
	 *   }
	 *
	 *   ngAfterViewInit() {
	 *     // viewChild is updated after the view has been initialized
	 *     console.log('ngAfterViewInit: ' + this.getMessage(this.viewChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<parent-cmp></parent-cmp>`,
	 *   directives: [ParentComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterViewInit = (function () {
	    function AfterViewInit() {
	    }
	    return AfterViewInit;
	}());
	exports.AfterViewInit = AfterViewInit;
	/**
	 * Implement this interface to get notified after every check of your component's view.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/0qDGHcPQkc25CXhTNzKU?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `
	 *     <button (click)="showView = !showView">Toggle view child</button>
	 *     <child-cmp *ngIf="showView" where="view"></child-cmp>`,
	 *   directives: [NgIf, ChildComponent]
	 * })
	 * class ParentComponent implements AfterViewChecked {
	 *   @ViewChild(ChildComponent) viewChild: ChildComponent;
	 *   showView = true;
	 *
	 *   constructor() {
	 *     // viewChild is not initialized yet
	 *     console.log(this.getMessage(this.viewChild));
	 *   }
	 *
	 *   ngAfterViewChecked() {
	 *     // viewChild is updated after the view has been checked
	 *     console.log('AfterViewChecked: ' + this.getMessage(this.viewChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<parent-cmp></parent-cmp>`,
	 *   directives: [ParentComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterViewChecked = (function () {
	    function AfterViewChecked() {
	    }
	    return AfterViewChecked;
	}());
	exports.AfterViewChecked = AfterViewChecked;
	//# sourceMappingURL=lifecycle_hooks.js.map

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var ReflectionCapabilities = (function () {
	    function ReflectionCapabilities(reflect) {
	        this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;
	    }
	    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	    ReflectionCapabilities.prototype.factory = function (t) {
	        switch (t.length) {
	            case 0:
	                return function () { return new t(); };
	            case 1:
	                return function (a1) { return new t(a1); };
	            case 2:
	                return function (a1, a2) { return new t(a1, a2); };
	            case 3:
	                return function (a1, a2, a3) { return new t(a1, a2, a3); };
	            case 4:
	                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };
	            case 5:
	                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };
	            case 6:
	                return function (a1, a2, a3, a4, a5, a6) {
	                    return new t(a1, a2, a3, a4, a5, a6);
	                };
	            case 7:
	                return function (a1, a2, a3, a4, a5, a6, a7) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7);
	                };
	            case 8:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8);
	                };
	            case 9:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
	                };
	            case 10:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	                };
	            case 11:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	                };
	            case 12:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	                };
	            case 13:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	                };
	            case 14:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	                };
	            case 15:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	                };
	            case 16:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
	                };
	            case 17:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
	                };
	            case 18:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
	                };
	            case 19:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
	                };
	            case 20:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
	                };
	        }
	        ;
	        throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
	    };
	    /** @internal */
	    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes /** TODO #9100 */, paramAnnotations /** TODO #9100 */) {
	        var result;
	        if (typeof paramTypes === 'undefined') {
	            result = new Array(paramAnnotations.length);
	        }
	        else {
	            result = new Array(paramTypes.length);
	        }
	        for (var i = 0; i < result.length; i++) {
	            // TS outputs Object for parameters without types, while Traceur omits
	            // the annotations. For now we preserve the Traceur behavior to aid
	            // migration, but this can be revisited.
	            if (typeof paramTypes === 'undefined') {
	                result[i] = [];
	            }
	            else if (paramTypes[i] != Object) {
	                result[i] = [paramTypes[i]];
	            }
	            else {
	                result[i] = [];
	            }
	            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
	                result[i] = result[i].concat(paramAnnotations[i]);
	            }
	        }
	        return result;
	    };
	    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.parameters)) {
	            return typeOrFunc.parameters;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (lang_1.isPresent(typeOrFunc.ctorParameters)) {
	            var ctorParameters = typeOrFunc.ctorParameters;
	            var paramTypes_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) { return ctorParam && ctorParam.type; });
	            var paramAnnotations_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) {
	                return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
	            });
	            return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);
	        }
	        // API for metadata created by invoking the decorators.
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
	            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
	            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
	                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	            }
	        }
	        // The array has to be filled with `undefined` because holes would be skipped by `some`
	        var parameters = new Array(typeOrFunc.length);
	        parameters.fill(undefined);
	        return parameters;
	    };
	    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.annotations)) {
	            var annotations = typeOrFunc.annotations;
	            if (lang_1.isFunction(annotations) && annotations.annotations) {
	                annotations = annotations.annotations;
	            }
	            return annotations;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (lang_1.isPresent(typeOrFunc.decorators)) {
	            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
	        }
	        // API for metadata created by invoking the decorators.
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
	            if (lang_1.isPresent(annotations))
	                return annotations;
	        }
	        return [];
	    };
	    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.propMetadata)) {
	            var propMetadata = typeOrFunc.propMetadata;
	            if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {
	                propMetadata = propMetadata.propMetadata;
	            }
	            return propMetadata;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (lang_1.isPresent(typeOrFunc.propDecorators)) {
	            var propDecorators_1 = typeOrFunc.propDecorators;
	            var propMetadata_1 = {};
	            Object.keys(propDecorators_1).forEach(function (prop) {
	                propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
	            });
	            return propMetadata_1;
	        }
	        // API for metadata created by invoking the decorators.
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
	            if (lang_1.isPresent(propMetadata))
	                return propMetadata;
	        }
	        return {};
	    };
	    // Note: JavaScript does not support to query for interfaces during runtime.
	    // However, we can't throw here as the reflector will always call this method
	    // when asked for a lifecycle interface as this is what we check in Dart.
	    ReflectionCapabilities.prototype.interfaces = function (type) { return []; };
	    ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {
	        if (!(type instanceof lang_1.Type))
	            return false;
	        var proto = type.prototype;
	        return !!proto[lcProperty];
	    };
	    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
	    ReflectionCapabilities.prototype.setter = function (name) {
	        return new Function('o', 'v', 'return o.' + name + ' = v;');
	    };
	    ReflectionCapabilities.prototype.method = function (name) {
	        var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	        return new Function('o', 'args', functionBody);
	    };
	    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
	    ReflectionCapabilities.prototype.importUri = function (type) {
	        // StaticSymbol
	        if (typeof type === 'object' && type['filePath']) {
	            return type['filePath'];
	        }
	        // Runtime type
	        return "./" + lang_1.stringify(type);
	    };
	    return ReflectionCapabilities;
	}());
	exports.ReflectionCapabilities = ReflectionCapabilities;
	function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	    if (!decoratorInvocations) {
	        return [];
	    }
	    return decoratorInvocations.map(function (decoratorInvocation) {
	        var decoratorType = decoratorInvocation.type;
	        var annotationCls = decoratorType.annotationCls;
	        var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	        var annotation = Object.create(annotationCls.prototype);
	        annotationCls.apply(annotation, annotationArgs);
	        return annotation;
	    });
	}
	//# sourceMappingURL=reflection_capabilities.js.map

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	var reflector_reader_1 = __webpack_require__(74);
	/**
	 * Reflective information about a symbol, including annotations, interfaces, and other metadata.
	 */
	var ReflectionInfo = (function () {
	    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
	        this.annotations = annotations;
	        this.parameters = parameters;
	        this.factory = factory;
	        this.interfaces = interfaces;
	        this.propMetadata = propMetadata;
	    }
	    return ReflectionInfo;
	}());
	exports.ReflectionInfo = ReflectionInfo;
	/**
	 * Provides access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var Reflector = (function (_super) {
	    __extends(Reflector, _super);
	    function Reflector(reflectionCapabilities) {
	        _super.call(this);
	        /** @internal */
	        this._injectableInfo = new collection_1.Map();
	        /** @internal */
	        this._getters = new collection_1.Map();
	        /** @internal */
	        this._setters = new collection_1.Map();
	        /** @internal */
	        this._methods = new collection_1.Map();
	        this._usedKeys = null;
	        this.reflectionCapabilities = reflectionCapabilities;
	    }
	    Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
	    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
	    /**
	     * Causes `this` reflector to track keys used to access
	     * {@link ReflectionInfo} objects.
	     */
	    Reflector.prototype.trackUsage = function () { this._usedKeys = new collection_1.Set(); };
	    /**
	     * Lists types for which reflection information was not requested since
	     * {@link #trackUsage} was called. This list could later be audited as
	     * potential dead code.
	     */
	    Reflector.prototype.listUnusedKeys = function () {
	        var _this = this;
	        if (this._usedKeys == null) {
	            throw new exceptions_1.BaseException('Usage tracking is disabled');
	        }
	        var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);
	        return allTypes.filter(function (key) { return !collection_1.SetWrapper.has(_this._usedKeys, key); });
	    };
	    Reflector.prototype.registerFunction = function (func, funcInfo) {
	        this._injectableInfo.set(func, funcInfo);
	    };
	    Reflector.prototype.registerType = function (type, typeInfo) {
	        this._injectableInfo.set(type, typeInfo);
	    };
	    Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };
	    Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };
	    Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };
	    Reflector.prototype.factory = function (type) {
	        if (this._containsReflectionInfo(type)) {
	            var res = this._getReflectionInfo(type).factory;
	            return lang_1.isPresent(res) ? res : null;
	        }
	        else {
	            return this.reflectionCapabilities.factory(type);
	        }
	    };
	    Reflector.prototype.parameters = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).parameters;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.parameters(typeOrFunc);
	        }
	    };
	    Reflector.prototype.annotations = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).annotations;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.annotations(typeOrFunc);
	        }
	    };
	    Reflector.prototype.propMetadata = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).propMetadata;
	            return lang_1.isPresent(res) ? res : {};
	        }
	        else {
	            return this.reflectionCapabilities.propMetadata(typeOrFunc);
	        }
	    };
	    Reflector.prototype.interfaces = function (type) {
	        if (this._injectableInfo.has(type)) {
	            var res = this._getReflectionInfo(type).interfaces;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.interfaces(type);
	        }
	    };
	    Reflector.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {
	        var interfaces = this.interfaces(type);
	        if (interfaces.indexOf(lcInterface) !== -1) {
	            return true;
	        }
	        else {
	            return this.reflectionCapabilities.hasLifecycleHook(type, lcInterface, lcProperty);
	        }
	    };
	    Reflector.prototype.getter = function (name) {
	        if (this._getters.has(name)) {
	            return this._getters.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.getter(name);
	        }
	    };
	    Reflector.prototype.setter = function (name) {
	        if (this._setters.has(name)) {
	            return this._setters.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.setter(name);
	        }
	    };
	    Reflector.prototype.method = function (name) {
	        if (this._methods.has(name)) {
	            return this._methods.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.method(name);
	        }
	    };
	    /** @internal */
	    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
	        if (lang_1.isPresent(this._usedKeys)) {
	            this._usedKeys.add(typeOrFunc);
	        }
	        return this._injectableInfo.get(typeOrFunc);
	    };
	    /** @internal */
	    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };
	    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	    return Reflector;
	}(reflector_reader_1.ReflectorReader));
	exports.Reflector = Reflector;
	function _mergeMaps(target, config) {
	    collection_1.StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });
	}
	//# sourceMappingURL=reflector.js.map

/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
	 * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
	 * handled.
	 *
	 * See DomSanitizationService for more details on security in Angular applications.
	 *
	 * @stable
	 */
	(function (SecurityContext) {
	    SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
	    SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
	    SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
	    SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
	    SecurityContext[SecurityContext["URL"] = 4] = "URL";
	    SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
	})(exports.SecurityContext || (exports.SecurityContext = {}));
	var SecurityContext = exports.SecurityContext;
	/**
	 * SanitizationService is used by the views to sanitize potentially dangerous values. This is a
	 * private API, use code should only refer to DomSanitizationService.
	 *
	 * @stable
	 */
	var SanitizationService = (function () {
	    function SanitizationService() {
	    }
	    return SanitizationService;
	}());
	exports.SanitizationService = SanitizationService;
	//# sourceMappingURL=security.js.map

/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Stores error information; delivered via [NgZone.onError] stream.
	 * @deprecated
	 */
	var NgZoneError = (function () {
	    function NgZoneError(error, stackTrace) {
	        this.error = error;
	        this.stackTrace = stackTrace;
	    }
	    return NgZoneError;
	}());
	exports.NgZoneError = NgZoneError;
	var NgZoneImpl = (function () {
	    function NgZoneImpl(_a) {
	        var _this = this;
	        var trace = _a.trace, onEnter = _a.onEnter, onLeave = _a.onLeave, setMicrotask = _a.setMicrotask, setMacrotask = _a.setMacrotask, onError = _a.onError;
	        this.onEnter = onEnter;
	        this.onLeave = onLeave;
	        this.setMicrotask = setMicrotask;
	        this.setMacrotask = setMacrotask;
	        this.onError = onError;
	        if (Zone) {
	            this.outer = this.inner = Zone.current;
	            if (Zone['wtfZoneSpec']) {
	                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
	            }
	            if (trace && Zone['longStackTraceZoneSpec']) {
	                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
	            }
	            this.inner = this.inner.fork({
	                name: 'angular',
	                properties: { 'isAngularZone': true },
	                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invokeTask(target, task, applyThis, applyArgs);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onHasTask: function (delegate, current, target, hasTaskState) {
	                    delegate.hasTask(target, hasTaskState);
	                    if (current == target) {
	                        // We are only interested in hasTask events which originate from our zone
	                        // (A child hasTask event is not interesting to us)
	                        if (hasTaskState.change == 'microTask') {
	                            _this.setMicrotask(hasTaskState.microTask);
	                        }
	                        else if (hasTaskState.change == 'macroTask') {
	                            _this.setMacrotask(hasTaskState.macroTask);
	                        }
	                    }
	                },
	                onHandleError: function (delegate, current, target, error) {
	                    delegate.handleError(target, error);
	                    _this.onError(new NgZoneError(error, error.stack));
	                    return false;
	                }
	            });
	        }
	        else {
	            throw new Error('Angular requires Zone.js polyfill.');
	        }
	    }
	    NgZoneImpl.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
	    NgZoneImpl.prototype.runInner = function (fn) { return this.inner.run(fn); };
	    ;
	    NgZoneImpl.prototype.runInnerGuarded = function (fn) { return this.inner.runGuarded(fn); };
	    ;
	    NgZoneImpl.prototype.runOuter = function (fn) { return this.outer.run(fn); };
	    ;
	    return NgZoneImpl;
	}());
	exports.NgZoneImpl = NgZoneImpl;
	//# sourceMappingURL=ng_zone_impl.js.map

/***/ },
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(21);
	var Symbol = root_1.root.Symbol;
	if (typeof Symbol === 'function') {
	    if (Symbol.observable) {
	        exports.$$observable = Symbol.observable;
	    }
	    else {
	        if (typeof Symbol.for === 'function') {
	            exports.$$observable = Symbol.for('observable');
	        }
	        else {
	            exports.$$observable = Symbol('observable');
	        }
	        Symbol.observable = exports.$$observable;
	    }
	}
	else {
	    exports.$$observable = '@@observable';
	}
	//# sourceMappingURL=observable.js.map

/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(97);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var animation_constants_1 = __webpack_require__(101);
	var animation_driver_1 = __webpack_require__(192);
	var animation_group_player_1 = __webpack_require__(102);
	var animation_keyframe_1 = __webpack_require__(193);
	var animation_player_1 = __webpack_require__(38);
	var animation_sequence_player_1 = __webpack_require__(194);
	var animationUtils = __webpack_require__(195);
	var animation_styles_1 = __webpack_require__(196);
	var change_detection_util = __webpack_require__(62);
	var constants = __webpack_require__(41);
	var console = __webpack_require__(64);
	var debug = __webpack_require__(200);
	var provider_util = __webpack_require__(108);
	var reflective_provider = __webpack_require__(69);
	var component_factory_resolver = __webpack_require__(70);
	var component_resolver = __webpack_require__(30);
	var debug_context = __webpack_require__(113);
	var element = __webpack_require__(71);
	var template_ref = __webpack_require__(116);
	var view = __webpack_require__(209);
	var view_type = __webpack_require__(43);
	var view_utils = __webpack_require__(44);
	var lifecycle_hooks = __webpack_require__(121);
	var metadata_view = __webpack_require__(73);
	var wtf_init = __webpack_require__(214);
	var reflection = __webpack_require__(46);
	var reflection_capabilities = __webpack_require__(122);
	var reflector_reader = __webpack_require__(74);
	var api = __webpack_require__(75);
	var security = __webpack_require__(124);
	var decorators = __webpack_require__(47);
	exports.__core_private__ = {
	    isDefaultChangeDetectionStrategy: constants.isDefaultChangeDetectionStrategy,
	    ChangeDetectorStatus: constants.ChangeDetectorStatus,
	    CHANGE_DETECTION_STRATEGY_VALUES: constants.CHANGE_DETECTION_STRATEGY_VALUES,
	    constructDependencies: reflective_provider.constructDependencies,
	    LifecycleHooks: lifecycle_hooks.LifecycleHooks,
	    LIFECYCLE_HOOKS_VALUES: lifecycle_hooks.LIFECYCLE_HOOKS_VALUES,
	    ReflectorReader: reflector_reader.ReflectorReader,
	    ReflectorComponentResolver: component_resolver.ReflectorComponentResolver,
	    CodegenComponentFactoryResolver: component_factory_resolver.CodegenComponentFactoryResolver,
	    AppElement: element.AppElement,
	    AppView: view.AppView,
	    DebugAppView: view.DebugAppView,
	    ViewType: view_type.ViewType,
	    MAX_INTERPOLATION_VALUES: view_utils.MAX_INTERPOLATION_VALUES,
	    checkBinding: view_utils.checkBinding,
	    flattenNestedViewRenderNodes: view_utils.flattenNestedViewRenderNodes,
	    interpolate: view_utils.interpolate,
	    ViewUtils: view_utils.ViewUtils,
	    VIEW_ENCAPSULATION_VALUES: metadata_view.VIEW_ENCAPSULATION_VALUES,
	    DebugContext: debug_context.DebugContext,
	    StaticNodeDebugInfo: debug_context.StaticNodeDebugInfo,
	    devModeEqual: change_detection_util.devModeEqual,
	    uninitialized: change_detection_util.uninitialized,
	    ValueUnwrapper: change_detection_util.ValueUnwrapper,
	    RenderDebugInfo: api.RenderDebugInfo,
	    SecurityContext: security.SecurityContext,
	    SanitizationService: security.SanitizationService,
	    TemplateRef_: template_ref.TemplateRef_,
	    wtfInit: wtf_init.wtfInit,
	    ReflectionCapabilities: reflection_capabilities.ReflectionCapabilities,
	    makeDecorator: decorators.makeDecorator,
	    DebugDomRootRenderer: debug.DebugDomRootRenderer,
	    createProvider: provider_util.createProvider,
	    isProviderLiteral: provider_util.isProviderLiteral,
	    EMPTY_ARRAY: view_utils.EMPTY_ARRAY,
	    EMPTY_MAP: view_utils.EMPTY_MAP,
	    pureProxy1: view_utils.pureProxy1,
	    pureProxy2: view_utils.pureProxy2,
	    pureProxy3: view_utils.pureProxy3,
	    pureProxy4: view_utils.pureProxy4,
	    pureProxy5: view_utils.pureProxy5,
	    pureProxy6: view_utils.pureProxy6,
	    pureProxy7: view_utils.pureProxy7,
	    pureProxy8: view_utils.pureProxy8,
	    pureProxy9: view_utils.pureProxy9,
	    pureProxy10: view_utils.pureProxy10,
	    castByValue: view_utils.castByValue,
	    Console: console.Console,
	    reflector: reflection.reflector,
	    Reflector: reflection.Reflector,
	    NoOpAnimationPlayer: animation_player_1.NoOpAnimationPlayer,
	    AnimationPlayer: animation_player_1.AnimationPlayer,
	    NoOpAnimationDriver: animation_driver_1.NoOpAnimationDriver,
	    AnimationDriver: animation_driver_1.AnimationDriver,
	    AnimationSequencePlayer: animation_sequence_player_1.AnimationSequencePlayer,
	    AnimationGroupPlayer: animation_group_player_1.AnimationGroupPlayer,
	    AnimationKeyframe: animation_keyframe_1.AnimationKeyframe,
	    prepareFinalAnimationStyles: animationUtils.prepareFinalAnimationStyles,
	    balanceAnimationKeyframes: animationUtils.balanceAnimationKeyframes,
	    flattenStyles: animationUtils.flattenStyles,
	    clearStyles: animationUtils.clearStyles,
	    renderStyles: animationUtils.renderStyles,
	    collectAndResolveStyles: animationUtils.collectAndResolveStyles,
	    AnimationStyles: animation_styles_1.AnimationStyles,
	    ANY_STATE: animation_constants_1.ANY_STATE,
	    DEFAULT_STATE: animation_constants_1.DEFAULT_STATE,
	    EMPTY_STATE: animation_constants_1.EMPTY_STATE,
	    FILL_STYLE_FLAG: animation_constants_1.FILL_STYLE_FLAG
	};
	//# sourceMappingURL=private_export.js.map

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var ActiveAnimationPlayersMap = (function () {
	    function ActiveAnimationPlayersMap() {
	        this._map = new collection_1.Map();
	        this._allPlayers = [];
	    }
	    Object.defineProperty(ActiveAnimationPlayersMap.prototype, "length", {
	        get: function () { return this.getAllPlayers().length; },
	        enumerable: true,
	        configurable: true
	    });
	    ActiveAnimationPlayersMap.prototype.find = function (element, animationName) {
	        var playersByAnimation = this._map.get(element);
	        if (lang_1.isPresent(playersByAnimation)) {
	            return playersByAnimation[animationName];
	        }
	    };
	    ActiveAnimationPlayersMap.prototype.findAllPlayersByElement = function (element) {
	        var players = [];
	        collection_1.StringMapWrapper.forEach(this._map.get(element), function (player /** TODO #9100 */) { return players.push(player); });
	        return players;
	    };
	    ActiveAnimationPlayersMap.prototype.set = function (element, animationName, player) {
	        var playersByAnimation = this._map.get(element);
	        if (!lang_1.isPresent(playersByAnimation)) {
	            playersByAnimation = {};
	        }
	        var existingEntry = playersByAnimation[animationName];
	        if (lang_1.isPresent(existingEntry)) {
	            this.remove(element, animationName);
	        }
	        playersByAnimation[animationName] = player;
	        this._allPlayers.push(player);
	        this._map.set(element, playersByAnimation);
	    };
	    ActiveAnimationPlayersMap.prototype.getAllPlayers = function () { return this._allPlayers; };
	    ActiveAnimationPlayersMap.prototype.remove = function (element, animationName) {
	        var playersByAnimation = this._map.get(element);
	        if (lang_1.isPresent(playersByAnimation)) {
	            var player = playersByAnimation[animationName];
	            delete playersByAnimation[animationName];
	            var index = this._allPlayers.indexOf(player);
	            collection_1.ListWrapper.removeAt(this._allPlayers, index);
	            if (collection_1.StringMapWrapper.isEmpty(playersByAnimation)) {
	                this._map.delete(element);
	            }
	        }
	    };
	    return ActiveAnimationPlayersMap;
	}());
	exports.ActiveAnimationPlayersMap = ActiveAnimationPlayersMap;
	//# sourceMappingURL=active_animation_players_map.js.map

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var animation_player_1 = __webpack_require__(38);
	var AnimationDriver = (function () {
	    function AnimationDriver() {
	    }
	    return AnimationDriver;
	}());
	exports.AnimationDriver = AnimationDriver;
	var NoOpAnimationDriver = (function (_super) {
	    __extends(NoOpAnimationDriver, _super);
	    function NoOpAnimationDriver() {
	        _super.apply(this, arguments);
	    }
	    NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	        return new animation_player_1.NoOpAnimationPlayer();
	    };
	    return NoOpAnimationDriver;
	}(AnimationDriver));
	exports.NoOpAnimationDriver = NoOpAnimationDriver;
	//# sourceMappingURL=animation_driver.js.map

/***/ },
/* 193 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var AnimationKeyframe = (function () {
	    function AnimationKeyframe(offset, styles) {
	        this.offset = offset;
	        this.styles = styles;
	    }
	    return AnimationKeyframe;
	}());
	exports.AnimationKeyframe = AnimationKeyframe;
	//# sourceMappingURL=animation_keyframe.js.map

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var animation_player_1 = __webpack_require__(38);
	var AnimationSequencePlayer = (function () {
	    function AnimationSequencePlayer(_players) {
	        var _this = this;
	        this._players = _players;
	        this._currentIndex = 0;
	        this._subscriptions = [];
	        this._finished = false;
	        this.parentPlayer = null;
	        this._players.forEach(function (player) { player.parentPlayer = _this; });
	        this._onNext(false);
	    }
	    AnimationSequencePlayer.prototype._onNext = function (start) {
	        var _this = this;
	        if (this._finished)
	            return;
	        if (this._players.length == 0) {
	            this._activePlayer = new animation_player_1.NoOpAnimationPlayer();
	            lang_1.scheduleMicroTask(function () { return _this._onFinish(); });
	        }
	        else if (this._currentIndex >= this._players.length) {
	            this._activePlayer = new animation_player_1.NoOpAnimationPlayer();
	            this._onFinish();
	        }
	        else {
	            var player = this._players[this._currentIndex++];
	            player.onDone(function () { return _this._onNext(true); });
	            this._activePlayer = player;
	            if (start) {
	                player.play();
	            }
	        }
	    };
	    AnimationSequencePlayer.prototype._onFinish = function () {
	        if (!this._finished) {
	            this._finished = true;
	            if (!lang_1.isPresent(this.parentPlayer)) {
	                this.destroy();
	            }
	            this._subscriptions.forEach(function (subscription) { return subscription(); });
	            this._subscriptions = [];
	        }
	    };
	    AnimationSequencePlayer.prototype.onDone = function (fn) { this._subscriptions.push(fn); };
	    AnimationSequencePlayer.prototype.play = function () { this._activePlayer.play(); };
	    AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
	    AnimationSequencePlayer.prototype.restart = function () {
	        if (this._players.length > 0) {
	            this.reset();
	            this._players[0].restart();
	        }
	    };
	    AnimationSequencePlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
	    AnimationSequencePlayer.prototype.finish = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.finish(); });
	    };
	    AnimationSequencePlayer.prototype.destroy = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.destroy(); });
	    };
	    AnimationSequencePlayer.prototype.setPosition = function (p /** TODO #9100 */) { this._players[0].setPosition(p); };
	    AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
	    return AnimationSequencePlayer;
	}());
	exports.AnimationSequencePlayer = AnimationSequencePlayer;
	//# sourceMappingURL=animation_sequence_player.js.map

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var animation_constants_1 = __webpack_require__(101);
	var metadata_1 = __webpack_require__(103);
	function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
	    if (nullValue === void 0) { nullValue = null; }
	    var finalStyles = {};
	    collection_1.StringMapWrapper.forEach(newStyles, function (value, prop) {
	        finalStyles[prop] = value == metadata_1.AUTO_STYLE ? nullValue : value.toString();
	    });
	    collection_1.StringMapWrapper.forEach(previousStyles, function (value, prop) {
	        if (!lang_1.isPresent(finalStyles[prop])) {
	            finalStyles[prop] = nullValue;
	        }
	    });
	    return finalStyles;
	}
	exports.prepareFinalAnimationStyles = prepareFinalAnimationStyles;
	function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
	    var limit = keyframes.length - 1;
	    var firstKeyframe = keyframes[0];
	    // phase 1: copy all the styles from the first keyframe into the lookup map
	    var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
	    var extraFirstKeyframeStyles = {};
	    var hasExtraFirstStyles = false;
	    collection_1.StringMapWrapper.forEach(collectedStyles, function (value, prop) {
	        // if the style is already defined in the first keyframe then
	        // we do not replace it.
	        if (!flatenedFirstKeyframeStyles[prop]) {
	            flatenedFirstKeyframeStyles[prop] = value;
	            extraFirstKeyframeStyles[prop] = value;
	            hasExtraFirstStyles = true;
	        }
	    });
	    var keyframeCollectedStyles = collection_1.StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
	    // phase 2: normalize the final keyframe
	    var finalKeyframe = keyframes[limit];
	    collection_1.ListWrapper.insert(finalKeyframe.styles.styles, 0, finalStateStyles);
	    var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
	    var extraFinalKeyframeStyles = {};
	    var hasExtraFinalStyles = false;
	    collection_1.StringMapWrapper.forEach(keyframeCollectedStyles, function (value, prop) {
	        if (!lang_1.isPresent(flatenedFinalKeyframeStyles[prop])) {
	            extraFinalKeyframeStyles[prop] = metadata_1.AUTO_STYLE;
	            hasExtraFinalStyles = true;
	        }
	    });
	    if (hasExtraFinalStyles) {
	        finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
	    }
	    collection_1.StringMapWrapper.forEach(flatenedFinalKeyframeStyles, function (value, prop) {
	        if (!lang_1.isPresent(flatenedFirstKeyframeStyles[prop])) {
	            extraFirstKeyframeStyles[prop] = metadata_1.AUTO_STYLE;
	            hasExtraFirstStyles = true;
	        }
	    });
	    if (hasExtraFirstStyles) {
	        firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
	    }
	    return keyframes;
	}
	exports.balanceAnimationKeyframes = balanceAnimationKeyframes;
	function clearStyles(styles) {
	    var finalStyles = {};
	    collection_1.StringMapWrapper.keys(styles).forEach(function (key) { finalStyles[key] = null; });
	    return finalStyles;
	}
	exports.clearStyles = clearStyles;
	function collectAndResolveStyles(collection, styles) {
	    return styles.map(function (entry) {
	        var stylesObj = {};
	        collection_1.StringMapWrapper.forEach(entry, function (value, prop) {
	            if (value == animation_constants_1.FILL_STYLE_FLAG) {
	                value = collection[prop];
	                if (!lang_1.isPresent(value)) {
	                    value = metadata_1.AUTO_STYLE;
	                }
	            }
	            collection[prop] = value;
	            stylesObj[prop] = value;
	        });
	        return stylesObj;
	    });
	}
	exports.collectAndResolveStyles = collectAndResolveStyles;
	function renderStyles(element, renderer, styles) {
	    collection_1.StringMapWrapper.forEach(styles, function (value, prop) { renderer.setElementStyle(element, prop, value); });
	}
	exports.renderStyles = renderStyles;
	function flattenStyles(styles) {
	    var finalStyles = {};
	    styles.forEach(function (entry) {
	        collection_1.StringMapWrapper.forEach(entry, function (value, prop) { finalStyles[prop] = value; });
	    });
	    return finalStyles;
	}
	exports.flattenStyles = flattenStyles;
	//# sourceMappingURL=animation_style_util.js.map

/***/ },
/* 196 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var AnimationStyles = (function () {
	    function AnimationStyles(styles) {
	        this.styles = styles;
	    }
	    return AnimationStyles;
	}());
	exports.AnimationStyles = AnimationStyles;
	//# sourceMappingURL=animation_styles.js.map

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var application_ref_1 = __webpack_require__(61);
	var application_tokens_1 = __webpack_require__(39);
	var change_detection_1 = __webpack_require__(40);
	var component_factory_resolver_1 = __webpack_require__(70);
	var component_resolver_1 = __webpack_require__(30);
	var dynamic_component_loader_1 = __webpack_require__(114);
	var view_utils_1 = __webpack_require__(44);
	var __unused; // avoid unused import when Type union types are erased
	/**
	 * A default set of providers which should be included in any Angular
	 * application, regardless of the platform it runs onto.
	 * @stable
	 */
	exports.APPLICATION_COMMON_PROVIDERS = 
	/*@ts2dart_const*/ [
	    application_ref_1.APPLICATION_CORE_PROVIDERS,
	    /* @ts2dart_Provider */ { provide: component_resolver_1.ComponentResolver, useClass: component_resolver_1.ReflectorComponentResolver },
	    { provide: component_factory_resolver_1.ComponentFactoryResolver, useValue: component_factory_resolver_1.ComponentFactoryResolver.NULL },
	    application_tokens_1.APP_ID_RANDOM_PROVIDER,
	    view_utils_1.ViewUtils,
	    /* @ts2dart_Provider */ { provide: change_detection_1.IterableDiffers, useValue: change_detection_1.defaultIterableDiffers },
	    /* @ts2dart_Provider */ { provide: change_detection_1.KeyValueDiffers, useValue: change_detection_1.defaultKeyValueDiffers },
	    /* @ts2dart_Provider */ { provide: dynamic_component_loader_1.DynamicComponentLoader, useClass: dynamic_component_loader_1.DynamicComponentLoader_ },
	];
	//# sourceMappingURL=application_common_providers.js.map

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @module
	 * @description
	 * Change detection enables data binding in Angular.
	 */
	var change_detection_1 = __webpack_require__(40);
	exports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;
	exports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;
	exports.CollectionChangeRecord = change_detection_1.CollectionChangeRecord;
	exports.DefaultIterableDiffer = change_detection_1.DefaultIterableDiffer;
	exports.IterableDiffers = change_detection_1.IterableDiffers;
	exports.KeyValueChangeRecord = change_detection_1.KeyValueChangeRecord;
	exports.KeyValueDiffers = change_detection_1.KeyValueDiffers;
	exports.SimpleChange = change_detection_1.SimpleChange;
	exports.WrappedValue = change_detection_1.WrappedValue;
	//# sourceMappingURL=change_detection.js.map

/***/ },
/* 199 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @stable
	 */
	var ChangeDetectorRef = (function () {
	    function ChangeDetectorRef() {
	    }
	    return ChangeDetectorRef;
	}());
	exports.ChangeDetectorRef = ChangeDetectorRef;
	//# sourceMappingURL=change_detector_ref.js.map

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var debug_node_1 = __webpack_require__(107);
	var DebugDomRootRenderer = (function () {
	    function DebugDomRootRenderer(_delegate) {
	        this._delegate = _delegate;
	    }
	    DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
	        return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
	    };
	    return DebugDomRootRenderer;
	}());
	exports.DebugDomRootRenderer = DebugDomRootRenderer;
	var DebugDomRenderer = (function () {
	    function DebugDomRenderer(_delegate) {
	        this._delegate = _delegate;
	    }
	    DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	        var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
	        var debugEl = new debug_node_1.DebugElement(nativeEl, null, debugInfo);
	        debug_node_1.indexDebugNode(debugEl);
	        return nativeEl;
	    };
	    DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
	        var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
	        var debugEl = new debug_node_1.DebugElement(nativeEl, debug_node_1.getDebugNode(parentElement), debugInfo);
	        debugEl.name = name;
	        debug_node_1.indexDebugNode(debugEl);
	        return nativeEl;
	    };
	    DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
	    DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	        var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
	        var debugEl = new debug_node_1.DebugNode(comment, debug_node_1.getDebugNode(parentElement), debugInfo);
	        debug_node_1.indexDebugNode(debugEl);
	        return comment;
	    };
	    DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	        var text = this._delegate.createText(parentElement, value, debugInfo);
	        var debugEl = new debug_node_1.DebugNode(text, debug_node_1.getDebugNode(parentElement), debugInfo);
	        debug_node_1.indexDebugNode(debugEl);
	        return text;
	    };
	    DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	        var debugParent = debug_node_1.getDebugNode(parentElement);
	        if (lang_1.isPresent(debugParent) && debugParent instanceof debug_node_1.DebugElement) {
	            var debugElement_1 = debugParent;
	            nodes.forEach(function (node) { debugElement_1.addChild(debug_node_1.getDebugNode(node)); });
	        }
	        this._delegate.projectNodes(parentElement, nodes);
	    };
	    DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
	        var debugNode = debug_node_1.getDebugNode(node);
	        if (lang_1.isPresent(debugNode)) {
	            var debugParent = debugNode.parent;
	            if (viewRootNodes.length > 0 && lang_1.isPresent(debugParent)) {
	                var debugViewRootNodes = [];
	                viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes.push(debug_node_1.getDebugNode(rootNode)); });
	                debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
	            }
	        }
	        this._delegate.attachViewAfter(node, viewRootNodes);
	    };
	    DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
	        viewRootNodes.forEach(function (node) {
	            var debugNode = debug_node_1.getDebugNode(node);
	            if (lang_1.isPresent(debugNode) && lang_1.isPresent(debugNode.parent)) {
	                debugNode.parent.removeChild(debugNode);
	            }
	        });
	        this._delegate.detachView(viewRootNodes);
	    };
	    DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	        viewAllNodes.forEach(function (node) { debug_node_1.removeDebugNodeFromIndex(debug_node_1.getDebugNode(node)); });
	        this._delegate.destroyView(hostElement, viewAllNodes);
	    };
	    DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl)) {
	            debugEl.listeners.push(new debug_node_1.EventListener(name, callback));
	        }
	        return this._delegate.listen(renderElement, name, callback);
	    };
	    DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
	        return this._delegate.listenGlobal(target, name, callback);
	    };
	    DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.properties[propertyName] = propertyValue;
	        }
	        this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
	    };
	    DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.attributes[attributeName] = attributeValue;
	        }
	        this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
	    };
	    DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	        this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	    };
	    DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.classes[className] = isAdd;
	        }
	        this._delegate.setElementClass(renderElement, className, isAdd);
	    };
	    DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.styles[styleName] = styleValue;
	        }
	        this._delegate.setElementStyle(renderElement, styleName, styleValue);
	    };
	    DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	        this._delegate.invokeElementMethod(renderElement, methodName, args);
	    };
	    DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
	    DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	        return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);
	    };
	    return DebugDomRenderer;
	}());
	exports.DebugDomRenderer = DebugDomRenderer;
	//# sourceMappingURL=debug_renderer.js.map

/***/ },
/* 201 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Creates a token that can be used in a DI Provider.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
	 *
	 * ```typescript
	 * var t = new OpaqueToken("value");
	 *
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: t, useValue: "bindingValue"}
	 * ]);
	 *
	 * expect(injector.get(t)).toEqual("bindingValue");
	 * ```
	 *
	 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
	 * caused by multiple providers using the same string as two different tokens.
	 *
	 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
	 * error messages.
	 * @ts2dart_const
	 * @stable
	 */
	var OpaqueToken = (function () {
	    function OpaqueToken(_desc) {
	        this._desc = _desc;
	    }
	    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	    return OpaqueToken;
	}());
	exports.OpaqueToken = OpaqueToken;
	//# sourceMappingURL=opaque_token.js.map

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	exports.Math = lang_1.global.Math;
	exports.NaN = typeof exports.NaN;
	//# sourceMappingURL=math.js.map

/***/ },
/* 203 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var PromiseCompleter = (function () {
	    function PromiseCompleter() {
	        var _this = this;
	        this.promise = new Promise(function (res, rej) {
	            _this.resolve = res;
	            _this.reject = rej;
	        });
	    }
	    return PromiseCompleter;
	}());
	exports.PromiseCompleter = PromiseCompleter;
	var PromiseWrapper = (function () {
	    function PromiseWrapper() {
	    }
	    PromiseWrapper.resolve = function (obj) { return Promise.resolve(obj); };
	    PromiseWrapper.reject = function (obj, _) { return Promise.reject(obj); };
	    // Note: We can't rename this method into `catch`, as this is not a valid
	    // method name in Dart.
	    PromiseWrapper.catchError = function (promise, onError) {
	        return promise.catch(onError);
	    };
	    PromiseWrapper.all = function (promises) {
	        if (promises.length == 0)
	            return Promise.resolve([]);
	        return Promise.all(promises);
	    };
	    PromiseWrapper.then = function (promise, success, rejection) {
	        return promise.then(success, rejection);
	    };
	    PromiseWrapper.wrap = function (computation) {
	        return new Promise(function (res, rej) {
	            try {
	                res(computation());
	            }
	            catch (e) {
	                rej(e);
	            }
	        });
	    };
	    PromiseWrapper.scheduleMicrotask = function (computation) {
	        PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) { });
	    };
	    PromiseWrapper.completer = function () { return new PromiseCompleter(); };
	    return PromiseWrapper;
	}());
	exports.PromiseWrapper = PromiseWrapper;
	//# sourceMappingURL=promise.js.map

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for compiler
	var compiler_1 = __webpack_require__(205);
	exports.Compiler = compiler_1.Compiler;
	var component_factory_1 = __webpack_require__(112);
	exports.ComponentFactory = component_factory_1.ComponentFactory;
	exports.ComponentRef = component_factory_1.ComponentRef;
	var component_factory_resolver_1 = __webpack_require__(70);
	exports.ComponentFactoryResolver = component_factory_resolver_1.ComponentFactoryResolver;
	exports.NoComponentFactoryError = component_factory_resolver_1.NoComponentFactoryError;
	var component_resolver_1 = __webpack_require__(30);
	exports.ComponentResolver = component_resolver_1.ComponentResolver;
	var dynamic_component_loader_1 = __webpack_require__(114);
	exports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;
	var element_ref_1 = __webpack_require__(115);
	exports.ElementRef = element_ref_1.ElementRef;
	var exceptions_1 = __webpack_require__(72);
	exports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;
	var query_list_1 = __webpack_require__(207);
	exports.QueryList = query_list_1.QueryList;
	var systemjs_component_resolver_1 = __webpack_require__(208);
	exports.SystemJsCmpFactoryResolver = systemjs_component_resolver_1.SystemJsCmpFactoryResolver;
	exports.SystemJsComponentResolver = systemjs_component_resolver_1.SystemJsComponentResolver;
	var template_ref_1 = __webpack_require__(116);
	exports.TemplateRef = template_ref_1.TemplateRef;
	var view_container_ref_1 = __webpack_require__(117);
	exports.ViewContainerRef = view_container_ref_1.ViewContainerRef;
	var view_ref_1 = __webpack_require__(118);
	exports.EmbeddedViewRef = view_ref_1.EmbeddedViewRef;
	exports.ViewRef = view_ref_1.ViewRef;
	//# sourceMappingURL=linker.js.map

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(5);
	var lang_1 = __webpack_require__(2);
	/**
	 * Low-level service for running the angular compiler duirng runtime
	 * to create {@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 * @stable
	 */
	var Compiler = (function () {
	    function Compiler() {
	    }
	    /**
	     * Loads the template and styles of a component and returns the associated `ComponentFactory`.
	     */
	    Compiler.prototype.compileComponentAsync = function (component) {
	        throw new exceptions_1.BaseException("Runtime compiler is not loaded. Tried to compile " + lang_1.stringify(component));
	    };
	    /**
	     * Compiles the given component. All templates have to be either inline or compiled via
	     * `compileComponentAsync` before.
	     */
	    Compiler.prototype.compileComponentSync = function (component) {
	        throw new exceptions_1.BaseException("Runtime compiler is not loaded. Tried to compile " + lang_1.stringify(component));
	    };
	    /**
	     * Clears all caches
	     */
	    Compiler.prototype.clearCache = function () { };
	    /**
	     * Clears the cache for the given component.
	     */
	    Compiler.prototype.clearCacheFor = function (compType) { };
	    return Compiler;
	}());
	exports.Compiler = Compiler;
	//# sourceMappingURL=compiler.js.map

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var injector_1 = __webpack_require__(65);
	var _UNDEFINED = new Object();
	var ElementInjector = (function (_super) {
	    __extends(ElementInjector, _super);
	    function ElementInjector(_view, _nodeIndex) {
	        _super.call(this);
	        this._view = _view;
	        this._nodeIndex = _nodeIndex;
	    }
	    ElementInjector.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = injector_1.THROW_IF_NOT_FOUND; }
	        var result = _UNDEFINED;
	        if (result === _UNDEFINED) {
	            result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED);
	        }
	        if (result === _UNDEFINED) {
	            result = this._view.parentInjector.get(token, notFoundValue);
	        }
	        return result;
	    };
	    return ElementInjector;
	}(injector_1.Injector));
	exports.ElementInjector = ElementInjector;
	//# sourceMappingURL=element_injector.js.map

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var async_1 = __webpack_require__(18);
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	/**
	 * An unmodifiable list of items that Angular keeps up to date when the state
	 * of the application changes.
	 *
	 * The type of object that {@link QueryMetadata} and {@link ViewQueryMetadata} provide.
	 *
	 * Implements an iterable interface, therefore it can be used in both ES6
	 * javascript `for (var i of items)` loops as well as in Angular templates with
	 * `*ngFor="let i of myList"`.
	 *
	 * Changes can be observed by subscribing to the changes `Observable`.
	 *
	 * NOTE: In the future this class will implement an `Observable` interface.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	 * ```typescript
	 * @Component({...})
	 * class Container {
	 *   @ViewChildren(Item) items:QueryList<Item>;
	 * }
	 * ```
	 * @stable
	 */
	var QueryList = (function () {
	    function QueryList() {
	        this._dirty = true;
	        this._results = [];
	        this._emitter = new async_1.EventEmitter();
	    }
	    Object.defineProperty(QueryList.prototype, "changes", {
	        get: function () { return this._emitter; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "length", {
	        get: function () { return this._results.length; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "first", {
	        get: function () { return this._results[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "last", {
	        get: function () { return this._results[this.length - 1]; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * See
	     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	     */
	    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	    /**
	     * See
	     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	     */
	    QueryList.prototype.filter = function (fn) {
	        return this._results.filter(fn);
	    };
	    /**
	     * See
	     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	     */
	    QueryList.prototype.reduce = function (fn, init) {
	        return this._results.reduce(fn, init);
	    };
	    /**
	     * See
	     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	     */
	    QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
	    /**
	     * See
	     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	     */
	    QueryList.prototype.some = function (fn) {
	        return this._results.some(fn);
	    };
	    QueryList.prototype.toArray = function () { return this._results.slice(); };
	    QueryList.prototype[lang_1.getSymbolIterator()] = function () { return this._results[lang_1.getSymbolIterator()](); };
	    QueryList.prototype.toString = function () { return this._results.toString(); };
	    QueryList.prototype.reset = function (res) {
	        this._results = collection_1.ListWrapper.flatten(res);
	        this._dirty = false;
	    };
	    QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
	    /** internal */
	    QueryList.prototype.setDirty = function () { this._dirty = true; };
	    Object.defineProperty(QueryList.prototype, "dirty", {
	        /** internal */
	        get: function () { return this._dirty; },
	        enumerable: true,
	        configurable: true
	    });
	    return QueryList;
	}());
	exports.QueryList = QueryList;
	//# sourceMappingURL=query_list.js.map

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var _SEPARATOR = '#';
	/**
	 * Component resolver that can load components lazily
	 * @experimental
	 */
	var SystemJsComponentResolver = (function () {
	    function SystemJsComponentResolver(_resolver) {
	        this._resolver = _resolver;
	    }
	    SystemJsComponentResolver.prototype.resolveComponent = function (componentType) {
	        var _this = this;
	        if (lang_1.isString(componentType)) {
	            var _a = componentType.split(_SEPARATOR), module = _a[0], component_1 = _a[1];
	            if (component_1 === void (0)) {
	                // Use the default export when no component is specified
	                component_1 = 'default';
	            }
	            return lang_1.global
	                .System.import(module)
	                .then(function (module) { return _this._resolver.resolveComponent(module[component_1]); });
	        }
	        return this._resolver.resolveComponent(componentType);
	    };
	    SystemJsComponentResolver.prototype.clearCache = function () { };
	    return SystemJsComponentResolver;
	}());
	exports.SystemJsComponentResolver = SystemJsComponentResolver;
	var FACTORY_MODULE_SUFFIX = '.ngfactory';
	var FACTORY_CLASS_SUFFIX = 'NgFactory';
	/**
	 * Component resolver that can load component factories lazily
	 * @experimental
	 */
	var SystemJsCmpFactoryResolver = (function () {
	    function SystemJsCmpFactoryResolver() {
	    }
	    SystemJsCmpFactoryResolver.prototype.resolveComponent = function (componentType) {
	        if (lang_1.isString(componentType)) {
	            var _a = componentType.split(_SEPARATOR), module = _a[0], factory_1 = _a[1];
	            return lang_1.global
	                .System.import(module + FACTORY_MODULE_SUFFIX)
	                .then(function (module) { return module[factory_1 + FACTORY_CLASS_SUFFIX]; });
	        }
	        return Promise.resolve(null);
	    };
	    SystemJsCmpFactoryResolver.prototype.clearCache = function () { };
	    return SystemJsCmpFactoryResolver;
	}());
	exports.SystemJsCmpFactoryResolver = SystemJsCmpFactoryResolver;
	//# sourceMappingURL=systemjs_component_resolver.js.map

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(18);
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var element_1 = __webpack_require__(71);
	var view_ref_1 = __webpack_require__(118);
	var view_type_1 = __webpack_require__(43);
	var view_utils_1 = __webpack_require__(44);
	var change_detection_1 = __webpack_require__(40);
	var profile_1 = __webpack_require__(45);
	var exceptions_1 = __webpack_require__(72);
	var debug_context_1 = __webpack_require__(113);
	var element_injector_1 = __webpack_require__(206);
	var animation_group_player_1 = __webpack_require__(102);
	var active_animation_players_map_1 = __webpack_require__(191);
	var _scope_check = profile_1.wtfCreateScope("AppView#check(ascii id)");
	/**
	 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	 *
	 */
	var AppView = (function () {
	    function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
	        this.clazz = clazz;
	        this.componentType = componentType;
	        this.type = type;
	        this.viewUtils = viewUtils;
	        this.parentInjector = parentInjector;
	        this.declarationAppElement = declarationAppElement;
	        this.cdMode = cdMode;
	        this.contentChildren = [];
	        this.viewChildren = [];
	        this.viewContainerElement = null;
	        this.numberOfChecks = 0;
	        this.activeAnimationPlayers = new active_animation_players_map_1.ActiveAnimationPlayersMap();
	        this.ref = new view_ref_1.ViewRef_(this);
	        if (type === view_type_1.ViewType.COMPONENT || type === view_type_1.ViewType.HOST) {
	            this.renderer = viewUtils.renderComponent(componentType);
	        }
	        else {
	            this.renderer = declarationAppElement.parentView.renderer;
	        }
	    }
	    Object.defineProperty(AppView.prototype, "destroyed", {
	        get: function () { return this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    AppView.prototype.cancelActiveAnimation = function (element, animationName, removeAllAnimations) {
	        if (removeAllAnimations === void 0) { removeAllAnimations = false; }
	        if (removeAllAnimations) {
	            this.activeAnimationPlayers.findAllPlayersByElement(element).forEach(function (player) { return player.destroy(); });
	        }
	        else {
	            var player = this.activeAnimationPlayers.find(element, animationName);
	            if (lang_1.isPresent(player)) {
	                player.destroy();
	            }
	        }
	    };
	    AppView.prototype.registerAndStartAnimation = function (element, animationName, player) {
	        var _this = this;
	        this.activeAnimationPlayers.set(element, animationName, player);
	        player.onDone(function () { _this.activeAnimationPlayers.remove(element, animationName); });
	        player.play();
	    };
	    AppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
	        this.context = context;
	        var projectableNodes;
	        switch (this.type) {
	            case view_type_1.ViewType.COMPONENT:
	                projectableNodes = view_utils_1.ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
	                break;
	            case view_type_1.ViewType.EMBEDDED:
	                projectableNodes = this.declarationAppElement.parentView.projectableNodes;
	                break;
	            case view_type_1.ViewType.HOST:
	                // Note: Don't ensure the slot count for the projectableNodes as we store
	                // them only for the contained component view (which will later check the slot count...)
	                projectableNodes = givenProjectableNodes;
	                break;
	        }
	        this._hasExternalHostElement = lang_1.isPresent(rootSelectorOrNode);
	        this.projectableNodes = projectableNodes;
	        return this.createInternal(rootSelectorOrNode);
	    };
	    /**
	     * Overwritten by implementations.
	     * Returns the AppElement for the host element for ViewType.HOST.
	     */
	    AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
	    AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, subscriptions) {
	        this.rootNodesOrAppElements = rootNodesOrAppElements;
	        this.allNodes = allNodes;
	        this.disposables = disposables;
	        this.subscriptions = subscriptions;
	        if (this.type === view_type_1.ViewType.COMPONENT) {
	            // Note: the render nodes have been attached to their host element
	            // in the ViewFactory already.
	            this.declarationAppElement.parentView.viewChildren.push(this);
	            this.dirtyParentQueriesInternal();
	        }
	    };
	    AppView.prototype.selectOrCreateHostElement = function (elementName, rootSelectorOrNode, debugInfo) {
	        var hostElement;
	        if (lang_1.isPresent(rootSelectorOrNode)) {
	            hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
	        }
	        else {
	            hostElement = this.renderer.createElement(null, elementName, debugInfo);
	        }
	        return hostElement;
	    };
	    AppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	        return this.injectorGetInternal(token, nodeIndex, notFoundResult);
	    };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
	        return notFoundResult;
	    };
	    AppView.prototype.injector = function (nodeIndex) {
	        if (lang_1.isPresent(nodeIndex)) {
	            return new element_injector_1.ElementInjector(this, nodeIndex);
	        }
	        else {
	            return this.parentInjector;
	        }
	    };
	    AppView.prototype.destroy = function () {
	        if (this._hasExternalHostElement) {
	            this.renderer.detachView(this.flatRootNodes);
	        }
	        else if (lang_1.isPresent(this.viewContainerElement)) {
	            this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
	        }
	        this._destroyRecurse();
	    };
	    AppView.prototype._destroyRecurse = function () {
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed) {
	            return;
	        }
	        var children = this.contentChildren;
	        for (var i = 0; i < children.length; i++) {
	            children[i]._destroyRecurse();
	        }
	        children = this.viewChildren;
	        for (var i = 0; i < children.length; i++) {
	            children[i]._destroyRecurse();
	        }
	        this.destroyLocal();
	        this.cdMode = change_detection_1.ChangeDetectorStatus.Destroyed;
	    };
	    AppView.prototype.destroyLocal = function () {
	        var _this = this;
	        var hostElement = this.type === view_type_1.ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
	        for (var i = 0; i < this.disposables.length; i++) {
	            this.disposables[i]();
	        }
	        for (var i = 0; i < this.subscriptions.length; i++) {
	            async_1.ObservableWrapper.dispose(this.subscriptions[i]);
	        }
	        this.destroyInternal();
	        this.dirtyParentQueriesInternal();
	        if (this.activeAnimationPlayers.length == 0) {
	            this.renderer.destroyView(hostElement, this.allNodes);
	        }
	        else {
	            var player = new animation_group_player_1.AnimationGroupPlayer(this.activeAnimationPlayers.getAllPlayers());
	            player.onDone(function () { _this.renderer.destroyView(hostElement, _this.allNodes); });
	        }
	    };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.destroyInternal = function () { };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.detachInternal = function () { };
	    AppView.prototype.detach = function () {
	        var _this = this;
	        this.detachInternal();
	        if (this.activeAnimationPlayers.length == 0) {
	            this.renderer.detachView(this.flatRootNodes);
	        }
	        else {
	            var player = new animation_group_player_1.AnimationGroupPlayer(this.activeAnimationPlayers.getAllPlayers());
	            player.onDone(function () { _this.renderer.detachView(_this.flatRootNodes); });
	        }
	    };
	    Object.defineProperty(AppView.prototype, "changeDetectorRef", {
	        get: function () { return this.ref; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppView.prototype, "parent", {
	        get: function () {
	            return lang_1.isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppView.prototype, "flatRootNodes", {
	        get: function () { return view_utils_1.flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppView.prototype, "lastRootNode", {
	        get: function () {
	            var lastNode = this.rootNodesOrAppElements.length > 0 ?
	                this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] :
	                null;
	            return _findLastRenderNode(lastNode);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.dirtyParentQueriesInternal = function () { };
	    AppView.prototype.detectChanges = function (throwOnChange) {
	        var s = _scope_check(this.clazz);
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.Checked ||
	            this.cdMode === change_detection_1.ChangeDetectorStatus.Errored)
	            return;
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed) {
	            this.throwDestroyedError('detectChanges');
	        }
	        this.detectChangesInternal(throwOnChange);
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.CheckOnce)
	            this.cdMode = change_detection_1.ChangeDetectorStatus.Checked;
	        this.numberOfChecks++;
	        profile_1.wtfLeave(s);
	    };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.detectChangesInternal = function (throwOnChange) {
	        this.detectContentChildrenChanges(throwOnChange);
	        this.detectViewChildrenChanges(throwOnChange);
	    };
	    AppView.prototype.detectContentChildrenChanges = function (throwOnChange) {
	        for (var i = 0; i < this.contentChildren.length; ++i) {
	            var child = this.contentChildren[i];
	            if (child.cdMode === change_detection_1.ChangeDetectorStatus.Detached)
	                continue;
	            child.detectChanges(throwOnChange);
	        }
	    };
	    AppView.prototype.detectViewChildrenChanges = function (throwOnChange) {
	        for (var i = 0; i < this.viewChildren.length; ++i) {
	            var child = this.viewChildren[i];
	            if (child.cdMode === change_detection_1.ChangeDetectorStatus.Detached)
	                continue;
	            child.detectChanges(throwOnChange);
	        }
	    };
	    AppView.prototype.addToContentChildren = function (renderAppElement) {
	        renderAppElement.parentView.contentChildren.push(this);
	        this.viewContainerElement = renderAppElement;
	        this.dirtyParentQueriesInternal();
	    };
	    AppView.prototype.removeFromContentChildren = function (renderAppElement) {
	        collection_1.ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
	        this.dirtyParentQueriesInternal();
	        this.viewContainerElement = null;
	    };
	    AppView.prototype.markAsCheckOnce = function () { this.cdMode = change_detection_1.ChangeDetectorStatus.CheckOnce; };
	    AppView.prototype.markPathToRootAsCheckOnce = function () {
	        var c = this;
	        while (lang_1.isPresent(c) && c.cdMode !== change_detection_1.ChangeDetectorStatus.Detached) {
	            if (c.cdMode === change_detection_1.ChangeDetectorStatus.Checked) {
	                c.cdMode = change_detection_1.ChangeDetectorStatus.CheckOnce;
	            }
	            var parentEl = c.type === view_type_1.ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
	            c = lang_1.isPresent(parentEl) ? parentEl.parentView : null;
	        }
	    };
	    AppView.prototype.eventHandler = function (cb) { return cb; };
	    AppView.prototype.throwDestroyedError = function (details) { throw new exceptions_1.ViewDestroyedException(details); };
	    return AppView;
	}());
	exports.AppView = AppView;
	var DebugAppView = (function (_super) {
	    __extends(DebugAppView, _super);
	    function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
	        _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
	        this.staticNodeDebugInfos = staticNodeDebugInfos;
	        this._currentDebugContext = null;
	    }
	    DebugAppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
	        this._resetDebug();
	        try {
	            return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	        this._resetDebug();
	        try {
	            return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.detach = function () {
	        this._resetDebug();
	        try {
	            _super.prototype.detach.call(this);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.destroyLocal = function () {
	        this._resetDebug();
	        try {
	            _super.prototype.destroyLocal.call(this);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.detectChanges = function (throwOnChange) {
	        this._resetDebug();
	        try {
	            _super.prototype.detectChanges.call(this, throwOnChange);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
	    DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
	        return this._currentDebugContext = new debug_context_1.DebugContext(this, nodeIndex, rowNum, colNum);
	    };
	    DebugAppView.prototype._rethrowWithContext = function (e, stack) {
	        if (!(e instanceof exceptions_1.ViewWrappedException)) {
	            if (!(e instanceof exceptions_1.ExpressionChangedAfterItHasBeenCheckedException)) {
	                this.cdMode = change_detection_1.ChangeDetectorStatus.Errored;
	            }
	            if (lang_1.isPresent(this._currentDebugContext)) {
	                throw new exceptions_1.ViewWrappedException(e, stack, this._currentDebugContext);
	            }
	        }
	    };
	    DebugAppView.prototype.eventHandler = function (cb) {
	        var _this = this;
	        var superHandler = _super.prototype.eventHandler.call(this, cb);
	        return function (event /** TODO #9100 */) {
	            _this._resetDebug();
	            try {
	                return superHandler(event);
	            }
	            catch (e) {
	                _this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        };
	    };
	    return DebugAppView;
	}(AppView));
	exports.DebugAppView = DebugAppView;
	function _findLastRenderNode(node) {
	    var lastNode;
	    if (node instanceof element_1.AppElement) {
	        var appEl = node;
	        lastNode = appEl.nativeElement;
	        if (lang_1.isPresent(appEl.nestedViews)) {
	            // Note: Views might have no root nodes at all!
	            for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
	                var nestedView = appEl.nestedViews[i];
	                if (nestedView.rootNodesOrAppElements.length > 0) {
	                    lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
	                }
	            }
	        }
	    }
	    else {
	        lastNode = node;
	    }
	    return lastNode;
	}
	//# sourceMappingURL=view.js.map

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(119);
	var directives_1 = __webpack_require__(120);
	var view_1 = __webpack_require__(73);
	var di_2 = __webpack_require__(119);
	exports.AttributeMetadata = di_2.AttributeMetadata;
	exports.ContentChildMetadata = di_2.ContentChildMetadata;
	exports.ContentChildrenMetadata = di_2.ContentChildrenMetadata;
	exports.QueryMetadata = di_2.QueryMetadata;
	exports.ViewChildMetadata = di_2.ViewChildMetadata;
	exports.ViewChildrenMetadata = di_2.ViewChildrenMetadata;
	exports.ViewQueryMetadata = di_2.ViewQueryMetadata;
	var directives_2 = __webpack_require__(120);
	exports.ComponentMetadata = directives_2.ComponentMetadata;
	exports.DirectiveMetadata = directives_2.DirectiveMetadata;
	exports.HostBindingMetadata = directives_2.HostBindingMetadata;
	exports.HostListenerMetadata = directives_2.HostListenerMetadata;
	exports.InputMetadata = directives_2.InputMetadata;
	exports.OutputMetadata = directives_2.OutputMetadata;
	exports.PipeMetadata = directives_2.PipeMetadata;
	var lifecycle_hooks_1 = __webpack_require__(121);
	exports.AfterContentChecked = lifecycle_hooks_1.AfterContentChecked;
	exports.AfterContentInit = lifecycle_hooks_1.AfterContentInit;
	exports.AfterViewChecked = lifecycle_hooks_1.AfterViewChecked;
	exports.AfterViewInit = lifecycle_hooks_1.AfterViewInit;
	exports.DoCheck = lifecycle_hooks_1.DoCheck;
	exports.OnChanges = lifecycle_hooks_1.OnChanges;
	exports.OnDestroy = lifecycle_hooks_1.OnDestroy;
	exports.OnInit = lifecycle_hooks_1.OnInit;
	var view_2 = __webpack_require__(73);
	exports.ViewEncapsulation = view_2.ViewEncapsulation;
	exports.ViewMetadata = view_2.ViewMetadata;
	var decorators_1 = __webpack_require__(47);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ComponentMetadata.
	/**
	 * Declare reusable UI building blocks for an application.
	 *
	 * Each Angular component requires a single `@Component` annotation. The `@Component`
	 * annotation specifies when a component is instantiated, and which properties and hostListeners it
	 * binds to.
	 *
	 * When a component is instantiated, Angular
	 * - creates a shadow DOM for the component.
	 * - loads the selected template into the shadow DOM.
	 * - creates all the injectable objects configured with `providers` and `viewProviders`.
	 *
	 * All template expressions and statements are then evaluated against the component instance.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the component class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the component.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='component'}
	 * @stable
	 * @Annotation
	 */
	exports.Component = decorators_1.makeDecorator(directives_1.ComponentMetadata, function (fn) { return fn.View = View; });
	// TODO(alexeagle): remove the duplication of this doc. It is copied from DirectiveMetadata.
	/**
	 * Directives allow you to attach behavior to elements in the DOM.
	 *
	 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
	 *
	 * A directive consists of a single directive annotation and a controller class. When the
	 * directive's `selector` matches
	 * elements in the DOM, the following steps occur:
	 *
	 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
	 * arguments.
	 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
	 * depth-first order,
	 *    as declared in the HTML.
	 *
	 * ## Understanding How Injection Works
	 *
	 * There are three stages of injection resolution.
	 * - *Pre-existing Injectors*:
	 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
	 * the dependency was
	 *     specified as `@Optional`, returns `null`.
	 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
	 * location, and others.
	 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
	 * the same parent-child hierarchy
	 *     as the component instances in the DOM.
	 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
	 * element has an `ElementInjector`
	 *     which follow the same parent-child hierarchy as the DOM elements themselves.
	 *
	 * When a template is instantiated, it also must instantiate the corresponding directives in a
	 * depth-first order. The
	 * current `ElementInjector` resolves the constructor dependencies for each directive.
	 *
	 * Angular then resolves dependencies as follows, according to the order in which they appear in the
	 * {@link ViewMetadata}:
	 *
	 * 1. Dependencies on the current element
	 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
	 * 3. Dependencies on component injectors and their parents until it encounters the root component
	 * 4. Dependencies on pre-existing injectors
	 *
	 *
	 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
	 * delegate to the parent
	 * injector.
	 *
	 * To inject other directives, declare the constructor parameter as:
	 * - `directive:DirectiveType`: a directive on the current element only
	 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
	 * element and the
	 *    Shadow DOM root.
	 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
	 * directives.
	 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
	 * child directives.
	 *
	 * To inject element-specific special objects, declare the constructor parameter as:
	 * - `element: ElementRef` to obtain a reference to logical element in the view.
	 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
	 * {@link DirectiveMetadata} directives only
	 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
	 *
	 * ### Example
	 *
	 * The following example demonstrates how dependency injection resolves constructor arguments in
	 * practice.
	 *
	 *
	 * Assume this HTML template:
	 *
	 * ```
	 * <div dependency="1">
	 *   <div dependency="2">
	 *     <div dependency="3" my-directive>
	 *       <div dependency="4">
	 *         <div dependency="5"></div>
	 *       </div>
	 *       <div dependency="6"></div>
	 *     </div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * With the following `dependency` decorator and `SomeService` injectable class.
	 *
	 * ```
	 * @Injectable()
	 * class SomeService {
	 * }
	 *
	 * @Directive({
	 *   selector: '[dependency]',
	 *   inputs: [
	 *     'id: dependency'
	 *   ]
	 * })
	 * class Dependency {
	 *   id:string;
	 * }
	 * ```
	 *
	 * Let's step through the different ways in which `MyDirective` could be declared...
	 *
	 *
	 * ### No injection
	 *
	 * Here the constructor is declared with no arguments, therefore nothing is injected into
	 * `MyDirective`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor() {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with no dependencies.
	 *
	 *
	 * ### Component-level injection
	 *
	 * Directives can inject any injectable instance from the closest component injector or any of its
	 * parents.
	 *
	 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
	 * from the parent
	 * component's injector.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(someService: SomeService) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a dependency on `SomeService`.
	 *
	 *
	 * ### Injecting a directive from the current element
	 *
	 * Directives can inject other directives declared on the current element.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(dependency: Dependency) {
	 *     expect(dependency.id).toEqual(3);
	 *   }
	 * }
	 * ```
	 * This directive would be instantiated with `Dependency` declared at the same element, in this case
	 * `dependency="3"`.
	 *
	 * ### Injecting a directive from any ancestor elements
	 *
	 * Directives can inject other directives declared on any ancestor element (in the current Shadow
	 * DOM), i.e. on the current element, the
	 * parent element, or its parents.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Host() dependency: Dependency) {
	 *     expect(dependency.id).toEqual(2);
	 *   }
	 * }
	 * ```
	 *
	 * `@Host` checks the current element, the parent, as well as its parents recursively. If
	 * `dependency="2"` didn't
	 * exist on the direct parent, this injection would
	 * have returned
	 * `dependency="1"`.
	 *
	 *
	 * ### Injecting a live collection of direct child directives
	 *
	 *
	 * A directive can also query for other child directives. Since parent directives are instantiated
	 * before child directives, a directive can't simply inject the list of child directives. Instead,
	 * the directive injects a {@link QueryList}, which updates its contents as children are added,
	 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
	 * `ngIf`, or an `ngSwitch`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
	 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
	 *
	 * ### Injecting a live collection of descendant directives
	 *
	 * By passing the descendant flag to `@Query` above, we can include the children of the child
	 * elements.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
	 *
	 * ### Optional injection
	 *
	 * The normal behavior of directives is to return an error when a specified dependency cannot be
	 * resolved. If you
	 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
	 * with `@Optional()`.
	 * This explicitly permits the author of a template to treat some of the surrounding directives as
	 * optional.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Optional() dependency:Dependency) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a `Dependency` directive found on the current element.
	 * If none can be
	 * found, the injector supplies `null` instead of throwing an error.
	 *
	 * ### Example
	 *
	 * Here we use a decorator directive to simply define basic tool-tip behavior.
	 *
	 * ```
	 * @Directive({
	 *   selector: '[tooltip]',
	 *   inputs: [
	 *     'text: tooltip'
	 *   ],
	 *   host: {
	 *     '(mouseenter)': 'onMouseEnter()',
	 *     '(mouseleave)': 'onMouseLeave()'
	 *   }
	 * })
	 * class Tooltip{
	 *   text:string;
	 *   overlay:Overlay; // NOT YET IMPLEMENTED
	 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
	 *
	 *   constructor(overlayManager:OverlayManager) {
	 *     this.overlayManager = overlayManager;
	 *   }
	 *
	 *   onMouseEnter() {
	 *     // exact signature to be determined
	 *     this.overlay = this.overlayManager.open(text, ...);
	 *   }
	 *
	 *   onMouseLeave() {
	 *     this.overlay.close();
	 *     this.overlay = null;
	 *   }
	 * }
	 * ```
	 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
	 * `tooltip` selector,
	 * like so:
	 *
	 * ```
	 * <div tooltip="some text here"></div>
	 * ```
	 *
	 * Directives can also control the instantiation, destruction, and positioning of inline template
	 * elements:
	 *
	 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
	 * runtime.
	 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
	 * location in the current view
	 * where these actions are performed.
	 *
	 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
	 * `<template>` element. Thus a
	 * directive in a child view cannot inject the directive that created it.
	 *
	 * Since directives that create views via ViewContainers are common in Angular, and using the full
	 * `<template>` element syntax is wordy, Angular
	 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
	 * equivalent.
	 *
	 * Thus,
	 *
	 * ```
	 * <ul>
	 *   <li *foo="bar" title="text"></li>
	 * </ul>
	 * ```
	 *
	 * Expands in use to:
	 *
	 * ```
	 * <ul>
	 *   <template [foo]="bar">
	 *     <li title="text"></li>
	 *   </template>
	 * </ul>
	 * ```
	 *
	 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
	 * the directive
	 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the directive class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the directive.
	 *
	 * ### Example
	 *
	 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
	 *
	 * Here is a simple directive that triggers on an `unless` selector:
	 *
	 * ```
	 * @Directive({
	 *   selector: '[unless]',
	 *   inputs: ['unless']
	 * })
	 * export class Unless {
	 *   viewContainer: ViewContainerRef;
	 *   templateRef: TemplateRef;
	 *   prevCondition: boolean;
	 *
	 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
	 *     this.viewContainer = viewContainer;
	 *     this.templateRef = templateRef;
	 *     this.prevCondition = null;
	 *   }
	 *
	 *   set unless(newCondition) {
	 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
	 *       this.prevCondition = true;
	 *       this.viewContainer.clear();
	 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
	 *       this.prevCondition = false;
	 *       this.viewContainer.create(this.templateRef);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * We can then use this `unless` selector in a template:
	 * ```
	 * <ul>
	 *   <li *unless="expr"></li>
	 * </ul>
	 * ```
	 *
	 * Once the directive instantiates the child view, the shorthand notation for the template expands
	 * and the result is:
	 *
	 * ```
	 * <ul>
	 *   <template [unless]="exp">
	 *     <li></li>
	 *   </template>
	 *   <li></li>
	 * </ul>
	 * ```
	 *
	 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
	 * the instantiated
	 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
	 * @stable
	 * @Annotation
	 */
	exports.Directive = decorators_1.makeDecorator(directives_1.DirectiveMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewMetadata.
	/**
	 * Metadata properties available for configuring Views.
	 *
	 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
	 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
	 * within the template.
	 *
	 * When a component is instantiated, the template is loaded into the component's shadow root, and
	 * the expressions and statements in the template are evaluated against the component.
	 *
	 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
	 *
	 * ### Example
	 *
	 * ```
	 * @Component({
	 *   selector: 'greet',
	 *   template: 'Hello {{name}}!',
	 *   directives: [GreetUser, Bold]
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 * @deprecated
	 * @Annotation
	 */
	var View = decorators_1.makeDecorator(view_1.ViewMetadata, function (fn) { return fn.View = View; });
	/**
	 * Specifies that a constant attribute value should be injected.
	 *
	 * The directive can inject constant string literals of host element attributes.
	 *
	 * ### Example
	 *
	 * Suppose we have an `<input>` element and want to know its `type`.
	 *
	 * ```html
	 * <input type="text">
	 * ```
	 *
	 * A decorator can inject string literal `text` like so:
	 *
	 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
	 * @stable
	 * @Annotation
	 */
	exports.Attribute = decorators_1.makeParamDecorator(di_1.AttributeMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from QueryMetadata.
	/**
	 * Declares an injectable parameter to be a live list of directives or variable
	 * bindings from the content children of a directive.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 *
	 * Assume that `<tabs>` component would like to get a list its children `<pane>`
	 * components as shown in this example:
	 *
	 * ```html
	 * <tabs>
	 *   <pane title="Overview">...</pane>
	 *   <pane *ngFor="let o of objects" [title]="o.title">{{o.text}}</pane>
	 * </tabs>
	 * ```
	 *
	 * The preferred solution is to query for `Pane` directives using this decorator.
	 *
	 * ```javascript
	 * @Component({
	 *   selector: 'pane',
	 *   inputs: ['title']
	 * })
	 * class Pane {
	 *   title:string;
	 * }
	 *
	 * @Component({
	 *  selector: 'tabs',
	 *  template: `
	 *    <ul>
	 *      <li *ngFor="let pane of panes">{{pane.title}}</li>
	 *    </ul>
	 *    <ng-content></ng-content>
	 *  `
	 * })
	 * class Tabs {
	 *   panes: QueryList<Pane>;
	 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
	 *     this.panes = panes;
	 *   }
	 * }
	 * ```
	 *
	 * A query can look for variable bindings by passing in a string with desired binding symbol.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
	 * ```html
	 * <seeker>
	 *   <div #findme>...</div>
	 * </seeker>
	 *
	 * @Component({ selector: 'seeker' })
	 * class seeker {
	 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * In this case the object that is injected depend on the type of the variable
	 * binding. It can be an ElementRef, a directive or a component.
	 *
	 * Passing in a comma separated list of variable bindings will query for all of them.
	 *
	 * ```html
	 * <seeker>
	 *   <div #findMe>...</div>
	 *   <div #findMeToo>...</div>
	 * </seeker>
	 *
	 *  @Component({
	 *   selector: 'seeker'
	 * })
	 * class Seeker {
	 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * Configure whether query looks for direct children or all descendants
	 * of the querying element, by using the `descendants` parameter.
	 * It is set to `false` by default.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
	 * ```html
	 * <container #first>
	 *   <item>a</item>
	 *   <item>b</item>
	 *   <container #second>
	 *     <item>c</item>
	 *   </container>
	 * </container>
	 * ```
	 *
	 * When querying for items, the first container will see only `a` and `b` by default,
	 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
	 *
	 * The queried directives are kept in a depth-first pre-order with respect to their
	 * positions in the DOM.
	 *
	 * Query does not look deep into any subcomponent views.
	 *
	 * Query is updated as part of the change-detection cycle. Since change detection
	 * happens after construction of a directive, QueryList will always be empty when observed in the
	 * constructor.
	 *
	 * The injected object is an unmodifiable live list.
	 * See {@link QueryList} for more details.
	 * @deprecated
	 * @Annotation
	 */
	exports.Query = decorators_1.makeParamDecorator(di_1.QueryMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildrenMetadata.
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChildren is set
	 *   }
	 * }
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.ContentChildren = decorators_1.makePropDecorator(di_1.ContentChildrenMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildMetadata.
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChild(ChildDirective) contentChild;
	 *   @ContentChild('container_ref') containerChild
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is set
	 *     // containerChild is set
	 *   }
	 * }
	 * ```
	 *
	 * ```html
	 * <container #container_ref>
	 *   <item>a</item>
	 *   <item>b</item>
	 * </container>
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.ContentChild = decorators_1.makePropDecorator(di_1.ContentChildMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildrenMetadata.
	/**
	 * Declares a list of child element references.
	 *
	 * Angular automatically updates the list when the DOM is updated.
	 *
	 * `ViewChildren` takes a argument to select elements.
	 *
	 * - If the argument is a type, directives or components with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
	 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
	 * bound.
	 *
	 * View children are set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp #child1></child-cmp>
	 *     <child-cmp #child2></child-cmp>
	 *     <child-cmp #child3></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * See also: [ViewChildrenMetadata]
	 * @stable
	 * @Annotation
	 */
	exports.ViewChildren = decorators_1.makePropDecorator(di_1.ViewChildrenMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildMetadata.
	/**
	 * Declares a reference to a child element.
	 *
	 * `ViewChildren` takes a argument to select elements.
	 *
	 * - If the argument is a type, a directive or a component with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a selector. An element containing the
	 * matching template variable (e.g. `#child`) will be bound.
	 *
	 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
	 * multiple matches.
	 *
	 * View child is set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild(ChildCmp) child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp #child></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild('child') child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 * See also: [ViewChildMetadata]
	 * @stable
	 * @Annotation
	 */
	exports.ViewChild = decorators_1.makePropDecorator(di_1.ViewChildMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewQueryMetadata.
	/**
	 * Similar to {@link QueryMetadata}, but querying the component view, instead of
	 * the content children.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
	 *
	 * ```javascript
	 * @Component({
	 *   ...,
	 *   template: `
	 *     <item> a </item>
	 *     <item> b </item>
	 *     <item> c </item>
	 *   `
	 * })
	 * class MyComponent {
	 *   shown: boolean;
	 *
	 *   constructor(private @Query(Item) items:QueryList<Item>) {
	 *     items.changes.subscribe(() => console.log(items.length));
	 *   }
	 * }
	 * ```
	 *
	 * Supports the same querying parameters as {@link QueryMetadata}, except
	 * `descendants`. This always queries the whole view.
	 *
	 * As `shown` is flipped between true and false, items will contain zero of one
	 * items.
	 *
	 * Specifies that a {@link QueryList} should be injected.
	 *
	 * The injected object is an iterable and observable live list.
	 * See {@link QueryList} for more details.
	 * @deprecated
	 * @Annotation
	 */
	exports.ViewQuery = decorators_1.makeParamDecorator(di_1.ViewQueryMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from PipeMetadata.
	/**
	 * Declare reusable pipe function.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='pipe'}
	 * @stable
	 * @Annotation
	 */
	exports.Pipe = decorators_1.makeDecorator(directives_1.PipeMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from InputMetadata.
	/**
	 * Declares a data-bound input property.
	 *
	 * Angular automatically updates data-bound properties during change detection.
	 *
	 * `InputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * The following example creates a component with two input properties.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'bank-account',
	 *   template: `
	 *     Bank Name: {{bankName}}
	 *     Account Id: {{id}}
	 *   `
	 * })
	 * class BankAccount {
	 *   @Input() bankName: string;
	 *   @Input('account-id') id: string;
	 *
	 *   // this property is not bound, and won't be automatically updated by Angular
	 *   normalizedBankName: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	 *   `,
	 *   directives: [BankAccount]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.Input = decorators_1.makePropDecorator(directives_1.InputMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from OutputMetadata.
	/**
	 * Declares an event-bound output property.
	 *
	 * When an output property emits an event, an event handler attached to that event
	 * the template is invoked.
	 *
	 * `OutputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Directive({
	 *   selector: 'interval-dir',
	 * })
	 * class IntervalDir {
	 *   @Output() everySecond = new EventEmitter();
	 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
	 *
	 *   constructor() {
	 *     setInterval(() => this.everySecond.emit("event"), 1000);
	 *     setInterval(() => this.five5Secs.emit("event"), 5000);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	 *     </interval-dir>
	 *   `,
	 *   directives: [IntervalDir]
	 * })
	 * class App {
	 *   everySecond() { console.log('second'); }
	 *   everyFiveSeconds() { console.log('five seconds'); }
	 * }
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.Output = decorators_1.makePropDecorator(directives_1.OutputMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from HostBindingMetadata.
	/**
	 * Declares a host property binding.
	 *
	 * Angular automatically checks host property bindings during change detection.
	 * If a binding changes, it will update the host element of the directive.
	 *
	 * `HostBindingMetadata` takes an optional parameter that specifies the property
	 * name of the host element that will be updated. When not provided,
	 * the class property name is used.
	 *
	 * ### Example
	 *
	 * The following example creates a directive that sets the `valid` and `invalid` classes
	 * on the DOM element that has ngModel directive on it.
	 *
	 * ```typescript
	 * @Directive({selector: '[ngModel]'})
	 * class NgModelStatus {
	 *   constructor(public control:NgModel) {}
	 *   @HostBinding('class.valid') get valid() { return this.control.valid; }
	 *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<input [(ngModel)]="prop">`,
	 *   directives: [FORM_DIRECTIVES, NgModelStatus]
	 * })
	 * class App {
	 *   prop;
	 * }
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.HostBinding = decorators_1.makePropDecorator(directives_1.HostBindingMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from HostListenerMetadata.
	/**
	 * Declares a host listener.
	 *
	 * Angular will invoke the decorated method when the host element emits the specified event.
	 *
	 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
	 * event.
	 *
	 * ### Example
	 *
	 * The following example declares a directive that attaches a click listener to the button and
	 * counts clicks.
	 *
	 * ```typescript
	 * @Directive({selector: 'button[counting]'})
	 * class CountClicks {
	 *   numberOfClicks = 0;
	 *
	 *   @HostListener('click', ['$event.target'])
	 *   onClick(btn) {
	 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<button counting>Increment</button>`,
	 *   directives: [CountClicks]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.HostListener = decorators_1.makePropDecorator(directives_1.HostListenerMetadata);
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var application_ref_1 = __webpack_require__(61);
	var console_1 = __webpack_require__(64);
	var reflection_1 = __webpack_require__(46);
	var reflector_reader_1 = __webpack_require__(74);
	var testability_1 = __webpack_require__(76);
	function _reflector() {
	    return reflection_1.reflector;
	}
	var __unused; // prevent missing use Dart warning.
	/**
	 * A default set of providers which should be included in any Angular platform.
	 * @experimental
	 */
	exports.PLATFORM_COMMON_PROVIDERS = [
	    application_ref_1.PLATFORM_CORE_PROVIDERS,
	    /*@ts2dart_Provider*/ { provide: reflection_1.Reflector, useFactory: _reflector, deps: [] },
	    /*@ts2dart_Provider*/ { provide: reflector_reader_1.ReflectorReader, useExisting: reflection_1.Reflector }, testability_1.TestabilityRegistry,
	    console_1.Console
	];
	//# sourceMappingURL=platform_common_providers.js.map

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(24);
	/**
	   A token that can be provided when bootstrapping an application to make an array of directives
	  * available in every component of the application.
	  *
	  * ### Example
	  *
	  * ```typescript
	  * import {PLATFORM_DIRECTIVES} from '@angular/core';
	  * import {OtherDirective} from './myDirectives';
	  *
	  * @Component({
	  *   selector: 'my-component',
	  *   template: `
	  *     <!-- can use other directive even though the component does not list it in `directives` -->
	  *     <other-directive></other-directive>
	  *   `
	  * })
	  * export class MyComponent {
	  *   ...
	  * }
	  *
	  * bootstrap(MyComponent, [{provide: PLATFORM_DIRECTIVES, useValue: [OtherDirective],
	  multi:true}]);
	  * ```
	  * @stable
	  */
	exports.PLATFORM_DIRECTIVES = 
	/*@ts2dart_const*/ new di_1.OpaqueToken('Platform Directives');
	/**
	  * A token that can be provided when bootstraping an application to make an array of pipes
	  * available in every component of the application.
	  *
	  * ### Example
	  *
	  * ```typescript
	  * import {PLATFORM_PIPES} from '@angular/core';
	  * import {OtherPipe} from './myPipe';
	  *
	  * @Component({
	  *   selector: 'my-component',
	  *   template: `
	  *     {{123 | other-pipe}}
	  *   `
	  * })
	  * export class MyComponent {
	  *   ...
	  * }
	  *
	  * bootstrap(MyComponent, [{provide: PLATFORM_PIPES, useValue: [OtherPipe], multi:true}]);
	  * ```
	  * @stable
	  */
	exports.PLATFORM_PIPES = new di_1.OpaqueToken('Platform Pipes');
	//# sourceMappingURL=platform_directives_and_pipes.js.map

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var trace;
	var events;
	function detectWTF() {
	    var wtf = lang_1.global['wtf'];
	    if (wtf) {
	        trace = wtf['trace'];
	        if (trace) {
	            events = trace['events'];
	            return true;
	        }
	    }
	    return false;
	}
	exports.detectWTF = detectWTF;
	function createScope(signature, flags) {
	    if (flags === void 0) { flags = null; }
	    return events.createScope(signature, flags);
	}
	exports.createScope = createScope;
	function leave(scope, returnValue) {
	    trace.leaveScope(scope, returnValue);
	    return returnValue;
	}
	exports.leave = leave;
	function startTimeRange(rangeType, action) {
	    return trace.beginTimeRange(rangeType, action);
	}
	exports.startTimeRange = startTimeRange;
	function endTimeRange(range) {
	    trace.endTimeRange(range);
	}
	exports.endTimeRange = endTimeRange;
	//# sourceMappingURL=wtf_impl.js.map

/***/ },
/* 214 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * This is here because DART requires it. It is noop in JS.
	 */
	function wtfInit() { }
	exports.wtfInit = wtfInit;
	//# sourceMappingURL=wtf_init.js.map

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for render
	var api_1 = __webpack_require__(75);
	exports.RenderComponentType = api_1.RenderComponentType;
	exports.Renderer = api_1.Renderer;
	exports.RootRenderer = api_1.RootRenderer;
	//# sourceMappingURL=render.js.map

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for util
	var decorators_1 = __webpack_require__(47);
	exports.Class = decorators_1.Class;
	//# sourceMappingURL=util.js.map

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for Zone
	var ng_zone_1 = __webpack_require__(77);
	exports.NgZone = ng_zone_1.NgZone;
	exports.NgZoneError = ng_zone_1.NgZoneError;
	//# sourceMappingURL=zone.js.map

/***/ },
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	URLON = {
		stringify: function (input) {
			function encodeString (str) {
				return encodeURI(str.replace(/([=:&@_;\/])/g, '/$1'));
			}
	
			function stringify (input) {
				// Number or Boolean or Null
				if (typeof input === 'number' || input === true || input === false || input === null) {
					return ':' + input;
				}
				// Array
				if (input instanceof Array) {
					var res = [];
					for (var i = 0; i < input.length; ++i) {
						res.push(stringify(input[i]));
					}
					return '@' + res.join('&') + ';';
				}
				// Object
				if (typeof input === 'object') {
					var res = [];
					for (var key in input) {
						res.push(encodeString(key) + stringify(input[key]));
					}
					return '_' + res.join('&') + ';';
				}
				// String or undefined			
				return '=' + encodeString((input !== null ? (input !== undefined ? input : "undefined") : "null").toString());
			}
	
			return stringify(input).replace(/;+$/g, '');
		},
	
		parse: function (str) {
			var pos = 0;
			str = decodeURI(str);
	
			function read() {
				var token = '';
				for (; pos !== str.length; ++pos) {
					if (str.charAt(pos) === '/') {
						pos += 1;
						if (pos === str.length) {
							token += ';';
							break;
						}
					} else if (str.charAt(pos).match(/[=:&@_;]/)) {
						break;
					}
					token += str.charAt(pos);
				}
				return token;
			}
	
			function parse() {
				var type = str.charAt(pos++);
	
				// String
				if (type === '=') {
					return read();
				}
				// Number or Boolean
				if (type === ':') {
					var value = read();
					if (value === 'true') {
						return true;
					}
					if (value === 'false') {
						return false;
					}
					value = parseFloat(value);
					return isNaN(value) ? null : value;
				}
				// Array
				if (type === '@') {
					var res = [];
					loop: {
						if (pos >= str.length || str.charAt(pos) === ';') {
							break loop;
						}
						while (1) {
							res.push(parse());
							if (pos >= str.length || str.charAt(pos) === ';') {
								break loop;
							}
							pos += 1;
						}
					}
					pos += 1;
					return res;
				}
				// Object
				if (type === '_') {
					var res = {};
					loop: {
						if (pos >= str.length || str.charAt(pos) === ';') {
							break loop;
						}
						while (1) {
							var name = read();
							res[name] = parse();
							if (pos >= str.length || str.charAt(pos) === ';') {
								break loop;
							}
							pos += 1;
						}
					}
					pos += 1;
					return res;
				}
				// Error
				throw 'Unexpected char ' + type;
			}
	
			return parse();
		}
	};
	
	if (true) {
		exports.stringify = URLON.stringify;
		exports.parse = URLON.parse;
	}


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.6"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.zip = function() {
	    if (!(n = arguments.length)) return [];
	    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
	      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
	        zip[j] = arguments[j][i];
	      }
	    }
	    return zips;
	  };
	  function d3_zipLength(d) {
	    return d.length;
	  }
	  d3.transpose = function(matrix) {
	    return d3.zip.apply(d3, matrix);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: "http://www.w3.org/1999/xhtml",
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0) {
	        prefix = name.slice(0, i);
	        name = name.slice(i + 1);
	      }
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
	            exitNodes[i] = node;
	          } else {
	            nodeByKeyValue.set(keyValue, node);
	          }
	          keyValues[i] = keyValue;
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = nodes;
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged && d3.event.target === target);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
	    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
	    function interpolate(t) {
	      var s = t * S;
	      if (dr) {
	        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
	      }
	      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
	    }
	    interpolate.duration = S * 1e3;
	    return interpolate;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: +_
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      }), center0 = null;
	    }
	    function mousedowned() {
	      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged && d3.event.target === target);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
	      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    format = format.toLowerCase();
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/.exec(format);
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }
	
	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format)) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      f: false,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  };
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now();
	    d3_timer_active = d3_timer_queueHead;
	    while (d3_timer_active) {
	      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
	      d3_timer_active = d3_timer_active.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.f) {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      } else {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;
	
	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;
	
	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;
	
	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();
	
	       case "c":
	        exponent = false;
	
	       case "d":
	        integer = true;
	        precision = 0;
	        break;
	
	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * π;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var λ00, φ00, λ0, cosφ0, sinφ0;
	    d3_geo_area.point = function(λ, φ) {
	      d3_geo_area.point = nextPoint;
	      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
	      sinφ0 = Math.sin(φ);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      φ = φ * d3_radians / 2 + π / 4;
	      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(λ00, φ00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
	  }
	  d3.geo.bounds = function() {
	    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dλSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
	        range[0] = λ0, range[1] = λ1;
	      }
	    };
	    function point(λ, φ) {
	      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
	      if (φ < φ0) φ0 = φ;
	      if (φ > φ1) φ1 = φ;
	    }
	    function linePoint(λ, φ) {
	      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
	        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = inflection[1] * d3_degrees;
	          if (φi > φ1) φ1 = φi;
	        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = -inflection[1] * d3_degrees;
	          if (φi < φ0) φ0 = φi;
	        } else {
	          if (φ < φ0) φ0 = φ;
	          if (φ > φ1) φ1 = φ;
	        }
	        if (antimeridian) {
	          if (λ < λ_) {
	            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	          } else {
	            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	          }
	        } else {
	          if (λ1 >= λ0) {
	            if (λ < λ0) λ0 = λ;
	            if (λ > λ1) λ1 = λ;
	          } else {
	            if (λ > λ_) {
	              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	            } else {
	              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	            }
	          }
	        }
	      } else {
	        point(λ, φ);
	      }
	      p0 = p, λ_ = λ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = λ0, range[1] = λ1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(λ, φ) {
	      if (p0) {
	        var dλ = λ - λ_;
	        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
	      } else λ__ = λ, φ__ = φ;
	      d3_geo_area.point(λ, φ);
	      linePoint(λ, φ);
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(λ__, φ__);
	      d3_geo_area.lineEnd();
	      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
	      range[0] = λ0, range[1] = λ1;
	      p0 = null;
	    }
	    function angle(λ0, λ1) {
	      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      φ1 = λ1 = -(λ0 = φ0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, dλ;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < ε2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < ε2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(λ, φ) {
	    λ *= d3_radians;
	    var cosφ = Math.cos(φ *= d3_radians);
	    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var λ00, φ00, x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ00 = λ, φ00 = φ;
	      d3_geo_centroid.point = nextPoint;
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(λ00, φ00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(λ, φ) {
	        var point = rotate(λ, φ);
	        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
	      }
	      function pointLine(λ, φ) {
	        var point = rotate(λ, φ);
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(λ, φ) {
	        ring.push([ λ, φ ]);
	        var point = rotate(λ, φ);
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(λ, φ) {
	        line.push([ λ, φ ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(λ1, φ1) {
	        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
	        if (abs(dλ - π) < ε) {
	          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          listener.point(λ1, φ0);
	          clean = 0;
	        } else if (sλ0 !== sλ1 && dλ >= π) {
	          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
	          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
	          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          clean = 0;
	        }
	        listener.point(λ0 = λ1, φ0 = φ1);
	        sλ0 = sλ1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        λ0 = φ0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
	    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var φ;
	    if (from == null) {
	      φ = direction * halfπ;
	      listener.point(-π, φ);
	      listener.point(0, φ);
	      listener.point(π, φ);
	      listener.point(π, 0);
	      listener.point(π, -φ);
	      listener.point(0, -φ);
	      listener.point(-π, -φ);
	      listener.point(-π, 0);
	      listener.point(-π, φ);
	    } else if (abs(from[0] - to[0]) > ε) {
	      var s = from[0] < to[0] ? π : -π;
	      φ = direction * s / 2;
	      listener.point(-s, φ);
	      listener.point(0, φ);
	      listener.point(s, φ);
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
	        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
	        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
	        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
	      }
	    }
	    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
	    function visible(λ, φ) {
	      return Math.cos(λ) * Math.cos(φ) > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(λ, φ) {
	          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ε;
	              point1[1] += ε;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
	      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
	      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
	      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
	      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(λ, φ) {
	      var r = smallRadius ? radius : π - radius, code = 0;
	      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
	      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
	      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(φ0, φ1) {
	    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
	    function forward(λ, φ) {
	      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
	      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = ρ0 - y;
	      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, τ);
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(λ, φ) {
	        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(λ, φ) {
	        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * δ2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(δ2);
	      maxDepth = (δ2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + δx, δy - x[1] * k ];
	    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + δx, δy - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
	      λ = _[0] % 360 * d3_radians;
	      φ = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
	      δλ = _[0] % 360 * d3_radians;
	      δφ = _[1] % 360 * d3_radians;
	      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
	      var center = project(λ, φ);
	      δx = x - center[0] * k;
	      δy = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(λ, φ) {
	    return [ λ, φ ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(λ, φ) {
	    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(δλ, δφ, δγ) {
	    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotationλ(δλ) {
	    return function(λ, φ) {
	      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	    };
	  }
	  function d3_geo_rotationλ(δλ) {
	    var rotation = d3_geo_forwardRotationλ(δλ);
	    rotation.invert = d3_geo_forwardRotationλ(-δλ);
	    return rotation;
	  }
	  function d3_geo_rotationφγ(δφ, δγ) {
	    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	    function rotation(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
	      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
	    }
	    rotation.invert = function(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
	      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * τ;
	      } else {
	        from = radius + direction * τ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ε;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ε;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - ε, dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - ε, dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var λ0, sinφ0, cosφ0;
	    d3_geo_length.point = function(λ, φ) {
	      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(λ, φ) {
	      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
	      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(λ, φ) {
	      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
	      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	    }
	    azimuthal.invert = function(x, y) {
	      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
	    return Math.sqrt(2 / (1 + cosλcosφ));
	  }, function(ρ) {
	    return 2 * Math.asin(ρ / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
	    var c = Math.acos(cosλcosφ);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), t = function(φ) {
	      return Math.tan(π / 4 + φ / 2);
	    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(λ, φ) {
	      if (F > 0) {
	        if (φ < -halfπ + ε) φ = -halfπ + ε;
	      } else {
	        if (φ > halfπ - ε) φ = halfπ - ε;
	      }
	      var ρ = F / Math.pow(t(φ), n);
	      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
	      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
	    if (abs(n) < ε) return d3_geo_equirectangular;
	    function forward(λ, φ) {
	      var ρ = G - φ;
	      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = G - y;
	      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / cosλcosφ;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(λ, φ) {
	    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k = π * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / (1 + cosλcosφ);
	  }, function(ρ) {
	    return 2 * Math.atan(ρ);
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(λ, φ) {
	    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ε) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ε) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -ε) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -ε) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
	            x: x0,
	            y: abs(x2 - x0) < ε ? y2 : y1
	          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
	            x: abs(y2 - y1) < ε ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
	            x: x1,
	            y: abs(x2 - x1) < ε ? y2 : y0
	          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
	            x: abs(y2 - y0) < ε ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -ε2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ε) * ε,
	          y: Math.round(fy(d, i) / ε) * ε,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;
	
	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;
	
	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;
	
	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * halfπ);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
	    if (ta[0] != tb[0] || ta[1] != tb[1]) {
	      s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: 1,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: 3,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    } else {
	      s.push("");
	    }
	    if (ra != rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(s.pop() + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(s.pop() + "rotate(" + rb + ")");
	    }
	    if (wa != wb) {
	      q.push({
	        i: s.push(s.pop() + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(s.pop() + "skewX(" + wb + ")");
	    }
	    if (ka[0] != kb[0] || ka[1] != kb[1]) {
	      n = s.push(s.pop() + "scale(", null, ",", null, ")");
	      q.push({
	        i: n - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: n - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] != 1 || kb[1] != 1) {
	      s.push(s.pop() + "scale(" + kb + ")");
	    }
	    n = q.length;
	    return function(t) {
	      var i = -1, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = (τ - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: (x - x0) / k
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight / (t.weight + s.weight));
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) alpha = x; else alpha = 0;
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        d3.timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = 0;
	      root.y = 0;
	      root.dx = size[0];
	      root.dy = size[1];
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(µ, σ) {
	      var n = arguments.length;
	      if (n < 2) σ = 1;
	      if (n < 1) µ = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
	      Math.floor), e;
	      return function(d) {
	        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	        if (x1 != null) {
	          var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.join("L");
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return d3_svg_lineLinear(points) + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ε) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - halfπ;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / π);
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, active;
	      if ((lock = this[ns]) && (active = lock[lock.active])) {
	        if (--lock.count) delete lock[lock.active]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id];
	    if (!transition) {
	      var time = inherit.time;
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	      d3.timer(function(elapsed) {
	        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
	        timer.t = delay + time;
	        if (delay <= elapsed) return start(elapsed - delay);
	        timer.c = start;
	        function start(elapsed) {
	          if (lock.active > id) return stop();
	          var active = lock[lock.active];
	          if (active) {
	            --lock.count;
	            delete lock[lock.active];
	            active.event && active.event.interrupt.call(node, node.__data__, active.index);
	          }
	          lock.active = id;
	          transition.event && transition.event.start.call(node, node.__data__, i);
	          transition.tween.forEach(function(key, value) {
	            if (value = value.call(node, node.__data__, i)) {
	              tweened.push(value);
	            }
	          });
	          ease = transition.ease;
	          duration = transition.duration;
	          d3.timer(function() {
	            timer.c = tick(elapsed || 1) ? d3_true : tick;
	            return 1;
	          }, 0, time);
	        }
	        function tick(elapsed) {
	          if (lock.active !== id) return 1;
	          var t = elapsed / duration, e = ease(t), n = tweened.length;
	          while (n > 0) {
	            tweened[--n].call(node, e);
	          }
	          if (t >= 1) {
	            transition.event && transition.event.end.call(node, node.__data__, i);
	            return stop();
	          }
	        }
	        function stop() {
	          if (--lock.count) delete lock[id]; else delete node[ns];
	          return 1;
	        }
	      }, 0, time);
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = arguments;
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3;
	  this.d3 = d3;
	}();

/***/ },
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    isUnsubscribed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(58);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, observer) {
	        _super.call(this);
	        this.subject = subject;
	        this.observer = observer;
	        this.isUnsubscribed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.observer);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ },
/* 254 */,
/* 255 */,
/* 256 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        _super.call(this, 'object unsubscribed');
	        this.name = 'ObjectUnsubscribedError';
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ },
/* 257 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        this.name = 'UnsubscriptionError';
	        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n') : '';
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 258 */
/***/ function(module, exports) {

	"use strict";
	function throwError(e) { throw e; }
	exports.throwError = throwError;
	//# sourceMappingURL=throwError.js.map

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(29);
	var rxSubscriber_1 = __webpack_require__(84);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver && typeof nextOrObserver === 'object') {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(264));


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var d3 = __webpack_require__(238);
	var Vizabi = __webpack_require__(265);
	var urlon = __webpack_require__(237);
	var VizabiWrapper = (function () {
	    function VizabiWrapper(element) {
	        this.element = element;
	    }
	    VizabiWrapper.prototype.ngOnInit = function () {
	        var initialModel = Vizabi.utils.deepClone(this.model);
	        this.createView();
	        this.readerProcessing();
	        this.setMetadata();
	        this.modelHashProcessing();
	        this.persistentChangeProcessing(initialModel);
	        this.component = Vizabi(this.chartType, this.view, this.model);
	    };
	    VizabiWrapper.prototype.ngOnDestroy = function () {
	        var _this = this;
	        Object.keys(Vizabi._instances).forEach(function (instanceKey) {
	            if (Vizabi._instances[instanceKey]._id === _this.component._id) {
	                _this.component.clear();
	                Vizabi._instances[instanceKey] = null;
	                _this.view.remove();
	            }
	        });
	    };
	    VizabiWrapper.prototype.createView = function () {
	        this.view = document.createElement('div');
	        this.element.nativeElement.appendChild(this.view);
	    };
	    VizabiWrapper.prototype.readerProcessing = function () {
	        if (this.readerModuleObject && this.readerGetMethod && this.readerName &&
	            this.readerParams && this.readerModuleObject[this.readerGetMethod]) {
	            var readerObject = this.readerModuleObject[this.readerGetMethod].apply(this, this.readerParams);
	            Vizabi.Reader.extend(this.readerName, readerObject);
	        }
	    };
	    VizabiWrapper.prototype.setMetadata = function () {
	        var translations = this.translations;
	        var metadata = this.metadata;
	        Vizabi.Tool.define('preload', function (promise) {
	            Vizabi._globals.conceptprops = metadata;
	            this.model.language.strings.set(this.model.language.id, translations);
	            promise.resolve();
	        });
	    };
	    VizabiWrapper.prototype.modelHashProcessing = function () {
	        if (this.modelHash) {
	            var str = encodeURI(decodeURIComponent(this.modelHash));
	            var urlModel = urlon.parse(str);
	            Vizabi.utils.deepExtend(this.model, urlModel);
	        }
	    };
	    VizabiWrapper.prototype.persistentChangeProcessing = function (initialModel) {
	        this.model.bind = this.model.bind || {};
	        this.model.bind.persistentChange = onPersistentChange;
	        function onPersistentChange(evt, minModel) {
	            var minModelDiff = Vizabi.utils.diffObject(minModel, initialModel);
	            minModelDiff.language = {};
	            window.location.hash = urlon.stringify(minModelDiff);
	        }
	    };
	    VizabiWrapper = __decorate([
	        core_1.Directive({
	            selector: 'vizabi',
	            properties: [
	                'readerModuleObject',
	                'readerGetMethod',
	                'readerParams',
	                'readerName',
	                'model',
	                'modelHash',
	                'metadata',
	                'translations',
	                'chartType'
	            ]
	        }), 
	        __metadata('design:paramtypes', [core_1.ElementRef])
	    ], VizabiWrapper);
	    return VizabiWrapper;
	}());
	exports.VizabiWrapper = VizabiWrapper;
	exports.vizabiWrapper = [VizabiWrapper];


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * vizabi - Vizabi Framework, Interactive charts and visualization tools animated through time
	 * @version v0.15.1-1
	 * @build timestampMon Aug 08 2016 15:33:02 GMT+0200 (CEST)
	 * @link http://vizabi.org
	 * @license BSD-3-Clause
	 */
	
	(function (global, factory) {
	       true ? module.exports = factory() :
	      typeof define === 'function' && define.amd ? define(factory) :
	      (global.Vizabi = factory());
	}(this, function () { 'use strict';
	
	      var globals = {ext_resources: {}};
	
	      /*
	       * A collection of interpolators
	       * @param {Number} x1, x2, y1, y2 - boundary points
	       * @param {Number} x - point of interpolation
	       * @return {Number} y - interpolated value
	       */
	      //
	      var interpolator = {
	          linear: function(x1, x2, y1, y2, x) {
	            return +y1 + (x - x1) / (x2 - x1) * (y2 - y1);
	          },
	          exp: function(x1, x2, y1, y2, x) {
	            return Math.exp((Math.log(y1) * (x2 - x) - Math.log(y2) * (x1 - x)) / (x2 - x1));
	          },
	          stepBefore: function(x1, x2, y1, y2, x) {
	              return y2;
	          },
	          stepAfter: function(x1, x2, y1, y2, x) {
	              return y1;
	          },
	          stepMiddle: function(x1, x2, y1, y2, x) {
	              return (x < (x1 + x2)/2) ? y1 : y2;
	          }
	      };
	
	      /*
	       * returns unique id with optional prefix
	       * @param {String} prefix
	       * @returns {String} id
	       */
	      var uniqueId = function() {
	        var id = 0;
	        return function(p) {
	          return p ? p + (id += 1) : id += 1;
	        };
	      }();
	
	      /*
	       * checks whether obj is a DOM element
	       * @param {Object} obj
	       * @returns {Boolean}
	       * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
	       */
	      var isElement = function(obj) {
	        return !!(obj && obj.nodeType === 1);
	      };
	
	      /*
	       * checks whether obj is an Array
	       * @param {Object} obj
	       * @returns {Boolean}
	       * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
	       */
	      var isArray = Array.isArray || function(obj) {
	        return toString.call(obj) === '[object Array]';
	      };
	
	      /*
	       * checks whether obj is an object
	       * @param {Object} obj
	       * @returns {Boolean}
	       * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
	       */
	      var isObject = function(obj) {
	        var type = typeof obj;
	        return type === 'object' && !!obj;
	      };
	
	      /*
	       * checks whether arg is a date
	       * @param {Object} arg
	       * @returns {Boolean}
	       */
	      var isDate = function(arg) {
	        return arg instanceof Date;
	      };
	
	      /*
	       * checks whether arg is a string
	       * @param {Object} arg
	       * @returns {Boolean}
	       */
	      var isString = function(arg) {
	        return typeof arg === 'string';
	      };
	
	      /*
	       * checks whether arg is a NaN
	       * @param {*} arg
	       * @returns {Boolean}
	       * from lodash: https://github.com/lodash/lodash/blob/master/lodash.js
	       */
	      var isNaN$1 = function(arg) {
	        // A `NaN` primitive is the only number that is not equal to itself
	        return isNumber(arg) && arg !== +arg;
	      };
	
	      /*
	       * checks whether arg is a number. NaN is a number too
	       * @param {*} arg
	       * @returns {Boolean}
	       * from lodash: https://github.com/lodash/lodash/blob/master/lodash.js
	       * dependencies are resolved and included here
	       */
	      var isNumber = function(arg) {
	        return typeof arg === 'number' || !!arg && typeof arg === 'object' && Object.prototype.toString.call(arg) ===
	          '[object Number]';
	      };
	
	      /*
	       * checks whether obj is a plain object {}
	       * @param {Object} obj
	       * @returns {Boolean}
	       */
	      var isPlainObject = function(obj) {
	        return obj !== null && Object.prototype.toString.call(obj) === '[object Object]';
	      };
	
	      /*
	       * checks whether two arrays are equal
	       * @param {Array} a
	       * @param {Array} b
	       * @returns {Boolean}
	       */
	      var arrayEquals = function(a, b) {
	        if(a === b) return true;
	        if(a == null || b == null) return false;
	        if(a.length != b.length) return false;
	        for(var i = 0; i < a.length; ++i) {
	          if(a[i] !== b[i]) return false;
	        }
	        return true;
	      };
	
	
	      /**
	       * Object Comparison
	       *
	       * http://stamat.wordpress.com/2013/06/22/javascript-object-comparison/
	       *
	       * No version
	       *
	       * @param a
	       * @param b
	       * @returns {boolean} if objects are equal
	       */
	      var comparePlainObjects = function (a, b) {
	
	          //Returns the object's class, Array, Date, RegExp, Object are of interest to us
	          var getClass = function (val) {
	              return Object.prototype.toString.call(val)
	                  .match(/^\[object\s(.*)\]$/)[1];
	          };
	
	          //Defines the type of the value, extended typeof
	          var whatis = function (val) {
	
	              if (val === undefined) {
	                  return 'undefined';
	              }
	              if (val === null) {
	                  return 'null';
	              }
	
	              var type = typeof val;
	
	              if (type === 'object') {
	                  type = getClass(val).toLowerCase();
	              }
	
	              if (type === 'number') {
	                  if (val.toString().indexOf('.') > 0) {
	                      return 'float';
	                  }
	                  else {
	                      return 'integer';
	                  }
	              }
	
	              return type;
	          };
	
	          var compare = function (a, b) {
	              if (a === b) {
	                  return true;
	              }
	              for (var i in a) {
	                  if (b.hasOwnProperty(i)) {
	                      if (!equal(a[i], b[i])) {
	                          return false;
	                      }
	                  } else {
	                      return false;
	                  }
	              }
	
	              for (var i in b) {
	                  if (!a.hasOwnProperty(i)) {
	                      return false;
	                  }
	              }
	              return true;
	          };
	
	          var compareArrays = function (a, b) {
	              if (a === b) {
	                  return true;
	              }
	              if (a.length !== b.length) {
	                  return false;
	              }
	              for (var i = 0; i < a.length; i++) {
	                  if (!equal(a[i], b[i])) {
	                      return false;
	                  }
	              }
	              return true;
	          };
	
	          var _equal = {};
	          _equal.array = compareArrays;
	          _equal.object = compare;
	          _equal.date = function (a, b) {
	              return a.getTime() === b.getTime();
	          };
	          _equal.regexp = function (a, b) {
	              return a.toString() === b.toString();
	          };
	
	          /**
	           * Are two values equal, deep compare for objects and arrays.
	           * @param a {any}
	           * @param b {any}
	           * @return {boolean} Are equal?
	           */
	          var equal = function (a, b) {
	              if (a !== b) {
	                  var atype = whatis(a), btype = whatis(b);
	
	                  if (atype === btype) {
	                      return _equal.hasOwnProperty(atype) ? _equal[atype](a, b) : a == b;
	                  }
	
	                  return false;
	              }
	
	              return true;
	          };
	
	          return compare(a, b);
	      };
	
	
	      var getViewportPosition = function(element) {
	        var xPosition = 0;
	        var yPosition = 0;
	
	        while(element) {
	          xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
	          yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
	          element = element.offsetParent;
	        }
	
	        return {
	          x: xPosition,
	          y: yPosition
	        };
	      };
	
	
	      var findScrollableAncestor = function(node) {
	        var scrollable = ["scroll", "auto"];
	        while(node = node.parentNode) {
	          var scrollHeight = node.scrollHeight,
	            height = node.clientHeight;
	            if (scrollHeight > height && scrollable.indexOf(d3.select(node).style("overflow")) !== -1) {
	              return node;
	            }
	        }
	        return null;
	      };
	
	      var roundStep = function(number, step) {
	        return Math.round(number / step) * step;
	      };
	
	      /*
	       * transforms a string into a validated fload value
	       * @param {string} string to be transformed
	       */
	      var strToFloat = function(string) {
	        return +string.replace(/[^\d.-]/g, '');
	      };
	
	      /*
	       * loops through an object or array
	       * @param {Object|Array} obj object or array
	       * @param {Function} callback callback function
	       * @param {Object} ctx context object
	       */
	      var forEach = function(obj, callback, ctx) {
	        if(!obj) {
	          return;
	        }
	        var i, size;
	        if(isArray(obj)) {
	          size = obj.length;
	          for(i = 0; i < size; i += 1) {
	            if(callback.apply(ctx, [
	                obj[i],
	                i
	              ]) === false) {
	              break;
	            }
	          }
	        } else {
	          var keys = Object.keys(obj);
	          size = keys.length;
	          for(i = 0; i < size; i += 1) {
	            if(callback.apply(ctx, [
	                obj[keys[i]],
	                keys[i]
	              ]) === false) {
	              break;
	            }
	          }
	        }
	      };
	
	      /*
	       * extends an object
	       * @param {Object} destination object
	       * @returns {Object} extented object
	       */
	      var extend = function(dest) {
	        //objects to overwrite dest are next arguments
	        var objs = Array.prototype.slice.call(arguments, 1);
	        //loop through each obj and each argument, left to right
	        forEach(objs, function(obj, i) {
	          forEach(obj, function(value, k) {
	            if(obj.hasOwnProperty(k)) {
	              dest[k] = value;
	            }
	          });
	        });
	        return dest;
	      };
	
	      // Deep extend and helper functions
	      // https://github.com/unclechu/node-deep-extend/blob/master/lib/deep-extend.js
	
	      function isSpecificValue(val) {
	        return (
	          val instanceof Date
	          || val instanceof RegExp
	        ) ? true : false;
	      }
	
	      function cloneSpecificValue(val) {
	        if (val instanceof Date) {
	          return new Date(val.getTime());
	        } else if (val instanceof RegExp) {
	          return new RegExp(val);
	        } else {
	          throw new Error('Unexpected situation');
	        }
	      }
	
	      /**
	       * Recursive cloning array.
	       */
	      function deepCloneArray(arr) {
	        var clone = [];
	        forEach(arr, function (item, index) {
	          if (typeof item === 'object' && item !== null) {
	            if (isArray(item)) {
	              clone[index] = deepCloneArray(item);
	            } else if (isSpecificValue(item)) {
	              clone[index] = cloneSpecificValue(item);
	            } else {
	              clone[index] = deepExtend({}, item);
	            }
	          } else {
	            clone[index] = item;
	          }
	        });
	        return clone;
	      }
	
	      /**
	       * Extening object that entered in first argument.
	       *
	       * Returns extended object or false if have no target object or incorrect type.
	       *
	       * If you wish to clone source object (without modify it), just use empty new
	       * object as first argument, like this:
	       *   deepExtend({}, yourObj_1, [yourObj_N]);
	       */
	      var deepExtend = function(/*obj_1, [obj_2], [obj_N]*/) {
	        if (arguments.length < 1 || typeof arguments[0] !== 'object') {
	          return false;
	        }
	
	        if (arguments.length < 2) {
	          return arguments[0];
	        }
	
	        var target = arguments[0];
	
	        // convert arguments to array and cut off target object
	        var args = Array.prototype.slice.call(arguments, 1);
	
	        var val, src, clone;
	
	        forEach(args, function (obj) {
	          // skip argument if it is array or isn't object
	          if (typeof obj !== 'object' || isArray(obj)) {
	            return;
	          }
	
	          forEach(Object.keys(obj), function (key) {
	            src = target[key]; // source value
	            val = obj[key]; // new value
	
	            // recursion prevention
	            if (val === target) {
	              return;
	
	            /**
	             * if new value isn't object then just overwrite by new value
	             * instead of extending.
	             */
	            } else if (typeof val !== 'object' || val === null) {
	              target[key] = val;
	              return;
	
	            // just clone arrays (and recursive clone objects inside)
	            } else if (isArray(val)) {
	              target[key] = deepCloneArray(val);
	              return;
	
	            // custom cloning and overwrite for specific objects
	            } else if (isSpecificValue(val)) {
	              target[key] = cloneSpecificValue(val);
	              return;
	
	            // overwrite by new value if source isn't object or array
	            } else if (typeof src !== 'object' || src === null || isArray(src)) {
	              target[key] = deepExtend({}, val);
	              return;
	
	            // source value and new value is objects both, extending...
	            } else {
	              target[key] = deepExtend(src, val);
	              return;
	            }
	          });
	        });
	
	        return target;
	      }
	
	      /*
	       * merges objects instead of replacing
	       * @param {Object} destination object
	       * @returns {Object} merged object
	       */
	      var merge = function(dest) {
	
	        // objects to overwrite dest are next arguments
	        var objs = Array.prototype.slice.call(arguments, 1);
	
	        // loop through each obj and each argument, left to right
	        forEach(objs, function(obj, i) {
	          forEach(obj, function(value, k) {
	            if(obj.hasOwnProperty(k)) {
	              if(dest.hasOwnProperty(k)) {
	                if(!isArray(dest[k])) {
	                  dest[k] = [dest[k]];
	                }
	                dest[k].push(value);
	              } else {
	                dest[k] = value;
	              }
	            }
	          });
	        });
	        return dest;
	
	      };
	
	      /*
	       * clones an object (shallow copy)
	       * @param {Object} src original object
	       * @param {Array} arr filter keys
	       * @returns {Object} cloned object
	       */
	      var clone = function(src, arr, exclude) {
	        if(isArray(src)) {
	          return src.slice(0);
	        }
	        var clone = {};
	        forEach(src, function(value, k) {
	          if((arr && arr.indexOf(k) === -1) || (exclude && exclude.indexOf(k) !== -1)) {
	            return;
	          }
	          if(src.hasOwnProperty(k)) {
	            clone[k] = value;
	          }
	        });
	        return clone;
	      };
	
	      /*
	       * deep clones an object (deep copy)
	       * @param {Object} src original object
	       * @returns {Object} cloned object
	       */
	      var deepClone = function(src) {
	        var clone = {};
	        if(isArray(src)) clone = [];
	
	        forEach(src, function(value, k) {
	          if(isObject(value) || isArray(value)) {
	            clone[k] = deepClone(value);
	          } else {
	            clone[k] = value;
	          }
	        });
	        return clone;
	      };
	
	      /*
	       * Prints message to timestamp
	       * @param {Arr} arr
	       * @param {Object} el
	       */
	      var without = function(arr, el) {
	        var idx = arr.indexOf(el);
	        if(idx !== -1) {
	          arr.splice(idx, 1);
	        }
	        return arr;
	      };
	
	      /*
	       * unique items in an array
	       * @param {Array} arr original array
	       * @param {Function} func optional evaluation function
	       * @returns {Array} unique items
	       * Based on:
	       * http://stackoverflow.com/questions/1960473/unique-values-in-an-array
	       */
	      var unique = function(arr, func) {
	        var u = {};
	        var a = [];
	        if(!func) {
	          func = function(d) {
	            return d;
	          };
	        }
	        for(var i = 0, l = arr.length; i < l; i += 1) {
	          var key = func(arr[i]);
	          if(u.hasOwnProperty(key)) {
	            continue;
	          }
	          a.push(arr[i]);
	          u[key] = 1;
	        }
	        return a;
	      };
	
	      /*
	       * unique items in an array keeping the last item
	       * @param {Array} arr original array
	       * @param {Function} func optional evaluation function
	       * @returns {Array} unique items
	       * Based on the previous method
	       */
	      var uniqueLast = function(arr, func) {
	        var u = {};
	        var a = [];
	        if(!func) {
	          func = function(d) {
	            return d;
	          };
	        }
	        for(var i = 0, l = arr.length; i < l; i += 1) {
	          var key = func(arr[i]);
	          if(u.hasOwnProperty(key)) {
	            a.splice(u[key], 1); //remove old item from array
	          }
	          a.push(arr[i]);
	          u[key] = a.length - 1;
	        }
	        return a;
	      };
	
	      /*
	       * returns first value that passes the test
	       * @param {Array} arr original collection
	       * @returns {Function} func test function
	       */
	      var find = function(arr, func) {
	        var found;
	        forEach(arr, function(i) {
	          if(func(i)) {
	            found = i;
	            return false; //break
	          }
	        });
	        return found;
	      };
	
	      /*
	       * filters an array based on object properties
	       * @param {Array} arr original array
	       * @returns {Object} filter properties to use as filter
	       */
	      var filter = function(arr, filter) {
	        var index = -1;
	        var length = arr.length;
	        var resIndex = -1;
	        var result = [];
	        var keys = Object.keys(filter);
	        var s_keys = keys.length;
	        var i;
	        var f;
	        while((index += 1) < length) {
	          var value = arr[index];
	          var match = true;
	          for(i = 0; i < s_keys; i += 1) {
	            f = keys[i];
	            if(!value.hasOwnProperty(f) || value[f] !== filter[f]) {
	              match = false;
	              break;
	            }
	          }
	          if(match) {
	            result[resIndex += 1] = value;
	          }
	        }
	        return result;
	      };
	
	      /*
	       * filters an array based on object properties.
	       * Properties may be arrays determining possible values
	       * @param {Array} arr original array
	       * @returns {Object} filter properties to use as filter
	       */
	      var filterAny = function(arr, filter, wildcard) {
	        var index = -1;
	        var length = arr.length;
	        var resIndex = -1;
	        var result = [];
	        var keys = Object.keys(filter);
	        var s_keys = keys.length;
	        var i, f;
	        while((index += 1) < length) {
	          var value = arr[index];
	          //normalize to array
	          var match = true;
	          for(i = 0; i < s_keys; i += 1) {
	            f = keys[i];
	            if(!value.hasOwnProperty(f) || !matchAny(value[f], filter[f], wildcard)) {
	              match = false;
	              break;
	            }
	          }
	          if(match) {
	            result[resIndex += 1] = value;
	          }
	        }
	        return result;
	      };
	
	      /*
	       * checks if the value matches the comparison value or any in array
	       * compare may be an determining possible values
	       * @param value original value
	       * @param compare value or array
	       * @param {String} wildc wildcard value
	       * @returns {Boolean} try
	       */
	      var matchAny = function(values, compare, wildc) {
	        //normalize value
	        if(!isArray(values)) values = [values];
	        if(!wildc) wildc = "*"; //star by default
	        var match = false;
	        for(var e = 0; e < values.length; e++) {
	          var value = values[e];
	
	          if(!isArray(compare) && value == compare) {
	            match = true;
	            break;
	          } else if(isArray(compare)) {
	            var found = -1;
	            for(var i = 0; i < compare.length; i++) {
	              var c = compare[i];
	              if(!isArray(c) && (c == value || c === wildc)) {
	                found = i;
	                break;
	              } else if(isArray(c)) { //range
	                var min = c[0];
	                var max = c[1] || min;
	                if(value >= min && value <= max) {
	                  found = i;
	                  break;
	                }
	              }
	            }
	            if(found !== -1) {
	              match = true;
	              break;
	            }
	          }
	        }
	        return match;
	      };
	
	      /**
	       * prevent scrolling parent scrollable elements for 2 second when element scrolled to end
	       * @param node
	       */
	
	      var preventAncestorScrolling = function(element) {
	        var preventScrolling = false;
	        element.on('mousewheel', function(d, i) {
	          var scrollTop = this.scrollTop,
	            scrollHeight = this.scrollHeight,
	            height = element.node().offsetHeight,
	            delta = d3.event.wheelDelta,
	            up = delta > 0;
	          var prevent = function() {
	            d3.event.stopPropagation();
	            d3.event.preventDefault();
	            d3.event.returnValue = false;
	            return false;
	          };
	
	          var scrollTopTween = function(scrollTop) {
	            return function () {
	              var i = d3.interpolateNumber(this.scrollTop, scrollTop);
	              return function (t) {
	                this.scrollTop = i(t);
	              };
	            }
	          };
	          if (!up) {
	            // Scrolling down
	            if (-delta > scrollHeight - height - scrollTop && scrollHeight != height + scrollTop) {
	              element.transition().delay(0).duration(0).tween("scrolltween", scrollTopTween(scrollHeight));
	              //freeze scrolling on 2 seconds on bottom position
	              preventScrolling = true;
	              setTimeout(function() {
	                preventScrolling = false;
	              }, 2000);
	            } else if (scrollTop == 0) { //unfreeze when direction changed
	              preventScrolling = false;
	            }
	          } else if (up) {
	            // Scrolling up
	            if (delta > scrollTop && scrollTop > 0) { //
	              //freeze scrolling on 2 seconds on top position
	              element.transition().delay(0).duration(0).tween("scrolltween", scrollTopTween(0));
	              preventScrolling = true;
	              setTimeout(function() {
	                preventScrolling = false;
	              }, 2000);
	            } else if (scrollHeight == height + scrollTop) { //unfreeze when direction changed
	              preventScrolling = false;
	            }
	          }
	          if (preventScrolling) {
	            return prevent();
	          }
	        });
	      };
	
	      /*
	       * maps all rows according to the formatters
	       * @param {Array} original original dataset
	       * @param {Object} formatters formatters object
	       * @returns {Boolean} try
	       */
	      var mapRows = function(original, formatters) {
	
	        function mapRow(value, fmt) {
	          if(!isArray(value)) {
	            return fmt(value);
	          } else {
	            var res = [];
	            for(var i = 0; i < value.length; i++) {
	              res[i] = mapRow(value[i], fmt);
	            }
	            return res;
	          }
	        }
	         
	        // default formatter turns empty strings in null and converts numeric values into number
	        //TODO: default formatter is moved to utils. need to return it to hook prototype class, but retest #1212 #1230 #1253
	        var defaultFormatter = function (val) {
	            var newVal = val;
	            if(val === ""){
	              newVal = null;
	            } else {
	              // check for numberic
	              var numericVal = parseFloat(val);
	              if (!isNaN$1(numericVal) && isFinite(val)) {
	                newVal = numericVal;
	              }
	            }  
	            return newVal;
	        }
	        
	        original = original.map(function(row) {
	          var columns = Object.keys(row);
	            
	          for(var i = 0; i < columns.length; i++) {
	            var col = columns[i];
	            row[col] = mapRow(row[col], formatters[col] || defaultFormatter);
	          }
	          return row;
	        });
	
	        return original;
	      };
	
	      /*
	       * Converts radius to area, simple math
	       * @param {Number} radius
	       * @returns {Number} area
	       */
	      var radiusToArea = function(r) {
	        return r * r * Math.PI;
	      };
	
	      /*
	       * Converts area to radius, simple math
	       * @param {Number} area
	       * @returns {Number} radius
	       */
	      var areaToRadius = function(a) {
	        return Math.sqrt(a / Math.PI);
	      };
	
	      /*
	       * Prints message to timestamp
	       * @param {String} message
	       */
	      var timeStamp = function(message) {
	        if(console && typeof console.timeStamp === 'function') {
	          console.timeStamp(message);
	        }
	      };
	
	      /*
	       * Prints warning
	       * @param {String} message
	       */
	      var warn = function(message) {
	        message = Array.prototype.slice.call(arguments).join(' ');
	        if(console && typeof console.warn === 'function') {
	          console.warn(message);
	        }
	        // "return true" is needed to find out if a parent function is exited with warning
	        // example:
	        // myfunction = function() { if(brokenstuff) return utils.warn("broken stuff found") }
	        // if(myfunction()) return; // stopped execution after myfunction finds broken stuff
	        // ... or moving on
	        return true;
	      };
	
	      /*
	       * Prints message for group
	       * @param {String} message
	       */
	      var groupCollapsed = function(message) {
	        message = Array.prototype.slice.call(arguments).join(' ');
	        if(console && typeof console.groupCollapsed === 'function') {
	          console.groupCollapsed(message);
	        }
	      };
	
	      /*
	       * Prints end of group
	       * @param {String} message
	       */
	      var groupEnd = function() {
	        if(console && typeof console.groupEnd === 'function') {
	          console.groupEnd();
	        }
	      };
	
	      /*
	       * Prints error
	       * @param {String} message
	       */
	      var error$1 = function(message) {
	        message = Array.prototype.slice.call(arguments).join(' ');
	        if(console && typeof console.error === 'function') {
	          console.error(message);
	        }
	      };
	
	      /*
	       * Count the number of decimal numbers
	       * @param {Number} number
	       */
	      var countDecimals = function(number) {
	        if(Math.floor(number.valueOf()) === number.valueOf()) {
	          return 0;
	        }
	        return number.toString().split('.')[1].length || 0;
	      };
	
	      /*
	       * Adds class to DOM element
	       * @param {Element} el
	       * @param {String} className
	       */
	      var addClass = function(el, className) {
	        if(el.classList) {
	          el.classList.add(className);
	        } else {
	          //IE<10
	          el.className += ' ' + className;
	        }
	      };
	
	      /*
	       * Remove class from DOM element
	       * @param {Element} el
	       * @param {String} className
	       */
	      var removeClass = function(el, className) {
	        if(el.classList) {
	          el.classList.remove(className);
	        } else {
	          //IE<10
	          el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'),
	            ' ');
	        }
	      };
	
	      /*
	       * Adds or removes class depending on value
	       * @param {Element} el
	       * @param {String} className
	       * @param {Boolean} value
	       */
	      var classed = function(el, className, value) {
	        if(value === true) {
	          addClass(el, className);
	        } else if(value === false) {
	          removeClass(el, className);
	        } else {
	          return hasClass(el, className);
	        }
	      };
	
	      /*
	       * Checks whether a DOM element has a class or not
	       * @param {Element} el
	       * @param {String} className
	       * @return {Boolean}
	       */
	      var hasClass = function(el, className) {
	        if(el.classList) {
	          return el.classList.contains(className);
	        } else {
	          //IE<10
	          return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
	        }
	      };
	
	      /*
	       * Throttles a function
	       * @param {Function} func
	       * @param {Number} ms duration
	       * @return {Function}
	       * Function recallLast was added to prototype of returned function.
	       * Call Function.recallLast() - immediate recall func with last saved arguments,
	       *                              else func will be called automaticly after ms duration
	       */
	      var throttle = function(func, ms) {
	
	        var throttled = false,
	          savedArgs,
	          savedThis,
	          nextTime,
	          wrapper = function() {
	            
	            if(nextTime > Date.now()) {
	              throttled = true;        
	              savedArgs = arguments;
	              savedThis = this;
	              return;
	            }
	
	            nextTime = Date.now() + ms;
	            throttled = false;
	            
	            func.apply(this, arguments);
	
	            setTimeout(function() {
	              __recallLast();          
	            }, ms);
	
	          },
	          
	          __recallLast = function() {
	            if(throttled) {
	              throttled = false;
	              func.apply(savedThis, savedArgs);
	            }     
	          };
	
	        wrapper.recallLast = __recallLast; 
	
	        return wrapper;
	      };
	
	
	      /*
	       * Returns keys of an object as array
	       * @param {Object} arg
	       * @returns {Array} keys
	       */
	      var keys = function(arg) {
	        return Object.keys(arg);
	      };
	
	      /*
	       * returns the values of an object in an array format
	       * @param {Object} obj
	       * @return {Array}
	       */
	      var values = function(obj) {
	        var arr;
	        var keys = Object.keys(obj);
	        var size = keys.length;
	        for(var i = 0; i < size; i += 1) {
	          (arr = arr || []).push(obj[keys[i]]);
	        }
	        return arr;
	      };
	
	
	      /*
	       * Computes the minumum value in an array
	       * @param {Array} arr
	       */
	      var arrayMin = function(arr) {
	        return arr.reduce(function(p, v) {
	          return(p < v ? p : v);
	        });
	      };
	
	      /*
	       * Computes the minumum value in an array
	       * @param {Array} arr
	       */
	      var arrayMax = function(arr) {
	        return arr.reduce(function(p, v) {
	          return(p > v ? p : v);
	        });
	      };
	
	      /*
	       * Computes the mean of an array
	       * @param {Array} arr
	       */
	      var arrayMean = function(arr) {
	        return arraySum(arr) / arr.length;
	      };
	
	      /*
	       * Computes the sum of an array
	       * @param {Array} arr
	       */
	      var arraySum = function(arr) {
	        return arr.reduce(function(a, b) {
	          return a + b;
	        });
	      };
	
	      /*
	       * Computes the median of an array
	       * @param {Array} arr
	       */
	      var arrayMedian = function(arr) {
	        arr = arr.sort(function(a, b) {
	          return a - b;
	        });
	        var middle = Math.floor((arr.length - 1) / 2);
	        if(arr.length % 2) {
	          return arr[middle];
	        } else {
	          return(arr[middle] + arr[middle + 1]) / 2;
	        }
	      };
	
	      /*
	       * Returns the last value of array
	       * @param {Array} arr
	       */
	      var arrayLast = function(arr) {
	        if(!arr.length) return null;
	        return arr[arr.length - 1];
	      };
	
	      /*
	       * Returns the resulting object of the difference between two objects
	       * @param {Object} obj2
	       * @param {Object} obj1
	       * @returns {Object}
	       */
	      var diffObject = function(obj2, obj1) {
	        var diff = {};
	        forEach(obj2, function(value, key) {
	          if(!obj1.hasOwnProperty(key)) {
	            diff[key] = value;
	          } else if(value !== obj1[key]) {
	            if(isPlainObject(value) && isPlainObject(obj1[key])) {
	              var d = diffObject(value, obj1[key]);
	              if(Object.keys(d).length > 0) {
	                diff[key] = d;
	              }
	            } else if(!isArray(value) || !isArray(obj1[key]) || !arrayEquals(value, obj1[key])) {
	              diff[key] = value;
	            }
	          }
	        });
	        return diff;
	      };
	
	      /*
	       * Returns the resulting object without _defs_ leveling
	       * @param {Object} obj
	       * @returns {Object}
	       */
	      var flattenDefaults = function(obj) {
	        var flattened = {};
	        forEach(obj, function(val, key) {
	          if(isPlainObject(val) && val._defs_) {
	            flattened[key] = val._defs_;
	          } else if(isPlainObject(val)) {
	            flattened[key] = flattenDefaults(val);
	          } else {
	            flattened[key] = val;
	          }
	        });
	        return flattened;
	      };
	
	      /*
	       * Returns the resulting object without date objects for time
	       * @param {Object} obj
	       * @returns {Object}
	       */
	      var flattenDates = function(obj, timeFormat) {
	        var flattened = {};
	        forEach(obj, function(val, key) {
	          //todo: hack to flatten time unit objects to strings
	          if (key === 'marker') {
	            ["axis_x", "axis_y", "size_label"].map(function(name) {
	              var hook = val[name];
	              if(typeof hook === 'object') {
	                if(isDate(hook.domainMin)) hook.domainMin = timeFormat(hook.domainMin);
	                if(isDate(hook.domainMax)) hook.domainMax = timeFormat(hook.domainMax);
	                if(isDate(hook.zoomedMin)) hook.zoomedMin = timeFormat(hook.zoomedMin);
	                if(isDate(hook.zoomedMax)) hook.zoomedMax = timeFormat(hook.zoomedMax);
	              }
	            });
	          } else if(key === 'time') {
	            if(typeof val.value === 'object') {
	              val.value = timeFormat(val.value);
	            }
	            if(typeof val.start === 'object') {
	              val.start = timeFormat(val.start);
	            }
	            if(typeof val.end === 'object') {
	              val.end = timeFormat(val.end);
	            }
	            if(typeof val.startSelected === 'object') {
	              val.startSelected = timeFormat(val.startSelected);
	            }
	            if(typeof val.endSelected === 'object') {
	              val.endSelected = timeFormat(val.endSelected);
	            }
	          }
	          if(isPlainObject(val)) {
	            flattened[key] = flattenDates(val, timeFormat);
	          } else {
	            flattened[key] = val;
	          }
	        });
	        return flattened;
	      }
	
	      /*
	       * Defers a function
	       * @param {Function} func
	       */
	      var defer = function(func) {
	        setTimeout(func, 1);
	      };
	
	      /*
	       * Defers a function
	       * @param {Function} func
	       */
	      var delay = function(func, delay) {
	        return setTimeout(func, delay);
	      };
	
	      var clearDelay = function(delayId) {
	        return clearTimeout(delayId);
	      };
	
	      /*
	       * Creates a hashcode for a string or array
	       * @param {String|Array} str
	       * @return {Number} hashCode
	       */
	      var hashCode = function(str) {
	        if(!isString(str)) {
	          str = JSON.stringify(str);
	        }
	        var hash = 0;
	        var size = str.length;
	        var c;
	        if(size === 0) {
	          return hash;
	        }
	        for(var i = 0; i < size; i += 1) {
	          c = str.charCodeAt(i);
	          hash = (hash << 5) - hash + c;
	          hash = hash & hash; // Convert to 32bit integer
	        }
	        return hash.toString();
	      };
	
	
	      /*
	       * Converts D3 nest array into the object with key-value pairs, recursively
	       * @param {Array} arr - array like this [{key: k, values: [a, b, ...]}, {...} ... {...}]
	       * @return {Object} object like this {k: [a, b, ...], ...}
	       */
	      //
	      var nestArrayToObj = function(arr) {
	        if(!arr || !arr.length || !arr[0].key) return arr;
	        var res = {};
	        for(var i = 0; i < arr.length; i++) {
	          res[arr[i].key] = nestArrayToObj(arr[i].values);
	        };
	        return res;
	      }
	
	
	      var interpolateVector = function(){
	          
	      }
	
	      /**
	       * interpolates the specific value 
	       * @param {Array} items -- an array of items, sorted by "dimTime", filtered so that no item[which] is null
	       * @param {String} use -- a use of hook that wants to interpolate. can be "indicator" or "property" or "constant"
	       * @param {String} which -- a hook pointer to indicator or property, e.g. "lex"
	       * @param {Number} next -- an index of next item in "items" array after the value to be interpolated. if omitted, then calculated here, but it's expensive
	       * @param {String} dimTime -- a pointer to time dimension, usually "time"
	       * @param {Date} time -- reference point for interpolation. here the valus is to be found
	       * @param {String} method refers to which formula to use. "linear" or "exp". Falls back to "linear" if undefined
	       * @param {Boolean} extrapolate indicates if we should use zero-order extrapolation outside the range of available data
	       * @returns {Number} interpolated value
	       */
	      var interpolatePoint = function(items, use, which, next, dimTime, time, method, extrapolate){
	
	          
	        if(!items || items.length === 0) {
	          warn('interpolatePoint failed because incoming array is empty. It was ' + which);
	          return null;
	        }
	        // return constant for the use of "constant"
	        if(use === 'constant') return which;
	          
	        // zero-order interpolation for the use of properties
	        if(use === 'property') return items[0][which];
	
	        // the rest is for the continuous measurements
	          
	        if (extrapolate){
	          // check if the desired value is out of range. 0-order extrapolation
	          if(time - items[0][dimTime] <= 0) return items[0][which];    
	          if(time - items[items.length - 1][dimTime] >= 0) return items[items.length - 1][which];
	        } else {
	          // no extrapolation according to Ola's request
	          if(time < items[0][dimTime] || time > items[items.length - 1][dimTime]) return null;
	        }
	          
	        if(!next && next !== 0) next = d3.bisectLeft(items.map(function(m){return m[dimTime]}), time);
	          
	        if(next === 0) return items[0][which];
	              
	        //return null if data is missing
	        if(items[next]===undefined || items[next][which] === null || items[next - 1][which] === null || items[next][which] === "") {
	          warn('interpolatePoint failed because next/previous points are bad in ' + which);
	          return null;
	        }
	          
	
	        //do the math to calculate a value between the two points
	        var result = interpolator[method||"linear"](
	          items[next - 1][dimTime],
	          items[next][dimTime],
	          items[next - 1][which],
	          items[next][which],
	          time
	        );
	
	        // cast to time object if we are interpolating time
	        if(which === dimTime) result = new Date(result);
	        if(isNaN$1(result)) {
	            warn('interpolatePoint failed because result is NaN. It was ' + which);
	            result = null;
	        }
	          
	        return result;
	
	      }
	
	
	      /*
	       * Performs an ajax request
	       * @param {Object} options
	       * @param {String} className
	       * @return {Boolean}
	       */
	      var ajax = function(options) {
	        var request = new XMLHttpRequest();
	        request.open(options.method, options.url, true);
	        if(options.method === 'POST' && !options.json) {
	          request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
	        } else if(options.method === 'POST' && options.json) {
	          request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
	        }
	        request.onload = function() {
	          if(request.status >= 200 && request.status < 400) {
	            // Success!
	            var data = options.json ? JSON.parse(request.responseText) : request.responseText;
	            if(options.success) {
	              options.success(data);
	            }
	          } else {
	            if(options.error) {
	              options.error();
	            }
	          }
	        };
	        request.onerror = function() {
	          if(options.error) {
	            options.error();
	          }
	        };
	        request.send(options.data);
	      };
	
	      /*
	       * Performs a GET http request
	       */
	      var get = function(url, pars, success, error, json) {
	        pars = pars || [];
	        forEach(pars, function(value, key) {
	          pars.push(key + '=' + value);
	        });
	        url = pars.length ? url + '?' + pars.join('&') : url;
	        ajax({
	          method: 'GET',
	          url: url,
	          success: success,
	          error: error,
	          json: json
	        });
	      };
	
	      /*
	       * Performs a POST http request
	       */
	      var post = function(url, pars, success, error, json) {
	        ajax({
	          method: 'POST',
	          url: url,
	          success: success,
	          error: error,
	          json: json,
	          data: pars
	        });
	      };
	
	      /**
	       * Make function memoized
	       * @param {Function} fn
	       * @returns {Function}
	       */
	      var memoize = function(fn) {
	        return function() {
	          var args = Array.prototype.slice.call(arguments);
	          var hash = '';
	          var i = args.length;
	          var currentArg = null;
	
	          while(i--) {
	            currentArg = args[i];
	            hash += (currentArg === Object(currentArg)) ? JSON.stringify(currentArg) : currentArg;
	            fn.memoize || (fn.memoize = {});
	          }
	
	          return(hash in fn.memoize) ? fn.memoize[hash] : fn.memoize[hash] = fn.apply(this, args);
	        };
	      };
	
	      // Returns a function, that, as long as it continues to be invoked, will not
	      // be triggered. The function will be called after it stops being called for
	      // N milliseconds. If `immediate` is passed, trigger the function on the
	      // leading edge, instead of the trailing.
	      var debounce = function(func, wait, immediate) {
	        var timeout;
	        return function() {
	          var context = this,
	            args = arguments;
	          var later = function() {
	            timeout = null;
	            if(!immediate) func.apply(context, args);
	          };
	          var callNow = immediate && !timeout;
	          clearTimeout(timeout);
	          timeout = setTimeout(later, wait);
	          if(callNow) func.apply(context, args);
	        }
	      };
	
	      var isTouchDevice = function() {
	        return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
	      };
	
	      //return a pruneed tree
	      var pruneTree = function(tree, filterCallback) {
	        var filteredTree = {};
	        var filteredChildrens = [];
	        if(tree.hasOwnProperty("children")) {
	          filteredChildrens = tree.children.map(function(childrenTree) {
	            return pruneTree(childrenTree, filterCallback);
	          }).filter(function(childrenTree) {
	            return Object.keys(childrenTree).length !== 0;
	          });
	        }
	        if(filteredChildrens.length != 0 || filterCallback(tree)) {
	          filteredTree["id"] = tree.id;
	        }
	        if(filteredChildrens.length != 0) {
	          filteredTree["children"] = filteredChildrens;
	        }
	        return filteredTree;
	      };
	
	      var setIcon = function(element, icon) {
	        element.selectAll('*').remove();
	        element.node().appendChild(
	          element.node().ownerDocument.importNode(
	            new DOMParser().parseFromString(
	              icon, 'application/xml').documentElement, true)
	        );
	        return element;
	      };
	
	      //http://stackoverflow.com/questions/26049488/how-to-get-absolute-coordinates-of-object-inside-a-g-group
	      function makeAbsoluteContext(element, svgDocument) {
	        return function(x,y) {
	          var offset = svgDocument.getBoundingClientRect();
	          var matrix = element.getScreenCTM();
	          return {
	            x: (matrix.a * x) + (matrix.c * y) + matrix.e - offset.left,
	            y: (matrix.b * x) + (matrix.d * y) + matrix.f - offset.top
	          };
	        };
	      }
	
	var utils = Object.freeze({
	        uniqueId: uniqueId,
	        isElement: isElement,
	        isArray: isArray,
	        isObject: isObject,
	        isDate: isDate,
	        isString: isString,
	        isNaN: isNaN$1,
	        isNumber: isNumber,
	        isPlainObject: isPlainObject,
	        arrayEquals: arrayEquals,
	        comparePlainObjects: comparePlainObjects,
	        getViewportPosition: getViewportPosition,
	        findScrollableAncestor: findScrollableAncestor,
	        roundStep: roundStep,
	        strToFloat: strToFloat,
	        forEach: forEach,
	        extend: extend,
	        deepExtend: deepExtend,
	        merge: merge,
	        clone: clone,
	        deepClone: deepClone,
	        without: without,
	        unique: unique,
	        uniqueLast: uniqueLast,
	        find: find,
	        filter: filter,
	        filterAny: filterAny,
	        matchAny: matchAny,
	        preventAncestorScrolling: preventAncestorScrolling,
	        mapRows: mapRows,
	        radiusToArea: radiusToArea,
	        areaToRadius: areaToRadius,
	        timeStamp: timeStamp,
	        warn: warn,
	        groupCollapsed: groupCollapsed,
	        groupEnd: groupEnd,
	        error: error$1,
	        countDecimals: countDecimals,
	        addClass: addClass,
	        removeClass: removeClass,
	        classed: classed,
	        hasClass: hasClass,
	        throttle: throttle,
	        keys: keys,
	        values: values,
	        arrayMin: arrayMin,
	        arrayMax: arrayMax,
	        arrayMean: arrayMean,
	        arraySum: arraySum,
	        arrayMedian: arrayMedian,
	        arrayLast: arrayLast,
	        diffObject: diffObject,
	        flattenDefaults: flattenDefaults,
	        flattenDates: flattenDates,
	        defer: defer,
	        delay: delay,
	        clearDelay: clearDelay,
	        hashCode: hashCode,
	        nestArrayToObj: nestArrayToObj,
	        interpolateVector: interpolateVector,
	        interpolatePoint: interpolatePoint,
	        ajax: ajax,
	        get: get,
	        post: post,
	        memoize: memoize,
	        debounce: debounce,
	        isTouchDevice: isTouchDevice,
	        pruneTree: pruneTree,
	        setIcon: setIcon,
	        makeAbsoluteContext: makeAbsoluteContext
	      });
	
	      function Promise(resolver) {
	        if(!(this instanceof Promise)) {
	          return new Promise(resolver);
	        }
	        this.status = 'pending';
	        this.value;
	        this.reason;
	        // then may be called multiple times on the same promise
	        this._resolves = [];
	        this._rejects = [];
	        if(isFn(resolver)) {
	          resolver(this.resolve.bind(this), this.reject.bind(this));
	        }
	        return this;
	      }
	
	      Promise.prototype.then = function(resolve, reject) {
	        var next = this._next || (this._next = Promise());
	        var status = this.status;
	        var x;
	        if('pending' === status) {
	          isFn(resolve) && this._resolves.push(resolve);
	          isFn(reject) && this._rejects.push(reject);
	          return next;
	        }
	        if('resolved' === status) {
	          if(!isFn(resolve)) {
	            next.resolve(resolve);
	          } else {
	      //      try {
	              x = resolve(this.value);
	              resolveX(next, x);
	      //      } catch(e) {
	      //        this.reject(e);
	      //      }
	          }
	          return next;
	        }
	        if('rejected' === status) {
	          if(!isFn(reject)) {
	            next.reject(reject);
	          } else {
	            try {
	              x = reject(this.reason);
	              resolveX(next, x);
	            } catch(e) {
	              this.reject(e);
	            }
	          }
	          return next;
	        }
	      };
	      Promise.prototype.resolve = function(value) {
	        if('rejected' === this.status) {
	          throw Error('Illegal call.');
	        }
	        this.status = 'resolved';
	        this.value = value;
	        this._resolves.length && fireQ(this);
	        return this;
	      };
	      Promise.prototype.reject = function(reason) {
	        if('resolved' === this.status) {
	          throw Error('Illegal call. ' + reason);
	        }
	        this.status = 'rejected';
	        this.reason = reason;
	        this._rejects.length && fireQ(this);
	        return this;
	      };
	      // shortcut of promise.then(undefined, reject)
	      Promise.prototype.catch = function(reject) {
	        return this.then(void 0, reject);
	      };
	      // return a promise with another promise passing in
	      Promise.cast = function(arg) {
	        var p = Promise();
	        if(arg instanceof Promise) {
	          return resolvePromise(p, arg);
	        } else {
	          return Promise.resolve(arg);
	        }
	      };
	      // return a promise which resolved with arg
	      // the arg maybe a thanable object or thanable function or other
	      Promise.resolve = function(arg) {
	        var p = Promise();
	        if(isThenable(arg)) {
	          return resolveThen(p, arg);
	        } else {
	          return p.resolve(arg);
	        }
	      };
	      // accept a promises array,
	      // return a promise which will resolsed with all promises's value,
	      // if any promise passed rejectd, the returned promise will rejected with the same reason
	      Promise.all = function(promises) {
	        var len = promises.length;
	        var promise = Promise();
	        var r = [];
	        var pending = 0;
	        var locked;
	        var test = promises;
	        //modified
	        forEach(promises, function(p, i) {
	          p.then(function(v) {
	            r[i] = v;
	            if((pending += 1) === len && !locked) {
	              promise.resolve(r);
	            }
	          }, function(e) {
	            locked = true;
	            promise.reject(e);
	          });
	        });
	        return promise;
	      };
	      // accept a promises array,
	      // return a promise which will resolsed with the first resolved promise passed,
	      // if any promise passed rejectd, the returned promise will rejected with the same reason
	      Promise.any = function(promises) {
	        var promise = Promise();
	        var called;
	        //modified
	        forEach(promises, function(p, i) {
	          p.then(function(v) {
	            if(!called) {
	              promise.resolve(v);
	              called = true;
	            }
	          }, function(e) {
	            called = true;
	            promise.reject(e);
	          });
	        });
	        return promise;
	      };
	      // return a promise which reject with reason
	      // reason must be an instance of Error object
	      Promise.reject = function(reason) {
	        if(!(reason instanceof Error)) {
	          throw Error('reason must be an instance of Error');
	        }
	        var p = Promise();
	        p.reject(reason);
	        return p;
	      };
	
	      function resolveX(promise, x) {
	        if(x === promise) {
	          promise.reject(new Error('TypeError'));
	        }
	        if(x instanceof Promise) {
	          return resolvePromise(promise, x);
	        } else if(isThenable(x)) {
	          return resolveThen(promise, x);
	        } else {
	          return promise.resolve(x);
	        }
	      }
	
	      function resolvePromise(promise1, promise2) {
	        var status = promise2.status;
	        if('pending' === status) {
	          promise2.then(promise1.resolve.bind(promise1), promise1.reject.bind(promise1));
	        }
	        if('resolved' === status) {
	          promise1.resolve(promise2.value);
	        }
	        if('rejected' === status) {
	          promise1.reject(promise2.reason);
	        }
	        return promise;
	      }
	
	      function resolveThen(promise, thanable) {
	        var called;
	        var resolve = once(function(x) {
	          if(called) {
	            return;
	          }
	          resolveX(promise, x);
	          called = true;
	        });
	        var reject = once(function(r) {
	          if(called) {
	            return;
	          }
	          promise.reject(r);
	          called = true;
	        });
	        try {
	          thanable.then.call(thanable, resolve, reject);
	        } catch(e) {
	          if(!called) {
	            throw e;
	          } else {
	            promise.reject(e);
	          }
	        }
	        return promise;
	      }
	
	      function fireQ(promise) {
	        var status = promise.status;
	        var queue = promise['resolved' === status ? '_resolves' : '_rejects'];
	        var arg = promise['resolved' === status ? 'value' : 'reason'];
	        var fn;
	        var x;
	        while(fn = queue.shift()) {
	          x = fn.call(promise, arg);
	          x && resolveX(promise._next, x);
	        }
	        return promise;
	      }
	
	      function isFn(fn) {
	        return 'function' === type(fn);
	      }
	
	      function type(obj) {
	        var o = {};
	        return o.toString.call(obj).replace(/\[object (\w+)\]/, '$1').toLowerCase();
	      }
	
	      function isThenable(obj) {
	        return obj && obj.then && isFn(obj.then);
	      }
	
	      function once(fn) {
	        var called;
	        var r;
	        return function() {
	          if(called) {
	            return r;
	          }
	          called = true;
	          return r = fn.apply(this, arguments);
	        };
	      }
	
	      var initializing = false;
	      var fnTest = /xyz/.test(function() {
	        xyz;
	      }) ? /\b_super\b/ : /.*/;
	
	      function extend$1(name, extensions) {
	
	        //in case there are two args
	        extensions = arguments.length === 1 ? name : extensions;
	        var _super = this.prototype;
	        initializing = true;
	        var prototype = new this();
	        initializing = false;
	
	        forEach(extensions, function(method, name) {
	          if(typeof extensions[name] === 'function' && typeof _super[name] === 'function' && fnTest.test(extensions[name])) {
	            prototype[name] = function(name, fn) {
	              return function() {
	                var tmp = this._super;
	                this._super = _super[name];
	                var ret = fn.apply(this, arguments);
	                this._super = tmp;
	                return ret;
	              };
	            }(name, extensions[name]);
	          } else {
	            prototype[name] = method;
	          }
	        });
	
	        function Class() {
	          if(!initializing && this.init) {
	            this.init.apply(this, arguments);
	          }
	        }
	
	        // Populate our constructed prototype object
	        Class.prototype = prototype;
	        Class.prototype.constructor = Class;
	        Class.extend = extend$1;
	
	        Class._collection = {};
	        Class.register = function(name, code) {
	          if(typeof this._collection[name] !== 'undefined') {
	            warn('"' + name + '" is already registered. Overwriting...');
	          }
	          this._collection[name] = code;
	        };
	
	        Class.unregister = function(name) {
	          this._collection[name] = void 0;
	        };
	
	        Class.getCollection = function() {
	          return this._collection;
	        };
	
	        //define a method or field in this prototype
	        Class.define = function(name, value) {
	          this.prototype[name] = value;
	        };
	
	        //get an item of the collection from this class
	        Class.get = function(name, silent) {
	          if(this._collection.hasOwnProperty(name)) {
	            return this._collection[name];
	          }
	          if(!silent) {
	            warn('"' + name + '" was not found.');
	          }
	          return false;
	        };
	        //register extension by name
	        if(arguments.length > 1 && this.register) {
	          this.register(name, Class);
	        }
	        return Class;
	      }
	
	      var Class = function() {};
	      Class.extend = extend$1;
	
	      /**
	       * Initializes the reader.
	       * @param {Object} reader_info Information about the reader
	       */
	      var Reader = Class.extend({
	        init: function(reader_info) {
	          this._name = this._name || reader_info.reader;
	          this._data = reader_info.data || [];
	          this._basepath = this._basepath || reader_info.path || null;
	          this._parsers = reader_info.parsers;
	
	          if(this._parsers) {
	            this._data = mapRows(this._data, this._parsers);
	          }
	        },
	
	        /**
	         * Reads from source
	         * @param {Array} queries Queries to be performed
	         * @param {String} language language
	         * @returns a promise that will be resolved when data is read
	         */
	        read: function(queries, language) {
	          return new Promise.resolve();
	        },
	
	        /**
	         * Gets the data
	         * @returns all data
	         */
	        getData: function() {
	          return this._data;
	        }
	      });
	
	      var Data = Class.extend({
	
	        init: function() {
	          this._collection = {};
	          this._collectionPromises = {};// stores promises, making sure we don't do one calulation twice 
	        },
	
	        /**
	         * Loads resource from reader or cache
	         * @param {Array} query Array with queries to be loaded
	         * @param {String} language Language
	         * @param {Object} reader Which reader to use - data reader info
	         * @param {*} evts ?
	         */
	        load: function(query, language, reader, evts) {
	          var _this = this;
	          var promise = new Promise();
	          var wait = new Promise().resolve();
	          var cached = query === true ? true : this.isCached(query, language, reader);
	          var loaded = false;
	          //if result is cached, dont load anything
	          if(!cached) {
	            timeStamp('Vizabi Data: Loading Data');
	            if(evts && typeof evts.load_start === 'function') {
	              evts.load_start();
	            }
	            wait = new Promise();
	            this.loadFromReader(query, language, reader).then(function(queryId) {
	              loaded = true;
	              cached = queryId;
	              wait.resolve();
	            }, function(err) {
	              warn(err);
	              wait.reject();
	            });
	          }
	          wait.then(function() {
	            //pass the data forward
	            var data = _this._collection[cached].data;
	            //not loading anymore
	            if(loaded && evts && typeof evts.load_end === 'function') {
	              evts.load_end();
	            }
	            promise.resolve(cached);
	          }, function() {
	            //not loading anymore
	            if(loaded && evts && typeof evts.load_end === 'function') {
	              evts.load_end();
	            }
	            promise.reject();
	          });
	          return promise;
	        },
	
	        /**
	         * Loads resource from reader
	         * @param {Array} query Array with queries to be loaded
	         * @param {String} lang Language
	         * @param {Object} reader Which reader to use. E.g.: "json"
	         * @param {String} path Where data is located
	         */
	        loadFromReader: function(query, lang, reader) {
	          var _this = this;
	          var promise = new Promise();
	          var reader_name = reader.reader;
	          var queryId = hashCode([
	            query,
	            lang,
	            reader
	          ]);
	
	          // joining multiple queries
	          // create a queue which this datamanager writes all queries to
	          this.queryQueue = this.queryQueue || [];
	          this.queryQueue.push({ query: query, queryId: queryId, promise: promise, reader: reader});
	
	          // wait one execution round for the queue to fill up
	          defer(function() {
	            // now the query queue is filled with all queries from one execution round
	
	            var mergedQueries = [];
	            var willExecute = false;
	
	            // check every query in the queue
	            _this.queryQueue = _this.queryQueue.filter(function(queueItem) {
	              if (queueItem.query == query) {
	                // Query is still in the queue so this is the first deferred query with same requested rows (where & group) to reach here. 
	                // This will be the base query which will be executed; It will be extended by other queries in the queue.
	                mergedQueries.push(queueItem);
	                willExecute = true;
	
	                // remove so that other queries won't merge it
	                return false;
	              } else {
	                // check if the requested rows are similar
	                if (comparePlainObjects(queueItem.query.where, query.where)
	                 && comparePlainObjects(queueItem.query.grouping, query.grouping)
	                  ) {
	
	                  // if so, merge the selects to the base query
	                  Array.prototype.push.apply(query.select, queueItem.query.select);
	                  // merge parsers so the reader can parse the newly added columns
	                  extend(reader.parsers, queueItem.reader.parsers);
	                  
	                  reader.parsers[_this.getAvailableDimension(query, "key")] = function(d){return ""+d};
	
	                  // include query's promise to promises for base query
	                  mergedQueries.push(queueItem);
	
	                  // remove queueItem from queue as it's merged in the current query
	                  return false;
	                }
	              } 
	              // otherwise keep it in the queue, so it can be joined with another query
	              return true;
	            });
	
	            if (!willExecute) return;
	
	            // make the promise a collection of all promises of merged queries
	            // promise = promises.length ? Promise.all(promises) : new Promise.resolve();
	
	            // remove double columns from select (resulting from merging)
	            // no double columns in formatter because it's an object, extend would've overwritten doubles
	            query.select = unique(query.select);
	
	            //create hash for dimensions only query
	            var dim, dimQ, dimQId = 0; 
	            dimQ = clone(query);
	            dim = keys(dimQ.grouping);
	            if (arrayEquals(dimQ.select.slice(0, dim.length), dim)) {
	              dimQ.select = dim;
	              dimQId = hashCode([
	                dimQ,
	                lang,
	                reader
	              ]);
	            }
	
	            // Create a new reader for this query
	            var readerClass = Reader.get(reader_name);
	            if (!readerClass) {
	              throw new Error('Unknown reader: ' + reader_name);
	            }
	            var r = new readerClass(reader);
	
	            // execute the query with this reader
	            r.read(query, lang).then(function() {
	
	                //success reading
	                var values = r.getData();
	                var q = query;
	
	                //make sure all queried is returned
	                values = values.map(function(d) {
	                  for(var i = 0; i < q.select.length; i += 1) {
	                    var col = q.select[i];
	                    if(typeof d[col] === 'undefined') {
	                      d[col] = null;
	                    }
	                  }
	                  return d;
	                });
	
	                _this._collection[queryId] = {};
	                _this._collectionPromises[queryId] = {};
	                var col = _this._collection[queryId];
	                col.data = values;
	                col.valid = {};
	                col.nested = {};
	                col.unique = {};
	                col.limits = {};
	                col.limitsPerFrame = {};
	                col.frames = {};
	                col.haveNoDataPointsPerKey = {};
	                col.query = q;
	                // col.sorted = {}; // TODO: implement this for sorted data-sets, or is this for the server/(or file reader) to handle?
	
	                // returning the query-id/values of the merged query without splitting the result up again per query
	                // this is okay because the collection-object above will only be passed by reference to the cache and this will not take up more memory. 
	                // On the contrary: it uses less because there is no need to duplicate the key-columns.
	                forEach(mergedQueries, function(mergedQuery) {
	                  // set the cache-location for each seperate query to the combined query's cache
	                  _this._collection[mergedQuery.queryId] = _this._collection[queryId];
	                  _this._collectionPromises[mergedQuery.queryId] = _this._collectionPromises[queryId];
	                  // resolve the query
	                  mergedQuery.promise.resolve(mergedQuery.queryId);
	                });
	        
	                //create cache record for dimension only query
	                if(dimQId !== 0) {
	                  _this._collection[dimQId] = _this._collection[queryId];              
	                }
	                //promise.resolve(queryId);
	              }, //error reading
	              function(err) { 
	                forEach(mergedQueries, function(mergedQuery) {
	                  mergedQuery.promise.reject(err);
	                });
	              }
	            );
	
	          })
	
	          return promise;
	        },
	
	        /**
	         * get data
	         */
	        get: function(queryId, what, whatId, args) {
	          // if not specified data from what query, return nothing
	          if(!queryId) return warn("Data.js 'get' method doesn't like the queryId you gave it: " + queryId);
	
	          // if they want data, return the data
	          if(!what || what == 'data') {
	            return this._collection[queryId]['data'];
	          }
	
	          // if they didn't give an instruction, give them the whole thing
	          // it's probably old code which modifies the data outside this class
	          // TODO: move these methods inside (e.g. model.getNestedItems())
	          if (!whatId) {
	            return this._collection[queryId][what];
	          }
	
	          // if they want a certain processing of the data, see if it's already in cache
	          var id = (typeof whatId == "string")? whatId : JSON.stringify(whatId);
	          if(this._collection[queryId][what][id]) {
	            return this._collection[queryId][what][id];
	          }
	
	          // if it's not cached, process the data and then return it
	          switch(what) {
	            case 'unique':
	              this._collection[queryId][what][id] = this._getUnique(queryId, whatId);
	              break;
	            case 'valid':
	              this._collection[queryId][what][id] = this._getValid(queryId, whatId);
	              break;
	            case 'limits':
	              this._collection[queryId][what][id] = this._getLimits(queryId, whatId);
	              break;
	            case 'nested':     
	              this._collection[queryId][what][id] = this._getNested(queryId, whatId);
	              break;
	            case 'haveNoDataPointsPerKey':     
	              //do nothing. no caching is available for this option, served directly from collection
	              break;
	          }
	          return this._collection[queryId][what][id];
	        },
	
	        getConceptprops: function(which){
	            if(!globals.conceptprops || !globals.conceptprops.indicatorsDB) return {};
	            return which ? globals.conceptprops.indicatorsDB[which] : globals.conceptprops.indicatorsDB;
	        },
	          
	        /**
	         * Gets the concept properties of all hooks
	         * @returns {Object} concept properties
	         */
	        getIndicatorsTree: function() {
	          return globals.conceptprops && globals.conceptprops.indicatorsTree ? globals.conceptprops.indicatorsTree : {};
	        },
	
	        getFrames: function(queryId, framesArray) {
	          var _this = this;
	          var whatId = framesArray[0] + " - " + framesArray[framesArray.length-1];
	          if (!this._collectionPromises[queryId][whatId]) {
	            this._collectionPromises[queryId][whatId] = {
	              queue: this.framesQueue(framesArray),
	              promise: null
	            };
	          }
	          if (this._collectionPromises[queryId][whatId] && this._collectionPromises[queryId][whatId]["promise"] instanceof Promise) {
	            return this._collectionPromises[queryId][whatId]["promise"];
	          } else {
	            this._collectionPromises[queryId][whatId]["promise"] = new Promise(function (resolve, reject) {
	              if (!queryId) reject(warn("Data.js 'get' method doesn't like the queryId you gave it: " + queryId));
	              _this._getFrames(queryId, whatId, framesArray).then(function (frames) {
	                _this._collection[queryId]["frames"][whatId] = frames;
	                resolve(_this._collection[queryId]["frames"][whatId]);
	              });
	            })
	           
	          }
	          return this._collectionPromises[queryId][whatId]["promise"];
	        },
	
	        getFrame: function(queryId, framesArray, neededFrame) {
	          //can only be called after getFrames()
	          var _this = this;
	          var query = _this._collection[queryId].query;
	          var whatId = framesArray[0] + " - " + framesArray[framesArray.length-1];
	          var columns = query.select.filter(function(f){return f != "municipality" && f != "year" && f !== "_default"});
	
	          return new Promise(function(resolve, reject) {
	            if (_this._collection[queryId]["frames"][whatId] && _this._collection[queryId]["frames"][whatId][neededFrame]) {
	              resolve(_this._collection[queryId]["frames"][whatId]);
	            } else {
	              _this._collectionPromises[queryId][whatId]["queue"].forceFrame(neededFrame, function() {
	                resolve(_this._collection[queryId]["frames"][whatId]);
	              });
	            }
	          });
	        },
	        /**
	         * set priority for generate each year frame
	         * @param framesArray
	         * @returns {*}
	         */
	        framesQueue: function(framesArray) {
	          return new function(){
	            this.callbacks = {};
	            this.forcedQueue = [];
	            this.queue = framesArray.slice(0); //clone array
	              
	            //put the last element to the start of the queue because we are likely to need it first
	            this.queue.splice(0, 0, this.queue.splice(this.queue.length - 1, 1)[0]);
	            this.key = 0;
	              
	            // returns the next frame in a queue
	            this.getNext = function() {
	              var queue = this;
	              var frameName = null;
	              if (this.forcedQueue.length > 0) {
	                frameName = this.forcedQueue.shift();
	              } else {
	                if (this.queue.length == 0) return false;
	                if (this.forcedQueue.length == 0 && this.key >= this.queue.length - 1) {
	                  this.key = 0;
	                }
	                frameName = this.queue.splice(this.key, 1).pop();
	              }
	              if (!this.callbacks[frameName]) {
	                this.callbacks[frameName] = [];
	              }
	              var frameComplete = function(frameName) { //function called after build each frame with name of frame build
	                if (queue.callbacks[frameName].length > 0) {
	                  for (var  i = 0; i < queue.callbacks[frameName].length; i++) {
	                    queue.callbacks[frameName][i]();
	                  }
	                  //delete queue.callbacks[frameName];
	                }
	              };
	              return {
	                frameName: frameName,
	                callback: frameComplete
	              };
	            };
	              
	            // force the particular frame up the queue
	            this.forceFrame = function(frameName, cb) {
	              var objIndexOf = function(obj, need) {
	                var search = need.toString();
	                var index = -1;
	                for(var i = 0, len = obj.length; i < len; i++) {
	                  if (obj[i].toString() == search) {
	                    index = i;
	                    break;
	                  }
	                }
	                return index;
	              };
	              if (this.callbacks[frameName]) {
	
	                this.callbacks[frameName].push(cb);
	              } else {
	                var newKey = objIndexOf(this.queue, frameName);//this.queue.indexOf(frameName.toString());
	                if (newKey !== -1) {
	                  this.forcedQueue.unshift(this.queue.splice(newKey, 1).pop());
	                  if (typeof cb === "function") {
	                    if (typeof this.callbacks[frameName] != "object") {
	                      this.callbacks[frameName] = [];
	                    }
	                    this.callbacks[frameName].push(cb);
	                  }
	                  this.key = newKey; //set key to next year after gorced element (preload if user click play)
	                } else {
	                  if (typeof this.callbacks[frameName] === "object") {
	                    this.callbacks[frameName].push(cb);
	                  } else {
	                    this.callbacks[frameName] = [cb];
	                  }
	                }
	              }
	            }
	          }();
	        },
	        
	        
	        // arg = "key" or "time"
	        getAvailableDimension: function(query, arg){
	          
	          // HARD CODED KEY/TIME. Added "flexibility" for StatsSA assignment. 
	          // This should be replaced by getting key/time dimensions from query or model.
	          var possibleDimensions = {
	            key: ["geo","municipality","province","district"],
	            time: ["time","year"]
	          }
	
	          for (var i = 0; i<possibleDimensions[arg].length; i++) {
	            if (query.select.indexOf(possibleDimensions[arg][i]) !== -1)
	              return possibleDimensions[arg][i];
	          }
	          
	        },
	
	        /**
	         * Get regularised dataset (where gaps are filled)
	         * @param {Number} queryId hash code for query
	         * @param {Array} framesArray -- array of keyframes across animatable
	         * @returns {Object} regularised dataset, nested by [animatable, column, key]
	         */
	        _getFrames: function(queryId, whatId, framesArray) {
	          var _this = this;
	
	          if (!_this._collection[queryId]["frames"][whatId]) {
	            _this._collection[queryId]["frames"][whatId] = {};
	          }
	          return new Promise(function(resolve, reject) {
	
	            //TODO: thses should come from state or from outside somehow
	            // FramesArray in the input contains the array of keyframes in animatable dimension.
	            // Example: array of years like [1800, 1801 … 2100]
	            // these will be the points where we need data
	            // (some of which might already exist in the set. in regular datasets all the points would exist!)
	
	            // Check if query.where clause is missing a time field
	
	            var indicatorsDB = _this.getConceptprops();
	
	            if(!indicatorsDB) warn("_getFrames in data.js is missing indicatorsDB, it's needed for gap filling");
	            if(!framesArray) warn("_getFrames in data.js is missing framesArray, it's needed so much");
	
	            var KEY = _this.getAvailableDimension(_this._collection[queryId].query, "key");
	            var TIME = _this.getAvailableDimension(_this._collection[queryId].query, "time");
	
	            var filtered = {};
	            var items, itemsIndex, oneFrame, method, use, next;
	
	            // We _nest_ the flat dataset in two levels: first by “key” (example: geo), then by “animatable” (example: year)
	            // See the _getNested function for more details
	            var nested = _this.get(queryId, 'nested', [KEY, TIME]);
	            var keys = Object.keys(nested);
	
	            // Get the list of columns that are in the dataset, exclude key column and animatable column
	            // Example: [“lex”, “gdp”, “u5mr"]
	            var query = _this._collection[queryId].query;
	            var columns = query.select.filter(function(f){return f != KEY && f != TIME && f !== "_default"});
	
	            var cLength = columns.length;
	            var key, k, column, c;
	
	            for (k = 0; k < keys.length; k++) {
	              filtered[keys[k]] = {};
	              for (c = 0; c < cLength; c++) filtered[keys[k]][columns[c]] = null;
	            }
	            for (c = 0; c < cLength; c++) _this._collection[queryId].haveNoDataPointsPerKey[columns[c]] = {};
	
	            var buildFrame = function(frameName, keys, queryId, callback) {
	                var frame = {};
	
	                if (!query.where[TIME]) {
	                  // The query.where clause doesn't have time field for properties:
	                  // we populate the regular set with a single value (unpack properties into constant time series)
	                  var dataset = _this._collection[queryId].data;
	                  for (c = 0; c < cLength; c++) frame[columns[c]] = {};
	
	                  for (var i = 0; i < dataset.length; i++) {
	                    var d = dataset[i];
	                    for (c = 0; c < cLength; c++) {
	                      frame[columns[c]][d[KEY]] = d[columns[c]];
	                      //check data for properties with missed data. If founded then write key to haveNoDataPointsPerKey with 
	                      //count of broken datapoints  
	                      if(d[columns[c]] == null) {
	                        _this._collection[queryId].haveNoDataPointsPerKey[columns[c]][d[KEY]] = dataset.length;
	                      }
	                    }
	                  }
	
	                } else {
	                  // If there is a time field in query.where clause, then we are dealing with indicators in this request
	
	                  // Put together a template for cached filtered sets (see below what's needed)
	
	                  // Now we run a 3-level loop: across frames, then across keys, then and across data columns (lex, gdp)
	
	                  for (c = 0; c < cLength; c++) frame[columns[c]] = {};
	
	                  for (k = 0; k < keys.length; k++) {
	                    key = keys[k];
	
	                    for (c = 0; c < cLength; c++) {
	                      column = columns[c];
	
	                      //If there are some points in the array with valid numbers, then
	                      //interpolate the missing point and save it to the “clean regular set”
	                      method = indicatorsDB[column] ? indicatorsDB[column].interpolation : null;
	                      use = indicatorsDB[column] ? indicatorsDB[column].use : "indicator";
	
	
	                      // Inside of this 3-level loop is the following:
	                      if (nested[key] && nested[key][frameName] && (nested[key][frameName][0][column] || nested[key][frameName][0][column] === 0)) {
	
	                        // Check if the piece of data for [this key][this frame][this column] exists
	                        // and is valid. If so, then save it into a “clean regular set”
	                        frame[column][key] = nested[key][frameName][0][column];
	
	                      } else if (method === "none") {
	                          
	                        // the piece of data is not available and the interpolation is set to "none"
	                        frame[column][key] = null;
	                          
	                      } else {
	                        // If the piece of data doesn’t exist or is invalid, then we need to inter- or extapolate it
	
	                        // Let’s take a slice of the nested set, corresponding to the current key nested[key]
	                        // As you remember it has the data nested further by frames.
	                        // At every frame the data in the current column might or might not exist.
	                        // Thus, let’s filter out all the frames which don’t have the data for the current column.
	                        // Let’s cache it because we will most likely encounter another gap in the same column for the same key
	                        items = filtered[key][column];
	                        if (items === null) {
	                          var givenFrames = Object.keys(nested[key]);
	                          items = new Array(givenFrames.length);
	                          itemsIndex = 0;
	
	                          for (var z = 0, length = givenFrames.length; z < length; z++) {
	                            oneFrame = nested[key][givenFrames[z]];
	                            if (oneFrame[0][column] || oneFrame[0][column] === 0) items[itemsIndex++] = oneFrame[0];
	                          }
	
	                          //trim the length of the array
	                          items.length = itemsIndex;
	
	                          if (itemsIndex === 0) {
	                            filtered[key][column] = [];
	                          } else {
	                            filtered[key][column] = items;
	                          }
	                            
	                          if(items.length==0) _this._collection[queryId].haveNoDataPointsPerKey[column][key] = items.length;
	                        }
	
	                        // Now we are left with a fewer frames in the filtered array. Let's check its length.
	                        //If the array is empty, then the entire column is missing for the key
	                        //So we let the key have missing values in this column for all frames
	                        if (items && items.length > 0) {
	                          next = null;
	                          frame[column][key] = interpolatePoint(items, use, column, next, TIME, frameName, method);
	                        }
	                      }
	                    } //loop across columns
	                  } //loop across keys
	                }
	                
	                // save the calcualted frame to global datamanager cache
	                _this._collection[queryId]["frames"][whatId][frameName] = frame;
	                
	                // fire the callback
	                if (typeof callback === "function") {
	                  // runs the function frameComplete inside framesQueue.getNext()
	                  callback(frameName); 
	                }
	                
	                // recursively call the buildFrame again, this time for the next frame
	                //QUESTION: FramesArray is probably not needed at this point. queryId and whatId is enough
	                var nextFrame = _this._collectionPromises[queryId][whatId]["queue"].getNext(); 
	                if (nextFrame) {
	                  // defer allows other interactions to squeeze in between buildFrame executions
	                  defer(function() {
	                    buildFrame(nextFrame.frameName, keys, queryId, nextFrame.callback);
	                  });
	                } else {
	                  //this goes to marker.js as a "response"
	                  resolve(_this._collection[queryId]["frames"][whatId]); 
	                }
	            };
	            var nextFrame = _this._collectionPromises[queryId][whatId]["queue"].getNext();
	            if (nextFrame) {
	              buildFrame(nextFrame.frameName, keys, queryId, nextFrame.callback);
	            }
	          });
	        },
	
	
	        _getNested: function(queryId, order) {
	          // Nests are objects of key-value pairs
	          // Example: 
	          // 
	          // order = ["geo", "time"];
	          // 
	          // original_data = [
	          //   { geo: "afg", time: 1800, gdp: 23424, lex: 23}
	          //   { geo: "afg", time: 1801, gdp: 23424, lex: null}
	          //   { geo: "chn", time: 1800, gdp: 23587424, lex: 46}
	          //   { geo: "chn", time: 1801, gdp: null, lex: null}
	          // ];
	          //  
	          // nested_data = {
	          //   afg: {
	          //     1800: {gdp: 23424, lex: 23},
	          //     1801: {gdp: 23424, lex: null}
	          //   }
	          //   chn: {
	          //     1800: {gdp: 23587424, lex: 46 },
	          //     1801: {gdp: null, lex: null }
	          //   }
	          // };
	
	          var nest = d3.nest();
	          for(var i = 0; i < order.length; i++) {
	            nest = nest.key(
	              (function(k) {
	                return function(d) {
	                  return d[k];
	                };
	              })(order[i])
	            );
	          };
	
	          return nestArrayToObj(nest.entries(this._collection[queryId]['data']));
	        },
	          
	
	        _getUnique: function(queryId, attr) {
	          var uniq;
	          var items = this._collection[queryId].data;
	          //if it's an array, it will return a list of unique combinations.
	          if(isArray(attr)) {
	            var values = items.map(function(d) {
	              return clone(d, attr); //pick attrs
	            });
	            uniq = unique(values, function(n) {
	              return JSON.stringify(n);
	            });
	          } //if it's a string, it will return a list of values
	          else {
	            var values = items.map(function(d) {
	              return d[attr];
	            });
	            uniq = unique(values);
	          }
	          return uniq;
	        },
	
	        _getValid: function(queryId, column) {
	          return this._collection[queryId].data.filter(function(f){return f[column] || f[column]===0});
	        },    
	          
	        _getLimits: function(queryId, attr) {
	
	          var items = this._collection[queryId].data;
	          // get only column attr and only rows with number or date
	          var filtered = items.reduce(function(filtered, d) {
	            
	            // check for dates
	            var f = (isDate(d[attr])) ? d[attr] : parseFloat(d[attr]);
	
	            // if it is a number
	            if(!isNaN(f)) {
	              filtered.push(f);
	            }
	
	            //filter
	            return filtered;
	          }, []);
	
	          // get min/max for the filtered rows
	          var min;
	          var max;
	          var limits = {};
	          for(var i = 0; i < filtered.length; i += 1) {
	            var c = filtered[i];
	            if(typeof min === 'undefined' || c < min) {
	              min = c;
	            }
	            if(typeof max === 'undefined' || c > max) {
	              max = c;
	            }
	          }
	          limits.min = min || 0;
	          limits.max = max || 100;
	          return limits;    
	        },
	
	        /**
	         * checks whether this combination is cached or not
	         */
	        isCached: function(query, language, reader) {
	          //encode in hashCode
	          var q = hashCode([
	            query,
	            language,
	            reader
	          ]);
	          //simply check if we have this in internal data
	          if(Object.keys(this._collection).indexOf(q) !== -1) {
	            return q;
	          }
	          return false;
	        }
	      });
	
	      var _freezeAllEvents = false;
	      var _frozenEventInstances = [];
	      var _freezeAllExceptions = {};
	
	      var DefaultEvent = Class.extend({
	
	        source: '',
	        type: 'default',
	
	        init: function(source, type) {
	          this.source = source;
	          if (type) this.type = type;
	        }
	
	      });
	
	      var ChangeEvent = DefaultEvent.extend('change', {
	
	        type: 'change',
	
	        init: function(source) {
	          this._super(source);
	        }
	
	      })
	
	      var EventSource = Class.extend({
	
	        /**
	         * Initializes the event class
	         */
	        init: function() {
	          this._id = this._id || uniqueId('e');
	          this._events = {};
	          //freezing events
	          this._freeze = false;
	          this._freezer = [];
	          this._freezeExceptions = {};
	        },
	
	        /**
	         * Binds a callback function to an event: part 1: split grouped parameters in seperate calls
	         * @param {String} type type of event
	         * @param {String|Array} target path to object the event should be bound to or array of target paths
	         * @param {Function|Array} func function to be bound with event or array with functions
	         */
	        on: function(type, path, func) {
	          
	          // if parameters had to be split up in seperate calls, don't continue with this call
	          if (this.splitEventParameters(type, path, func, this.on))
	            return;
	
	          // get the target model
	          var target = this.traversePath(path);
	          if (!target) return;
	
	          // register the event to this object
	          target._events[type] = target._events[type] || [];
	          if(typeof func === 'function') {
	            target._events[type].push(func);
	          } else {
	            warn('Can\'t bind event \'' + type + '\'. It must be a function.');
	          }
	        },
	
	
	        /**
	         * Unbinds all events associated with a name or a specific one
	         * @param {String|Array} name name of event or array with names
	         */
	        off: function(type, path, func) {
	
	          // if no arguments, unbind all
	          if (arguments.length == 0) {
	            this._events = {};
	            return;
	          }
	
	          // if parameters had to be split up in seperate calls, don't continue with this call
	          if (this.splitEventParameters(type, path, func, this.off))
	            return;
	
	          // get target model
	          var target = this.traversePath(path);
	          if (!target) return;
	
	          // unbind events
	          if(target._events.hasOwnProperty(type)) {
	            // if function not given, remove all events of type
	            if (typeof func === 'undefined') {
	              target._events[type] = [];
	              return;
	            }
	            var index = target._events[type].indexOf(func);
	            if (index > -1) {
	              target._events[type].splice(index, 1);
	            } else {
	              warn('Could not unbind function ' + func.name + '. Function not in bound function list.');
	            }
	          }
	        },
	
	        /**
	         * Split grouped event parameters to seperate calls to given funtion
	         * @param {String|Object|Array} type type of event
	         * @param {String|Array} target path to object the event should be bound to or array of target paths
	         * @param {Function|Array} func function to be bound with event or array with functions
	         * @param {Function} eventFunc function to further process the split up parameters 
	         * @return {Boolean} true if the parameters where split up, false if nothing was split up
	         * eventFunc is mostly arguments.callee but this is deprecated in ECMAscript 5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee
	         */
	        splitEventParameters: function(type, path, func, eventFunc) {
	          var i;
	          var calls = [];
	
	          // multiple at a time, array format: [{type: function}, {'type:path': function}, ... ]
	          // seems redundant but used so that binding-sets won't be turned into models (which happens when it's a pure object). Used e.g. in Tool.init();
	          if(isArray(type)) {
	            for(i = 0; i < type.length; i += 1) {
	              eventFunc.call(this, type[i], func);
	            }
	            return true;
	          }
	
	          //multiple at a time, object format: {type: function, 'type:path': function, ... }
	          if(isObject(type)) {
	            for(i in type) {
	              eventFunc.call(this, i, type[i]);
	            }
	            return true;
	          }
	
	          // type and path are both in type: on('type:path', function)
	          // or
	          // path undefined: on('type', function)
	          if(typeof path === 'function') {
	            func = path; // put callback function in func variable
	            // on('type:path', func)
	            if (type.indexOf(':') !== -1) {
	              var split = type.split(':');  
	              type = split[0];
	              path = split[1];
	            } 
	            // on(type, func)
	            else {
	              path = undefined;
	            }
	            eventFunc.call(this, type, path, func);
	            return true;
	          }
	
	          // bind multiple paths at a time to one function: on(type, [path1, path2], function)
	          if(isArray(path)) {
	            for(i = 0; i < path.length; i += 1) {
	              eventFunc.call(this, type, path[i], func);
	            }
	            return true;
	          }
	
	          //bind multiple functions at the same time to one path: on(type, path, [function1, function2])
	          if(func && isArray(func)) {
	            for(i = 0; i < func.length; i += 1) {
	              eventFunc.call(this, type, path, func[i]);
	            }
	            return true;
	          }   
	          return false;
	        },
	
	        /**
	         * // TODO: if events will not be strictly model-bound, this might have to move to model.
	         * Traverse path down the model tree
	         * @param {String|Array} target path to object that should be returned. Either in string or array form
	         */
	        traversePath: function(path) {
	
	          // if there's no path to traverse
	          if (typeof path === 'undefined' || isArray(path) && path.length == 0) {
	            return this; 
	          }
	
	          // prepare path to array
	          if (typeof path === 'string') {
	            path = path.split('.');
	          }
	          
	          // check if path is an array
	          if (!isArray(path)) {
	            error$1('Path is wrong type. Path should be a string or array but is ' + typeof path + '.');
	            return null;
	          }
	
	          // descent to next child to find target object
	          var currentTarget = path.shift();
	          if (this[currentTarget] === undefined)
	            warn('Can\'t find child "' + currentTarget + '" of the model ' + this._name + '.');
	          else
	            return this.getModelObject(currentTarget).traversePath(path);
	        },
	
	        /**
	         * Triggers an event, adding it to the buffer
	         * @param {String|Array} name name of event or array with names
	         * @param args Optional arguments (values to be passed)
	         */
	        trigger: function(evtType, args) {
	          var i;
	          var size;
	
	          // split up eventType-paremeter for multiple event-triggers
	          if(isArray(evtType)) {
	            for(i = 0, size = evtType.length; i < size; i += 1) {
	              this.trigger(evtType[i], args);
	            }
	            return;
	          }
	
	          // create an event-object if necessary
	          var evt;
	          if ((evtType instanceof DefaultEvent)) {
	            evt = evtType;
	          } else {
	            var eventClass = DefaultEvent.get(evtType, true); // silent
	            if(eventClass) {
	              evt = new eventClass(this);
	            } else {
	              evt = new DefaultEvent(this, evtType);
	            }
	          } 
	
	          // if this eventType has no events registered
	          if(!this._events.hasOwnProperty(evt.type)) {
	            return;
	          }
	
	          // for each function registered to this eventType on this object
	          var _this = this;
	          forEach(this._events[evt.type], function(func) {
	
	            // prepare execution
	            var execute = function() {
	              var msg = 'Vizabi Event: ' + evt.type; // + ' - ' + eventPath;
	              timeStamp(msg);
	              func.apply(_this, [
	                evt,
	                args
	              ]);
	            };
	
	            //TODO: improve readability of freezer code
	            //only execute if not frozen and exception doesnt exist
	            if(_this._freeze || _freezeAllEvents) {
	              //if exception exists for freezing, execute
	              if(_freezeAllEvents && _freezeAllExceptions.hasOwnProperty(evt.type) || !_freezeAllEvents && _this._freeze &&
	                _this._freezeExceptions.hasOwnProperty(evt.type)) {
	                execute();
	              } //otherwise, freeze it
	              else {
	                _this._freezer.push(execute);
	                if(_freezeAllEvents && !_frozenEventInstances[_this._id]) {
	                  _this.freeze();
	                  _frozenEventInstances[_this._id] = _this;
	                }
	              }
	            } else {
	              execute();
	            }
	          })    
	        },
	
	        /**
	         * Prevents all events from being triggered, buffering them
	         */
	        freeze: function(exceptions) {
	          this._freeze = true;
	          if(!exceptions) {
	            return;
	          }
	          if(!isArray(exceptions)) {
	            exceptions = [exceptions];
	          }
	          for(var i = 0; i < exceptions.length; i += 1) {
	            this._freezeExceptions[exceptions[i]] = true;
	          }
	        },
	
	        /**
	         * triggers all frozen events
	         */
	        unfreeze: function() {
	          this._freeze = false;
	          this._freezeExceptions = {};
	          //execute old frozen events
	          while(this._freezer.length) {
	            var execute = this._freezer.shift();
	            execute();
	          }
	        },
	
	        /**
	         * clears all frozen events
	         */
	        clearFrozen: function() {
	          this._freeze = false;
	          this._freezeExceptions = {};
	          this._freezer = [];
	        }
	      });
	
	      EventSource.freezeAll = freezeAll;
	      EventSource.unfreezeAll = unfreezeAll;
	
	      //generic event functions
	      /**
	       * freezes all events
	       */
	      function freezeAll(exceptions) {
	        _freezeAllEvents = true;
	        if(!exceptions) {
	          return;
	        }
	        if(!isArray(exceptions)) {
	          exceptions = [exceptions];
	        }
	        forEach(exceptions, function(e) {
	          _freezeAllExceptions[e] = true;
	        });
	      };
	
	      /**
	       * triggers all frozen events form all instances
	       */
	      function unfreezeAll() {
	        _freezeAllEvents = false;
	        _freezeAllExceptions = {};
	        //unfreeze all instances
	        var keys = Object.keys(_frozenEventInstances);
	        for(var i = 0; i < keys.length; i++) {
	          var instance = _frozenEventInstances[keys[i]];
	          if(!instance) {
	            continue;
	          }
	          instance.unfreeze();
	        }
	        _frozenEventInstances = {};
	      };
	
	      var Intervals = Class.extend({
	
	        /**
	         * Initializes intervals
	         */
	        init: function() {
	          this.intervals = {};
	        },
	
	        /**
	         * Sets an interval
	         * @param {String} name name of interval
	         * @param {Function} func function to be executed
	         * @param {Number} duration duration in milliseconds
	         */
	        setInterval: function(name, func, duration) {
	          this.clearInterval(name);
	          this.intervals[name] = setInterval(func, duration);
	        },
	
	        /**
	         * Clears an interval
	         * @param {String} name name of interval to be removed
	         */
	        clearInterval: function(name) {
	          return name ? clearInterval(this.intervals[name]) : this.clearAllIntervals();
	        },
	
	        /**
	         * Clears all intervals
	         */
	        clearAllIntervals: function() {
	          for(var i in this.intervals) {
	            this.clearInterval(i);
	          }
	        }
	      });
	
	      var _DATAMANAGER = new Data();
	
	      var ModelLeaf = EventSource.extend({
	
	        _name: '',
	        _parent: null,
	        _persistent: true,
	
	        init: function(name, value, parent, binds) {
	
	          // getter and setter for the value
	          Object.defineProperty(this, 'value', {
	            get: this.get,
	            set: this.set
	          });
	          Object.defineProperty(this, 'persistent', {
	            get: function() { return this._persistent; }
	          });
	
	          this._super();
	
	          this._name = name;
	          this._parent = parent;
	          this.value = value;
	          this.on(binds); // after super so there is an .events object
	        },
	
	        // if they want a persistent value and the current value is not persistent, return the last persistent value
	        get: function(persistent) {
	          return (persistent && !this._persistent) ? this._persistentVal : this._val;
	        },
	
	        set: function(val, force, persistent) {
	          if (force || (this._val !== val && JSON.stringify(this._val) !== JSON.stringify(val))) {
	
	            // persistent defaults to true
	            persistent = (typeof persistent !== 'undefined') ? persistent : true;
	       
	            // set leaf properties
	            if (persistent) this._persistentVal = val; // set persistent value if change is persistent.
	            this._val = val;
	            this._persistent = persistent;
	
	            // trigger change event
	            this.trigger(new ChangeEvent(this), this._name);
	          }
	        },
	
	        // duplicate from Model. Should be in a shared parent class.
	        setTreeFreezer: function(freezerStatus) {
	          if (freezerStatus) {
	            this.freeze();
	          } else {
	            this.unfreeze();
	          }
	        }
	
	      })
	
	      var Model = EventSource.extend({
	        /**
	         * Initializes the model.
	         * @param {Object} values The initial values of this model
	         * @param {Object} parent reference to parent
	         * @param {Object} bind Initial events to bind
	         * @param {Boolean} freeze block events from being dispatched
	         */
	        init: function(name, values, parent, bind) {
	          this._type = this._type || 'model';
	          this._id = this._id || uniqueId('m');
	          this._data = {};
	          //holds attributes of this model
	          this._parent = parent;
	          this._name = name;
	          this._ready = false;
	          this._readyOnce = false;
	          //has this model ever been ready?
	          this._loadedOnce = false;
	          this._loading = [];
	          //array of processes that are loading
	          this._intervals = getIntervals(this);
	          //holds the list of dependencies for virtual models
	          this._deps = {
	            parent: [],
	            children: []
	          };
	          //will the model be hooked to data?
	          this._space = {};
	          this._spaceDims = {};
	
	          this._dataId = false;
	          this._limits = {};
	          //stores limit values
	          this._super();
	
	          //initial values
	          if(values) {
	            this.set(values);
	          }
	          // bind initial events
	          // bind after setting, so no events are fired by setting initial values
	          if(bind) {
	            this.on(bind);
	          }
	        },
	
	        /* ==========================
	         * Getters and Setters
	         * ==========================
	         */
	
	        /**
	         * Gets an attribute from this model or all fields.
	         * @param attr Optional attribute
	         * @returns attr value or all values if attr is undefined
	         */
	        get: function(attr) {
	          if(!attr) {
	            return this._data;
	          }
	          if (isModel(this._data[attr]))
	            return this._data[attr];
	          else
	            return this._data[attr].value; // return leaf value
	        },
	
	        /**
	         * Sets an attribute or multiple for this model (inspired by Backbone)
	         * @param attr property name
	         * @param val property value (object or value)
	         * @param {Boolean} force force setting of property to value and triggers set event
	         * @param {Boolean} persistent true if the change is a persistent change
	         * @returns defer defer that will be resolved when set is done
	         */
	        set: function(attr, val, force, persistent) {
	          var setting = this._setting;
	          var attrs;
	          var freezeCall = false; // boolean, indicates if this .set()-call froze the modelTree
	          
	          //expect object as default
	          if(!isPlainObject(attr)) {
	            (attrs = {})[attr] = val;
	          } else {
	            // move all arguments one place
	            attrs = attr;
	            persistent = force;
	            force = val;
	          }
	
	          //we are currently setting the model
	          this._setting = true;
	
	          // Freeze the whole model tree if not frozen yet, so no events are fired while setting
	          if (!this._freeze) {
	            freezeCall = true;
	            this.setTreeFreezer(true);
	          }
	
	          // init/set all given values
	          var newSubmodels = false;
	          for(var a in attrs) {
	            val = attrs[a];
	
	            var bothModel = isPlainObject(val) && this._data[a] instanceof Model;
	            var bothModelLeaf = !isPlainObject(val) && this._data[a] instanceof ModelLeaf;
	            
	            if (this._data[a] && (bothModel || bothModelLeaf)) {
	              // data type does not change (model or leaf and can be set through set-function)
	              this._data[a].set(val, force, persistent);
	            } else {
	              // data type has changed or is new, so initializing the model/leaf
	              this._data[a] = initSubmodel(a, val, this);
	              newSubmodels = true;
	            }
	          }
	
	          // only if there's new submodels, we have to set new getters/setters
	          if (newSubmodels)
	            bindSettersGetters(this);
	
	          if(this.validate && !setting) {
	            this.validate();
	          }
	
	          if(!setting || force) {
	            this._setting = false;
	            if(!this.isHook()) {
	              this.setReady();
	            }
	          }
	          
	          // if this set()-call was the one freezing the tree, now the tree can be unfrozen (i.e. all setting is done)
	          if (freezeCall) {
	            this.setTreeFreezer(false);
	          }
	
	        },
	
	
	        setTreeFreezer: function(freezerStatus) {
	          // first traverse down
	          // this ensures deepest events are triggered first
	          forEach(this._data, function(submodel) {
	            submodel.setTreeFreezer(freezerStatus);
	          });
	
	          // then freeze/unfreeze
	          if (freezerStatus) {
	            this.freeze();
	          } else {
	            this.unfreeze();
	          }
	        },
	
	        /**
	         * Gets the type of this model
	         * @returns {String} type of the model
	         */
	        getType: function() {
	          return this._type;
	        },
	
	
	
	        /**
	         * Gets all submodels of the current model
	         * @param {Object} object [object=false] Should it return an object?
	         * @param {Function} fn Validation function
	         * @returns {Array} submodels
	         */
	        getSubmodels: function(object, fn) {
	          var submodels = (object) ? {} : [];
	          var fn = fn || function() {
	            return true;
	          };
	          var _this = this;
	          forEach(this._data, function(s, name) {
	            if(s && typeof s._id !== 'undefined' && isModel(s) && fn(s)) {
	              if(object) {
	                submodels[name] = s;
	              } else {
	                submodels.push(s);
	              }
	            }
	          });
	          return submodels;
	        },
	
	        /**
	         * Gets the current model and submodel values as a JS object
	         * @returns {Object} All model as JS object, leafs will return their values
	         */
	        getPlainObject: function(persistent) {
	          var obj = {};
	          forEach(this._data, function(dataItem, i) {
	            // if it's a submodel
	            if(dataItem instanceof Model) {
	              obj[i] = dataItem.getPlainObject(persistent);
	            } 
	            // if it's a modelLeaf
	            else {
	              obj[i] = dataItem.get(persistent);
	            }
	          });
	          return obj;
	        },
	
	
	        /**
	         * Gets the requested object, including the leaf-object, not the value
	         * @returns {Object} Model or ModelLeaf object.
	         */
	        getModelObject: function(name) {
	          if (name)
	            return this._data[name];
	          else
	            return this;
	        },
	
	        /**
	         * Clears this model, submodels, data and events
	         */
	        clear: function() {
	          var submodels = this.getSubmodels();
	          for(var i in submodels) {
	            submodels[i].clear();
	          }
	          this._spaceDims = {};
	          this.setReady(false);
	          this.off();
	          this._intervals.clearAllIntervals();
	          this._data = {};
	        },
	
	        /**
	         * Validates data.
	         * Interface for the validation function implemented by a model
	         * @returns Promise or nothing
	         */
	        validate: function() {},
	
	        /* ==========================
	         * Model loading
	         * ==========================
	         */
	
	        /**
	         * checks whether this model is loading anything
	         * @param {String} optional process id (to check only one)
	         * @returns {Boolean} is it loading?
	         */
	        isLoading: function(p_id) {
	          if(this.isHook() && (!this._loadedOnce || this._loadCall)) {
	            return true;
	          }
	          if(p_id) {
	            return this._loading.indexOf(p_id) !== -1;
	          } //if loading something
	          else if(this._loading.length > 0) {
	            return true;
	          } //if not loading anything, check submodels
	          else {
	            var submodels = this.getSubmodels();
	            var i;
	            for(i = 0; i < submodels.length; i += 1) {
	              if(submodels[i].isLoading()) {
	                return true;
	              }
	            }
	            for(i = 0; i < this._deps.children.length; i += 1) {
	              var d = this._deps.children[i];
	              if(d.isLoading() || !d._ready) {
	                return true;
	              }
	            }
	            return false;
	          }
	        },
	
	        /**
	         * specifies that the model is loading data
	         * @param {String} p_id of the loading process
	         */
	        setLoading: function(p_id) {
	          //if this is the first time we're loading anything
	          if(!this.isLoading()) {
	            this.trigger('load_start');
	          }
	          //add id to the list of processes that are loading
	          this._loading.push(p_id);
	        },
	
	        /**
	         * specifies that the model is done with loading data
	         * @param {String} p_id of the loading process
	         */
	        setLoadingDone: function(p_id) {
	          this._loading = without(this._loading, p_id);
	          this.setReady();
	        },
	
	        /**
	         * Sets the model as ready or not depending on its loading status
	         */
	        setReady: function(value) {
	          if(value === false) {
	            this._ready = false;
	            if(this._parent && this._parent.setReady) {
	              this._parent.setReady(false);
	            }
	            return;
	          }
	          //only ready if nothing is loading at all
	          var prev_ready = this._ready;
	          this._ready = !this.isLoading() && !this._setting && !this._loadCall;
	          // if now ready and wasn't ready yet
	          if(this._ready && prev_ready !== this._ready) {
	            if(!this._readyOnce) {
	              this._readyOnce = true;
	              this.trigger('readyOnce');
	            }
	            this.trigger('ready');
	          }
	        },
	
	        /**
	         * loads data (if hook)
	         * Hooks loads data, models ask children to load data
	         * Basically, this method:
	         * loads is theres something to be loaded:
	         * does not load if there's nothing to be loaded
	         * @param {Object} options (includes splashScreen)
	         * @returns defer
	         */
	        load: function(opts) {
	
	          opts = opts || {};
	          var splashScreen = opts.splashScreen || false;
	
	          var _this = this;
	          var data_hook = this._dataModel;
	          var language_hook = this._languageModel;
	          var query = this.getQuery(splashScreen);
	          var promiseLoad = new Promise();
	          var promises = [];
	          //useful to check if in the middle of a load call
	          this._loadCall = true;
	
	          //load hook
	          //if its not a hook, the promise will not be created
	          if(this.isHook() && data_hook && query) {
	            //hook changes, regardless of actual data loading
	            this.trigger('hook_change');
	            //get reader info
	            var reader = data_hook.getPlainObject();
	            reader.parsers = this._getAllParsers();
	
	            var lang = language_hook ? language_hook.id : 'en';
	            var promise = new Promise();
	            var evts = {
	              'load_start': function() {
	                _this.setLoading('_hook_data');
	                EventSource.freezeAll([
	                  'load_start',
	                  'resize',
	                  'dom_ready'
	                ]);
	              }
	            };
	
	            defer(function() { //defer require to fire "hook_change" event
	              timeStamp('Vizabi Model: Loading Data: ' + _this._id);
	              _DATAMANAGER.load(query, lang, reader, evts).then(function(dataId) {
	                _this._dataId = dataId;
	                timeStamp('Vizabi Model: Data loaded: ' + _this._id);
	                _this.afterLoad();
	                promise.resolve();
	              }, function(err) {
	                warn('Problem with query: ', JSON.stringify(query));
	                promise.reject(err);
	              });
	              
	            });
	            promises.push(promise);
	          }
	
	          //load submodels as well
	          forEach(this.getSubmodels(true), function(sm, name) {
	            promises.push(sm.load(opts));
	          });
	
	          //when all promises/loading have been done successfully
	          //we will consider this done
	          var wait = promises.length ? Promise.all(promises) : new Promise.resolve();
	          wait.then(function() {
	
	            //only validate if not showing splash screen to avoid fixing the year
	            if(_this.validate) {
	              _this.validate();
	            }
	            timeStamp('Vizabi Model: Model loaded: ' + _this._id);
	            //end this load call
	            _this._loadedOnce = true;
	
	            //we need to defer to make sure all other submodels
	            //have a chance to call loading for the second time
	            _this._loadCall = false;
	            promiseLoad.resolve();
	            defer(function() {
	              _this.setReady();
	            });
	          }, function() {
	            _this.trigger('load_error');
	            promiseLoad.reject();
	          });
	
	          return promiseLoad;
	        },
	
	        /**
	         * executes after preloading processing is done
	         */
	        afterPreload: function() {
	          var submodels = this.getSubmodels();
	          forEach(submodels, function(s) {
	            s.afterPreload();
	          });
	        },
	
	        /**
	         * executes after data has actually been loaded
	         */
	        afterLoad: function() {
	          EventSource.unfreezeAll();
	          this.setLoadingDone('_hook_data');
	        },
	
	        /**
	         * removes all external dependency references
	         */
	        resetDeps: function() {
	          this._deps.children = [];
	        },
	
	        /**
	         * add external dependency ref to this model
	         */
	        addDep: function(child) {
	          this._deps.children.push(child);
	          child._deps.parent.push(this);
	        },
	
	        /**
	         * gets query that this model/hook needs to get data
	         * @returns {Array} query
	         */
	        getQuery: function(splashScreen) {
	
	          var dimensions, filters, select, grouping, orderBy, q;
	
	          //if it's not a hook, no query is necessary
	          if(!this.isHook()) return true;
	          //error if there's nothing to hook to
	          if(Object.keys(this._space).length < 1) {
	            error$1('Error:', this._id, 'can\'t find the space');
	            return true;
	          }
	
	          var prop = (this.use === "property") || (this.use === "constant");
	          var exceptions = (prop) ? { exceptType: 'time' } : {};
	
	          // select
	          dimensions = this._getAllDimensions(exceptions);
	          if(this.use !== 'constant') dimensions = dimensions.concat([this.which]);
	          select = unique(dimensions);
	
	          // where 
	          filters = this._getAllFilters(exceptions, splashScreen);
	          
	          // grouping
	          grouping = this._getGrouping();
	
	          // order by
	          orderBy = (!prop) ? this._space.time.dim : null;
	
	          //return query
	          return {
	            'select': select,
	            'where': filters,
	            'grouping': grouping,
	            'orderBy': orderBy // should be _space.animatable, but that's time for now
	          };
	        },
	
	        /* ===============================
	         * Hooking model to external data
	         * ===============================
	         */
	
	        /**
	         * is this model hooked to data?
	         */
	        isHook: function() {
	          return this.use ? true : false;
	        },
	        /**
	         * Hooks all hookable submodels to data
	         */
	        setHooks: function() {
	          if(this.isHook()) {
	            //what should this hook to?
	            this.hookModel();
	          } else {
	            //hook submodels
	            var submodels = this.getSubmodels();
	            forEach(submodels, function(s) {
	              s.setHooks();
	            });
	          }
	        },
	
	        /**
	         * Hooks this model to data, entities and time
	         * @param {Object} h Object containing the hooks
	         */
	        hookModel: function() {
	          var _this = this;
	          var spaceRefs = getSpace(this);
	          // assuming all models will need data and language support
	          this._dataModel = getClosestModel(this, 'data');
	          this._languageModel = getClosestModel(this, 'language');
	          //check what we want to hook this model to
	          forEach(spaceRefs, function(name) {
	            //hook with the closest prefix to this model
	            _this._space[name] = getClosestModel(_this, name);
	            //if hooks change, this should load again
	            //TODO: remove hardcoded 'show"
	            if(_this._space[name].show) {
	              _this._space[name].on('change:show', function(evt) {
	                //hack for right size of bubbles
	                if(_this._type === 'size' && _this.which === _this.which_1) {
	                  _this.which_1 = '';
	                };
	                //defer is necessary because other events might be queued.
	                //load right after such events
	                defer(function() {
	                  _this.load().then(function() {
	
	                  }, function(err) {
	                    warn(err);
	                  });
	                });
	              });
	            }
	          });
	          //this is a hook, therefore it needs to reload when data changes
	          this.on('change:which', function(evt) {
	            //defer is necessary because other events might be queued.
	            //load right after such events
	            _this.load();
	          });
	          //this is a hook, therefore it needs to reload when data changes
	          this.on('hook_change', function() {
	            _this._spaceDims = {};
	            _this.setReady(false);
	          });
	        },
	
	        /**
	         * Gets all submodels of the current model that are hooks
	         * @param object [object=false] Should it return an object?
	         * @returns {Array|Object} hooks array or object
	         */
	        getSubhooks: function(object) {
	          return this.getSubmodels(object, function(s) {
	            return s.isHook();
	          });
	        },
	
	        /**
	         * gets all sub values for a certain hook
	         * only hooks have the "hook" attribute.
	         * @param {String} type specific type to lookup
	         * @returns {Array} all unique values with specific hook use
	         */
	        getHookWhich: function(type) {
	          var values = [];
	          if(this.use && this.use === type) {
	            values.push(this.which);
	          }
	          //repeat for each submodel
	          forEach(this.getSubmodels(), function(s) {
	            values = unique(values.concat(s.getHookWhich(type)));
	          });
	          //now we have an array with all values in a type of hook for hooks.
	          return values;
	        },
	
	        /**
	         * gets all sub values for indicators in this model
	         * @returns {Array} all unique values of indicator hooks
	         */
	        getIndicators: function() {
	          return this.getHookWhich('indicator');
	        },
	
	        /**
	         * gets all sub values for indicators in this model
	         * @returns {Array} all unique values of property hooks
	         */
	        getProperties: function() {
	          return this.getHookWhich('property');
	        },
	
	        /**
	         * Gets the dimension of this model if it has one
	         * @returns {String|Boolean} dimension
	         */
	        getDimension: function() {
	          return this.dim || false; //defaults to dim if it exists
	        },
	
	        /**
	         * Gets the dimension (if entity) or which (if hook) of this model
	         * @returns {String|Boolean} dimension
	         */
	        getDimensionOrWhich: function() {
	          return this.dim || (this.use != 'constant' ? this.which : false); //defaults to dim or which if it exists
	        },
	
	        /**
	         * Gets the filter for this model if it has one
	         * @returns {Object} filters
	         */
	        getFilter: function() {
	          return {}; //defaults to no filter
	        },
	
	
	        /**
	         * maps the value to this hook's specifications
	         * @param value Original value
	         * @returns hooked value
	         */
	        mapValue: function(value) {
	          return value;
	        },
	
	
	
	          
	        /**
	         * gets nested dataset
	         * @param {Array} keys define how to nest the set
	         * @returns {Object} hash-map of key-value pairs
	         */
	        getNestedItems: function(keys) {
	          if(!keys) return warn("No keys provided to getNestedItems(<keys>)");
	          return _DATAMANAGER.get(this._dataId, 'nested', keys);
	        },
	
	
	        /**
	         * Gets formatter for this model
	         * @returns {Function|Boolean} formatter function
	         */
	        getParser: function() {
	          //TODO: default formatter is moved to utils. need to return it to hook prototype class, but retest #1212 #1230 #1253
	          return null;
	        },
	
	        getDataManager: function(){
	          return _DATAMANAGER;
	        },
	
	        /**
	         * Gets limits
	         * @param {String} attr parameter
	         * @returns {Object} limits (min and max)
	         */
	        getLimits: function(attr) {
	          return _DATAMANAGER.get(this._dataId, 'limits', attr);
	        },
	
	        /**
	         * gets all hook dimensions
	         * @param {Object} opts options with exceptType or onlyType
	         * @returns {Array} all unique dimensions
	         */
	        _getAllDimensions: function(opts) {
	
	          var optsStr = JSON.stringify(opts);
	          if(optsStr in this._spaceDims) {
	            return this._spaceDims[optsStr];
	          }
	
	          opts = opts || {};
	          var dims = [];
	          var dim;
	
	          var models = this._space;
	          //in case it's a parent of hooks
	          if(!this.isHook() && this.space) {
	            models = [];
	            var _this = this;
	            forEach(this.space, function(name) {
	              models.push(getClosestModel(_this, name));
	            });
	          }
	
	          forEach(models, function(m) {
	            if(opts.exceptType && m.getType() === opts.exceptType) {
	              return true;
	            }
	            if(opts.onlyType && m.getType() !== opts.onlyType) {
	              return true;
	            }
	            if(dim = m.getDimension()) {
	              dims.push(dim);
	            }
	          });
	
	          this._spaceDims[optsStr] = dims;
	
	          return dims;
	        },
	
	        /**
	         * gets first dimension that matches type
	         * @param {Object} options
	         * @returns {Array} all unique dimensions
	         */
	        _getFirstDimension: function(opts) {
	          opts = opts || {};
	
	          var models = this._space;
	          //in case it's a parent of hooks
	          if(!this.isHook() && this.space) {
	            models = [];
	            var _this = this;
	            forEach(this.space, function(name) {
	              models.push(getClosestModel(_this, name));
	            });
	          }
	
	          var dim = false;
	          forEach(models, function(m) {
	            if(opts.exceptType && m.getType() !== opts.exceptType) {
	              dim = m.getDimension();
	              return false;
	            } else if(opts.type && m.getType() === opts.type) {
	              dim = m.getDimension();
	              return false;
	            } else if(!opts.exceptType && !opts.type) {
	              dim = m.getDimension();
	              return false;
	            }
	          });
	          return dim;
	        },
	
	        /**
	         * gets all hook filters
	         * @param {Boolean} splashScreen get filters for first screen only
	         * @returns {Object} filters
	         */
	        _getAllFilters: function(opts, splashScreen) {
	          opts = opts || {};
	          var filters = {};
	          forEach(this._space, function(h) {
	            if(opts.exceptType && h.getType() === opts.exceptType) {
	              return true;
	            }
	            if(opts.onlyType && h.getType() !== opts.onlyType) {
	              return true;
	            }
	            filters = extend(filters, h.getFilter(splashScreen));
	          });
	          return filters;
	        },
	
	        /**
	         * gets grouping for each of the used entities
	         * @param {Boolean} splashScreen get filters for first screen only
	         * @returns {Object} filters
	         */
	        _getGrouping: function() {
	          var groupings = {};
	          forEach(this._space, function(h) {
	            groupings[h.dim] = h.grouping || undefined;
	          });
	          return groupings;
	        },
	
	        /**
	         * gets all hook filters
	         * @returns {Object} filters
	         */
	        _getAllParsers: function() {
	
	          var parsers = {};
	
	          function addParser(model) {
	            // get parsers from model
	            var parser = model.getParser();
	            var column = model.getDimensionOrWhich();
	            if (parser && column) {
	              parsers[column] = parser;
	            }
	          }
	
	          // loop through all models which can have filters
	          forEach(this._space, function(h) {
	            addParser(h);
	          });
	          addParser(this);
	
	          return parsers;
	        },
	
	        getDefaults: function() {
	          // if defaults are set, does not care about defaults from children
	          if(this._defaults) return this._defaults;
	          var d = {};
	          forEach(this.getSubmodels(true), function(model, name) {
	            d[name] = model.getDefaults();
	          });
	          return d;
	        }
	
	      });
	
	      /* ===============================
	       * Private Helper Functions
	       * ===============================
	       */
	
	      /**
	       * Checks whether an object is a model or not
	       * if includeLeaf is true, a leaf is also seen as a model
	       */
	      function isModel(model, includeLeaf) {
	        return model && (model.hasOwnProperty('_data') || (includeLeaf &&  model.hasOwnProperty('_val')));
	      }
	
	      /**
	       * Binds all attributes in _data to magic setters and getters
	       */
	      function bindSettersGetters(model) {
	        for(var prop in model._data) {
	          Object.defineProperty(model, prop, {
	            configurable: true,
	            //allow reconfiguration
	            get: function(p) {
	              return function() {
	                return model.get(p);
	              };
	            }(prop),
	            set: function(p) {
	              return function(value) {
	                return model.set(p, value);
	              };
	            }(prop)
	          });
	        }
	      }
	
	      /**
	       * Loads a submodel, when necessaary
	       * @param {String} attr Name of submodel
	       * @param {Object} val Initial values
	       * @param {Object} ctx context / parent model
	       * @returns {Object} model new submodel
	       */
	      function initSubmodel(attr, val, ctx) {
	
	        var submodel;
	
	        // if value is a value -> leaf
	        if(!isPlainObject(val) || isArray(val)) {  
	
	          var binds = {
	            //the submodel has changed (multiple times)
	            'change': onChange
	          }
	          submodel = new ModelLeaf(attr, val, ctx, binds);
	        }
	
	        // if value is an object -> model
	        else {
	
	          var binds = {
	            //the submodel has changed (multiple times)
	            'change': onChange,
	            //loading has started in this submodel (multiple times)
	            'hook_change': onHookChange,
	            //loading has started in this submodel (multiple times)
	            'load_start': onLoadStart,
	            //loading has failed in this submodel (multiple times)
	            'load_error': onLoadError,
	              //loading has ended in this submodel (multiple times)
	            'ready': onReady
	          };
	
	          // if the value is an already instantiated submodel (Model or ModelLeaf)
	          // this is the case for example when a new componentmodel is made (in Component._modelMapping)
	          // it takes the submodels from the toolmodel and creates a new model for the component which refers 
	          // to the instantiated submodels (by passing them as model values, and thus they reach here)
	          if (isModel(val, true)) {
	            submodel = val;
	            submodel.on(binds);
	          } 
	          // if it's just a plain object, create a new model
	          else {
	            // construct model
	            var modelType = attr.split('_')[0];
	            var Modl = Model.get(modelType, true) || models[modelType] || Model;
	            submodel = new Modl(attr, val, ctx, binds);
	            // model is still frozen but will be unfrozen at end of original .set()
	          }
	        }
	
	        return submodel;
	
	        // Default event handlers for models
	        function onChange(evt, path) {
	          if(!ctx._ready) return; //block change propagation if model isnt ready
	          path = ctx._name + '.' + path
	          ctx.trigger(evt, path);    
	        }
	        function onHookChange(evt, vals) {
	          ctx.trigger(evt, vals);
	        }
	        function onLoadStart(evt, vals) {
	          ctx.setReady(false);
	          ctx.trigger(evt, vals);
	        }
	        function onLoadError(evt, vals) {
	          ctx.trigger(evt, vals);
	        }
	        function onReady(evt, vals) {
	          //trigger only for submodel
	          ctx.setReady(false);
	          //wait to make sure it's not set false again in the next execution loop
	          defer(function() {
	            ctx.setReady();
	          });
	          //ctx.trigger(evt, vals);
	        }
	      }
	
	      /**
	       * gets closest interval from this model or parent
	       * @returns {Object} Intervals object
	       */
	      function getIntervals(ctx) {
	        if(ctx._intervals) {
	          return ctx._intervals;
	        } else if(ctx._parent) {
	          return getIntervals(ctx._parent);
	        } else {
	          return new Intervals();
	        }
	      }
	
	      /**
	       * gets closest prefix model moving up the model tree
	       * @param {String} prefix
	       * @returns {Object} submodel
	       */
	      function getClosestModel(ctx, name) {
	        var model = findSubmodel(ctx, name);
	        if(model) {
	          return model;
	        } else if(ctx._parent) {
	          return getClosestModel(ctx._parent, name);
	        }
	      }
	
	      /**
	       * find submodel with name that starts with prefix
	       * @param {String} prefix
	       * @returns {Object} submodel or false if nothing is found
	       */
	      function findSubmodel(ctx, name) {
	        for(var i in ctx._data) {
	          //found submodel
	          if(i === name && isModel(ctx._data[i])) {
	            return ctx._data[i];
	          }
	        }
	      }
	
	      /**
	       * Learn what this model should hook to
	       * @returns {Array} space array
	       */
	      function getSpace(model) {
	        if(isArray(model.space)) {
	          return model.space;
	        } else if(model._parent) {
	          return getSpace(model._parent);
	        } else {
	          error$1(
	            'ERROR: space not found.\n You must specify the objects this hook will use under the "space" attribute in the state.\n Example:\n space: ["entities", "time"]'
	          );
	        }
	      }
	
	      /*!
	       * HOOK MODEL
	       */
	
	
	      var Hook = Model.extend({
	        
	        //some hooks can be important. like axis x and y
	        //that means, if X or Y doesn't have data at some point, we can't show markers
	        _important: false,
	        
	          /**
	         * Gets tick values for this hook
	         * @returns {Number|String} value The value for this tick
	         */
	        getTickFormatter: function() {
	            
	          var _this = this;
	          var SHARE = "share";
	          var PERCENT = "percent";
	          
	          // percentageMode works like rounded if set to SHARE, but multiplies by 100 and suffixes with "%"
	          // percentageMode works like rounded if set to PERCENT, but suffixes with "%"
	            
	          return function format(x, index, removePrefix, percentageMode){
	            
	          percentageMode = _this.getConceptprops().format;
	          if(percentageMode===SHARE) x*=100;
	
	          // Format time values
	          // Assumption: a hook has always time in its space
	          if(isDate(x)) return _this._space.time.timeFormat(x);
	            
	          // Dealing with values that are supposed to be time
	          if(_this.scaleType === "time" && !isDate(x)) {
	              return _this._space.time.timeFormat(new Date(x));
	          }
	            
	          // Strings, null, NaN and undefined are bypassing any formatter
	          if(isString(x) || !x && x!==0) return x;
	
	          if(Math.abs(x)<0.00000000000001) return "0";
	              
	          var format = "r"; //rounded format. use "f" for fixed
	          var prec = 3; //round to so many significant digits
	          
	          var prefix = "";
	          if(removePrefix) return d3.format("." + prec + format)(x);
	              
	          //---------------------
	          // BEAUTIFIERS GO HOME!
	          // don't break formatting please
	          //---------------------
	          // the tiny constant compensates epsilon-error when doing logsrithms
	          switch(Math.floor(Math.log(Math.abs(x))/Math.LN10 + 0.00000000000001)) {
	            case -13: x = x * 1000000000000; prefix = "p"; break; //0.1p
	            case -10: x = x * 1000000000; prefix = "n"; break; //0.1n
	            case -7: x = x * 1000000; prefix = "µ"; break; //0.1µ
	            case -6: x = x * 1000000; prefix = "µ"; break; //1µ
	            case -5: x = x * 1000000; prefix = "µ"; break; //10µ
	            case -4: break; //0.0001
	            case -3: break; //0.001
	            case -2: break; //0.01
	            case -1: break; //0.1
	            case 0:  break; //1
	            case 1:  break; //10
	            case 2:  break; //100
	            case 3:  break; //1000
	            case 4:  x = x / 1000; prefix = "k"; break; //10k
	            case 5:  x = x / 1000; prefix = "k"; break; //100k
	            case 6:  x = x / 1000000; prefix = "M"; break; //1M
	            case 7:  x = x / 1000000; prefix = "M"; break; //10M
	            case 8:  x = x / 1000000; prefix = "M"; break; //100M
	            case 9:  x = x / 1000000000; prefix = "B"; break; //1B
	            case 10: x = x / 1000000000; prefix = "B"; break; //10B
	            case 11: x = x / 1000000000; prefix = "B"; break; //100B
	            case 12: x = x / 1000000000000; prefix = "TR"; break; //1TR
	            case 13: x = x / 1000000000000; prefix = "TR"; break; //10TR
	            case 14: x = x / 1000000000000; prefix = "TR"; break; //100TR
	            //use the D3 SI formatting for the extreme cases
	            default: return(d3.format("." + prec + "s")(x)).replace("G", "B");
	          }  
	          
	          var formatted = d3.format("." + prec + format)(x);
	          //remove trailing zeros if dot exists to avoid numbers like 1.0M, 3.0B, 1.500, 0.9700, 0.0
	          if (formatted.indexOf(".")>-1) formatted = formatted.replace(/0+$/,"").replace(/\.$/,"");
	            
	          
	          
	          // use manual formatting for the cases above
	          return(formatted + prefix + (percentageMode===PERCENT || percentageMode===SHARE?"%":""));
	          }
	        },
	          
	        /**
	         * Gets the d3 scale for this hook. if no scale then builds it
	         * @returns {Array} domain
	         */
	        getScale: function(margins) {
	          if(!this.scale) {
	            this.buildScale(margins);
	          }
	          return this.scale;
	        },
	
	        /**
	         * Gets the domain for this hook
	         * @returns {Array} domain
	         */
	        buildScale: function() {
	          if(!this.isHook()) {
	            return;
	          }
	          var domain;
	          var scaleType = this.scaleType || 'linear';
	          switch(this.use) {
	            case 'indicator':
	              var limits = this.getLimits(this.which);
	              domain = [
	                limits.min,
	                limits.max
	              ];
	              break;
	            case 'property':
	              domain = this.getUnique(this.which);
	              break;
	            default:
	              domain = [this.which];
	              break;
	          }
	          //TODO: d3 is global?
	          this.scale = scaleType === 'time' ? d3.time.scale.utc().domain(domain) : d3.scale[scaleType]().domain(domain);
	        },
	          
	            //TODO: this should go down to datamanager, hook should only provide interface
	        /**
	         * gets maximum, minimum and mean values from the dataset of this certain hook
	         */
	        gerLimitsPerFrame: function() {
	            
	          if(this.use === "property") return warn("getMaxMinMean: strange that you ask min max mean of a property"); 
	          if(!this.isHook) return warn("getMaxMinMean: only works for hooks");
	            
	          var result = {};
	          var values = [];
	          var value = null;
	          var TIME = this._getFirstDimension({type: "time"});
	            
	          var steps = this._parent._parent.time.getAllSteps();
	            
	          if(this.use === "constant") {
	              steps.forEach(function(t){ 
	                  value = this.which;
	                  result[t] = {
	                      min: value,
	                      max: value
	                  }
	              });
	
	          }else if(this.which===TIME){
	              steps.forEach(function(t){ 
	                  value = new Date(t);
	                  result[t] = {
	                      min: value,
	                      max: value
	                  }
	              });
	
	          }else{
	              var args = {framesArray: steps, which: this.which};
	              result = this.getDataManager().get(this._dataId, 'limitsPerFrame', args);   
	          }
	            
	          return result;
	        },
	          
	          
	           /**
	           * Gets unique values in a column
	           * @param {String|Array} attr parameter
	           * @returns {Array} unique values
	           */
	          getUnique: function(attr) {
	              if(!this.isHook()) return;
	              if(!attr) attr = this._getFirstDimension({type: "time"});
	              return this.getDataManager().get(this._dataId, 'unique', attr);
	          },
	          
	          
	          
	          
	            /**
	         * gets dataset without null or nan values with respect to this hook's which
	         * @returns {Object} filtered items object
	         */
	        getValidItems: function() {
	          return this.getDataManager().get(this._dataId, 'valid', this.which);
	        },
	
	        getNestedItems: function(groupBy) {
	          return this.getDataManager().get(this._dataId, 'nested', groupBy);
	        },
	          
	        getLimitsByDimensions: function(dims) {
	          var filtered = this.getDataManager().get(this._dataId, 'nested', dims);
	          var values = {};
	          var limitsDim = {};
	          var attr = this.which;
	          
	          var countLimits = function(items, limitsDim, id) {
	       
	            var filtered = items.reduce(function(filtered, d) {
	              
	              // check for dates
	              var f = (isDate(d[attr])) ? d[attr] : parseFloat(d[attr]);
	
	              // if it is a number
	              if(!isNaN(f)) {
	                filtered.push(f);
	              }
	
	              //filter
	              return filtered;
	            }, []);
	            
	            // get min/max for the filtered rows
	            var min;
	            var max;
	            var limits = {};
	            for(var i = 0; i < filtered.length; i += 1) {
	              var c = filtered[i];
	              if(typeof min === 'undefined' || c < min) {
	                min = c;
	              }
	              if(typeof max === 'undefined' || c > max) {
	                max = c;
	              }
	            }
	            limits.min = min || 0;
	            limits.max = max || 100;
	            limitsDim[id] = limits;    
	          
	          }
	          
	          var iterateGroupKeys = function(data, deep, result, cb) {
	            deep--;
	            forEach(data, function(d, id) {
	              if(deep) {
	                result[id] = {};
	                iterateGroupKeys(d, deep, result[id], cb);
	              } else {
	                cb(d, result, id);
	              }
	            });
	          }
	          
	          iterateGroupKeys(filtered, dims.length, limitsDim, countLimits);
	          
	          return limitsDim;
	        },
	        
	        
	          
	        /**
	         * Gets the concept properties of the hook's "which"
	         * @returns {Object} concept properties
	         */
	        getConceptprops: function() {
	          return this.use !== 'constant' ? this.getDataManager().getConceptprops(this.which) : {};
	        }    
	      });
	
	      /*!
	       * VIZABI Axis Model (hook)
	       */
	
	      var allowTypes = {
	          "indicator": ["linear", "log", "genericLog", "time", "pow"],
	          "property": ["ordinal"],
	          "constant": ["ordinal"]
	      };
	
	      var AxisModel = Hook.extend({
	        
	        //some hooks can be important. like axis x and y
	        //that means, if X or Y doesn't have data at some point, we can't show markers
	        _important: true,
	        
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          use: null,
	          which: null,
	          domainMin: null,
	          domainMax: null,
	          zoomedMin: null,
	          zoomedMax: null
	        },
	          
	        _type: "axis",
	
	        /**
	         * Initializes the color hook
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          //TODO: add defaults extend to super
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);      
	          this._super(name, values, parent, bind);
	        },
	
	        /**
	         * Validates a color hook
	         */
	        validate: function() {
	
	          //only some scaleTypes are allowed depending on use. reset to default if inappropriate
	          if(allowTypes[this.use].indexOf(this.scaleType) === -1) this.scaleType = allowTypes[this.use][0];
	
	          //kill the scale if indicator or scale type have changed
	          //the scale will be rebuild upon getScale request in model.js
	          if(this.which_1 != this.which || this.scaleType_1 != this.scaleType) this.scale = null;
	          this.which_1 = this.which;
	          this.scaleType_1 = this.scaleType;
	
	          //here the modified min and max may change the domain, if the scale is defined
	          if(this.scale && this._readyOnce && this.use === "indicator") {
	            if(this.scaleType == "time") {
	              
	              var timeMdl = this._space.time;
	              var limits = timeMdl.beyondSplash ? 
	                  {min: timeMdl.beyondSplash.start, max: timeMdl.beyondSplash.end}
	                  :
	                  {min: timeMdl.start, max: timeMdl.end};
	              
	              if (this.scale.domain()[0] < limits.min || this.scale.domain()[1] > limits.max) {
	                this.scale.domain([limits.min, limits.max]);
	              }
	              
	              //restore the correct object type for time values
	              if(this.zoomedMin != null && !isDate(this.zoomedMin)) this.zoomedMin = this._space.time.parseToUnit(this.zoomedMin.toString());
	              if(this.zoomedMax != null && !isDate(this.zoomedMax)) this.zoomedMax = this._space.time.parseToUnit(this.zoomedMax.toString());
	
	              if(!isDate(this.domainMin)) this.domainMin = this.scale.domain()[0];
	              if(!isDate(this.domainMax)) this.domainMax = this.scale.domain()[1];
	            }
	            //min and max nonsense protection
	            if(this.domainMin == null || this.domainMin <= 0 && this.scaleType === "log") this.domainMin = this.scale.domain()[0];
	            if(this.domainMax == null || this.domainMax <= 0 && this.scaleType === "log") this.domainMax = this.scale.domain()[1];
	
	            //zoomedmin and zoomedmax nonsense protection    
	            if(this.zoomedMin == null || this.zoomedMin < this.scale.domain()[0]) this.zoomedMin = this.scale.domain()[0];
	            if(this.zoomedMax == null || this.zoomedMax > this.scale.domain()[1]) this.zoomedMax = this.scale.domain()[1];
	
	            this.scale.domain([this.domainMin, this.domainMax]);
	          }
	        },
	
	        /**
	         * Gets the domain for this hook
	         * @returns {Array} domain
	         */
	        buildScale: function(margins) {
	          var domain;
	
	          if(this.scaleType == "time") {
	            
	            var timeMdl = this._space.time;
	            var limits = timeMdl.beyondSplash ? 
	                {min: timeMdl.beyondSplash.start, max: timeMdl.beyondSplash.end}
	                :
	                {min: timeMdl.start, max: timeMdl.end};
	            
	            domain = [limits.min, limits.max];
	            this.scale = d3.time.scale.utc().domain(domain);
	
	            return;
	          }
	
	          switch(this.use) {
	            case "indicator":
	              var limits = this.getLimits(this.which);
	              //default domain is based on limits
	              domain = [limits.min, limits.max];
	              //domain from concept properties can override it if defined
	              domain = this.getConceptprops().domain ? this.getConceptprops().domain : domain;
	              //min and max can override the domain if defined
	              domain = this.domainMin!=null && this.domainMax!=null ? [+this.domainMin, +this.domainMax] : domain;
	              break;
	            case "property":
	              domain = this.getUnique(this.which);
	              break;
	            case "constant":
	            default:
	              domain = [this.which];
	              break;
	          }
	          
	          var scaletype = (d3.min(domain)<=0 && d3.max(domain)>=0 && this.scaleType === "log")? "genericLog" : this.scaleType;
	          this.scale = d3.scale[scaletype || "linear"]().domain(domain);
	        }
	      });
	
	      /*!
	       * VIZABI Color Model (hook)
	       */
	
	      var defaultPalettes = {
	        "_continuous": {
	          "0": "#B4DE79",
	          "50": "#E1CE00",
	          "100": "#F77481"
	        },
	        "_discrete": {
	          "0": "#bcfa83",
	          "1": "#4cd843",
	          "2": "#ff8684",
	          "3": "#e83739",
	          "4": "#ffb04b",
	          "5": "#ff7f00",
	          "6": "#f599f5",
	          "7": "#c027d4",
	          "8": "#f4f459",
	          "9": "#d66425",
	          "10": "#7fb5ed",
	          "11": "#0ab8d8"
	        },
	        "_default": {
	          "_default": "#93daec"
	        }
	      };
	
	      var ColorModel = Hook.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          use: null,
	          palette: {},
	          paletteLabels: null,
	          scaleType: null,
	          which: null
	        },
	
	        /**
	         * Initializes the color hook
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "color";
	          //TODO: add defaults extend to super
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	
	          this._original_palette = values.palette;
	
	          this._super(name, values, parent, bind);
	
	          this._firstLoad = true;
	          this._hasDefaultColor = false;
	        },
	
	        // args: {colorID, shadeID}
	        getColorShade: function(args){
	          var palette = this.getPalette();
	            
	          if(!args) return warn("getColorShade() is missing arguments");  
	            
	          // if colorID is not given or not found in the palette, replace it with default color
	          if(!args.colorID || !palette[args.colorID]) args.colorID = "_default";
	          
	          // if the resolved colr value is not an array (has only one shade) -- return it
	          if( !isArray(palette[args.colorID]) ) return palette[args.colorID];
	            
	          var conceptpropsColor = this.getConceptprops().color;
	          var shade = args.shadeID && conceptpropsColor && conceptpropsColor.shades && conceptpropsColor.shades[args.shadeID] ? conceptpropsColor.shades[args.shadeID] : 0;
	              
	          return palette[args.colorID][shade];
	          
	        },
	          
	
	        afterPreload: function() {
	          this._super();
	        },
	        
	        /**
	         * Get the above constants
	         */
	        isUserSelectable: function() {
	          var conceptpropsColor = this.getConceptprops().color;
	          return conceptpropsColor == null || conceptpropsColor.selectable == null || conceptpropsColor.selectable;
	        },
	
	        /**
	         * Validates a color hook
	         */
	        validate: function() {
	
	          var possibleScales = ["log", "genericLog", "linear", "time", "pow"];
	          if(!this.scaleType || (this.use === "indicator" && possibleScales.indexOf(this.scaleType) === -1)) {
	            this.scaleType = 'linear';
	          }
	          if(this.use !== "indicator" && this.scaleType !== "ordinal") {
	            this.scaleType = "ordinal";
	          }
	
	          // reset palette and scale in the following cases: indicator or scale type changed
	          if(this._firstLoad === false && (this.which_1 != this.which || this.scaleType_1 != this.scaleType)) {
	
	            //TODO a hack that kills the scale and palette, it will be rebuild upon getScale request in model.js
	            if(this.palette) this.palette._data = {};
	            this.scale = null;
	          }
	
	          this.which_1 = this.which;
	          this.scaleType_1 = this.scaleType;
	          this._firstLoad = false;
	        },
	
	        /**
	         * set color
	         */
	        setColor: function(value, pointer) {
	          var temp = this.getPalette();
	          temp[pointer] = value;
	          this.scale.range(values(temp));
	          this.palette[pointer] = value;
	        },
	
	
	        /**
	         * maps the value to this hook's specifications
	         * @param value Original value
	         * @returns hooked value
	         */
	        mapValue: function(value) {
	          //if the property value does not exist, supply the _default
	          // otherwise the missing value would be added to the domain
	          if(this.scale != null && this.use == "property" && this._hasDefaultColor && this.scale.domain().indexOf(value) == -1) value = "_default";
	          return this._super(value);
	        },
	
	
	        getDefaultPalette: function() {     
	            var conceptpropsColor = this.getConceptprops().color;
	            var palette;
	            
	            if(conceptpropsColor && conceptpropsColor.palette) {
	              //specific color palette from hook concept properties
	              palette = clone(conceptpropsColor.palette);
	            } else if(defaultPalettes[this.which]) {
	              //color palette for this.which exists in palette defaults
	              palette = clone(defaultPalettes[this.which]);
	            } else if(this.use === "constant" && /^#([0-9a-f]{3}|[0-9a-f]{6})$/.test(this.which)) {
	              //an explicit hex color constant #abc or #adcdef is provided
	              palette = {"_default": this.which};
	            } else if(this.use === "indicator") {
	              palette = clone(defaultPalettes["_continuous"]);
	            } else if(this.use === "property") {
	              palette = clone(defaultPalettes["_discrete"]);
	            } else {
	              palette = clone(defaultPalettes["_default"]);
	            }
	            
	            return palette;
	        },
	
	        _getPaletteLabels: function() {
	            var conceptpropsColor = this.getConceptprops().color;
	            var paletteLabels = null;
	            
	            if(conceptpropsColor && conceptpropsColor.paletteLabels) {
	              //specific color palette from hook concept properties
	              paletteLabels = clone(conceptpropsColor.paletteLabels);
	            }
	            return paletteLabels;
	        },
	
	        getPaletteLabels: function() {
	          return this.paletteLabels.getPlainObject(); 
	        },
	
	        getPalette: function(){
	          //rebuild palette if it's empty
	          if (!this.palette || Object.keys(this.palette._data).length===0){
	            this.palette.set(this.getDefaultPalette(), false, false);
	            this.getModelObject("paletteLabels").set(this._getPaletteLabels(), false, false);
	          }
	          
	          return this.palette.getPlainObject(); 
	        },
	          
	        /**
	         * Gets the domain for this hook
	         * @returns {Array} domain
	         */
	        buildScale: function() {
	          var _this = this;
	
	          var paletteObject = _this.getPalette();
	          var domain = Object.keys(paletteObject);
	          var range = values(paletteObject);
	
	          this._hasDefaultColor = domain.indexOf("_default") > -1;
	          
	          if(this.scaleType == "time") {
	            
	            var timeMdl = this._space.time;
	            var limits = timeMdl.beyondSplash ? 
	                {min: timeMdl.beyondSplash.start, max: timeMdl.beyondSplash.end}
	                :
	                {min: timeMdl.start, max: timeMdl.end};
	            
	            var singlePoint = (limits.max - limits.min == 0);
	              
	            domain = domain.sort(function(a,b){return a-b});
	            range = domain.map(function(m){
	              return singlePoint? paletteObject[domain[0]] : paletteObject[m]
	            });
	            domain = domain.map(function(m){
	              return limits.min.valueOf() + m/100 * (limits.max.valueOf() - limits.min.valueOf())
	            });
	            
	            this.scale = d3.time.scale.utc()
	              .domain(domain)
	              .range(range)
	              .interpolate(d3.interpolateRgb);
	            return;
	          }
	
	          switch(this.use) {
	            case "indicator":
	              var limits = this.getLimits(this.which);
	              //default domain is based on limits
	              limits = [limits.min, limits.max];
	              //domain from concept properties can override it if defined
	              limits = this.getConceptprops().domain ? this.getConceptprops().domain : limits;
	                
	              var singlePoint = (limits[1] - limits[0] == 0);
	
	              domain = domain.sort(function(a,b){return a-b});
	              range = domain.map(function(m){
	                return singlePoint? paletteObject[domain[0]] : paletteObject[m]
	              });
	              domain = domain.map(function(m){
	                return limits[0] + m/100 * (limits[1] - limits[0])
	              });        
	              
	              var scaleType = (d3.min(domain)<=0 && d3.max(domain)>=0 && this.scaleType === "log")? "genericLog" : this.scaleType;
	
	              if(this.scaleType == "log" || this.scaleType == "genericLog") {
	                var s = d3.scale.genericLog()
	                  .domain(limits)
	                  .range(limits);
	                domain = domain.map(function(d) {
	                  return s.invert(d)
	                });
	              }
	              this.scale = d3.scale[scaleType || "linear"]()
	                .domain(domain)
	                .range(range)
	                .interpolate(d3.interpolateRgb);
	              return;
	
	            default:
	              range = range.map(function(m){ return isArray(m)? m[0] : m; });
	                  
	              this.scale = d3.scale["ordinal"]()
	                .domain(domain)
	                .range(range);
	              return;
	          }
	        }
	
	      });
	
	      /*
	       * VIZABI Data Model (model.data)
	       */
	
	      var DataModel = Model.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          reader: "csv",
	          splash: false
	        },
	
	
	        /**
	         * Initializes the data model.
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "data";
	          //TODO: add defaults extend to super
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	
	          //same constructor as parent, with same arguments
	          this._super(name, values, parent, bind);
	        }
	
	      });
	
	      /*!
	       * VIZABI Entities Model
	       */
	
	      var EntitiesModel = Model.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          show: {},
	          select: [],
	          highlight: [],
	          opacityHighlightDim: .1,
	          opacitySelectDim: .3,
	          opacityRegular: 1
	        },
	
	        /**
	         * Initializes the entities model.
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "entities";
	          //TODO: add defaults extend to super
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	
	          this._visible = [];
	          this._multiple = true;
	
	          this._super(name, values, parent, bind);
	        },
	
	        /**
	         * Validates the model
	         * @param {boolean} silent Block triggering of events
	         */
	        validate: function(silent) {
	          var _this = this;
	          var dimension = this.getDimension();
	          var visible_array = this._visible.map(function(d) {
	            return d[dimension]
	          });
	
	          if(visible_array.length) {
	            this.select = this.select.filter(function(f) {
	              return visible_array.indexOf(f[dimension]) !== -1;
	            });
	            this.setHighlight(this.highlight.filter(function(f) {
	              return visible_array.indexOf(f[dimension]) !== -1;
	            }));
	          }
	        },
	
	        /**
	         * Sets the visible entities
	         * @param {Array} arr
	         */
	        setVisible: function(arr) {
	          this._visible = arr;
	        },
	
	        /**
	         * Gets the visible entities
	         * @returns {Array} visible
	         */
	        getVisible: function(arr) {
	          return this._visible;
	        },
	
	        /**
	         * Determines whether multiple entities can be selected
	         * @param {Boolean} bool
	         */
	        selectMultiple: function(bool) {
	          this._multiple = bool;
	        },
	
	        /**
	         * Gets the dimensions in this entities
	         * @returns {String} String with dimension
	         */
	        getDimension: function() {
	          return this.dim;
	        },
	
	        /**
	         * Gets the filter in this entities
	         * @returns {Array} Array of unique values
	         */
	        getFilter: function() {
	          return this.show.getPlainObject();
	        },
	
	        /**
	         * Gets the selected items
	         * @returns {Array} Array of unique selected values
	         */
	        getSelected: function() {
	          var dim = this.getDimension();
	          return this.select.map(function(d) {
	            return d[dim];
	          });
	        },
	
	        /**
	         * Selects or unselects an entity from the set
	         */
	        selectEntity: function(d, timeDim, timeFormatter) {
	          var dimension = this.getDimension();
	          var value = d[dimension];
	          if(this.isSelected(d)) {
	            this.select = this.select.filter(function(d) {
	              return d[dimension] !== value;
	            });
	          } else {
	            var added = {};
	            added[dimension] = value;
	            if(timeDim && timeFormatter) {
	              added["trailStartTime"] = timeFormatter(d[timeDim]);
	            }
	            this.select = (this._multiple) ? this.select.concat(added) : [added];
	          }
	        },
	
	        selectEntityMD: function(d, timeDim, timeFormatter) {
	          var _this = this;
	          var value = this._createValue(d);
	          if(this.isSelectedMD(d)) {
	            this.select = this.select.filter(function(d) {
	              return JSON.stringify(_this._createValue(d)) !== JSON.stringify(value);
	            });
	          } else {
	            if(timeDim && timeFormatter) {
	              value["trailStartTime"] = timeFormatter(d[timeDim]);
	            }
	            this.select = (this._multiple) ? this.select.concat(value) : [value];
	          }
	        },
	          
	        /**
	         * Select all entities
	         */
	        selectAll: function(timeDim, timeFormatter) {
	          if(!this._multiple) return;
	          
	          var added,
	            dimension = this.getDimension();
	          
	          var select = this._visible.map(function(d) {
	            added = {};
	            added[dimension] = d[dimension];
	            if(timeDim && timeFormatter) {
	              added["trailStartTime"] = timeFormatter(d[timeDim]);
	            }
	            return added;
	          });
	
	          this.select = select;
	        },
	          
	        /**
	         * Shows or unshows an entity from the set
	         */
	        showEntity: function(d) {
	          //clear selected countries when showing something new
	          this.clearSelected();
	          
	          var dimension = this.getDimension();
	          var value = d[dimension];
	          var show = this.show[dimension];
	            
	          if(!show || show[0] === "*") show = [];
	            
	          show = show.concat([]); //clone array
	            
	          if(this.isShown(d)) {
	            show = show.filter(function(d) { return d !== value; });
	          } else {
	            show = show.concat(value);
	          }
	            
	          if(show.length === 0) show = ["*"];
	          this.show[dimension] = show.concat([]);
	
	        },
	
	        setLabelOffset: function(d, xy) {
	          if(xy[0]===0 && xy[1]===1) return;
	            
	          var dimension = this.getDimension();
	          var value = d[dimension];
	
	          find(this.select, function(d) {
	            return d[dimension] === value;
	          }).labelOffset = [Math.round(xy[0]*1000)/1000, Math.round(xy[1]*1000)/1000];
	
	          //force the model to trigger events even if value is the same
	          this.set("select", this.select, true);
	        },
	
	        /**
	         * Selects an entity from the set
	         * @returns {Boolean} whether the item is selected or not
	         */
	        isSelected: function(d) {
	          var dimension = this.getDimension();
	          var value = d[this.getDimension()];
	
	          return this.select
	              .map(function(d) {return d[dimension];})
	              .indexOf(value) !== -1;
	        },
	          
	        isSelectedMD: function(d) {
	          var _this = this;
	          var value = this._createValue(d);
	              
	          return this.select
	            .map(function(d) {
	              return JSON.stringify(_this._createValue(d)) === JSON.stringify(value);
	            })
	            .indexOf(true) !== -1;
	        },
	        
	        _createValue: function(d) {
	          var dims = this.getDimension() ? [this.getDimension()].concat(this._getAllDimensions()) : this._getAllDimensions(); 
	          return dims.reduce(function(value, key) {
	            value[key] = d[key];
	            return value;
	          }, {});
	        },
	         
	        /**
	         * Selects an entity from the set
	         * @returns {Boolean} whether the item is shown or not
	         */
	        isShown: function(d) {
	          var dimension = this.getDimension();
	          return this.show[dimension] && this.show[dimension].indexOf(d[dimension]) !== -1;
	        },
	
	        /**
	         * Clears selection of items
	         */
	        clearSelected: function() {
	          this.select = [];
	        },
	        /**
	         * Clears showing of items
	         */
	        clearShow: function() {
	          var dimension = this.getDimension();
	          this.show[dimension] = ["*"];
	        },
	
	
	        setHighlight: function(arg) {
	          if (!isArray(arg))
	            this.setHighlight([].concat(arg));
	          this.getModelObject('highlight').set(arg, false, false); // highlights are always non persistent changes
	        },
	
	        //TODO: join the following 3 methods with the previous 3
	
	        /**
	         * Highlights an entity from the set
	         */
	        highlightEntity: function(d, timeDim, timeFormatter, copyDatum) {
	          var dimension = this.getDimension();
	          var value = d[dimension];
	          if(!this.isHighlighted(d)) {
	            var added = {};
	            if(copyDatum) {
	              added = clone(d);                
	            } else {
	              added[dimension] = value;
	              if(timeDim && timeFormatter) {
	                added["trailStartTime"] = timeFormatter(d[timeDim]);
	              }
	            }
	            this.setHighlight(this.highlight.concat(added));
	          }
	        },
	
	        /**
	         * Unhighlights an entity from the set
	         */
	        unhighlightEntity: function(d) {
	          var dimension = this.getDimension();
	          var value = d[dimension];
	          if(this.isHighlighted(d)) {
	            this.setHighlight(this.highlight.filter(function(d) {
	              return d[dimension] !== value;
	            }));
	          }
	        },
	
	        /**
	         * Checks whether an entity is highlighted from the set
	         * @returns {Boolean} whether the item is highlighted or not
	         */
	        isHighlighted: function(d) {
	          var dimension = this.getDimension();
	          var value = d[this.getDimension()];
	
	          var highlight_array = this.highlight.map(function(d) {
	            return d[dimension];
	          });
	
	          return highlight_array.indexOf(value) !== -1;
	        },
	
	        /**
	         * Clears selection of items
	         */
	        clearHighlighted: function() {
	          this.setHighlight([]);
	        }
	          
	      });
	
	      /*
	       * VIZABI Group Model
	       */
	
	      var GroupModel = Hook.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          use: null,
	          which: null,
	          merge: false,
	          manualSorting: null
	        },
	
	        /**
	         * Initializes the group hook
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "model";
	          //TODO: add defaults extend to super
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	          this._super(name, values, parent, bind);
	        },
	
	        /**
	         * Validates a color hook
	         */
	        validate: function() {
	          //there must be no scale
	          if(this.scale) this.scale = null;
	
	          //use must be "property" 
	          if(this.use != "property") {
	            warn("group model: use must be 'property'. Resetting...")
	            this.use = "property";
	          }
	        },
	
	        /**
	         * There must be no scale
	         */
	        buildScale: function() {}
	
	      });
	
	      /*
	       * VIZABI Data Model (options.data)
	       */
	
	      var LabelModel = Hook.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	        },
	
	        /**
	         * Initializes the size hook
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "label";
	          //TODO: add defaults extend to super
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	          this._super(name, values, parent, bind);
	        }
	
	
	      });
	
	      var LanguageModel = Model.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          id: "en",
	          strings: {}
	        },
	
	        /**
	         * Initializes the language model.
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "language";
	          //default values for state model
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	
	          //same constructor, with same arguments
	          this._super(name, values, parent, bind);
	        },
	
	        /**
	         * Gets a certain UI string
	         * @param {String} id string identifier
	         * @param {String} lang language
	         * @param {Object} ui_strings ui_strings object or model
	         * @returns {string} translated string
	         */
	        getUIString: function(id, lang, strings) {
	          lang = lang || this.id;
	          strings = strings || this.strings;
	
	          if(strings && strings[lang] && (strings[lang][id] || strings[lang][id]==="")) {
	            return strings[lang][id];
	          } else {
	            if(!strings || !strings[lang]) warn("Strings are not loaded for the " + lang + " language. Check if translation JSON is valid");
	            return id;
	          }
	        },
	
	        /**
	         * Gets the translation function
	         * @returns {string} translation function
	         */
	        getTFunction: function() {
	          var lang = this.id,
	            strings = this.strings,
	            _this = this;
	
	          return function(string) {
	            return _this.getUIString(string, lang, strings);
	          }
	        }
	
	      });
	
	      /*!
	       * HOOK MODEL
	       */
	
	
	      var Marker = Model.extend({
	
	        /**
	         * Gets the narrowest limits of the subhooks with respect to the provided data column
	         * @param {String} attr parameter (data column)
	         * @returns {Object} limits (min and max)
	         * this function is only needed to route the "time" to some indicator, 
	         * to adjust time start and end to the max and min time available in data
	         */
	        getTimeLimits: function(attr) {
	            var _this = this;
	            var time = this._parent.time;
	            var min, max, minArray = [], maxArray = [], items = {};      
	            if (!this.cachedTimeLimits) this.cachedTimeLimits = {};      
	            forEach(this.getSubhooks(), function(hook) {
	              if(hook.use !== "indicator" || !hook._important) return;
	              var hookConceptprops = hook.getConceptprops();
	              if(!hookConceptprops) return warn(hook._name + ": " + hook.which + " is not found in metadata.json. \
	            Check that you read the correct file or server instance... \
	            Check that the pointer 'which' of the hook is correct too");
	                                              
	              var availability = hookConceptprops.availability;
	              var availabilityForHook = _this.cachedTimeLimits[hook._dataId + hook.which];
	                
	              if (availabilityForHook){
	                  //if already calculated the limits then no ned to do it again
	                  min = availabilityForHook.min;
	                  max = availabilityForHook.max;
	              }else if (availability){
	                  //if date limits are supplied by the concept properties then use them
	                  min = time.timeFormat.parse(availability[0]+"");
	                  var timeEnd = time._defaults.end || availability[1];
	                  max = time.timeFormat.parse(Math.min(timeEnd, availability[1])+"");
	              }else{ 
	                  //otherwise calculate own date limits (a costly operation)
	                  items = hook.getValidItems().map(function(m){return m[time.getDimension()];});
	                  min = d3.min(items);
	                  max = d3.max(items);
	              }
	              _this.cachedTimeLimits[hook._dataId + hook.which] = {min: min, max: max};
	              minArray.push(min);
	              maxArray.push(max);
	            });
	            
	            var resultMin = d3.max(minArray);
	            var resultMax = d3.min(maxArray);
	            if(resultMin > resultMax) {
	                resultMin = d3.min(minArray);
	                resultMax = d3.max(maxArray);
	                warn("getTimeLimits(): Availability of the indicator's data has no intersection. I give up and just return some valid time range where you'll find no data points. Enjoy!")
	            }
	            return {min: resultMin, max: resultMax}
	        },
	
	
	        /**
	         * Computes the intersection of keys in all hooks: a set of keys that have data in each hook
	         * @returns array of keys that have data in all hooks of this._datacube
	         */
	          getKeys: function(KEY) {
	              var _this = this;
	              var resultKeys = [];
	              
	              KEY = KEY || this._getFirstDimension();
	              var TIME = this._getFirstDimension({type: "time"});
	            
	              forEach(this._dataCube||this.getSubhooks(true), function(hook, name) {
	
	                  // If hook use is constant, then we can provide no additional info about keys
	                  // We can just hope that we have something else than constants =)
	                  if(hook.use === "constant") return;
	
	                  // Get keys in data of this hook
	                  var nested = _this.getDataManager().get(hook._dataId, 'nested', [KEY, TIME]);
	                  var noDataPoints = _this.getDataManager().get(hook._dataId, 'haveNoDataPointsPerKey', hook.which);
	                  
	                  var keys = Object.keys(nested);
	                  var keysNoDP = Object.keys(noDataPoints || []);
	
	                  // If ain't got nothing yet, set the list of keys to result
	                  if(resultKeys.length == 0) resultKeys = keys;
	                      
	                  // Remove the keys from it that are not in this hook
	                  if(hook._important) resultKeys = resultKeys.filter(function(f) {
	                    return keys.indexOf(f) > -1 && keysNoDP.indexOf(f) == -1;
	                  })
	              });
	              return resultKeys.map(function(d){var r = {}; r[KEY] = d; return r; });
	          },
	          
	        /**
	         * 
	         * @param {String|null} time of a particularly requested data frame. Null if all frames are requested
	         * @param {function} cb 
	         * @return null
	         */
	          getFrame: function(time, cb) {
	            var _this = this;
	            if (!this.cachedFrames) this.cachedFrames = {};
	            this._dataCube = this._dataCube || this.getSubhooks(true);  
	            
	            //array of steps -- names of all frames  
	            var steps = this._parent.time.getAllSteps();
	              
	            var cachePath = steps[0] + " - " + steps[steps.length-1];
	            var dataLoading = false;
	            forEach(this._dataCube, function(hook, name) {
	              if (hook._loadCall) dataLoading = true;  
	              cachePath = cachePath + "_" +  hook._dataId;
	            });
	            // prevent calculating corrupted frames when one of models is loading 
	            if (dataLoading) return cb(null, time);
	            // check if the requested time point has a cached animation frame
	            if(time && _this.cachedFrames[cachePath] && _this.cachedFrames[cachePath][time]) {
	              // if it does, then return that frame directly and stop here
	              //QUESTION: can we call the callback and return the frame? this will allow callbackless API too
	              return cb(_this.cachedFrames[cachePath][time], time);
	            } else {
	              // if it doesn't (the requested time point falls between animation frames or frame is not cached yet)
	              // check if interpolation makes sense: we've requested a particular time and we have more than one frame
	              if (time && steps.length > 1) {
	                
	                //find the next frame after the requested time point
	                var nextFrameIndex = d3.bisectLeft(steps, time);
	                
	                if(!steps[nextFrameIndex]) warn("The requested frame is out of range");
	                  
	                //if "time" doesn't hit the frame precisely 
	                if (steps[nextFrameIndex].toString() != time.toString()) {
	                  
	                  //interpolate between frames and fire the callback
	                  this._interpolateBetweenFrames(time, nextFrameIndex, steps, function (response) {
	                    return cb(response, time); 
	                  }); 
	                }
	              }
	              
	              //QUESTION: we don't need any further execution after we called for interpolation, right?
	              //request preparing the data, wait until it's done
	              _this.getFrames(time).then(function() {
	                if (!time && _this.cachedFrames[cachePath]) {
	                  //time can be null: then return all frames
	                  return cb(_this.cachedFrames[cachePath], time);
	                } else if(_this.cachedFrames[cachePath][time]) {
	                  //time can be !null: then a particular frame calculation was forced and now it's done  
	                  return cb(_this.cachedFrames[cachePath][time], time);
	                } else {
	                  warn("marker.js getFrame: Data is not available for frame: " + time);
	                  return cb(null, time);
	                }
	              }); 
	            }
	          },
	          
	          _interpolateBetweenFrames: function(time, nextFrameIndex, steps, cb) {
	            var _this = this;
	            
	            if (nextFrameIndex == 0) {
	              //getFrame makes sure the frane is ready because a frame with non-existing data might be adressed
	              this.getFrame(steps[nextFrameIndex], function(values) { 
	                return cb(values);
	              });
	            } else {
	              var prevFrameTime = steps[nextFrameIndex - 1];
	              var nextFrameTime = steps[nextFrameIndex];
	                
	              //getFrame makes sure the frane is ready because a frame with non-existing data might be adressed
	              this.getFrame(prevFrameTime, function(pValues) {
	                _this.getFrame(nextFrameTime, function(nValues) {
	                  var fraction = (time - prevFrameTime) / (nextFrameTime - prevFrameTime);
	                  var dataBetweenFrames = {};
	                  
	                  //loop across the hooks
	                  forEach(pValues, function(values, hook) {
	                    dataBetweenFrames[hook] = {};
	                  
	                    //loop across the entities
	                    forEach(values, function(val1, key) {
	                      var val2 = nValues[hook][key];
	                      if(isDate(val1)){
	                        dataBetweenFrames[hook][key] = time;
	                      } else if(!isNumber(val1)){
	                          //we can be interpolating string values
	                          dataBetweenFrames[hook][key] = val1;
	                      }else{
	                          //interpolation between number and null should rerurn null, not a value in between (#1350)
	                          dataBetweenFrames[hook][key] = (val1==null || val2==null) ? null : val1 + ((val2 - val1) * fraction);
	                      }
	                    });
	                  });
	                  cb(dataBetweenFrames);
	                })
	              })
	            }
	          },
	
	          getFrames: function(forceFrame) {
	            var _this = this;
	            
	            var KEY = this._getFirstDimension();
	            var TIME = this._getFirstDimension({type: "time"});
	            
	            if (!this.frameQueues) this.frameQueues = {}; //static queue of frames
	            if (!this.partialResult) this.partialResult = {};
	              
	            //array of steps -- names of all frames  
	            var steps = this._parent.time.getAllSteps();
	              
	            var cachePath = steps[0] + " - " + steps[steps.length-1];
	            forEach(this._dataCube, function(hook, name) {
	              cachePath = cachePath + "_" + hook._dataId;
	            });
	
	            //if the collection of frames for this data cube is not scheduled yet (otherwise no need to repeat calculation)
	            if (!this.frameQueues[cachePath] || !this.frameQueues[cachePath] instanceof Promise) {
	              
	              //this is a promise nobody listens to - it prepares all the frames we need without forcing any  
	              this.frameQueues[cachePath] = new Promise(function(resolve, reject) { 
	
	                _this.partialResult[cachePath] = {};
	                steps.forEach(function(t) { _this.partialResult[cachePath][t] = {}; });
	
	                // Assemble the list of keys as an intersection of keys in all queries of all hooks
	                var keys = _this.getKeys();
	
	                var deferredHooks = [];
	              
	                // Assemble data from each hook. Each frame becomes a vector containing the current configuration of hooks.
	                // frame -> hooks -> entities: values
	                forEach(_this._dataCube, function(hook, name) {
	                  if(hook.use === "constant") {
	                    //special case: fill data with constant values
	                    steps.forEach(function(t) {
	                      _this.partialResult[cachePath][t][name] = {};
	                      keys.forEach(function(key) {
	                        _this.partialResult[cachePath][t][name][key[KEY]] = hook.which;
	                      });
	                    });
	                  } else if(hook.which === KEY) {
	                    //special case: fill data with keys to data itself
	                    steps.forEach(function(t) {
	                      _this.partialResult[cachePath][t][name] = {};
	                      keys.forEach(function(key) {
	                        _this.partialResult[cachePath][t][name][key[KEY]] = key[KEY];
	                      });
	                    });
	                  } else if(hook.which === TIME) {
	                    //special case: fill data with time points
	                    steps.forEach(function(t) {
	                      _this.partialResult[cachePath][t][name] = {};
	                      keys.forEach(function(key) {
	                        _this.partialResult[cachePath][t][name][key[KEY]] = new Date(t);
	                      });
	                    });
	                  } else {
	                    //calculation of async frames is taken outside the loop
	                    //hooks with real data that needs to be fetched from datamanager
	                    deferredHooks.push({hook: hook, name: name}); 
	                  }
	                });
	                  
	                //check if we have any data to get from datamanager
	                if (deferredHooks.length > 0) {
	                  var promises = [];
	                  for (var hookId = 0; hookId < deferredHooks.length; hookId++) {
	                    (function(hookKey) {
	                      var defer = deferredHooks[hookKey];
	                      promises.push(new Promise(function(res, rej) {
	                        _this.getDataManager().getFrames(defer.hook._dataId, steps).then(function(response) {
	                          forEach(response, function (frame, t) {
	                            _this.partialResult[cachePath][t][defer.name] = frame[defer.hook.which];
	                          });
	                          res();
	                        })
	                      }));
	                    }(hookId));
	                  }
	                  Promise.all(promises).then(function() {
	                    _this.cachedFrames[cachePath] = _this.partialResult[cachePath];
	                    resolve();
	                  });
	                } else {
	                  _this.cachedFrames[cachePath] = _this.partialResult[cachePath];
	                  resolve();
	                }
	
	              });
	            }
	
	            return new Promise(function(resolve, reject) {
	              if (steps.length < 2 || !forceFrame) {
	                  //wait until the above promise is resolved, then resolve the current promise
	                _this.frameQueues[cachePath].then(function() {
	                  resolve(); //going back to getFrame(), to ".then"
	                });
	              } else {
	                var promises = [];
	                forEach(_this._dataCube, function(hook, name) {
	                  //exception: we know that these are knonwn, no need to calculate these
	                  if(hook.use !== "constant" && hook.which !== KEY && hook.which !== TIME) {
	                    (function(_hook, _name) {
	                      promises.push(new Promise(function(res, rej) {
	                        _this.getDataManager().getFrame(_hook._dataId, steps, forceFrame).then(function(response) {
	                          _this.partialResult[cachePath][forceFrame][_name] = response[forceFrame][_hook.which];
	                          res();
	                        })
	                      }));
	                    }(hook, name)); //isolate this () code with its own hook and name
	                  }
	                });
	                if (promises.length > 0) {
	                  Promise.all(promises).then(function() {
	                    if (!_this.cachedFrames[cachePath]) {
	                      _this.cachedFrames[cachePath] = {};
	                    }
	                    _this.cachedFrames[cachePath][forceFrame] = _this.partialResult[cachePath][forceFrame];
	                    resolve();
	                  });
	                }
	              }
	            });
	
	          },
	          
	          
	
	        /**
	         * gets multiple values from the hook
	         * @param {Object} filter Reference to the row. e.g: {geo: "swe", time: "1999", ... }
	         * @param {Array} group_by How to nest e.g: ["geo"]
	         * @param {Boolean} [previous = false] previous Append previous data points
	         * @returns an array of values
	         */
	        getValues: function(filter$$, group_by, previous) {
	          var _this = this;
	
	          if(this.isHook()) {
	            return [];
	          }
	
	          var dimTime, time, filtered, next, method, u, w, value, method;
	          this._dataCube = this._dataCube || this.getSubhooks(true);
	          filter$$ = clone(filter$$, this._getAllDimensions());
	          dimTime = this._getFirstDimension({
	            type: 'time'
	          });
	          time = new Date(filter$$[dimTime]); //clone date
	          filter$$ = clone(filter$$, null, dimTime);
	
	          var response = {};
	          var f_keys = Object.keys(filter$$);
	          var f_values = f_keys.map(function(k) {
	            return filter$$[k];
	          });
	
	          //if there's a filter, interpolate only that
	          if(f_keys.length) {
	            forEach(this._dataCube, function(hook, name) {
	              u = hook.use;
	              w = hook.which;
	
	              if(hook.use !== "property") next = next || d3.bisectLeft(hook.getUnique(dimTime), time);        
	
	              method = hook.getConceptprops ? hook.getConceptprops().interpolation : null;
	              filtered = _this.getDataManager().get(hook._dataId, 'nested', f_keys);
	              forEach(f_values, function(v) {
	                filtered = filtered[v]; //get precise array (leaf)
	              });
	              value = interpolatePoint(filtered, u, w, next, dimTime, time, method);
	              response[name] = hook.mapValue(value);
	
	              //concat previous data points
	              if(previous) {
	                var values = filter(filtered, filter$$).filter(function(d) {
	                  return d[dimTime] <= time;
	                }).map(function(d) {
	                  return hook.mapValue(d[w]);
	                }).concat(response[name]);
	                response[name] = values;
	              }
	            });
	          }
	          //else, interpolate all with time
	          else {
	            forEach(this._dataCube, function(hook, name) {
	                
	              filtered = _this.getDataManager().get(hook._dataId, 'nested', group_by);
	                  
	              response[name] = {};
	              //find position from first hook
	              u = hook.use;
	              w = hook.which;
	                
	              if(hook.use !== "property") next = (typeof next === 'undefined') ? d3.bisectLeft(hook.getUnique(dimTime), time) : next;
	              
	              method = hook.getConceptprops ? hook.getConceptprops().interpolation : null;
	                      
	              var interpolate = function(arr, result, id) {
	                //TODO: this saves when geos have different data length. line can be optimised. 
	                next = d3.bisectLeft(arr.map(function(m){return m[dimTime]}), time);
	                  
	                value = interpolatePoint(arr, u, w, next, dimTime, time, method);
	                result[id] = hook.mapValue(value);
	
	                //concat previous data points
	                if(previous) {
	                  var values = filter(arr, filter$$).filter(function(d) {
	                    return d[dimTime] <= time;
	                  }).map(function(d) {
	                    return hook.mapValue(d[w]);
	                  }).concat(result[id]);
	                  result[id] = values;
	                }
	
	              }
	              
	              var iterateGroupKeys = function(data, deep, result, cb) {
	                deep--;
	                forEach(data, function(d, id) {
	                  if(deep) {
	                    result[id] = {};
	                    iterateGroupKeys(d, deep, result[id], cb);
	                  } else {
	                    cb(d, result, id);
	                  }
	                });
	              }
	              
	              iterateGroupKeys(filtered, group_by.length, response[name], interpolate);
	              
	            });
	          }
	
	          return response;
	        },
	
	        /**
	         * Gets the concept properties of all hooks
	         * @returns {Object} concept properties
	         */
	        getConceptprops: function() {
	          return this.getDataManager().getConceptprops();
	        },
	          
	        /**
	         * Gets the concept properties of all hooks
	         * @returns {Object} concept properties
	         */
	        getIndicatorsTree: function() {
	          return this.getDataManager().getIndicatorsTree();
	        } 
	          
	
	      });
	
	      /*
	       * VIZABI Size Model
	       */
	
	      var SizeModel = AxisModel.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          use: null,
	          which: null,
	          domainMin: null,
	          domainMax: null,
	          zoomedMin: null,
	          zoomedMax: null,
	          extent: null
	        },
	          
	        _type: "size",
	          
	        buildScale: function(margins){
	          //do whatever axis.buildScale does
	          this._super(margins);
	          //but then also clamp a numeric scale
	          if(this.scaleType !== 'ordinal') this.scale.clamp(true);
	        }
	      });
	
	      /*
	       * VIZABI Stack Model
	       */
	
	      var palettes = {
	        'ALL': "all",
	        _default: "none"
	      };
	
	      var StackModel = Hook.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          use: null,
	          which: null,
	          merge: false
	        },
	        /**
	         * Initializes the stack hook
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "model";
	          //TODO: add defaults extend to super
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	          this._super(name, values, parent, bind);
	        },
	
	        /**
	         * Validates a color hook
	         */
	        validate: function() {
	          //there must be no scale
	          if(this.scale) this.scale = null;
	
	          //use must not be "indicator" 
	          if(this.use === "indicator") {
	            warn("stack model: use must not be 'indicator'. Resetting use to 'constant' and which to '" + palettes._default)
	            this.use = "constant";
	            this.which = palettes._default;
	          }
	
	          //if use is "constant"
	          if(this.use === "constant" && values(palettes).indexOf(this.which) == -1) {
	            warn("stack model: the requested value '" + this.which + "' is not allowed. resetting to '" +
	              palettes._default)
	            this.which == palettes._default;
	          }
	        },
	
	        /**
	         * Get the above constants
	         */
	        getPalettes: function() {
	          return palettes;
	        },
	
	        /**
	         * There must be no scale
	         */
	        buildScale: function() {}
	
	      });
	
	      /*!
	       * VIZABI Time Model
	       */
	
	      // short-cut for developers to get UTC date strings
	      // not meant to be used in code!!!
	      Date.prototype.utc = Date.prototype.toUTCString;
	
	      /*
	       * Time formats for internal data
	       * all in UTC
	       */
	      var formats = {
	        'year':    d3.time.format.utc('%Y'),
	        'month':   d3.time.format.utc('%Y%m'),
	        'day':     d3.time.format.utc('%Y%m%d'),
	        'hour':    d3.time.format.utc("%Y-%m-%d %H"),
	        'minute':  d3.time.format.utc("%Y-%m-%d %H:%M"),
	        'second':  d3.time.format.utc("%Y-%m-%d %H:%M:%S"),
	        'week':    weekFormat(),   // %Yw%W d3 week format does not comply with ISO
	        'quarter': quarterFormat() // %Yq%Q d3 does not support quarters
	      };
	
	      var TimeModel = Model.extend({
	
	        /**
	         * Default values for this model
	         */
	        _defaults: {
	          dim: "time",
	          value: "2015",
	          start: "1800", //mandatory defaults! 
	          end: "2016", //mandatory defaults!
	          startSelected: "1800",
	          endSelected: "2015",
	          playable: true,
	          playing: false,
	          loop: false,
	          round: 'round',
	          delay: 600, //delay between animation frames
	          delayThresholdX2: 600, //delay X2 boundary: if less -- then every other frame will be dropped and animation dely will be double the value
	          delayThresholdX4: 600, //delay X4 boundary: if less -- then 3/4 frame will be dropped and animation dely will be 4x the value
	          unit: "year",
	          step: 1, //step must be integer, and expressed in units
	          immediatePlay: false,
	          record: false
	        },
	
	        /**
	         * Initializes the language model.
	         * @param {Object} values The initial values of this model
	         * @param parent A reference to the parent model
	         * @param {Object} bind Initial events to bind
	         */
	        init: function(name, values, parent, bind) {
	
	          this._type = "time";
	          //default values for time model
	          var defaults = deepClone(this._defaults);
	          values = extend(defaults, values);
	
	          //same constructor
	          this._super(name, values, parent, bind);
	
	          var _this = this;
	          this.timeFormat = formats[this.unit];
	          this.dragging = false;
	          this.postponePause = false;
	          this.allSteps = {};
	          this.delayAnimations = this.delay;
	
	          //bing play method to model change
	          this.on({
	
	            "change:playing": function() {
	              if(_this.playing === true) {
	                _this._startPlaying();
	              } else {
	                _this._stopPlaying();
	              }
	            },
	
	            "change:unit": function() {
	              _this.timeFormat = formats[_this.unit];
	            }
	
	          });
	        },
	
	        /**
	         * Formats value, start and end dates to actual Date objects
	         */
	        _formatToDates: function() {
	
	          var date_attr = ["value", "start", "end", "startSelected", "endSelected"];
	          for(var i = 0; i < date_attr.length; i++) {
	            var attr = date_attr[i];
	            if(!isDate(this[attr])) {
	              var date = this.parseToUnit(this[attr].toString(), this.unit);
	              this.set(attr, date);
	            }
	          }
	        },
	
	        /*
	         * Formatting and parsing functions
	         * @param {Date} date
	         * @param {String} unit
	         * @returns {String}
	         */
	        format: function(dateObject, unit) {
	          unit = unit || this.unit;
	          return formats[unit] ? formats[unit](dateObject) : formats['year'](dateObject);
	        },
	
	        parseToUnit: function(timeString, unit) {
	          unit = unit || this.unit;
	          return formats[unit] ? formats[unit].parse(timeString) : null;
	        },
	
	        parse: function(timeString) {
	          var keys = Object.keys(formats), i = 0; 
	          for (; i < keys.length; i++) {
	            var dateObject = formats[keys[i]].parse(timeString);
	            if (dateObject) return { unit: keys[i], time: dateObject };
	          }
	          return null;
	        },
	
	
	        /**
	         * Validates the model
	         */
	        validate: function() {
	
	          //unit has to be one of the available_time_units
	          if(!formats[this.unit]) {
	            warn(this.unit + ' is not a valid time unit, using "year" instead.');
	            this.unit = "year";
	          }
	
	          if(this.step < 1) {
	            this.step = 1;
	          }
	            
	          //make sure dates are transformed into dates at all times
	          if(!isDate(this.start) || !isDate(this.end) || !isDate(this.value) 
	            || !isDate(this.startSelected) || !isDate(this.endSelected)) {
	            this._formatToDates();
	          }
	
	          //end has to be >= than start
	          if(this.end < this.start) {
	            this.end = new Date(this.start);
	          }
	          
	          if(this.value < this.startSelected) {
	            this.value = new Date(this.startSelected); 
	          }
	          
	          if(this.value > this.endSelected) {
	            this.value = new Date(this.endSelected);
	          }
	          
	          if(this.startSelected < this.start) {
	            this.startSelected = new Date(this.start);
	          }
	
	          if(this.endSelected > this.end) {
	            this.endSelected = new Date(this.end);
	          }
	        
	          //value has to be between start and end
	          if(this.value < this.start) {
	            this.value = new Date(this.start);
	          } else if(this.value > this.end) {
	            this.value = new Date(this.end);
	          }
	
	          if(this.playable === false && this.playing === true) {
	            this.playing = false;
	          }
	        },
	
	        /**
	         * Plays time
	         */
	        play: function() {
	          this._startPlaying();
	        },
	
	        /**
	         * Pauses time
	         */
	        pause: function(soft) {
	          if(soft) {
	            this.postponePause = true;
	          } else {
	            this.playing = false;
	          }
	        },
	
	        /**
	         * Indicates dragging of time
	         */
	        dragStart: function() {
	          this.dragging = true;
	        },
	        dragStop: function() {
	          this.dragging = false;
	        },
	
	
	        /**
	         * gets time range
	         * @returns range between start and end
	         */
	        getRange: function() {
	          var is = this.getIntervalAndStep();
	          return d3.time[is.interval].utc.range(this.start, this.end, is.step);
	        },
	
	        /** 
	         * gets the d3 interval and stepsize for d3 time interval methods
	         * D3's week-interval starts on sunday and it does not support a quarter interval
	         * 
	         **/
	        getIntervalAndStep: function() {
	          var d3Interval, step;
	          switch (this.unit) {
	            case 'week': d3Interval = 'monday'; step = this.step; break;
	            case 'quarter': d3Interval = 'month'; step = this.step*3; break;
	            default: d3Interval = this.unit; step = this.step; break;
	          }
	          return { interval: d3Interval, step: step };
	        },
	
	        /**
	         * Gets filter for time
	         * @param {Boolean} firstScreen get filter for current year only
	         * @returns {Object} time filter
	         */
	        getFilter: function(firstScreen) {
	          var defaultStart = this.parseToUnit(this._defaults.start, this.unit);
	          var defaultEnd = this.parseToUnit(this._defaults.end, this.unit);
	            
	          var start = this.timeFormat(defaultStart || this.start);
	          var end = this.timeFormat(defaultEnd || this.end);
	          var value = this.timeFormat(this.value);
	          var dim = this.getDimension();
	          var filter = {};
	
	          filter[dim] = (firstScreen) ? [
	            [value]
	          ] : [
	            [start, end]
	          ];
	          return filter;
	        },
	
	        /**
	         * Gets formatter for this model
	         * @returns {Function} formatter function
	         */
	        getParser: function() {
	          return this.timeFormat.parse;
	        },
	
	        /**
	         * Gets an array with all time steps for this model
	         * @returns {Array} time array
	         */
	        getAllSteps: function() {
	          var hash = "" + this.start + this.end + this.step;
	          
	          //return if cached
	          if(this.allSteps[hash]) return this.allSteps[hash];
	            
	          this.allSteps[hash] = [];
	          var curr = this.start;
	          while(curr <= this.end) {
	            var is = this.getIntervalAndStep();
	            this.allSteps[hash].push(curr);
	            curr = d3.time[is.interval].utc.offset(curr, is.step);
	          }
	          return this.allSteps[hash];
	        },
	
	        /**
	         * Snaps the time to integer
	         * possible inputs are "start", "end", "value". "value" is default
	         */
	        snap: function(what) {
	          if(!this.round) return;
	          if(what == null) what = "value";
	          var op = 'round';
	          if(this.round === 'ceil') op = 'ceil';
	          if(this.round === 'floor') op = 'floor';
	          var is = this.getIntervalAndStep();
	          var time = d3.time[is.interval].utc[op](this[what]);
	          this.set(what, time, true); //3rd argumennt forces update
	        },
	
	        /**
	         * Starts playing the time, initializing the interval
	         */
	        _startPlaying: function() {
	          //don't play if it's not playable
	          if(!this.playable) return;
	
	          var _this = this;
	
	          //go to start if we start from end point
	          if(this.value >= this.endSelected) {
	            _this.getModelObject('value').set(_this.startSelected, null, false /*make change non-persistent for URL and history*/);
	          } else {
	            //the assumption is that the time is already snapped when we start playing
	            //because only dragging the timeslider can un-snap the time, and it snaps on drag.end
	            //so we don't need this line. let's see if we survive without.
	            //as a consequence, the first time update in playing sequence will have this.playing flag up
	            //so the bubble chart will zoom in smoothly. Closes #1213
	            //this.snap();
	          }
	          this.playing = true;
	          this.playInterval(this.immediatePlay);
	
	          this.trigger("play");
	        },
	
	        playInterval: function(immediatePlay){
	          if(!this.playing) return;
	          var _this = this;
	          this.delayAnimations = this.delay;
	          if(this.delay < this.delayThresholdX2) this.delayAnimations*=2;
	          if(this.delay < this.delayThresholdX4) this.delayAnimations*=2;
	
	          var delayAnimations = immediatePlay ? 1 : this.delayAnimations;
	
	          this._intervals.setInterval('playInterval_' + this._id, function() {
	            // when time is playing and it reached the end
	            if(_this.value >= _this.endSelected) {
	              // if looping
	              if(_this.loop) {
	                // reset time to start, silently
	                _this.getModelObject('value').set(_this.startSelected, null, false /*make change non-persistent for URL and history*/);
	              } else {
	                _this.playing = false;
	              }
	              return;
	            } else {
	
	              _this._intervals.clearInterval('playInterval_' + _this._id);
	
	              if(_this.postponePause || !_this.playing) {
	                _this.playing = false;
	                _this.postponePause = false;
	                _this.getModelObject('value').set(_this.value, true, true /*force the change and make it persistent for URL and history*/);
	              } else {
	                var is = _this.getIntervalAndStep();
	                if(_this.delay < _this.delayThresholdX2) is.step*=2;
	                if(_this.delay < _this.delayThresholdX4) is.step*=2;
	                var time = d3.time[is.interval].utc.offset(_this.value, is.step);
	                if(time >= _this.endSelected) {
	                  // if no playing needed anymore then make the last update persistent and not overshooting
	                  _this.getModelObject('value').set(_this.endSelected, null, true /*force the change and make it persistent for URL and history*/);
	                }else{
	                  _this.getModelObject('value').set(time, null, false /*make change non-persistent for URL and history*/);
	                }
	                _this.playInterval();
	              }
	            }
	          }, delayAnimations);
	
	        },
	        
	        incrementTime: function(time) {
	          var is = this.getIntervalAndStep();
	          return d3.time[is.interval].utc.offset(time, is.step);
	        },
	
	        /**
	         * Stops playing the time, clearing the interval
	         */
	        _stopPlaying: function() {
	          this._intervals.clearInterval('playInterval_' + this._id);
	          //this.snap();
	          this.trigger("pause");
	        }
	
	      });
	
	      /*
	       * Week Format to format and parse dates
	       * Conforms with ISO8601
	       * Follows format: YYYYwWW: 2015w04, 3845w34, 0020w53
	       */ 
	      function weekFormat() {
	
	        var format = function(d) {
	          return formatWeekYear(d) + 'w' + formatWeek(d);
	        }
	        
	        format.parse = function parse(dateString) {
	          var matchedDate = dateString.match(/^(\d{4})w(\d{2})$/);
	          return matchedDate ? getDateFromWeek(matchedDate[1], matchedDate[2]): null;
	        };
	        
	        var formatWeekYear = function(d) {
	            var origin = +d;
	            return new Date(origin + ((4 - (d.getUTCDay() || 7)) * 86400000)).getUTCFullYear();
	        };
	        
	        var formatWeek = function(d) {
	          var origin = +d;
	          var quote = new Date(origin + ((4 - (d.getUTCDay() || 7)) * 86400000))
	          var week = Math.ceil(((quote.getTime() - quote.setUTCMonth(0, 1)) / 86400000 + 1) / 7);
	          return week < 10 ? '0' + week : week;
	        };
	        
	        var getDateFromWeek = function(p1, p2) {
	          var week = parseInt(p2);
	          var year = p1;
	          var startDateOfYear = new Date(); // always 4th of January (according to standard ISO 8601)
	          startDateOfYear.setUTCFullYear(year);
	          startDateOfYear.setUTCMonth(0);
	          startDateOfYear.setUTCDate(4);
	          var startDayOfWeek = startDateOfYear.getUTCDay() || 7;
	          var dayOfWeek = 1; // Monday === 1
	          var dayOfYear = week * 7 + dayOfWeek - (startDayOfWeek + 4);
	
	          var date = formats['year'].parse(year);
	          date = new Date(date.getTime() + dayOfYear * 24 * 60 * 60 * 1000);
	
	          return date;
	        }
	        
	        return format;
	        
	      };
	
	      /*
	       * Quarter Format to format and parse quarter dates
	       * A quarter is the month%3
	       * Follows format: YYYYqQ: 2015q4, 5847q1, 0040q2
	       */ 
	      function quarterFormat() {
	        
	        var format = function(d) {
	          return formats['year'](d) + 'q' + formatQuarter(d)
	        }
	        
	        format.parse = function(dateString) {
	          var matchedDate = dateString.match(/^(\d{4})q(\d)$/);
	          return matchedDate ? getDateFromQuarter(matchedDate[1], matchedDate[2]): null;
	        }
	
	        var formatQuarter = function(d) {
	          return ((d.getUTCMonth() / 3) | 0) + 1;
	        };
	       
	        var getDateFromQuarter = function(p1, p2) {
	          var quarter = parseInt(p2);
	          var month = 3 * quarter - 2; // first month in quarter
	          var year = p1;
	          return formats['month'].parse([year, (month < 9 ? '0': '') + month].join(''));
	        }   
	        
	        return format;
	      }
	
	      var _index = {
	      axis : AxisModel,
	      color : ColorModel,
	      data : DataModel,
	      entities : EntitiesModel,
	      group : GroupModel,
	      hook : Hook,
	      label : LabelModel,
	      language : LanguageModel,
	      marker : Marker,
	      size : SizeModel,
	      stack : StackModel,
	      time : TimeModel,
	      };
	
	var models = Object.freeze({
	      	axis: AxisModel,
	      	color: ColorModel,
	      	data: DataModel,
	      	entities: EntitiesModel,
	      	group: GroupModel,
	      	hook: Hook,
	      	label: LabelModel,
	      	language: LanguageModel,
	      	marker: Marker,
	      	size: SizeModel,
	      	stack: StackModel,
	      	time: TimeModel,
	      	default: _index
	      });
	
	      var class_loading_first$1 = 'vzb-loading-first';
	      var class_loading_data$1 = 'vzb-loading-data';
	      var class_error = 'vzb-error';
	
	      var templates$1 = {};
	      var Component = EventSource.extend({
	
	        /**
	         * Initializes the component
	         * @param {Object} config Initial config, with name and placeholder
	         * @param {Object} parent Reference to tool
	         */
	        init: function(config, parent) {
	          this._id = this._id || uniqueId('c');
	          this._ready = false;
	          this._readyOnce = false;
	          this.name = this.name || config.name;
	          this.template = this.template || '<div></div>';
	          this.placeholder = this.placeholder || config.placeholder;
	          this.template_data = this.template_data || {
	            name: this.name
	          };
	          //make sure placeholder is DOM element
	          if(this.placeholder && !isElement(this.placeholder)) {
	            try {
	              this.placeholder = parent.placeholder.querySelector(this.placeholder);
	            } catch(e) {
	              error$1('Error finding placeholder \'' + this.placeholder + '\' for component \'' + this.name + '\'');
	            }
	          }
	          this.parent = parent || this;
	          this.root = this.parent.root || this;
	
	          this.components = this.components || [];
	          this._components_config = this.components.map(function(x) {
	            return clone(x);
	          });
	          this._frameRate = 10;
	          //define expected models for this component
	          this.model_expects = this.model_expects || [];
	          this.model_binds = this.model_binds || {};
	          this.ui = this.ui || config.ui;
	          this._super();
	          //readyOnce alias
	          var _this = this;
	          this.on({
	            'readyOnce': function() {
	              if(typeof _this.readyOnce === 'function') {
	                _this.readyOnce();
	              }
	            },
	            'ready': function() {
	              if(typeof _this.ready === 'function') {
	                _this.ready();
	              }
	            },
	            'domReady': function() {
	              if(typeof _this.domReady === 'function') {
	                _this.domReady();
	              }
	            },
	            'resize': function() {
	              if(typeof _this.resize === 'function') {
	                _this.resize();
	              }
	            }
	          });
	          this.triggerResize = throttle(this.triggerResize, 100);
	        },
	
	        /**
	         * Preloads data before anything else
	         */
	        preload: function(promise) {
	          promise.resolve(); //by default, load nothing
	        },
	
	        /**
	         * Executes after preloading is finished
	         */
	        afterPreload: function() {
	          if(this.model) {
	            this.model.afterPreload();
	          }
	        },
	
	        /**
	         * Renders the component (after data is ready)
	         */
	        render: function() {
	          var _this = this;
	          this.loadTemplate();
	          this.loadComponents();
	          //render each subcomponent
	          forEach(this.components, function(subcomp) {
	            subcomp.render();
	            _this.on('resize', function() {
	              subcomp.trigger('resize');
	            });
	          });
	
	          // if a componente's model is ready, the component is ready
	          this.model.on('ready', function() {
	            done();
	          });
	
	          //if it's a root component with model
	          if(this.isRoot() && this.model) {
	            this.model.setHooks();
	
	            var splashScreen = this.model && this.model.data && this.model.data.splash;
	
	            preloader(this).then(function() {
	              var timeMdl = _this.model.state.time;
	              if(splashScreen) {
	
	                //TODO: cleanup hardcoded splash screen
	                timeMdl.splash = true;
	                timeMdl.beyondSplash = clone(timeMdl.getPlainObject(), ['start', 'end']);
	
	                _this.model.load({
	                  splashScreen: true
	                }).then(function() {
	                  //delay to avoid conflicting with setReady
	                  delay(function() {
	                    //force loading because we're restoring time.
	                    _this.model.setLoading('restore_orig_time');
	                    //restore because validation kills the original start/end
	                    timeMdl.start = timeMdl.beyondSplash.start;
	                    timeMdl.end = timeMdl.beyondSplash.end;
	                    delete timeMdl.beyondSplash;
	
	                    _this.model.load().then(function() {
	                      _this.model.setLoadingDone('restore_orig_time');
	                      timeMdl.splash = false;
	                      //_this.model.data.splash = false;
	                      timeMdl.trigger('change', timeMdl.getPlainObject());
	                    });
	                  }, 300);
	
	                }, function() {
	                  renderError();
	                });
	              } else {
	                _this.model.load().then(function() {
	                  delay(function() {
	                    if(timeMdl) {
	                      timeMdl.trigger('change');
	                    } else {
	                      done();
	                    }
	                  }, 300);
	                }, function() {
	                  renderError();
	                });
	              }
	            });
	
	          } else if(this.model && this.model.isLoading()) {
	            // nothing
	          } else {
	            done();
	          }
	
	          function renderError() {
	            removeClass(_this.placeholder, class_loading_first$1);
	            removeClass(_this.placeholder, class_loading_data$1);
	            addClass(_this.placeholder, class_error);
	            _this.setError({
	              type: 'data'
	            });
	          }
	
	          function done() {
	            removeClass(_this.placeholder, class_loading_first$1);
	            removeClass(_this.placeholder, class_loading_data$1);        
	            _this.setReady();
	          }
	        },
	
	        setError: function(opts) {
	          if(typeof this.error === 'function') {
	            this.error(opts);
	          }
	        },
	
	        setReady: function(value) {
	          if(!this._readyOnce) {
	            this.trigger('readyOnce');
	            this._readyOnce = true;
	          }
	          this._ready = true;
	          this.trigger('ready');
	        },
	
	        /**
	         * Loads the template
	         * @returns defer a promise to be resolved when template is loaded
	         */
	        loadTemplate: function() {
	          var tmpl = this.template;
	          var data = this.template_data;
	          var _this = this;
	          var rendered = '';
	          if(!this.placeholder) {
	            return;
	          }
	          //todo: improve t function getter + generalize this
	          data = extend(data, {
	            t: this.getTranslationFunction(true)
	          });
	          if(this.template) {
	            try {
	              rendered = templateFunc(tmpl, data);
	            } catch(e) {
	              error$1('Templating error for component: \'' + this.name +
	                '\' - Check if template name is unique and correct. E.g.: \'bubblechart\'');
	
	              removeClass(this.placeholder, class_loading_data$1);
	              addClass(this.placeholder, class_error);
	              this.setError({
	                type: 'template'
	              });
	            }
	          }
	          //add loading class and html
	          addClass(this.placeholder, class_loading_data$1);
	          addClass(this.placeholder, class_loading_first$1);
	          this.placeholder.innerHTML = rendered;
	          this.element = this.placeholder.children[0];
	          //only tools have layout (manage sizes)
	          if(this.layout) {
	            this.layout.setContainer(this.element);
	            this.layout.on('resize', function() {
	              if(_this._ready) {
	                _this.triggerResize();
	              }
	            });
	          }
	          //template is ready
	          this.trigger('domReady');
	        },
	
	        triggerResize: function() {
	          this.trigger('resize');
	        },
	
	        getActiveProfile: function(profiles, presentationProfileChanges) {
	          // get layout values
	          var layoutProfile = this.getLayoutProfile();
	          var presentationMode = this.getPresentationMode();
	          var activeProfile = deepClone(profiles[layoutProfile]); // clone so it can be extended without changing the original profile
	
	          // extend the profile with presentation mode values
	          if (presentationMode && (presentationProfileChanges||{})[layoutProfile]) {
	            deepExtend(activeProfile, presentationProfileChanges[layoutProfile]);
	          }
	
	          return activeProfile;
	        },
	
	        /*
	         * Loads all subcomponents
	         */
	        loadComponents: function() {
	          var _this = this;
	          var config;
	          var comp;
	          //use the same name for collection
	          this.components = [];
	          //external dependencies let this model know what it
	          //has to wait for
	          if(this.model) {
	            this.model.resetDeps();
	          }
	          // Loops through components, loading them.
	          forEach(this._components_config, function(c) {
	            if(!c.component) {
	              error$1('Error loading component: name not provided');
	              return;
	            }
	            comp = (isString(c.component)) ? Component.get(c.component) : c.component;
	
	            if(!comp) return;
	
	            config = extend(c, {
	              name: c.component,
	              ui: _this._uiMapping(c.placeholder, c.ui)
	            });
	            //instantiate new subcomponent
	            var subcomp = new comp(config, _this);
	            var c_model = c.model || [];
	            subcomp.model = _this._modelMapping(subcomp.name, c_model, subcomp.model_expects, subcomp.model_binds);
	            _this.components.push(subcomp);
	          });
	        },
	
	        /**
	         * Checks whether this is the root component
	         * @returns {Boolean}
	         */
	        isRoot: function() {
	          return this.parent === this;
	        },
	
	        /**
	         * Returns subcomponent by name
	         * @returns {Boolean}
	         */
	        findChildByName: function(name) {
	          return find(this.components, function(f) {
	            return f.name === name
	          });
	        },
	
	        /**
	         * Get layout profile of the current resolution
	         * @returns {String} profile
	         */
	        getLayoutProfile: function() {
	          //get profile from parent if layout is not available
	          if(this.layout) {
	            return this.layout.currentProfile();
	          } else {
	            return this.parent.getLayoutProfile();
	          }
	        },
	
	        /**
	         * Get if presentation mode is set of the current tool
	         * @returns {Bool} presentation mode
	         */
	        getPresentationMode: function() {
	          //get profile from parent if layout is not available
	          if(this.layout) {
	            return this.layout.getPresentationMode();
	          } else {
	            return this.parent.getPresentationMode();
	          }
	        },
	
	        //TODO: make ui mapping more powerful
	        /**
	         * Maps the current ui to the subcomponents
	         * @param {String} id subcomponent id (placeholder)
	         * @param {Object} ui Optional ui parameters to overwrite existing
	         * @returns {Object} the UI object
	         */
	        _uiMapping: function(id, ui) {
	          //if overwritting UI
	          if(ui) {
	            return new Model('ui', ui);
	          }
	          if(id && this.ui) {
	            id = id.replace('.', '');
	            //remove trailing period
	            var sub_ui = this.ui[id];
	            if(sub_ui) {
	              return sub_ui;
	            }
	          }
	          return this.ui;
	        },
	
	        /**
	         * Maps the current model to the subcomponents
	         * @param {String} subcomponentName name of the subcomponent
	         * @param {String|Array} model_config Configuration of model
	         * @param {String|Array} model_expects Expected models
	         * @param {Object} model_binds Initial model bindings
	         * @returns {Object} the model
	         */
	        _modelMapping: function(subcomponentName, model_config, model_expects, model_binds) {
	          var _this = this;
	          var values = {};
	          //If model_config is an array, we map it
	          if(isArray(model_config) && isArray(model_expects)) {
	
	            //if there's a different number of models received and expected
	            if(model_expects.length !== model_config.length) {
	              groupCollapsed('DIFFERENCE IN NUMBER OF MODELS EXPECTED AND RECEIVED');
	              warn('Please, configure the \'model_expects\' attribute accordingly in \'' + subcomponentName +
	                '\' or check the models passed in \'' + _this.name + '\'.\n\nComponent: \'' + _this.name +
	                '\'\nSubcomponent: \'' + subcomponentName + '\'\nNumber of Models Expected: ' + model_expects.length +
	                '\nNumber of Models Received: ' + model_config.length);
	              groupEnd();
	            }
	            forEach(model_config, function(m, i) {
	              var model_info = _mapOne(m);
	              var new_name;
	              if(model_expects[i]) {
	                new_name = model_expects[i].name;
	                if(model_expects[i].type && model_info.type !== model_expects[i].type && (!isArray(
	                      model_expects[i].type) ||
	                    model_expects[i].type.indexOf(model_info.type) === -1)) {
	
	                  groupCollapsed('UNEXPECTED MODEL TYPE: \'' + model_info.type + '\' instead of \'' +
	                    model_expects[i].type + '\'');
	                  warn('Please, configure the \'model_expects\' attribute accordingly in \'' + subcomponentName +
	                    '\' or check the models passed in \'' + _this.name + '\'.\n\nComponent: \'' + _this.name +
	                    '\'\nSubcomponent: \'' + subcomponentName + '\'\nExpected Model: \'' + model_expects[i].type +
	                    '\'\nReceived Model\'' + model_info.type + '\'\nModel order: ' + i);
	                  groupEnd();
	                }
	              } else {
	
	                groupCollapsed('UNEXPECTED MODEL: \'' + model_config[i] + '\'');
	                warn('Please, configure the \'model_expects\' attribute accordingly in \'' + subcomponentName +
	                  '\' or check the models passed in \'' + _this.name + '\'.\n\nComponent: \'' + _this.name +
	                  '\'\nSubcomponent: \'' + subcomponentName + '\'\nNumber of Models Expected: ' + model_expects.length +
	                  '\nNumber of Models Received: ' + model_config.length);
	                groupEnd();
	                new_name = model_info.name;
	              }
	              values[new_name] = model_info.model;
	            });
	
	            // fill the models that weren't passed with empty objects
	            // e.g. if expected = [ui, language, color] and passed/existing = [ui, language]
	            // it will fill values up to [ui, language, {}]
	            var existing = model_config.length;
	            var expected = model_expects.length;
	            if(expected > existing) {
	              //skip existing
	              model_expects.splice(0, existing);
	              //adds new expected models if needed
	              forEach(expected, function(m) {
	                values[m.name] = {};
	              });
	            }
	          } else {
	            return;
	          }
	          //return a new model with the defined submodels
	          return new Model(subcomponentName, values, null, model_binds);
	          /**
	           * Maps one model name to current submodel and returns info
	           * @param {String} name Full model path. E.g.: "state.marker.color"
	           * @returns {Object} the model info, with name and the actual model
	           */
	          function _mapOne(name) {
	            var parts = name.split('.');
	            var current = _this.model;
	            var current_name = '';
	            while(parts.length) {
	              current_name = parts.shift();
	              current = current[current_name];
	            }
	            return {
	              name: name,
	              model: current,
	              type: current ? current.getType() : null
	            };
	          }
	        },
	
	        /**
	         * Get translation function for templates
	         * @param {Boolean} wrap wrap in spam tags
	         * @returns {Function}
	         */
	        getTranslationFunction: function(wrap) {
	          var t_func;
	          try {
	            t_func = this.model.get('language').getTFunction();
	          } catch(err) {
	            if(this.parent && this.parent !== this) {
	              t_func = this.parent.getTranslationFunction();
	            }
	          }
	          if(!t_func) {
	            t_func = function(s) {
	              return s;
	            };
	          }
	          if(wrap) {
	            return this._translatedStringFunction(t_func);
	          } else {
	            return t_func;
	          }
	        },
	
	        /**
	         * Get function for translated string
	         * @param {Function} translation_function The translation function
	         * @returns {Function}
	         */
	        _translatedStringFunction: function(translation_function) {
	          return function(string) {
	            var translated = translation_function(string);
	            return '<span data-vzb-translate="' + string + '">' + translated + '</span>';
	          };
	        },
	
	        /**
	         * Translate all strings in the template
	         */
	        translateStrings: function() {
	          var t = this.getTranslationFunction();
	          var strings = this.placeholder.querySelectorAll('[data-vzb-translate]');
	          if(strings.length === 0) {
	            return;
	          }
	          forEach(strings, function(str) {
	            if(!str || !str.getAttribute) {
	              return;
	            }
	            str.innerHTML = t(str.getAttribute('data-vzb-translate'));
	          });
	        },
	
	        /**
	         * Checks whether this component is a tool or not
	         * @returns {Boolean}
	         */
	        isTool: function() {
	          return this._id[0] === 't';
	        },
	
	        /**
	         * Executes after the template is loaded and rendered.
	         * Ideally, it contains HTML instantiations related to template
	         * At this point, this.element and this.placeholder are available
	         * as DOM elements
	         */
	        readyOnce: function() {},
	
	        /**
	         * Executes after the template and model (if any) are ready
	         */
	        ready: function() {},
	
	        /**
	         * Executes when the resize event is triggered.
	         * Ideally, it only contains operations related to size
	         */
	        resize: function() {},
	
	        /**
	         * Clears a component
	         */
	        clear: function() {
	          this.freeze();
	          if(this.model) this.model.freeze();
	          forEach(this.components, function(c) {
	            c.clear();
	          });
	        }
	      });
	
	      /**
	       * Preloader implementation with promises
	       * @param {Object} comp any component
	       * @returns {Promise}
	       */
	      function preloader(comp) {
	        var promise = new Promise();
	        var promises = []; //holds all promises
	
	        //preload all subcomponents first
	        forEach(comp.components, function(subcomp) {
	          promises.push(preloader(subcomp));
	        });
	
	        var wait = promises.length ? Promise.all(promises) : new Promise.resolve();
	        wait.then(function() {
	          comp.preload(promise);
	        }, function(err) {
	          error$1("Error preloading data:", err);
	        });
	
	        return promise.then(function() {
	          comp.afterPreload();
	          return true;
	        });
	      }
	
	      // Based on Simple JavaScript Templating by John Resig
	      //generic templating function
	      function templateFunc(str, data) {
	
	        var func = function(obj) {
	          return str.replace(/<%=([^\%]*)%>/g, function(match) {
	            //match t("...")
	            var s = match.match(/t\s*\(([^)]+)\)/g);
	            //replace with translation
	            if(s.length) {
	              s = obj.t(s[0].match(/\"([^"]+)\"/g)[0].split('"').join(''));
	            }
	            //use object[name]
	            else {
	              s = match.match(/([a-z\-A-Z]+([a-z\-A-Z0-9]?[a-zA-Z0-9]?)?)/g)[0];
	              s = obj[s] || s;
	            }
	            return s;
	          });
	        }
	        // Figure out if we're getting a template, or if we need to
	        // load the template - and be sure to cache the result.
	        var fn = !/<[a-z][\s\S]*>/i.test(str) ? templates$1[str] = templates$1[str] || templateFunc(globals.templates[str]) : func;
	
	        // Provide some basic currying to the user
	        return data ? fn(data) : fn;
	      }
	
	      //utility function to check if a component is a component
	      //TODO: Move to utils?
	      Component.isComponent = function(c) {
	        return c._id && (c._id[0] === 't' || c._id[0] === 'c');
	      };
	
	      //classes are vzb-portrait, vzb-landscape...
	      var class_prefix = 'vzb-';
	      var class_presentation = 'presentation';
	      var class_portrait = 'vzb-portrait';
	      var class_lansdcape = 'vzb-landscape';
	
	      var Layout = EventSource.extend({
	
	        screen_profiles: {
	          small: {
	            min_width: 0,
	            min_height: 0
	          },
	          medium: {
	            min_width: 600,
	            min_height: 400
	          },
	          large: {
	            min_width: 900,
	            min_height: 520
	          }
	        },
	
	        /**
	         * Initializes the layout manager
	         */
	        init: function(ui) {
	          this.ui = ui || {};
	
	          this._container = null;
	          //dom element
	          this._curr_profile = null;
	          this._prev_size = {};
	          //resize when window resizes
	          var _this = this;
	
	          this.resizeHandler = this.resizeHandler || resize$1.bind(this);
	
	          window.addEventListener('resize', this.resizeHandler);
	          this._super();
	        },
	
	        /**
	         * Calculates the size of the newly resized container
	         */
	        setSize: function(force) {
	          var _this = this;
	          var width = this._container.clientWidth;
	          var height = this._container.clientHeight;
	
	          /**
	           * issue #1118
	           * check if device is iPhone then add top margin for searchbar if it visible
	           */
	          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) // browser is safari
	            && navigator.userAgent.match(/iPhone/i) // checking device
	          ) {
	            this._container.style.top =  0;
	            if (this._container.clientWidth > this._container.clientHeight // landscape mode
	              && this._container.clientWidth < 700) {  // small device
	              var bodyHeight = this._container.clientHeight;
	              var windowHeight = window.innerHeight;
	              if (2 < (bodyHeight - windowHeight) && (bodyHeight - windowHeight) <= 45) { // check searchbar is visible
	                this._container.style.top =  44 + "px";
	                document.body.scrollTop = 44; // scrolling empty space
	              }
	            }
	          }
	
	          if(!force && this._prev_size && this._prev_size.width === width && this._prev_size.height === height) {
	            return;
	          }
	
	          // choose profile depending on size
	          forEach(this.screen_profiles, function(range, size) {
	            //remove class
	            removeClass(_this._container, class_prefix + size);
	            //find best fit
	            if(width >= range.min_width && height >= range.min_height) {
	              _this._curr_profile = size;
	            }
	          });
	
	          //update size class
	          addClass(this._container, class_prefix + this._curr_profile);
	          //toggle, untoggle classes based on orientation
	          if(width < height) {
	            addClass(this._container, class_portrait);
	            removeClass(this._container, class_lansdcape);
	          } else {
	            addClass(this._container, class_lansdcape);
	            removeClass(this._container, class_portrait);
	          }
	          this._prev_size.width = width;
	          this._prev_size.height = height;
	          this.trigger('resize');
	        },
	
	        /**
	         * Sets the container for this layout
	         * @param container DOM element
	         */
	        setContainer: function(container) {
	          this._container = container;
	          this.setSize();
	          this.updatePresentation();
	        },
	
	        /**
	         * Sets the presentation mode for this layout
	         * @param {Bool} presentation mode on or off
	         */
	        updatePresentation: function() {
	          if (this.ui.presentation) {
	              addClass(this._container, class_prefix + class_presentation);
	          } else {
	              removeClass(this._container, class_prefix + class_presentation);
	          }
	        },
	
	        getPresentationMode: function() {
	          return this.ui.presentation;
	        },
	
	        /**
	         * Gets the current selected profile
	         * @returns {String} name of current profile
	         */
	        currentProfile: function() {
	          return this._curr_profile;
	        },
	
	        clear: function() {
	          window.removeEventListener('resize', this.resizeHandler);
	        }
	
	      });
	
	      function resize$1() {
	        if(this._container) {
	          this.setSize();
	        }
	      }
	
	      // source https://github.com/encharm/Font-Awesome-SVG-PNG/tree/master/black/svg
	
	      var paintbrush =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1615 0q70 0 122.5 46.5t52.5 116.5q0 63-45 151-332 629-465 752-97 91-218 91-126 0-216.5-92.5t-90.5-219.5q0-128 92-212l638-579q59-54 130-54zm-909 1034q39 76 106.5 130t150.5 76l1 71q4 213-129.5 347t-348.5 134q-123 0-218-46.5t-152.5-127.5-86.5-183-29-220q7 5 41 30t62 44.5 59 36.5 46 17q41 0 55-37 25-66 57.5-112.5t69.5-76 88-47.5 103-25.5 125-10.5z"/></svg>';
	      var search =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1216 832q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 52-38 90t-90 38q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>';
	      var circle =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1664 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"/></svg>';
	      var expand =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M883 1056q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23zm781-864v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45z"/></svg>';
	      var asterisk =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1546 1050q46 26 59.5 77.5t-12.5 97.5l-64 110q-26 46-77.5 59.5t-97.5-12.5l-266-153v307q0 52-38 90t-90 38h-128q-52 0-90-38t-38-90v-307l-266 153q-46 26-97.5 12.5t-77.5-59.5l-64-110q-26-46-12.5-97.5t59.5-77.5l266-154-266-154q-46-26-59.5-77.5t12.5-97.5l64-110q26-46 77.5-59.5t97.5 12.5l266 153v-307q0-52 38-90t90-38h128q52 0 90 38t38 90v307l266-153q46-26 97.5-12.5t77.5 59.5l64 110q26 46 12.5 97.5t-59.5 77.5l-266 154z"/></svg>';
	      var trails =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M 1381.375 17.1875 C 1375.7825 17.176804 1370.1216 17.316078 1364.4375 17.5625 C 1273.4913 21.505489 1197.0982 57.199956 1135.2188 124.6875 C 1076.5961 188.62338 1047.6964 263.96059 1048.5312 350.65625 L 835.71875 433 C 797.77288 391.67699 749.96961 361.96416 692.3125 343.84375 C 604.96227 316.39162 520.95691 323.70366 440.25 365.8125 C 359.5432 407.92133 305.45225 472.64985 278 560 C 250.54783 647.35004 257.89117 731.38694 300 812.09375 C 342.10886 892.80075 406.83755 946.89147 494.1875 974.34375 C 576.9404 1000.3512 657.38873 994.58645 735.5625 957.09375 L 959.28125 1171.4375 L 972.375 1184.4062 C 966.2931 1198.3454 961.94845 1209.2226 959.34375 1217.0625 C 956.73915 1224.9024 953.7186 1236.224 950.25 1251.0312 L 711.03125 1285.1875 C 669.59175 1209.0324 607.72526 1157.2863 525.40625 1129.9375 C 438.51381 1101.0693 354.34933 1107.021 272.96875 1147.8125 C 191.58796 1188.6039 136.49335 1252.4513 107.625 1339.3438 C 78.756758 1426.2362 84.708528 1510.3694 125.5 1591.75 C 166.29138 1673.1307 230.1387 1728.2567 317.03125 1757.125 C 403.92369 1785.9933 488.05682 1780.0415 569.4375 1739.25 C 650.81799 1698.4587 705.94425 1634.6111 734.8125 1547.7188 C 737.41718 1539.8788 740.43763 1528.5573 743.90625 1513.75 L 983.125 1479.5938 C 1024.5644 1555.7487 1086.4309 1607.4948 1168.75 1634.8438 C 1255.6425 1663.7119 1339.8069 1657.7603 1421.1875 1616.9688 C 1502.5682 1576.1772 1557.6631 1512.3299 1586.5312 1425.4375 C 1615.3996 1338.5451 1609.4477 1254.4119 1568.6562 1173.0312 C 1527.8647 1091.6506 1464.0174 1036.5244 1377.125 1007.6562 C 1294.9259 980.34721 1214.5066 984.74084 1135.8438 1020.8125 L 1120.2812 1005.9062 L 898.0625 785.96875 C 902.79653 774.40321 906.33847 765.03422 908.5 758.15625 C 920.42249 720.22 925.7916 682.90194 924.59375 646.21875 L 1130.9688 566.34375 C 1141.2015 577.59424 1149.3796 586.0106 1155.4688 591.59375 C 1222.9566 653.47326 1302.1474 682.44278 1393.0938 678.5 C 1484.04 674.55731 1560.4642 638.83151 1622.3438 571.34375 C 1684.2232 503.85591 1713.1929 424.6337 1709.25 333.6875 C 1705.3072 242.74139 1669.5816 166.34819 1602.0938 104.46875 C 1538.8238 46.456824 1465.2625 17.347946 1381.375 17.1875 z "/></svg>';
	      var lock =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M640 768h512v-192q0-106-75-181t-181-75-181 75-75 181v192zm832 96v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-192q0-184 132-316t316-132 316 132 132 316v192h32q40 0 68 28t28 68z"/></svg>';
	      var unlock =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1376 768q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-320q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45q0-106-75-181t-181-75-181 75-75 181v320h736z"/></svg>';
	      var unexpand =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M896 960v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45zm755-672q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23z"/></svg>';
	      var axes =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500"><path d="M430.25,379.655l-75.982-43.869v59.771H120.73V151.966h59.774l-43.869-75.983L92.767,0L48.898,75.983L5.029,151.966h59.775 v271.557c0,15.443,12.52,27.965,27.963,27.965h261.5v59.773l75.982-43.869l75.982-43.867L430.25,379.655z"/></svg>';
	      var gear =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1152 896q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm512-109v222q0 12-8 23t-20 13l-185 28q-19 54-39 91 35 50 107 138 10 12 10 25t-9 23q-27 37-99 108t-94 71q-12 0-26-9l-138-108q-44 23-91 38-16 136-29 186-7 28-36 28h-222q-14 0-24.5-8.5t-11.5-21.5l-28-184q-49-16-90-37l-141 107q-10 9-25 9-14 0-25-11-126-114-165-168-7-10-7-23 0-12 8-23 15-21 51-66.5t54-70.5q-27-50-41-99l-183-27q-13-2-21-12.5t-8-23.5v-222q0-12 8-23t19-13l186-28q14-46 39-92-40-57-107-138-10-12-10-24 0-10 9-23 26-36 98.5-107.5t94.5-71.5q13 0 26 10l138 107q44-23 91-38 16-136 29-186 7-28 36-28h222q14 0 24.5 8.5t11.5 21.5l28 184q49 16 90 37l142-107q9-9 24-9 13 0 25 10 129 119 165 170 7 8 7 22 0 12-8 23-15 21-51 66.5t-54 70.5q26 50 41 98l183 28q13 2 21 12.5t8 23.5z"/></svg>';
	      var stack =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 54.849 54.849"><g><path d="M54.497,39.614l-10.363-4.49l-14.917,5.968c-0.537,0.214-1.165,0.319-1.793,0.319c-0.627,0-1.254-0.104-1.79-0.318     l-14.921-5.968L0.351,39.614c-0.472,0.203-0.467,0.524,0.01,0.716L26.56,50.81c0.477,0.191,1.251,0.191,1.729,0L54.488,40.33     C54.964,40.139,54.969,39.817,54.497,39.614z"/><path d="M54.497,27.512l-10.364-4.491l-14.916,5.966c-0.536,0.215-1.165,0.321-1.792,0.321c-0.628,0-1.256-0.106-1.793-0.321     l-14.918-5.966L0.351,27.512c-0.472,0.203-0.467,0.523,0.01,0.716L26.56,38.706c0.477,0.19,1.251,0.19,1.729,0l26.199-10.479     C54.964,28.036,54.969,27.716,54.497,27.512z"/><path d="M0.361,16.125l13.662,5.465l12.537,5.015c0.477,0.191,1.251,0.191,1.729,0l12.541-5.016l13.658-5.463     c0.477-0.191,0.48-0.511,0.01-0.716L28.277,4.048c-0.471-0.204-1.236-0.204-1.708,0L0.351,15.41     C-0.121,15.614-0.116,15.935,0.361,16.125z"/></g></svg>';
	      var iconDrag =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M896 384q-53 0-90.5 37.5t-37.5 90.5v128h-32v-93q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v429l-32-30v-172q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v224q0 47 35 82l310 296q39 39 39 102 0 26 19 45t45 19h640q26 0 45-19t19-45v-25q0-41 10-77l108-436q10-36 10-77v-246q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v32h-32v-125q0-40-25-72.5t-64-40.5q-14-2-23-2-46 0-79 33t-33 79v128h-32v-122q0-51-32.5-89.5t-82.5-43.5q-5-1-13-1zm0-128q84 0 149 50 57-34 123-34 59 0 111 27t86 76q27-7 59-7 100 0 170 71.5t70 171.5v246q0 51-13 108l-109 436q-6 24-6 71 0 80-56 136t-136 56h-640q-84 0-138-58.5t-54-142.5l-308-296q-76-73-76-175v-224q0-99 70.5-169.5t169.5-70.5q11 0 16 1 6-95 75.5-160t164.5-65q52 0 98 21 72-69 174-69z"/></svg>';
	      var iconWarn =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.209 512.209"><path d="M507.345,439.683L288.084,37.688c-3.237-5.899-7.71-10.564-13.429-13.988c-5.705-3.427-11.893-5.142-18.554-5.142   s-12.85,1.718-18.558,5.142c-5.708,3.424-10.184,8.089-13.418,13.988L4.859,439.683c-6.663,11.998-6.473,23.989,0.57,35.98   c3.239,5.517,7.664,9.897,13.278,13.128c5.618,3.237,11.66,4.859,18.132,4.859h438.529c6.479,0,12.519-1.622,18.134-4.859   c5.62-3.23,10.038-7.611,13.278-13.128C513.823,463.665,514.015,451.681,507.345,439.683z M292.655,411.132   c0,2.662-0.91,4.897-2.71,6.704c-1.807,1.811-3.949,2.71-6.427,2.71h-54.816c-2.474,0-4.616-0.899-6.423-2.71   c-1.809-1.807-2.713-4.042-2.713-6.704v-54.248c0-2.662,0.905-4.897,2.713-6.704c1.807-1.811,3.946-2.71,6.423-2.71h54.812   c2.479,0,4.62,0.899,6.428,2.71c1.803,1.807,2.71,4.042,2.71,6.704v54.248H292.655z M292.088,304.357   c-0.198,1.902-1.198,3.47-3.001,4.709c-1.811,1.238-4.046,1.854-6.711,1.854h-52.82c-2.663,0-4.947-0.62-6.849-1.854   c-1.908-1.243-2.858-2.807-2.858-4.716l-4.853-130.47c0-2.667,0.953-4.665,2.856-5.996c2.474-2.093,4.758-3.14,6.854-3.14h62.809   c2.098,0,4.38,1.043,6.854,3.14c1.902,1.331,2.851,3.14,2.851,5.424L292.088,304.357z"/></svg>';
	      var iconPin =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M800 864v-448q0-14-9-23t-23-9-23 9-9 23v448q0 14 9 23t23 9 23-9 9-23zm672 352q0 26-19 45t-45 19h-429l-51 483q-2 12-10.5 20.5t-20.5 8.5h-1q-27 0-32-27l-76-485h-404q-26 0-45-19t-19-45q0-123 78.5-221.5t177.5-98.5v-512q-52 0-90-38t-38-90 38-90 90-38h640q52 0 90 38t38 90-38 90-90 38v512q99 0 177.5 98.5t78.5 221.5z"/></svg>';
	      var iconQuestion =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="17 17 483 483"> <circle stroke-width="40" cx="258.57" cy="258.57" r="220"/> <path d="M299.756,413.021v-61.78c0-3.003-0.966-5.472-2.896-7.401s-4.398-2.896-7.401-2.896h-61.78 c-3.003,0-5.47,0.965-7.4,2.896c-1.932,1.931-2.896,4.398-2.896,7.401v61.78c0,3.002,0.965,5.47,2.896,7.399 c1.931,1.931,4.396,2.896,7.4,2.896h61.779c3.003,0,5.472-0.967,7.401-2.896S299.756,416.021,299.756,413.021z"/> <path d="M382.128,196.789c0-18.877-5.952-36.36-17.856-52.449c-11.905-16.088-26.762-28.53-44.566-37.325 c-17.804-8.795-36.037-13.192-54.7-13.192c-52.127,0-91.919,22.845-119.377,68.537c-3.218,5.148-2.359,9.653,2.574,13.514 l42.474,32.177c1.502,1.287,3.54,1.931,6.114,1.931c3.433,0,6.115-1.287,8.044-3.861c11.369-14.587,20.594-24.454,27.672-29.603 c7.294-5.148,16.519-7.723,27.673-7.723c10.297,0,19.468,2.789,27.513,8.366c8.044,5.578,12.065,11.906,12.065,18.985 c0,8.151-2.146,14.694-6.437,19.628c-4.29,4.934-11.583,9.76-21.881,14.479c-13.514,6.006-25.901,15.284-37.164,27.834 c-11.263,12.549-16.894,26.01-16.894,40.382v11.583c0,3.004,0.965,5.472,2.896,7.401c1.931,1.93,4.396,2.896,7.4,2.896h61.779 c3.003,0,5.471-0.965,7.401-2.896c1.93-1.931,2.896-4.397,2.896-7.401c0-4.075,2.306-9.385,6.917-15.928 c4.612-6.542,10.458-11.852,17.537-15.927c6.863-3.861,12.119-6.918,15.768-9.171c3.646-2.252,8.579-6.008,14.802-11.263 c6.22-5.255,10.993-10.402,14.317-15.443c3.325-5.042,6.328-11.53,9.01-19.467C380.788,214.916,382.128,206.228,382.128,196.789z"/> </svg>';
	      var iconClose =
	        '<svg class="vzb-icon vzb-icon-pin" viewBox="-150 -250 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1149 414q0 26 -19 45l-181 181l181 181q19 19 19 45q0 27 -19 46l-90 90q-19 19 -46 19q-26 0 -45 -19l-181 -181l-181 181q-19 19 -45 19q-27 0 -46 -19l-90 -90q-19 -19 -19 -46q0 -26 19 -45l181 -181l-181 -181q-19 -19 -19 -45q0 -27 19 -46l90 -90q19 -19 46 -19 q26 0 45 19l181 181l181 -181q19 -19 45 -19q27 0 46 19l90 90q19 19 19 46z"/></svg>';
	      var presentation =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path id="flip-chart-1" d="M334.549,393.834l58.607,68.666h-45.096l-58.709-68.666H334.549z M240.333,462.5h34.333v-68.666h-34.333 V462.5z M360.5,153.5h-34.334v137.334H360.5V153.5z M121.566,462.5h45.113l58.709-68.666h-45.197L121.566,462.5z M206,273.666 h-34.333v17.168H206V273.666z M257.5,239.333h-34.333v51.5H257.5V239.333z M309,205h-34.334v85.834H309V205z M446.334,102h-17.168 v257.5H85.833V102H68.667V50.5h377.667V102z M394.834,102H120.167v223.166h274.667V102z"/></svg>';
	      var about =
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1088 1256v240q0 16-12 28t-28 12h-240q-16 0-28-12t-12-28v-240q0-16 12-28t28-12h240q16 0 28 12t12 28zm316-600q0 54-15.5 101t-35 76.5-55 59.5-57.5 43.5-61 35.5q-41 23-68.5 65t-27.5 67q0 17-12 32.5t-28 15.5h-240q-15 0-25.5-18.5t-10.5-37.5v-45q0-83 65-156.5t143-108.5q59-27 84-56t25-76q0-42-46.5-74t-107.5-32q-65 0-108 29-35 25-107 115-13 16-31 16-12 0-25-8l-164-125q-13-10-15.5-25t5.5-28q160-266 464-266 80 0 161 31t146 83 106 127.5 41 158.5z"/></svg>'
	      var cursorArrow =
	        '<svg class="vzb-icon" viewBox="-200 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1389 1043q31 30 14 69-17 40-59 40h-382l201 476q10 25 0 49t-34 35l-177 75q-25 10-49 0t-35-34l-191-452-312 312q-19 19-45 19-12 0-24-5-40-17-40-59v-1504q0-42 40-59 12-5 24-5 27 0 45 19z"/></svg>'
	      var cursorPlus = 
	        '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1088 800v64q0 13-9.5 22.5t-22.5 9.5h-224v224q0 13-9.5 22.5t-22.5 9.5h-64q-13 0-22.5-9.5t-9.5-22.5v-224h-224q-13 0-22.5-9.5t-9.5-22.5v-64q0-13 9.5-22.5t22.5-9.5h224v-224q0-13 9.5-22.5t22.5-9.5h64q13 0 22.5 9.5t9.5 22.5v224h224q13 0 22.5 9.5t9.5 22.5zm128 32q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 53-37.5 90.5t-90.5 37.5q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>'
	      var cursorMinus = 
	        '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1088 800v64q0 13-9.5 22.5t-22.5 9.5h-576q-13 0-22.5-9.5t-9.5-22.5v-64q0-13 9.5-22.5t22.5-9.5h576q13 0 22.5 9.5t9.5 22.5zm128 32q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 53-37.5 90.5t-90.5 37.5q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>'
	      var hundredPercent = 
	        '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg"><g transform="translate(18 11)"><text transform="scale(0.9 1)" x="0" y="0">100</text><text transform="scale(0.6 1)" class="percent" x="0" y="0">%</text></g></svg>'
	      var percent = 
	        '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1408 1280q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm-768-768q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm1024 768q0 159-112.5 271.5t-271.5 112.5-271.5-112.5-112.5-271.5 112.5-271.5 271.5-112.5 271.5 112.5 112.5 271.5zm-96-1088q0 20-13 38l-1056 1408q-19 26-51 26h-160q-26 0-45-19t-19-45q0-20 13-38l1056-1408q19-26 51-26h160q26 0 45 19t19 45zm-672 320q0 159-112.5 271.5t-271.5 112.5-271.5-112.5-112.5-271.5 112.5-271.5 271.5-112.5 271.5 112.5 112.5 271.5z"/></svg>'
	
	
	      var iconset = Object.freeze({
	        paintbrush: paintbrush,
	        search: search,
	        circle: circle,
	        expand: expand,
	        asterisk: asterisk,
	        trails: trails,
	        lock: lock,
	        unlock: unlock,
	        unexpand: unexpand,
	        axes: axes,
	        gear: gear,
	        stack: stack,
	        drag: iconDrag,
	        warn: iconWarn,
	        pin: iconPin,
	        question: iconQuestion,
	        close: iconClose,
	        presentation: presentation,
	        about: about,
	        cursorArrow: cursorArrow,
	        cursorPlus: cursorPlus,
	        cursorMinus: cursorMinus,
	        hundredPercent: hundredPercent,
	        percent: percent
	      });
	
	      var class_loading_first = 'vzb-loading-first';
	      var class_loading_data = 'vzb-loading-data';
	      var class_loading_error = 'vzb-loading-error';
	      var class_placeholder = 'vzb-placeholder';
	      var class_buttons_off = 'vzb-buttonlist-off';
	
	      //tool model is quite simple and doesn't need to be registered
	      var ToolModel = Model.extend({
	        /**
	         * Initializes the tool model.
	         * @param {Object} values The initial values of this model
	         * @param {Object} binds contains initial bindings for the model
	         * @param {Function|Array} validade validate rules
	         */
	        init: function(name, values, defaults, binds, validate) {
	          this._id = uniqueId('tm');
	          this._type = 'tool';
	          //generate validation function
	          this.validate = generateValidate(this, validate);
	          //default submodels
	          values = values || {};
	          defaults = defaults || {};
	          values = defaultModel(values, defaults);
	          //constructor is similar to model
	          this._super(name, values, null, binds);
	          // change language
	          if(values.language) {
	            var _this = this;
	            this.on('change:language.id', function() {
	              _this.trigger('translate');
	            });
	          }
	        }
	      });
	      //tool
	      var Tool = Component.extend({
	        /**
	         * Initializes the tool
	         * @param {Object} placeholder object
	         * @param {Object} external_model External model such as state, data, etc
	         */
	        init: function(placeholder, external_model) {
	          this._id = uniqueId('t');
	          this.template = this.template || 
	            '<div class="vzb-tool vzb-tool-' + this.name + '">' + 
	              '<div class="vzb-tool-stage">' + 
	                '<div class="vzb-tool-viz">' + 
	                '</div>' + 
	                '<div class="vzb-tool-timeslider">' + 
	                '</div>' + 
	              '</div>' + 
	              '<div class="vzb-tool-sidebar">' + 
	                '<div class="vzb-tool-dialogs">' + 
	                '</div>' +
	                '<div class="vzb-tool-buttonlist">' + 
	                '</div>' + 
	              '</div>' +         
	              '<div class="vzb-tool-datanotes vzb-hidden">' + 
	              '</div>' + 
	              '<div class="vzb-tool-treemenu vzb-hidden">' + 
	              '</div>' + 
	              '<div class="vzb-tool-datawarning vzb-hidden">' + 
	              '</div>' + 
	              '<div class="vzb-tool-labels vzb-hidden">' + 
	              '</div>' + 
	            '</div>';
	          this.model_binds = this.model_binds || {};
	          
	          external_model = external_model || {}; //external model can be undefined
	          external_model.bind = external_model.bind || {}; //bind functions can be undefined
	
	          
	          //bind the validation function with the tool
	          var validate = this.validate.bind(this);
	          var _this = this;
	
	          // callbacks has to be an array so that it will not be turned into a submodel when the toolmodel is made.
	          var callbacks = {
	            'change': function(evt, path) {
	              if(_this._ready) {
	                _this.model.validate();
	
	                if (evt.source.persistent)
	                  _this.model.trigger(new DefaultEvent(evt.source, 'persistentChange'), _this.getMinModel());
	              }
	            },
	            'hook_change': function() {
	              if (!_this.model.state.time.splash) { // not block when it initial splash screen
	                _this.beforeLoading(true);
	              }
	            },
	            'change:ui.presentation': function() {
	              _this.layout.updatePresentation();
	              _this.trigger('resize');
	            },
	            'translate': function(evt, val) {
	              if(_this._ready) {
	                Promise.all([_this.preloadLanguage(), _this.model.load()])
	                  .then(function() {
	                    _this.model.validate();
	                    _this.translateStrings();
	                  });
	              }
	            },
	            'load_start': function() {
	              _this.beforeLoading();
	            },
	            'ready': function(evt) {
	              if(_this._ready) {
	                _this.afterLoading();
	              }
	            }      
	          };
	          extend(callbacks, this.model_binds, external_model.bind);
	          delete external_model.bind;
	
	          this.model = new ToolModel(this.name, external_model, this.default_model, callbacks, validate);
	
	          // default model is the model set in the tool
	          this.default_model = this.default_model || {};
	
	          this.ui = this.model.ui || {};
	
	          this.layout = new Layout(this.ui);
	          //splash
	          this.ui.splash = this.model && this.model.data && this.model.data.splash;
	          this._super({
	            name: this.name || this._id,
	            placeholder: placeholder
	          }, this);
	
	          this.render();
	          this._setUIModel();
	        },
	
	        ready: function(){
	          this.checkTimeLimits();  
	        },
	          
	        checkTimeLimits: function() {
	          if(!this.model.state.time) return;
	          
	          var time = this.model.state.time;
	          
	          if(this.model.state.marker) {
	            var tLimits = this.model.state.marker.getTimeLimits(time.getDimension());
	
	            if(!tLimits || !isDate(tLimits.min) || !isDate(tLimits.max)) 
	                return warn("checkTimeLimits(): min-max date objects look wrong: " + tLimits.min + " " + tLimits.max);
	
	            // change start and end (but keep startOrigin and endOrigin for furhter requests)
	            // change is not persistent if it's splashscreen change
	            if(time.start < tLimits.min) time.getModelObject('start').set(tLimits.min, false, !time.splash);
	            if(time.end > tLimits.max) time.getModelObject('end').set(tLimits.max, false, !time.splash);
	          }
	            
	          //force time validation because time.value might now fall outside of start-end
	          time.validate(); 
	        },
	          
	
	        getMinModel: function() {
	          var currentToolModel = this.model.getPlainObject(true); // true = get only persistent model values
	          var defaultToolModel = this.default_model;
	          var defaultsFromModels = this.model.getDefaults();
	          //flattens _defs_ object
	          defaultToolModel = flattenDefaults(defaultToolModel);
	          // compares with chart default model
	          var modelChanges = diffObject(currentToolModel, defaultToolModel);
	          // change date object to string according to current format
	          modelChanges = flattenDates(modelChanges, this.model.state.time.timeFormat);
	          //compares with model's defaults
	          return diffObject(modelChanges, defaultsFromModels);
	        },
	
	        /**
	         * Clears a tool
	         */
	
	        clear: function() {
	          this.layout.clear();
	          this.setModel = this.getModel = function() {
	            return;
	          };
	          this._super();
	        },
	
	        /**
	         * Visually display errors
	         */
	        error: function(opts) {
	
	          var msg = (opts && opts.type === "data") ? "Error loading chart data. <br>Please, try again soon." : "Error loading chart";
	
	          this.placeholder.innerHTML = '<div class="vzb-error-message"><h1>'+iconWarn+'</h1><p>'+msg+'</p></div>';
	        },
	
	        /**
	         * Sets model from external page
	         * @param {Object} JSONModel new model in JSON format
	         * @param {Boolean} overwrite overwrite everything instead of extending
	         */
	        setModel: function(newModelJSON, overwrite) {
	          if(overwrite) {
	            this.model.reset(newModelJSON);
	          } else {
	            this.model.set(newModelJSON);
	          }
	          this._setUIModel();
	        },
	
	        /**
	         * get model
	         * @return {Object} JSON object of model
	         */
	        getModel: function() {
	          return this.model.getPlainObject() || {};
	        },
	        /**
	         * Displays loading class
	         */
	        beforeLoading: function(loadingData) {
	          if(!this._readyOnce) {
	              addClass(this.placeholder, class_loading_first);    
	          }
	          if(loadingData) {
	              addClass(this.placeholder, class_loading_data);    
	          }
	        },
	        /**
	         * Removes loading class
	         */
	        afterLoading: function() {
	          removeClass(this.placeholder, class_loading_first);
	          removeClass(this.placeholder, class_loading_data);
	        },
	        /**
	         * Adds loading error class
	         */
	        errorLoading: function() {
	          addClass(this.placeholder, class_loading_error);
	        },
	        /* ==========================
	         * Validation and query
	         * ==========================
	         */
	        /**
	         * Validating the tool model
	         * @param model the current tool model to be validated
	         */
	        validate: function(model) {
	          model = this.model || model;
	
	          if(!model || !model.state) return warn("tool validation aborted: model.state looks wrong: " + model);
	        },
	
	        _setUIModel: function() {
	          //add placeholder class
	          addClass(this.placeholder, class_placeholder);
	          //add-remove buttonlist class
	          if(!this.ui || !this.ui.buttons || !this.ui.buttons.length) {
	            addClass(this.element, class_buttons_off);
	          } else {
	            removeClass(this.element, class_buttons_off);
	          }
	        },
	
	        preloadLanguage: function() {
	          return Promise.resolve();
	        }
	      });
	
	      /* ==========================
	       * Validation methods
	       * ==========================
	       */
	
	      /**
	       * Generates a validation function based on specific model validation
	       * @param {Object} m model
	       * @param {Function} validate validation function
	       * @returns {Function} validation
	       */
	      function generateValidate(m, validate) {
	        var max = 10;
	
	        function validate_func() {
	          var model = JSON.stringify(m.getPlainObject());
	          var c = arguments[0] || 0;
	          //TODO: remove validation hotfix
	          //while setting this.model is not available
	          if(!this._readyOnce) {
	            validate(this);
	          } else {
	            validate();
	          }
	          var model2 = JSON.stringify(m.getPlainObject());
	          if(c >= max) {
	            error$1('Max validation loop.');
	          } else if(model !== model2) {
	            validate_func.call(this, [c += 1]);
	          }
	        }
	
	        return validate_func;
	      }
	
	      /* ==========================
	       * Default model methods
	       * ==========================
	       */
	
	      /**
	       * Generates a valid state based on default model
	       */
	      function defaultModel(values, defaults) {
	        var keys = Object.keys(defaults);
	        var size = keys.length;
	        var field;
	        var blueprint;
	        var original;
	        var type;
	        for(var i = 0; i < size; i += 1) {
	          field = keys[i];
	          if(field === '_defs_') {
	            continue;
	          }
	          blueprint = defaults[field];
	          original = values[field];
	          type = typeof blueprint;
	          if(type === 'object') {
	            type = isPlainObject(blueprint) && blueprint._defs_ ? 'object' : isArray(blueprint) ? 'array' :
	              'model';
	          }
	          if(typeof original === 'undefined') {
	            if(type !== 'object' && type !== 'model') {
	              values[field] = blueprint;
	            } else {
	              values[field] = defaultModel({}, blueprint);
	            }
	          }
	          original = values[field];
	          if(type === 'number' && isNaN(original)) {
	            values[field] = 0;
	          } else if(type === 'string' && typeof original !== 'string') {
	            values[field] = '';
	          } else if(type === 'array' && !isArray(original)) {
	            values[field] = [];
	          } else if(type === 'model') {
	            if(!isObject(original)) {
	              values[field] = {};
	            }
	            values[field] = defaultModel(values[field], blueprint);
	          } else if(type === 'object') {
	            if(!isObject(original) || Object.keys(original).length === 0) {
	              original = false; //will be overwritten
	            }
	            if(!isObject(blueprint._defs_)) {
	              blueprint._defs_ = {};
	            }
	            values[field] = original || blueprint._defs_;
	          }
	        }
	        return values;
	      }
	
	      //utility function to check if a component is a tool
	      //TODO: Move to utils?
	      Tool.isTool = function(c) {
	        return c._id && c._id[0] === 't';
	      };
	
	      var FILE_CACHED = {}; //caches files from this reader
	      var FILE_REQUESTED = {}; //caches files from this reader
	
	      var CSVReader = Reader.extend({
	
	        /**
	         * Initializes the reader.
	         * @param {Object} reader_info Information about the reader
	         */
	        init: function(reader_info) {
	          this._name = 'csv';
	          this._data = [];
	          this._basepath = reader_info.path;
	          this._parsers = reader_info.parsers;
	          if(!this._basepath) {
	            error$1("Missing base path for csv reader");
	          }
	        },
	
	        /**
	         * Reads from source
	         * @param {Object} query to be performed
	         * @param {String} language language
	         * @returns a promise that will be resolved when data is read
	         */
	        read: function(query, language) {
	          var _this = this;
	          var p = new Promise();
	
	          //this specific reader has support for the tag {{LANGUAGE}}
	          this.path = this._basepath.replace("{{LANGUAGE}}", language);
	
	          //replace conditional tags {{<any conditional>}}
	          this.path = this.path.replace(/{{(.*?)}}/g, function(match, capture) {
	            capture = capture.toLowerCase();
	            if(isArray(query.where[capture])) {
	              return query.where[capture].sort().join('-');
	            }
	            return query.where[capture];
	          });
	
	          //if only one year, files ending in "-YYYY.csv"
	          var loadPath = this.path;
	          if(query.where.time && query.where.time[0].length === 1) {
	            loadPath = loadPath.replace(".csv", "-" + query.where.time[0][0] + ".csv");
	          }
	
	          _this._data = [];
	
	          (function(query, p) {
	
	            // load and then read from the cache when loaded
	            var loadPromise = _this.load(loadPath, parse);
	            loadPromise.then(function() {
	              parse(FILE_CACHED[loadPath]);
	            })
	
	            function parse(res) {
	
	              var data = res;   
	
	              //rename geo.category to geo.cat
	              var where = query.where;
	              if(where['geo.category']) {
	                where['geo.cat'] = clone(where['geo.category']);
	                where['geo.category'] = void 0;
	              }
	
	              // load (join) any properties if necessary
	              var propertiesLoadPromise = _this.loadProperties(data, query);
	
	              // once done, continue parsing
	              propertiesLoadPromise.then(function() {
	
	                //make sure conditions don't contain invalid conditions
	                var validConditions = [];
	                forEach(where, function(v, p) {
	                  for(var i = 0, s = data.length; i < s; i++) {
	                    if(data[i].hasOwnProperty(p)) {
	                      validConditions.push(p);
	                      return true;
	                    }
	                  };
	                });
	
	                // only use valid conditions
	                where = clone(deepClone(where), validConditions);
	
	                // 
	                where = mapRows([where], _this._parsers)[0];
	
	                //filter any rows that match where condition
	                data = filterAny(data, where);
	
	                //warn if filtering returns empty array
	                if(data.length == 0) {
	                  p.reject("data reader returns empty array, that's bad");
	                  return;
	                }
	
	                //only selected items get returned
	                data = data.map(function(row) {
	                  return clone(row, query.select);
	                });
	
	                // grouping
	                data = _this.groupData(data, query);
	
	
	                // hack: if no year queried, add it, vizabi expects it
	                if (typeof data[0].year === 'undefined' && typeof data[0].time === 'undefined') {
	                  var isDatapointQuery = true;
	                  forEach(query.select,function(column) {
	                    // heuristic: if properties are mentioned, it's not a datapoint query
	                    if (column.indexOf('.') !== -1) {
	                      isDatapointQuery = false;
	                    }
	                  });
	                  if (isDatapointQuery) {
	                    forEach(data, function(row) {
	                      row.year = new Date("2011");
	                    })
	                  }
	                }
	
	                // hack for Stats SA: if no geo queried, add it, agepyramid expects it even if there's only 1 country.
	                // heuristic: check age or age_by_1_year to apply it only to age pyramid
	                if (typeof data[0].geo === 'undefined' && (typeof data[0].age !== "undefined" || typeof data[0].age_by_1_year !== "undefined")) {
	                  var isDatapointQuery = true;
	                  forEach(query.select,function(column) {
	                    // heuristic: if properties are mentioned, it's not a datapoint query
	                    if (column.indexOf('.') !== -1) {
	                      isDatapointQuery = false;
	                    }
	                  });
	                  if (isDatapointQuery) {
	                    forEach(data, function(row) {
	                      row.geo = "zaf";
	                    })
	                  }
	                }
	
	                // sorting
	                // one column, one direction (ascending) for now
	                if(query.orderBy && data[0]) {
	                  if (data[0][query.orderBy]) {
	                    data.sort(function(a, b) {
	                      return a[query.orderBy] - b[query.orderBy];
	                    });
	                  } else {
	                    p.reject("Cannot sort by " + query.orderBy + ". Column does not exist in result.");
	                  }
	                }
	
	
	                _this._data = data;
	                p.resolve();
	
	              })
	
	
	            }
	
	          })(query, p);
	
	          return p;
	        },
	
	        /**
	         * Gets the data
	         * @returns all data
	         */
	        getData: function() {
	          return this._data;
	        },
	
	
	        format: function(res) {
	
	          //make category an array
	          res = res.map(function(row) {
	            if(row['geo.cat']) {
	              row['geo.cat'] = [row['geo.cat']];
	            }
	            return row;
	          });
	
	          //format data
	          res = mapRows(res, this._parsers);
	
	          return res;
	        },
	
	        load: function(path) {
	          var _this = this;
	
	          //if not yet cached or request, start a request
	          if(!FILE_CACHED.hasOwnProperty(path) && !FILE_REQUESTED.hasOwnProperty(path)) {
	            // load the csv
	            d3.csv(path, function(error, res) {
	
	              if(!res) {
	                error$1("No permissions or empty file: " + path, error);
	                return;
	              }
	
	              if(error) {
	                error$1("Error Happened While Loading CSV File: " + path, error);
	                return;
	              }
	
	              //fix CSV response
	              res = _this.format(res);
	
	              //cache and resolve
	              FILE_CACHED[path] = res;
	              FILE_REQUESTED[path].resolve();
	              // commented this out because the promise needs to stay for future requests, indicating it is already in the cache
	              // FILE_REQUESTED[path] = void 0; 
	
	            });
	            FILE_REQUESTED[path] = new Promise();
	          }    
	          // always return a promise, even if it is already in the cache
	          return FILE_REQUESTED[path];
	        },
	
	        loadProperties: function(data, query) {
	            var _this = this;
	
	            // see if there are any properties used in the query and load them
	            // At the moment properties are loaded and added to the data-set only when required but for every query. Maybe loading and adding them to the data-set once is better?
	            var propertiesPromises = [];
	            var propertiesByKey = {};
	
	            // check both select and where for columns that actually refer to properties
	            forEach(query.select, function(column) {
	              checkForProperty(column);
	            });
	            forEach(query.where, function(values, column) {
	              checkForProperty(column);
	            });
	
	            // load properties for each column referring to property in the dataset
	              
	            // The below process O(n*m*o) but both n and o are typically small: n = number of property-sets, m = size of data-set, o = number of columns in property-set
	            // for each requested property-set
	            forEach(propertiesByKey, function(properties, key) {
	              properties[key] = true; // also retrieve the key-column
	              propertiesPromises.push(loadProperties(properties, key));
	            });
	
	            return propertiesPromises.length ? Promise.all(propertiesPromises) : new Promise.resolve();
	
	
	            function checkForProperty(column) {
	              var split = column.split('.');
	              if (split.length == 2) {
	                propertiesByKey[split[0]] = propertiesByKey[split[0]] || [];
	                propertiesByKey[split[0]].push(column);
	              }
	            }
	
	            function loadProperties(queriedProperties, keyColumn) {
	
	              /*
	               * Code below is for a path to a file when properties are shared between datasets
	               *
	
	              // parse the url of the original csv
	              var parser = document.createElement('a');
	              parser.href = path;
	
	              // construct the path of the file with properties of the key column
	              var newpathname = parser.pathname.substr(0, parser.pathname.lastIndexOf('/') + 1) + key + "-properties.csv";
	              var propertiesPath = parser.protocol + '//' + parser.host + newpathname + parser.search + parser.hash;
	              */
	
	              // get path of properties that are specific for the current data-set
	              var propertiesPath = _this.path.replace(".csv", "-" + keyColumn + "-properties.csv");
	
	              // load the file and return the promise for loading
	              var processedPromise = new Promise();
	              var loadPromise = _this.load(propertiesPath);
	              loadPromise.then(function() {
	
	                var properties = {};
	
	                // load all the properties in a map with the keyColumn-value as keyColumn (e.g. properties['swe']['geo.name'] = 'Sweden')
	                // this map is readable in O(1)
	                forEach(FILE_CACHED[propertiesPath], function(object) {
	                  properties[object[keyColumn]] = object;
	                }); 
	
	                // go through each row of data
	                forEach(data, function(row, index) { // e.g. row = { geo: se, pop: 1000, gdp: 5 }
	                  // copy each property that was queried to the matching data-row (matching = same keyColumn)
	                  forEach(queriedProperties, function(property) {
	                      
	                      // check if row exists in properties
	                      if(properties[row[keyColumn]]){
	                          row[property] = properties[row[keyColumn]][property];
	                      }else{
	                          // if not, then complain
	                          warn(row[keyColumn] + " is missing from GEO-PROPERTIES.CSV");
	                      }
	                    
	                  })
	                });
	                  
	                processedPromise.resolve();
	
	              });
	
	              return processedPromise;
	            }
	        },
	
	        groupData: function(data, query) {
	
	          // nested object which will be used to find the right group for each datarow. Each leaf will contain a reference to a data-object for aggregration.
	          var grouping_map = {}; 
	
	          var filtered = data.filter(function(val, index) {
	
	            var keep;
	            var leaf = grouping_map; // start at the base
	
	            // find the grouping-index for each grouping property (i.e. entity)
	            var keys = Object.keys(query.grouping);
	            var n = keys.length;
	            for (var i = 0; i < n; i++) {
	              var grouping = query.grouping[keys[i]];
	              var entity = keys[i];
	
	              var group_index;
	
	              // TO-DO: only age is grouped together for now, should be more generic
	              if (entity == 'age' || entity == 'age_by_1_year') {
	
	                var group_by = grouping;
	                var group_offset = 0;
	
	                var group_nr = Math.floor((val[entity] - group_offset) / group_by); // group number
	                var group_start = group_nr * group_by + group_offset; // number at which the group starts
	
	                // if the group falls outside the where filter, make the group smaller
	                if (group_start < query.where[entity][0][0])
	                  group_start = query.where[entity][0][0];   
	
	                group_index = group_start;
	                val[entity] = group_index;
	              }
	
	              // if this is not the last grouping property
	              if (i < (n-1)) {
	
	                // create if next grouping level doesn't exist yet
	                if (!leaf[val[entity]])
	                  leaf[val[entity]] = {};
	                // set leaf to next level to enable recursion
	                leaf = leaf[val[entity]];
	
	              } else {
	
	                // if last grouping property: we are at the leaf and can aggegrate
	
	                if (!leaf[val[entity]]) {
	
	                  // if the final leaf isn't set yet, start it by letting it refer to the current row in the data. We will keep this row in the data-set.
	                  leaf[val[entity]] = val;
	                  keep = true;
	
	                } else {
	
	                  // if the final leaf was already set, aggregrate!
	                  leaf = leaf[val[entity]];
	                  // if the leaf already had values, apply the aggregrate functions for each property
	                  forEach(query.select, function(property, key) {
	                    
	                    //avoid aggregating keys, such as geo and time, also avoid aggregating properties, such as geo.region
	                    if(keys.indexOf(property) != -1 || property.indexOf(keys[0]) != -1) return;
	                    // aggregrate the un-grouped data (now only sum population)
	                    // leaf[property] = parseFloat(leaf[property]) + parseFloat(val[property]);
	                    
	                    //never aggregate strings!
	                    if(val[property]!=="" && !+val[property] && +val[property]!==0) return;
	                    leaf[property] = leaf[property] + val[property];
	                  });  
	                  keep = false;
	
	                }
	
	              }
	
	            }
	
	            // if this row will function as place for aggregration, keep it, otherwise, discard it through the filter.
	            return keep;
	
	          });
	        
	          return filtered;
	
	        }
	
	      });
	
	      var index = null;
	      var concepts = null;
	      var conceptTypeHash = {};
	      var entities = [];
	
	      function Ddf(ddfPath) {
	        this.ddfPath = ddfPath;
	
	        if (this.ddfPath[this.ddfPath.length - 1] !== '/') {
	          this.ddfPath += '/';
	        }
	
	        var parser = document.createElement('a');
	        parser.href = ddfPath;
	      }
	
	      Ddf.prototype.reset = function () {
	        index = null;
	        concepts = [];
	        conceptTypeHash = {};
	        entities = [];
	        CACHE.FILE_CACHED = {};
	        CACHE.FILE_REQUESTED = {};
	      };
	
	      Ddf.prototype.getIndex = function (cb) {
	        var indexFileName = this.ddfPath + 'ddf--index.csv';
	        var indexAction = load(indexFileName);
	
	        indexAction.then(function () {
	          index = CACHE.FILE_CACHED[indexFileName];
	
	          cb(null, index);
	        }, function (err) {
	          cb(err);
	        });
	      };
	
	      Ddf.prototype.getConceptFileNames = function () {
	        var _this = this;
	        var result = [];
	
	        if(index) {
	          index.forEach(function (indexRecord) {
	            if (indexRecord.key === 'concept') {
	              result.push(_this.ddfPath + indexRecord.file);
	            }
	          });
	        }
	
	        return unique(result);
	      };
	
	      function getSelectParts(query) {
	        return query.select.map(function (selectPart) {
	          var pos = selectPart.indexOf('.');
	
	          return pos >= 0 ? selectPart.substr(pos + 1) : selectPart;
	        });
	      }
	
	      function getWhereParts(query) {
	        var whereParts = [];
	
	        for (var whereKey in query.where) {
	          if (query.where.hasOwnProperty(whereKey)) {
	            var pos = whereKey.indexOf('.');
	            var value = pos >= 0 ? whereKey.substr(pos + 1) : whereKey;
	
	            value = value.replace(/is--/, '');
	            whereParts.push(value);
	          }
	        }
	
	        return whereParts;
	      }
	
	      Ddf.prototype.getEntitySetsByQuery = function (query) {
	        if (!query || !query.select || !query.where) {
	          return 'Wrong entities query; it should contain "select" and "where" fields';
	        }
	
	        var selectPartsEntitySets = getSelectParts(query).filter(function (part) {
	          return conceptTypeHash[part] === 'entity_set';
	        });
	
	        var wherePartsEntitySets = getWhereParts(query).filter(function (part) {
	          return conceptTypeHash[part] === 'entity_set';
	        });
	
	        return wherePartsEntitySets.length > 0 ? wherePartsEntitySets : selectPartsEntitySets;
	      };
	
	      Ddf.prototype.getEntityFileNames = function (query) {
	        var _this = this;
	        var result = [];
	        var expectedEntities = this.getEntitySetsByQuery(query);
	
	        if (typeof expectedEntities === 'string') {
	          return expectedEntities;
	        }
	
	        if(index) {
	          index.forEach(function (indexRecord) {
	            if (expectedEntities.indexOf(indexRecord.key) >= 0) {
	              result.push(_this.ddfPath + indexRecord.file);
	            }
	          });
	        }
	
	        return unique(result);
	      };
	
	      // this method detects kind of particular entity file
	      Ddf.prototype.getHeaderDescriptor = function (select, firstRecord) {
	        var count = 0;
	        var convert = {};
	
	        // following code answers next question:
	        // `Is this set of entities contains all of selectable concepts?`
	        // or `Is this entities file good for given query?`
	
	        if(firstRecord) {
	          select.map(function (field) {
	            // headers should not contain data before `.`
	            var pos = field.indexOf('.');
	            var _field = pos >= 0 ? field.substr(pos + 1) : field;
	
	            if (firstRecord[_field]) {
	              convert[_field] = field;
	              count++;
	            }
	          });
	        }
	
	        // todo: remove this ugly hack later
	        convert.latitude = 'geo.latitude';
	        convert.longitude = 'geo.longitude';
	
	        return {
	          // this entity file is expected for future processing
	          // if at least one criteria was matched
	          needed: count > 0,
	          convert: convert
	        };
	      };
	
	      Ddf.prototype.applyFilter = function (record, filter) {
	        var matches = 0;
	
	        for (var k in filter) {
	          if (filter.hasOwnProperty(k)) {
	            var pos = k.indexOf('.');
	            var normConcept = pos >= 0 ? k.substr(pos + 1) : k;
	
	            if (!record[normConcept]) {
	              continue;
	            }
	
	            if (record[normConcept].toUpperCase() ===
	              filter[k].toString().toUpperCase()) {
	              matches++;
	            }
	          }
	        }
	
	        return Object.keys(filter).length === matches;
	      };
	
	      // get information for entity correction by filter
	      // for example rule `geo.is--country: true` will be generate pair: `geo: "country"`
	      // it will be needed when geo column in the entity css is 'country', but Vizabi expects only "geo"
	      Ddf.prototype.getFilterConvertPairs = function (filter) {
	        var result = {};
	
	        for (var k in filter) {
	          if (filter.hasOwnProperty(k)) {
	            var pos = k.indexOf('.');
	            if (pos >= 0) {
	              result[k.substr(0, pos)] = k.substr(pos).replace(/^.is--/, '');
	            }
	          }
	        }
	
	        return result;
	      };
	
	      Ddf.prototype.normalizeAndFilter = function (headerDescriptor, content, filter) {
	        var _this = this;
	        var result = [];
	        var convertPairs = _this.getFilterConvertPairs(filter);
	
	        content.forEach(function (record) {
	          if (!_this.applyFilter(record, filter)) {
	            return;
	          }
	
	          var _record = {};
	
	          for (var field in record) {
	            if (record.hasOwnProperty(field)) {
	              // get filtered data with expected prefix
	              // for example, correct:
	              // transform (in `geo` file) column `name` to `geo.name` field in `Vizabi's data`
	              var _field = headerDescriptor.convert[field];
	
	              // add Vizabi oriented data if related concepts are not same in the csv file
	              for (var convertPairKey in convertPairs) {
	                if (convertPairs.hasOwnProperty(convertPairKey) && record[convertPairs[convertPairKey]]) {
	                  _record[convertPairKey] = record[convertPairs[convertPairKey]];
	                }
	              }
	
	              if (_field) {
	                _record[_field] = record[field];
	              }
	            }
	          }
	
	          result.push(_record);
	        });
	
	        return result;
	      };
	
	      Ddf.prototype.getEntities = function (query, cb) {
	        var _this = this;
	        var entityActions = [];
	        var entityFileNames = _this.getEntityFileNames(query);
	
	        if (typeof entityFileNames === 'string') {
	          return cb(entityFileNames);
	        }
	
	        entityFileNames.forEach(function (fileName) {
	          entityActions.push(load(fileName));
	        });
	
	        if(!entityActions.length) {
	          cb([]);
	        }
	
	        // secondly we should get entities
	        Promise.all(entityActions).then(function () {
	          var _entities = [];
	
	          Object.keys(CACHE.FILE_CACHED).forEach(function (fileName) {
	            if (entityFileNames.indexOf(fileName) >= 0) {
	              if(CACHE.FILE_CACHED[fileName] && CACHE.FILE_CACHED[fileName][0]) {
	                var headerDescriptor = _this.getHeaderDescriptor(query.select, CACHE.FILE_CACHED[fileName][0]);
	                // apply filter only for entities?
	                if (headerDescriptor.needed === true) {
	                  _entities = _entities
	                    .concat(_this.normalizeAndFilter(headerDescriptor, CACHE.FILE_CACHED[fileName], query.where));
	                }
	              }
	            }
	          });
	
	          if (_entities.length > 0) {
	            entities = _entities;
	          }
	
	          cb(null, entities);
	        }, function (err) {
	          cb(err);
	        });
	      };
	
	      Ddf.prototype.getConcepts = function (query, cb) {
	        var _this = this;
	        var conceptActions = [];
	        var conceptFileNames = _this.getConceptFileNames();
	
	        if(!conceptFileNames.length) {
	          cb(conceptActions);
	        }
	
	        conceptFileNames.forEach(function (fileName) {
	          conceptActions.push(load(fileName));
	        });
	
	        // first of all we need concepts
	        Promise.all(conceptActions).then(function () {
	          var _concepts = [];
	
	          Object.keys(CACHE.FILE_CACHED).forEach(function (fileName) {
	            if (conceptFileNames.indexOf(fileName) >= 0) {
	              _concepts = _concepts.concat(CACHE.FILE_CACHED[fileName]);
	            }
	          });
	
	          if (_concepts.length > 0) {
	            concepts = _concepts;
	            concepts.forEach(function (concept) {
	              var splittedConcepts = concept.concept.split(/,/);
	
	              splittedConcepts.forEach(function (splittedConcept) {
	                conceptTypeHash[splittedConcept] = concept.concept_type;
	              });
	            });
	          }
	
	          cb(null, concepts);
	        }, function (err) {
	          cb(err);
	        });
	      };
	
	      Ddf.prototype.getConceptsAndEntities = function (query, cb) {
	        var _this = this;
	
	        _this.getConcepts(query, function (err, concepts) {
	          if (err) {
	            return cb(err);
	          }
	
	          _this.getEntities(query, function (err, entities) {
	            cb(err, concepts, entities);
	          });
	        });
	      };
	
	      // extract measures and other concept names from query
	      Ddf.prototype.divideByQuery = function (query) {
	        var measures = [];
	        var other = [];
	
	        query.select.forEach(function (partOfSelect) {
	          if (conceptTypeHash[partOfSelect] === 'measure') {
	            measures.push(partOfSelect);
	          }
	
	          if (conceptTypeHash[partOfSelect] !== 'measure') {
	            other.push(partOfSelect);
	          }
	        });
	
	        return {
	          measures: measures,
	          other: other
	        };
	      };
	
	      Ddf.prototype.getDataPointDescriptorsByIndex = function (query) {
	        var _this = this;
	        var descriptors = [];
	        var fileNames = [];
	
	        if (index) {
	          index.forEach(function (indexRecord) {
	            if (conceptTypeHash[indexRecord.value] === 'measure') {
	              var other = indexRecord.key.split(/,/);
	              var parts = other.concat(indexRecord.value);
	              var founded = 0;
	
	              parts.forEach(function (part) {
	                if (query.select.indexOf(part) >= 0) {
	                  founded++;
	                }
	              });
	
	              if (founded === parts.length) {
	                fileNames.push(_this.ddfPath + indexRecord.file);
	                descriptors.push({
	                  fileName: _this.ddfPath + indexRecord.file,
	                  measures: [indexRecord.value],
	                  // only one measure should be present in DDF1 data point in case of Vizabi using?
	                  measure: indexRecord.value,
	                  other: other
	                });
	              }
	            }
	          });
	        }
	
	        return {
	          descriptors: descriptors,
	          fileNames: fileNames
	        };
	      };
	
	      // data points descriptors will be used for data points content loading
	      Ddf.prototype.getDataPointDescriptors = function (query) {
	        this.categorizedQuery = this.divideByQuery(query);
	        var descResultByIndex = this.getDataPointDescriptorsByIndex(query);
	        var result = descResultByIndex.descriptors;
	        return result;
	      };
	
	      // get data points source
	      Ddf.prototype.getDataPointsContent = function (query, cb) {
	        var _this = this;
	        var actions = [];
	
	        this.dataPointDescriptors = this.getDataPointDescriptors(query);
	
	        this.dataPointDescriptors.forEach(function (dataPointDescriptor) {
	          actions.push(load(dataPointDescriptor.fileName));
	        });
	
	        if(!actions.length) {
	          return cb();
	        }
	
	        Promise.all(actions).then(function () {
	          _this.dataPointDescriptors.forEach(function (dataPointDescriptor) {
	            dataPointDescriptor.content = CACHE.FILE_CACHED[dataPointDescriptor.fileName];
	          });
	
	          cb();
	        }, function (err) {
	          cb(err);
	        });
	      };
	
	      Ddf.prototype.getExpectedConcept = function (type) {
	        for (var i = 0; i < concepts.length; i++) {
	          if (this.categorizedQuery.other.indexOf(concepts[i].concept) >= 0 &&
	            concepts[i].concept_type === type) {
	            return concepts[i].concept;
	          }
	        }
	
	        return null;
	      };
	
	      Ddf.prototype.getTimeConcept = function () {
	        return this.getExpectedConcept('time');
	      };
	
	      Ddf.prototype.getEntityDomainConcept = function () {
	        return this.getExpectedConcept('entity_domain');
	      };
	
	      // get data points data (for reader)
	      Ddf.prototype.getDataPoints = function (query, cb) {
	        var _this = this;
	
	        _this.getDataPointsContent(query, function (err) {
	          if (err) {
	            return cb(err);
	          }
	
	          var entityDomainConcept = _this.getEntityDomainConcept();
	          var timeConcept = _this.getTimeConcept();
	
	          // fill hash (measure by entity_domain and time)
	          _this.dataPointDescriptors.forEach(function (pointDescriptor) {
	            pointDescriptor.contentHash = {};
	
	            pointDescriptor.content.forEach(function (record) {
	              if (!pointDescriptor.contentHash[record[entityDomainConcept]]) {
	                pointDescriptor.contentHash[record[entityDomainConcept]] = {};
	              }
	
	              pointDescriptor.contentHash[record[entityDomainConcept]][record[timeConcept]] =
	                record[pointDescriptor.measure];
	            });
	          });
	
	          var result = [];
	          // get range for entity_domain
	          var entityDomainValues = getExpectedEntityDomainValues(_this.getEntityDomainConcept());
	          // get range for time
	          var timeRangeValues = getTimeRange(query.where[_this.getTimeConcept()]);
	
	          // fill data points data
	          entityDomainValues.forEach(function (entity) {
	            timeRangeValues.forEach(function (time) {
	              var record = {};
	
	              // record (row)
	              record[entityDomainConcept] = entity;
	              record[timeConcept] = new Date(time);
	
	              // add measures
	              var count = 0;
	              _this.dataPointDescriptors.forEach(function (pointDescriptor) {
	                if (pointDescriptor.contentHash[entity] && pointDescriptor.contentHash[entity][time]) {
	                  record[pointDescriptor.measure] = Number(pointDescriptor.contentHash[entity][time]);
	                  count++;
	                }
	              });
	
	              if (count === _this.dataPointDescriptors.length) {
	                result.push(record);
	              }
	            });
	          });
	
	          cb(err, result);
	        });
	      };
	
	      Ddf.prototype.cachedFileExists = function (path) {
	        return typeof CACHE.FILE_CACHED[path] != 'undefined';
	      };
	
	      //// csv utils
	
	      var EVALALLOWED = null;
	
	      var CACHE = {
	        FILE_CACHED: {},
	        FILE_REQUESTED: {}
	      };
	
	      function defineEvalAllowed() {
	        try {
	          new Function("", "");
	          EVALALLOWED = true;
	        } catch (ignore) {
	          // Content-Security-Policy does not allow "unsafe-eval".
	          EVALALLOWED = false;
	        }
	      }
	
	      // parsing csv string to an object, circumventing d3.parse which uses eval unsafe new Function() which doesn't comply with CSP
	      // https://developer.chrome.com/apps/contentSecurityPolicy
	      // https://github.com/mbostock/d3/pull/1910
	      function csvToObject(res) {
	        var header;
	        return (res == null) ? null : d3.csv.parseRows(res, function (row, i) {
	          if (i) {
	            var o = {}, j = -1, m = header.length;
	            while (++j < m) o[header[j]] = row[j];
	            return o;
	          }
	          header = row;
	        });
	      }
	
	      function load(path) {
	        if (CACHE.FILE_REQUESTED[path]) {
	          return CACHE.FILE_REQUESTED[path];
	        }
	
	        CACHE.FILE_REQUESTED[path] = new Promise();
	
	        // checks if eval() statements are allowed. They are needed for fast parsing by D3.
	        if (EVALALLOWED == null) {
	          defineEvalAllowed();
	        }
	
	        // true:  load using csv, which uses d3.csv.parse, is faster but doesn't comply with CSP
	        // false: load using text and d3.csv.parseRows to circumvent d3.csv.parse and comply with CSP
	        var loader = (EVALALLOWED) ? d3.csv : d3.text;
	        var parser = (EVALALLOWED) ? null : csvToObject;
	
	        if (Ddf.chromeFs) {
	          loader = function (path, cb) {
	            Ddf.chromeFs.readFile(path, '', function (err, file) {
	              cb(err, file);
	            });
	          };
	          parser = csvToObject;
	        }
	
	        loader(path, function (error, res) {
	          var reason;
	
	          if (!res) {
	            reason = 'No permissions or empty file: ' + path + ': ' + error.message;
	            error$1(reason);
	
	            CACHE.FILE_CACHED[path] = null;
	            CACHE.FILE_REQUESTED[path].reject(reason);
	            return;
	          }
	
	          if (error) {
	            reason = 'Error Happened While Loading CSV File: ' + path + ': ' + error.message;
	            error$1(reason);
	
	            CACHE.FILE_CACHED[path] = null;
	            CACHE.FILE_REQUESTED[path].reject(reason);
	            return;
	          }
	
	          if (parser) {
	            res = parser(res);
	          }
	
	          CACHE.FILE_CACHED[path] = res;
	          CACHE.FILE_REQUESTED[path].resolve();
	        });
	
	        return CACHE.FILE_REQUESTED[path];
	      }
	
	      //// time utils
	
	      function flatten(arr) {
	        arr = arr || [];
	        return arr.reduce(function (prev, cur) {
	          var more = [].concat(cur).some(Array.isArray);
	          return prev.concat(more ? cur.flatten() : cur);
	        }, []);
	      }
	
	      function getUnique(arr) {
	        var u = {};
	        var a = [];
	        for (var i = 0, l = arr.length; i < l; ++i) {
	          if (u.hasOwnProperty(arr[i])) {
	            continue;
	          }
	
	          a.push(arr[i]);
	          u[arr[i]] = 1;
	        }
	        return a;
	      }
	
	      var TIME_TYPE_PATTERN = [
	        // year
	        /^(\d{4})$/,
	        // quarter
	        /^(\d{4})q(\d{1})$/,
	        // month
	        /^(\d{4})(\d{2})$/,
	        // week
	        /^(\d{4})w(\d{1,2})$/,
	        // date
	        /^(\d{4})(\d{2})(\d{2})$/
	      ];
	
	      function extractLocalTimeRange(type) {
	        function parse(option) {
	          var match1 = TIME_TYPE_PATTERN[type].exec(option[0]);
	          var match2 = TIME_TYPE_PATTERN[type].exec(option[1]);
	
	          return {
	            first: [match1[1], match1[2], match1[3]],
	            second: [match2[1], match2[2], match2[3]]
	          };
	        }
	
	        function getTypicalRange(option, minLimit, maxLimit, divider, isFullV) {
	          var parsed = parse(option);
	          var sYear = Number(parsed.first[0]);
	          var v1 = Number(parsed.first[1]);
	          var fYear = Number(parsed.second[0]);
	          var v2 = Number(parsed.second[1]);
	
	          var result = [];
	          for (var year = sYear; year <= fYear; year++) {
	            var sV = year === sYear ? v1 : minLimit;
	            var fV = year === fYear ? v2 : maxLimit;
	            for (var v = sV; v <= fV; v++) {
	              if (isFullV === true && v < 10) {
	                v = '0' + v;
	              }
	
	              result.push(year + divider + v);
	            }
	          }
	
	          return result;
	        }
	
	        var options = [
	          function year(option) {
	            var parsed = parse(option);
	            var sYear = Number(parsed.first[0]);
	            var fYear = Number(parsed.second[0]);
	
	            var result = [];
	            for (var year = sYear; year <= fYear; year++) {
	              result.push('' + year);
	            }
	
	            return result;
	          },
	          function quarter(option) {
	            return getTypicalRange(option, 1, 4, 'q', false);
	          },
	          function month(option) {
	            return getTypicalRange(option, 1, 12, '', true);
	          },
	          function week(option) {
	            return getTypicalRange(option, 1, 53, 'w', true);
	          },
	          function date(option) {
	            var parsed = parse(option);
	            var sYear = Number(parsed.first[0]);
	            var month1 = Number(parsed.first[1]);
	            var day1 = Number(parsed.first[2]);
	            var fYear = Number(parsed.second[0]);
	            var month2 = Number(parsed.second[1]);
	            var day2 = Number(parsed.second[2]);
	
	            var result = [];
	            for (var year = sYear; year <= fYear; year++) {
	              var sMonth = year === sYear ? month1 : 1;
	              var fMonth = year === fYear ? month2 : 12;
	              for (var month = sMonth; month <= fMonth; month++) {
	                var monthStr = month < 10 ? '0' + month : month;
	                var sDay = (year === sYear && month === sMonth) ? day1 : 1;
	                var fDay = (year === fYear && month === fMonth) ? day2 : 31;
	
	                for (var day = sDay; day <= fDay; day++) {
	                  var dayStr = day < 10 ? '0' + day : day;
	
	                  result.push(year + '' + monthStr + '' + dayStr);
	                }
	              }
	            }
	
	            return result;
	          }
	        ];
	
	        return options[type];
	      }
	
	      function detectTimeType(timeQuery) {
	        var flat = flatten(timeQuery);
	        var types = [];
	        for (var i = 0; i < flat.length; i++) {
	          for (var j = 0; j < TIME_TYPE_PATTERN.length; j++) {
	            if (TIME_TYPE_PATTERN[j].test(flat[i])) {
	              types.push(j);
	              break;
	            }
	          }
	        }
	
	        types = getUnique(types);
	
	        if (types.length !== 1) {
	          throw new Error('Wrong time query format: ' + JSON.stringify(timeQuery));
	        }
	
	        return types[0];
	      }
	
	      function getTimeRange(query) {
	        var type = detectTimeType(query);
	        var extractor = extractLocalTimeRange(type);
	        var result = [];
	
	        query.forEach(function (option) {
	          if (typeof option === 'string') {
	            result.push(option);
	          }
	
	          if (typeof option === 'object') {
	            result = result.concat(extractor(option));
	          }
	        });
	
	        return result;
	      }
	
	      //// entity set utils
	
	      function getExpectedEntityDomainValues(entityName) {
	        return entities.map(function (entity) {
	          return entity[entityName];
	        })
	      }
	
	      function getShapes(geoCat) {
	        var shapes = {
	          world_4region: [[
	            "africa",
	            "Africa",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='africa' d='M322.7,114.7l-1-1.8l-6.5,2.3l-16-4.8l-2.3,1.7l-1.8,4.5l-16.9-8.6l-0.2-0.6l-0.3-5.5l-2-2.8l-29,4.4l-0.2-0.4 l-1.7,0.2l-0.1,1.1l-6.7,7l-0.5,1.9l-0.6,0.7l-0.3,3.3l-15.3,23.7l0.6,13.2l-1.4,3l1.1,7.6l12.1,17.9l6,2.8l7.1-1.9l4.5,0.8 l13.7-3.3l3.9,4.5h3.5l1.6,1.4l1.8,3.6l-1.1,10.7l9.2,27.4l-4,14.6l8.5,30.7l1.1,1.1v0.7h0.5l3.5,12.5l2,1.7l11.9-0.6l15-18.2v-3.9 l5.1-4.5l1.1-4.2l-1.1-5.9l10.5-12.2l0.6-0.3l1.6-3.7l-3.4-24l25-43.3l-13.1,1.1l-1.8-1.1l-24.7-48.6l0.9-0.4l0.6-1L322.7,114.7  M360.1,233.2l2.3,1.7l-8.6,30.5l-4.3-0.6l-2-7.6l2.8-14.6l6.4-4.4l2.8-4.9L360.1,233.2z'/></svg>"
	          ], [
	            "americas",
	            "Americas",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='americas' d='M134.8,152l-11.4,1.8l-3.1-1.7l5.3-1.3l-0.7-1.1l-3.3-1.4h-0.1l-8.1-0.9l-0.3-0.3l-0.3-1.5l-6.2-3.6l-3.4,0.8 l-1.6,1.3l-1.2-0.5l-0.7-1.7l3.8-1.6l9.1,0.7l9.5,5.3l0,0l3.3,1.8l1.7-0.5l6.6,2.8L134.8,152 M183.7,25.4l-0.5-1.5l-2.6-2.2 l-2.1-0.6l-2.9-2.2l-18.2-2.2l-5.1,3.7l2,4.3l-6,2.2l1-1.7l-4.6-1.9l-0.5-1.7l-1.1-1.2l-2.9,0.5l-2.1,4.2l-5.8,2.5l-15.5-2.2 l10.5-1.7l-1.3-4l-11.6-0.4l-3.2-1.5L96,20.7h5.8l4,1.9l-1.7,1l0.8,1l7.2,2.3l-78.9-5.3l-10,3.6l-0.4,4.4L18,31.1l1,1.8l1.7,1.2 l-5.5,4.5l-0.4,5.6L13.8,46l1.8,1.8l-4.4,6.2L22,43.7l1.8-0.5l1.3-1.2l13.4,4l4,4.2l-1.3,14l1.6,2.6l-3.3,1.3L39.4,70l2.7,2.6 L28.6,96.9l1.6,11.2l4.8,5.6l-0.2,3.4l2.5,6.1l-0.5,5l6.6,11.9L38,121.5l1.7-4l3.4,6.1l0.3,2.2l7.1,13.1l1.1,9.2l11.1,8.7l1.6,0.3 l1.3,0.9l5.5,1.2l3.4-0.9l5.5,4.2l0.3,0.5l0.8,0.3l2.1,1.9l5.5,0.5l0.2,0.6l0.8,0.3l4.8,8.9l2.3,1.5l0.2,0.5l7.1,3.4l1.6-1.7 l-5.1-2.2l-1.3-15.6l-6.3-2.2l-3.7,0.3v-4.6l3.7-8.9l-5.2-0.9l-0.5,0.3L83,151l-6.3,2.2l-4-2.8l-3.2-8.9l3.2-11.8l0.5-0.3l0.2-1.2 l2.6-3.1l8.5-3.6l6.3,1.8l4.5-3.1l9.2,1.1l2.5,3.1l1.5,7.8l1.3,1.8l2.1-4.5l-1.1-5l1.6-7l13.7-12.3l0.2-3.7l0.8-1.7l0.9-0.2l0.7,0.5 l0.6-1.9l15-8.8l2.2-3.9l11.9-5.1l-2.2,3.6l11.4-3.8l-5.2-1.7l-1.8-2.8l1.6-4.2l-0.8-0.9h-4.2l0.8-1.5l19.5-3.2l1.6,2.8l-4.5,4.2 l6,1.7l5.3-2.2l-6.3-7.6l4.5-6.1l-1.1-0.6l-0.2-0.5h-3.2l-3.7-13.4l-7.7,3.1l-1.8-1.9l0.2-3.9l-2.3-2.5l-3.4-1.5l-6.6,1.9l-2.1,4.2 l-1.1,0.6l-1.3,2.2l-0.3,3.4l-10,9.5l-0.8,2.8l-1.8,1.9l-2.1,0.3l-1.8-2.5l1.1-4.8l-11.9-6.1l-3.1-5.1l15-12l1.3,0.3l5.1-1.2 l1.1-1.2l0.4-1.2l3.4-0.3l-1.7,4.8L147,34l4.6,0.7l-2.2-2.9l-2.1-1.2l8.2-2.8l0.3-0.6l2-1.7l0.7,0.1l8.1-4.2l7.4,5.3l0.2,1.5l-6,1.5 l-1.8,2.2l3.7,5.3l3.4,1.2l2.3-2.2l2.9-1.2L179,33l-0.2-1.9l7.7-1.7L183.7,25.4 M119.7,74.5l0.8,3.1l1.7,1.8l3.3-0.2l5.4,4.7 l2.7,0.2l-0.5,1.7l-4.7-0.4l0.2-1.2l-2.6-0.9l-2,0.6l-2.6,3.4l3.1,1.7l-3.2,2.3l-2.6-1.2l0.1-9.3l-9.6,9.9L108,88l4.5-7l4.3-2 l-5.1-2.1l-4.8,0.5l0.2-1.7l1.3-1.2l8.7-2.2L119.7,74.5 M205.9,223.1l-1.3,3.1H204l-7.1,11.2l-1.9,18.2l-3.1,6.1h-0.5v0.6l-0.8,0.3 l-1.1,1.2l-2.7-0.3l-9.4,6.7l-7.7,21.6l-3.9,3.3l-5.1-1.1l2.1,3.3l0.5,5.3l-7.9,3.3l-1.4,1.5l-0.5,3.6l-1.1,0.6l-1.1-0.3l-1.8,0.9 l1.8,6.1l-1.8,5.6l3.4,6.1l-2,5.9l0.5,3.1l11.1,8.2l-0.2,0.5l-9.3-0.6l-4.3-5.1l-4.7-1.7l-8.6-17.1l0.5-1.7l-6-12.3l-4.5-56.7 l-12.4-10.2l-4.2-8.1l-0.8-0.6l-9.8-21.5l1.1-2.2l-0.3-2.6l-0.5-0.8l7.9-15.3l0.3-5.6l-1-2.8l1-3.9l1.8-0.3l9.7-8.2l2.1,0.3l0.8,5.1 l2.7-5.1l1.3-0.3l4.2,2.8h0.9l0.2,0.6l14.8,3.9l1.6,1.4l0.3,0.6l7.9,6.7l7.7,0.9l4.3,4l2,6.3l-1,4.6l4.4,1.4l1.1,2.2l5.2-1.1 l2.1,1.1l2.6,4l2.9-0.9l9,1.9l8.6,5.8L205.9,223.1'/></svg>"
	          ], [
	            "asia",
	            "Asia",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='asia' d='M322.9,118.9l22.8,42.5l13.5-5.9l16.8-19l-7.3-6.5l-0.7-3.4h-0.1l-5.7,5.2l-0.9,0.1l-3.2-4.4l-0.4-0.2l-0.7,1.7 l-1.2-0.4l-4.1-11.4l0.2-0.5l1.9-1.2l5.1,6.8l6.2,2.7l0.8-0.2l1.1-1.1l1.6,0.4l2.9,2.6l0.4,0.8l16.4,0.8l6.9,6.5l0.4,0.1l1.4-0.3 l0.3,0.1l-1.7,2.5l2.9,2.8h0.7l3.3-3.3l0.5,0.3l9.2,32.1l4,3.7l1.3-1.3h0.2l1.7,1.3l1.4,6.6l1.6,0.9l1.7-2.9l-2.3-7.3l-0.1,0.3v-0.2 l-1.7,0.6l-1.3-1.1l1.2-14.3l14.3-17.6l5.9-1.7l0.3,0.1l3.1,4.5l0.8,0.2l0.9,1.5l0.8,0.3l4.7,10.3l0.2,0.1l2-0.6l5.4,10.1l-0.3,10.5 l2.8,3.7l0,0l4.2,10.8l1.8,1.7l-1.1,2.4l-0.8-0.6l-1.9-4l-1.7-1.4l-0.3-0.9l-5.5-3.5l-2.4-0.3l-0.2,1.2l19.8,28.5l2.6-3.6l-5.7-11.2 l0.9-4l0.7-0.2l0.2-2.3l-9.3-18.6l-0.3-8.9l1.4-1.5l6.7,7.8l1.4,0.3l1.1-0.6l0.1,0.1l-0.2,3.4l0.6,0.5l0.5,0.2l7.4-7.9l-2-10.4 l-6.9-9.5l4.9-6l0.8,0.2l0.8,0.5l1.7,3.9l2.9-4.7l10.1-3.6l5.1-8.1l1.6-9.9l-2.5-2l1.1-1.7l-7.5-11.5l3.5-4.7l-6.1-0.9l-3.5-3.7 l4.1-4.3l0.8-0.1l1.4,0.9l0.6,2.9l2.8-1.3l3.9,1.4l0.9,3.2l2.3,0.5l5,9h0.4l2.3-2.4h0.3l1-1.5l-1.7-3.8l-5.8-5.9l2.1-4v-3.6l2.6-2.4 l0.5,0.1l0.2-0.1l-3.5-15.2l-0.2,0.1v-0.1l-9.3,1.2l-7.3-9.3L464,58.8l-0.8,1.9L441.2,60l-1.5-1.8l-0.2,0.1l0,0l-7.3,4.1l-7.5-3 l-0.5,0.3l-1.8-0.8l-0.9-1.2l-0.3,0.1l-0.1-0.1l-5.7-0.4l-0.3-0.2l0,0l0,0l-1,0.5l-1.5,4.5l-4.2,2.7l-16.8-4.4L377.5,50l0,0l-0.2,1 l1.8,6.7l-13.3,3l-9.2-3.8l-1.1,3.1l-6.7-1.6l-0.1,0.1h-0.2l-4.4,6.8l3.8,3.8l0.6,2.7l0,0l0,0L352,71l2.6,2.2V74l-2.3,1.9l-0.8,1.6 l1.6,3.9l0.9,0.3l1,1.1l2.6,0.9l1.7,1.7l-0.2,1.1l-1.5,2.8l2.1,3.7v4.5l-1.3,1.4l-3.8-0.9l-4.7-5.1v-0.6l-1.4-1.4l-3.9,2.1l-2.4-2.1 l-1.6,0.9l-0.3,5.1l-15.2,4.7l-1.7,9.8l-2.5,1.7L322.9,118.9 M531.1,99.3l-1,2l-4,1.7l-2.4,3l-3.3-2.5l-6.4,0.2l-0.2-0.7l8.9-4.2 l3.7-4.9l-0.6-3.3l-3.2-5.1l-0.7-0.4v-5.1l1.4-2.6l1.7,0.3l0.6,0.7h0.8l1.1,0.8l1.3,0.3l0.6,1.9l-1.7,2l-2.6-1.2L531.1,99.3  M500.5,130.3l1.9-0.9l-0.8,6.3l-1.6-0.3L500.5,130.3 M515.9,180.5l-1.7,0.4l-2.2-3.3l-3.6-2.2l4.3-2.5l0.9-3.1l-0.3-4.1l-4.6-2.1 l-2,0.5l-5.1,8.5l-2.4,0.3l-0.2-3.4l0.8-0.7l4.2-9.3l-1.8-3.7l1.4-9.3l2.4,1.8l1.6,3.6l-0.5,4.8l8,6.4l0.1-0.1l3.1,11.2L515.9,180.5 L515.9,180.5L515.9,180.5 M497.7,179.5l2.6,0.9l1.1,1.9l-1.8,5.1l0.8,7l-6,10.9l-9.2-1.7l-2.9-10.9L497.7,179.5L497.7,179.5  M509,194.8l-1.8,0.1L509,194.8 M515,193.9l-1.7,2.2l-2.4-0.2l-1.9-1.1l-3.3,1.3l-0.3,1.9l1.2,1.4l2.1-0.3l0.9-0.7l1.1,0.1l0.3,1.2 l-1.9,2.6l0.7,5.6l-2.3-2l-1-2l-1.5,1l0.9,5.2l-3.1-0.4l0.2-2.8l-1.4-2.5l2.9-10.5l3.2-1.6l3.8,1.2l3.4-1.1L515,193.9 M530.7,198.1 l2.5,0.5l0.4,0.4l2,5.3l2.1-2.2l4.2-1.7l14.5,11.5l2.4,0.5l4-2.6l-1.2,4.7l-3.5,1.4l-0.5,1.4l0.1,1.3l4.4,6.5l-4.4-1.5l-5.2-7.5 l-5.6,4.4l-5.6-2l-1.2-1.5l1.3-1.5l-1.9-2.4l-0.3-0.8l-8.5-5l-0.9-4.7l-3.4-3.1l2.4-1.4H530.7 M476.6,212.1l19.1,5l3.1-0.8l4.4,1.4 l3.3-0.9l12.4,2.1l-0.1,0.6l-8.2,4v-1.9l-35.4-5.6l-1.5-1.8l2.5-1.9H476.6 M569.4,280.1l-19,14.6l-0.7-1.1l2.2-4.6l5.1-3l7.4-9.7 l0.9-4.3l4.8,5.1L569.4,280.1 M554.3,267.3l-11.1,18.2l-5.7,3.1l-4.8,7.7l-2.5,0.5l-0.6-1.9l0.5-3.4l2.8-2.9l-6.6-0.8l-1.6-1.4 l-1.7-8.4l-0.9-0.9l-3.1,1.1l-5.2-3.9l-32.3,7.3l-2.3-1.9l2.3-4.5l0.6-21.9l1.8-2.5l13.9-6.4l4.3-4.8l0.3-0.9l10-9.2l4.2,1.9l5.5-7 l4.2-1.4l4.9,2l-1.1,5l2.8,4.8l4.5,2.8l3.2-4.5l2.5-11.7l4.6,10.8v7.6l7.7,18.5L554.3,267.3L554.3,267.3L554.3,267.3L554.3,267.3 L554.3,267.3L554.3,267.3'/></svg>"
	          ], [
	            "europe",
	            "Europe",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='europe' d='M556.7,26.9l-35.5-7.3l-3.5,1.4l-49.9-5.2l-2.7,2l-45.8-4.1l-1.3-1.9l-15.3-2.2l-0.2,0.1h-0.1l-0.2,0.2l-6,0.6 l-0.5,0.5L372.4,17l-1.7,1.7l-5.8-3.1h-1.7l-1.5,3.7l1.8,2.5l-0.4,0.2l-10.1-1.5l-6.8,1.9l-5.3-0.6l-7.2,2.6l-4.2-1h-0.1l-3.1,3.2 l-0.9,0.2l-2.6,2.2l-2.3,0.8l-1.6,2h-1.7l-5.1-5.1l-1-0.2l-0.1-0.5l1.3-0.9l8.4,1.6l0.5-0.1l2.4-1.8l-0.8-0.9l-20.2-5.5l-16.9,3.4 L268,37l0.8,6.1l3.2,1.7l4-1l1.5,0.9l2.6,5.5h0.8l0.7,1.2l0.8,0.2l7.9-9.7l-2.9-5.4l8.5-8.9h0.5l1.3,1.7l-2.7,6.6l0.8,2.8l11.9,2.4 l-4,1.8l-3.5-0.3l-1.5,1.2l1,1.6l-0.1,2.2l-0.9-0.6H297l-1.8,1.2l-0.5,3.9l-2.3,2.2h-4.3l-4.2,1.9l-6.8-0.7l-0.6-0.4l2.5-1.7 l0.5-1.2l-0.9-1.7l-0.2-0.1l-2.3,0.5l-0.2-0.1l-0.2-3.4l-0.4-0.1l-2.6,3.9l1.3,3.7l-1.4,1.7L269,57l-18.9,13.1l0.1,1l1.7,1.6 l0.8,0.3l1.3,2.2l0.3,3.6l-3.1,4.5l-9.7-0.9l-1.3,1.5L239,97.9l0.4,1.1l5.1,3.1l0.2,0.8l1.6-0.2l0.1-0.2h0.1v-0.1l7.9-4.5l10-14.3 l10-2.8l1.2,0.5l11,11.5l0.2,2.3l-2,1.8l-1.9-0.4l-1.8,0.5l3.8,3.9l1.1-0.7l3.7-5.6l0.2-0.5l-0.9-1.9l0.2-0.4l2.3,0.3l0.8-1 l-1.7-0.9l-8.7-7.6l-0.5-4.5l1.4,0.2l10.4,8l3.4,9l1,0.5l0.5,0.6v1.5l4.5,6.1v0.4l0.7,1.1l3.7,1.3l1.4-1.6l-3.8-2.3l-0.1-1.7 l2.2-2.6l-6.3-6.3l5.6-2.2L306,90l5.8,8l4.2-0.6l2.7,0.9l1,4.7l0.7-0.1l1.8-2l-1.3-1.7l0.2-0.9h4.3l0.3,2.7l15.2-4.7l0.4-5.1 l1.5-0.9l2.5,2l3.9-2.1l1.4,1.5l0.3-3.9l-3.1-5.3l-1.3-8.6l2.9-2.5l-0.6-2.7l-3.8-3.8l4.5-6.9l6.8,1.6l1.1-3.1l9.2,3.8l13.3-3.1 l-1.8-6.7l0.2-1l8.7,7.4l22.2,7.4l4.3-2.7l1.5-4.5l1-0.5l0.2,0.2l6,0.4l1,1.2l1.7,0.8l0.5-0.3l7.5,2.9l7.5-4.2l1.5,1.8l22.1,0.8 l0.7-1.8l23.5-1.4l7,9.2l9.6-1.2l3.4,15.2l1,1.1l-0.2,0.2l1.7,1.7l0.5,0.1l1.8-2.2l1.6-5.3L508,56.7l-2.9-2.2l-5.5,0.3l-2.6-2.5 l1.8-7.8l0.5-0.3l0.2-0.9l3.4-1.7l14.2,0.6l1.3-4.8l1.6-1.2l0.4-0.1l4.3,1.2l0.1-0.1l0.2,0.1l3.1-2.5l1.7,0.9l-1,12l6.9,15.9l3.1-3 l0.1-0.3l2.3,1.1l0.8-2.2l-1.1-8.7l-4.8-5.8l0.1-2.6l0.8-1.5l4.5-2.2l2.2,0.2l4-3.7l2.1-0.3l1.1-1.7l-5.2-2.5l-0.5-1.7l2.9-1.7 l8.2,2.2l0.9-0.2l0.8-1.2L556.7,26.9 M331,87l-11.6-3.1l-8.9,2.9l-0.2-0.1l-0.5-1.9l2.9-7l2.9-2.5h1.7l2.1,1.1l2.3-1.7l1.8-3.4 l1.8-0.6l2.1,0.6l-0.8,3.9l7.7,7.3L331,87 M252.8,18.2l-5.8,5.6l-3.7,1.1l-1.1,4.3l-2.2,1.7l-0.2,1.2l0.9,1.7l7.8,1.2l-2.4,2.9 l-4.6,1.7l-5.9-2.9l2-1.8l1.9-0.8l-2.5-2.1l-11.4,1.7l-4.7,3.1l-8,1.7L203,49l-3.4,0.3l-3.7-2.8l-1.3-10.6l5.2-4.5l1.1-2l-1.9-3.3 l-0.5-0.3v-0.6l-0.5-0.3v-0.6l-0.6-0.3l-1.1-1.4l-3.1-1.4h-5.5l-4-1.7l71.2-3.4L252.8,18.2 M258.9,60.7l0.7,1.2l-10.5,1.5l3.4-1.5 l-0.1-1.5l-2.7-0.9l4.2-4.9l-2.7-2.7l-5.9,7.4l-4.4,0.8l1.1-2.7l-0.2-2.7l8.5-4.8l0.3-3.8l1-1.3l1.3,0.4l0.2,1.1l1.3,0.3l-0.8,3.2 l3.3,2.4l1.7,5.1l2.6,0.9L258.9,60.7'/></svg>"
	          ]],
	          geographic_regions: [[
	            "america",
	            "America",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='america' d='M189.96,40.495c1.3,0.72,2.56,1.51,3.82,2.32l1.04,0.23c0.57,0.13,1.7,0.39,2.27,0.52c0.55,0.18,1.64,0.55,2.18,0.73c-0.13,1.2-0.26,2.41-0.36,3.61c-4.66,0.37-9.34,0.55-14,0.8c0.06,1.15,0.11,2.3,0.16,3.45c0.58-0.04,1.74-0.11,2.32-0.14c1.6-0.47,2.8,0.77,3.51,2.04l0.63,0.8c0.88,0.68,1.23,1.54,1.06,2.59l-0.11,1.04c1.27-0.13,1.89,0.44,1.87,1.71c2.21,0.13,4.42,0.26,6.65,0.27c1.38-0.07,2.75,0.11,4.1,0.43c1.94,0.35,3.91,0.45,5.88,0.44c0.57,0.09,1.72,0.27,2.29,0.35l1.24,0.46c0.12-1.63,0.31-3.27,0.3-4.91c-0.29-1.27,0.12-2.87,1.7-2.85c1.17-0.31,2.33-0.63,3.5-0.96c-0.16-0.53-0.46-1.58-0.61-2.1c-0.42-1.05-0.16-1.91,0.76-2.6c1.85-1.74,3.41-3.76,5.09-5.66c2.13-2.35,5.27-3.21,8.07-4.51l0.62-0.31c1.1-0.64,2.26-1.21,3.49-1.58c1.25-0.46,2.52-0.97,3.57-1.83c0.51-0.9,1.27-1.43,2.28-1.59c2.35-0.65,4.6-1.6,6.83-2.58l-0.65-1.11c-0.6-0.83-0.87-1.75-0.81-2.76c-2.47-0.83-4.94-1.79-7.54-2.09c-1.18-0.02-2.34-0.27-3.43-0.68c-0.87-0.11-2.59-0.34-3.45-0.46c-1.18,0.08-2.35-0.12-3.47-0.479c-2.02-0.15-6.06-0.46-8.09-0.62c-1.35,0.04-4.07,0.11-5.43,0.14c-0.54,0.18-1.64,0.54-2.18,0.71c-0.62,0.89-1.44,1.311-2.48,1.271l-0.72,0.03c-4.64,0.31-9.27,0.63-13.89,1.02l-0.78,0.38c-2.28,1.27-4.54,2.55-6.82,3.82l-0.7,0.42c-0.93,0.689-1.95,1.24-3.04,1.6l-0.93,0.521c-0.83,0.83-1.72,1.02-2.7,0.56C184.92,35.785,186.99,38.645,189.96,40.495z M203.85,33.395l-1.02,0.57c2.36,1.12-1.66,3.47-1.3,0.83c-0.15-1.15-0.3-2.311-0.43-3.46C201.77,28.755,206.22,32.025,203.85,33.395z M204.82,54.435c-2.256-0.119-4.503-0.26-6.75-0.442c-0.075-1.56,0.615-2.036,2.07-1.438C201.7,53.195,203.26,53.815,204.82,54.435 M162.94,36.825c0.44,0.12,1.3,0.36,1.74,0.48c1.02-0.1,1.92,0.2,2.7,0.88c1.21,0.82,2.51,1.5,3.83,2.14c1.16,0.36,1.59,1.11,1.31,2.23c0.15-0.36,0.43-1.09,0.58-1.46c0.31-1.14,1.05-1.58,2.22-1.31c1.21,0.15,2.43,0.26,3.66,0.33c0.56,0.1,1.69,0.29,2.25,0.39c0.49,0.17,1.46,0.5,1.95,0.66c0.19-1.6,0.38-3.21,0.57-4.81l-0.66-0.3c-2.57-1.13-5.11-2.33-7.64-3.53l0.2,1.09c0.74,1.38-1.02,2.32-2.03,1.35c-1.1-0.49-2.23-0.92-3.38-1.28c-1.12-0.23-2.15-0.77-2.95-1.6c-0.99-0.82-1.99-1.62-3-2.4c-1.93,0.89-3.85,1.8-5.74,2.74c0.42,0.4,1.28,1.2,1.71,1.6C161.26,34.855,162.13,35.815,162.94,36.825 M146.08,43.795c0.74-1.05,1.6-2.01,2.57-2.86c0.47-0.47,1.42-1.42,1.89-1.89c-3.31-0.11-6.59-0.23-9.88-0.37c0.93,2.65,1.99,5.26,3.18,7.8C144.61,45.605,145.35,44.705,146.08,43.795 M126.03,51.835c2.62-0.65,5.14-1.52,7.75-2.24c-0.52,1.48-1.03,2.97-1.56,4.45c-0.15,0.4-0.43,1.2-0.57,1.6c1.2,0,2.12,1.06,2.04,2.24c0.42,0.14,1.27,0.42,1.7,0.56c2.78,0.89,5.5,1.98,8.13,3.25c0.76-0.15,2.27-0.46,3.03-0.62c0.85-0.58,1.77-0.78,2.78-0.58c3.31,0.26,6.48-1.06,9.3-2.65c0.95-0.74,1.82-0.69,2.61,0.13c0.27-1.58,0.55-3.16,0.84-4.74c-2.61-1.72-5.18-3.49-7.79-5.21l-0.6-0.39c-1.13-0.69-2.22-1.45-3.19-2.35c-0.19,0.48-0.57,1.45-0.76,1.93c-0.33,1.19-1.07,1.63-2.23,1.33l0.36,1.28c0.87,1.17-0.63,2.79-1.7,1.55c-2.62-1.55-5.39-2.82-7.95-4.47c-2.48-1.64-4.97-3.27-7.46-4.89c-2.52,0.64-4.88,1.82-6.94,3.4c-0.82,0.75-1.98,1.45-3.11,0.91c-0.15,1.61-0.31,3.23-0.47,4.84C122.14,51.535,124.08,52.215,126.03,51.835 M176.44,48.955l-0.4-1.49c-3.84,0.58-7.59,1.65-11.2,3.1c0.39,0.4,1.18,1.19,1.58,1.59c1.19,1.11,2.27,2.34,3.31,3.6c1.17,2.14,3.56,2.08,5.56,1.21c0.73-1.21,1.51-2.4,2.29-3.58c0.25-0.73,0.75-2.2,1-2.94C177.36,50.695,176.65,50.195,176.44,48.955 M320.03,350.335c-0.43-1.08-0.7-2.22-0.76-3.37c-0.96-1.18-2.23-2.02-3.43-2.9c-2.29-1.58-4.56-3.18-6.87-4.71c-6.17-1.83-12.18-4.11-18.19-6.42c-1.25-0.35-2.65-0.8-3.27-2.05c-1.73-2.42-2.9-5.17-3.72-8.02c-0.54-1.74-0.94-3.49-1.21-5.25l-0.97,0.03c-1.07,0.09-1.87-0.35-2.4-1.34c-0.73-0.86-1.54-1.63-2.44-2.3c-1.07-0.54-1.41-1.33-1.01-2.36c-2.81-0.28-5.71-0.37-8.45-0.97c-1.79-1.51-3.28-3.33-4.68-5.18l-0.42-0.53c-3.22-4.75-8.95-8.5-14.85-7.28c-1.59,0.11-3.24,0.24-4.77-0.29c-3.42-1.09-6.75-2.48-10.11-3.67c-0.86,0.83-1.69,1.68-2.5,2.55c-0.83,0.98-1.75,1.87-2.72,2.7c-0.92,1.06-1.58,2.3-2.16,3.57c-0.15,1.4-1.72,1.69-2.63,0.76c-0.61-0.01-1.82-0.05-2.43-0.07c-2.08,0.09-4.21-0.19-6.23-0.36l-1.3-0.14c-1.27-0.02-1.85-0.64-1.74-1.87c0.11-4.16,0.39-8.36-0.12-12.5c0.09-1.47-0.99-2.41-2.32-2.7c-1.12-0.2-2.19-0.59-3.16-1.18c-0.72-0.35-2.16-1.04-2.89-1.39c-0.38-0.2-1.15-0.59-1.53-0.78c0.19-2.24,0.58-6.7,0.77-8.94c0.17-1.35,0.45-2.68,0.71-4.01c-0.73-1.02-1.3-2.16-1.69-3.35c-1.41-0.13-2.82-0.25-4.22-0.37c-0.07,1.19-1.18,2.11-2.36,1.93c-0.49,1.16-0.96,2.32-1.44,3.49c-0.45,1.52-1.59,2.7-2.99,3.41l-1.12,0.7c-1.02,0.89-2.69,1.36-3.71,0.2l-0.8-0.63c-2.7-1.79-4.49-4.5-5.88-7.35l-0.46-0.82c-0.61-0.88-0.7-1.81-0.29-2.8c0.95-4.01,1.78-8.05,2.24-12.15c0.18-1.43,0.56-4.28,0.74-5.71c0.51-0.12,1.53-0.38,2.05-0.5c4.34-0.98,8.8-0.27,13.19,0.1c0.4-0.88,0.98-1.61,1.74-2.2l0.86-0.78c1.29-1.25,2.9-1.47,4.81-0.66c7.01,0.89,5.82,9.64,10.35,13.31c0.98,0.58,1.98,1.14,2.94,1.78c0.85-1.45,1.68-2.91,2.54-4.35c1.59,0.13,3.18,0.29,4.78,0.45c0.05-0.72,0.15-2.16,0.2-2.88c-0.68-0.6-1.31-1.25-1.89-1.93c-0.83,0.05-2.48,0.14-3.3,0.18c-1.15,0.15-1.85-0.36-2.12-1.52c-0.48-1.21-1.02-2.38-1.64-3.51c-0.69-0.84-0.86-1.76-0.52-2.75c0.45-1.72,0.81-3.47,1.39-5.14c1.92-3.29,5.11-5.51,7.9-8c3.73-2.83,5-7.82,4.94-12.3c-0.17-1.02,0.05-1.95,0.65-2.79l0.3-0.99c0.05-1.04,0.45-1.92,1.21-2.63l0.61-0.85c0.94-1.39,1.91-3.09,3.76-3.31c1.39-0.36,2.78-0.7,4.18-1.04c-0.01-1.86,0.26-3.64,0.82-5.35c1.01-1.68,1.96-3.64,3.86-4.47c3.43-1.92,5.49,2.56,7.97,4.13c0.34-0.5,1.02-1.48,1.37-1.97c0.63-1.18,1.73-1.96,2.9-2.55c3.53-1.93,5.72-5.48,8.29-8.44c-1.73-0.08-3.47-0.14-5.2-0.13l-0.69,0.42c-1.16,0.68-3.49,2.03-4.65,2.7c-0.18-2.73-0.37-5.46-0.56-8.19c-0.16-1.88-0.4-3.76-0.64-5.63c3.98-1.15,9.02,0.07,12.39-2.86c0.65-0.67,2.51-2.1,2.9-0.45c-0.49,1.17-1.38,1.52-2.67,1.07c-0.13,2.38-0.34,4.76-0.33,7.14c0.02,1.15,0.03,2.32-0.15,3.46c3.36,0.98,6.79,2.07,10.34,1.83c1.45-0.11,2.9-0.21,4.36-0.17c-0.22-1.62-0.53-3.23-0.93-4.81c-0.55-0.93-0.62-1.87-0.2-2.83l0.42-1.16c-0.98,0.56-1.86,0.39-2.64-0.5c-0.99-0.79-1.99-1.55-3.01-2.29c-0.17-1.03-0.34-2.06-0.5-3.09c-0.39-1.14,0.12-2.29,0.81-3.19c0.26-0.41,0.77-1.23,1.02-1.65c-1.23,0.19-1.89-0.34-1.99-1.58c-0.26-1.61-0.52-3.22-0.75-4.83c-2.32-1.69-4.63-3.4-6.9-5.15l-0.61-0.49c-3.13-2.6-3.67-6.84-5.2-10.39l-0.33-0.76c-0.79-1.49-1.58-2.99-2.33-4.5l-0.5-0.78c-0.93-0.52-1.46-1.3-1.59-2.33c-0.16-0.71-0.49-2.13-0.66-2.84c-1.89,1.68-3.82,3.34-5.9,4.78c-1.01,0.73-2.21,1.13-3.38,1.52c-1.21,0.35-1.87-0.14-1.99-1.5l-0.29-1.46c-0.38-1.91-0.65-3.83-0.82-5.76c-0.37-0.28-1.13-0.83-1.51-1.11c-1.97-1.44-3.84-2.99-5.77-4.47c-2.81-1.52-6.83-4.98-9.96-2.68c-0.82,0.99-1.68,1.98-2.81,2.63l-0.48,0.32c1.23,0.07,1.76,0.73,1.62,1.98c-0.02,0.59-0.05,1.77-0.06,2.36c0.13,1.22-0.43,2.32-1,3.34l-0.35,1.23c-0.16,1.45-0.48,4.34-0.64,5.78l1,1c1.06,0.86,1.74,2.08,2.08,3.4c0.2,0.55,0.61,1.65,0.82,2.19c1.07,0.76,1,2.28-0.25,2.81c-0.13,0.52-0.39,1.55-0.51,2.06c-0.09,1.05-0.61,1.82-1.56,2.3c-0.52,0.46-1.55,1.38-2.07,1.84c-0.63,0.99-1.46,1.32-2.5,0.98l0.86,0.89c0.84,0.72,1.08,1.61,0.72,2.68c-0.09,0.51-0.28,1.52-0.37,2.03c-0.33,1.91-0.66,3.83-0.99,5.75c-2.6-2.17-4.47-5.01-5.64-8.17c-0.67-1.56-1.46-3.12-2.87-4.13c-1.31-1.02-2.56-2.12-3.75-3.27c-0.49-0.36-1.47-1.1-1.96-1.46c-0.97-0.34-1.67-0.96-2.09-1.88l-0.54-0.47c-2.16-1.24-4.37-2.39-6.62-3.44c-0.56-0.03-1.68-0.09-2.24-0.11c-1.42,0.43-2.59-0.58-2.73-1.97c-0.45-1.25-1.33-2.26-2.19-3.23c-0.88-0.76-1.5-1.84-1.29-3.03c-0.02-1.82-0.05-5.44-0.07-7.25c-0.15-1.06,0.23-1.89,1.14-2.49l0.56-0.51c2.08-2.03,4.12-4.09,6.26-6.06l0.59-0.53c1.88-1.6,3.89-3.03,5.88-4.48c1.43,1.48,2.86,2.97,4.31,4.44l0.7,0.71c1.06-0.53,2.21-0.87,3.38-1.01l1.1-0.19c1.52-0.33,3.08-0.32,4.62-0.14c0.74,0.05,2.22,0.15,2.95,0.2l-0.47-0.85c-0.49-0.82-0.88-1.68-1.18-2.58c-0.52-1.42-1.36-2.96-2.95-3.34c-1-0.16-1.8-0.65-2.39-1.47c-0.5-0.38-1.5-1.13-2-1.5c-1.4-0.39-2.09-2.31-0.38-2.85l0.61-0.39c2.4-1.55,4.78-3.12,7.19-4.66c-0.09-4.37,0.03-8.75,0.43-13.1c2.47-0.39,4.87-0.71,7.4-0.95c0.1,0.38,0.31,1.15,0.41,1.53c1.18,3.42,0.01,6.92-1.29,10.1c1.73,0.26,3.47,0.5,5.22,0.74c0.88-1.42,1.76-2.84,2.67-4.25l0.23,0.87c0.51,1.48,1.12,2.93,1.68,4.4c0.69,1.19,0.26,2.77-0.95,3.44c-3.19,2.63-7,4.34-10.61,6.29c-0.06,1.3-0.11,2.59-0.15,3.89c0.44,0.16,1.32,0.48,1.77,0.64c1.19,0.31,1.61,1.06,1.26,2.23c0.65-0.32,1.95-0.96,2.6-1.28c0.96-0.65,2.12-0.99,3.28-0.73c0.8,0.05,2.39,0.16,3.19,0.22c1.14-0.03,1.85,0.52,2.14,1.66l0.45,1.03c0.65,1.35,1.3,2.72,1.68,4.19c1.31,0.26,2.63,0.5,3.96,0.72c1.19,0.04,2.25,0.59,3.16,1.33l0.74,0.45c0.98,0.37,1.64,1.04,1.98,2.03c0.37,0.03,1.09,0.08,1.45,0.1c0.5-0.24,1.49-0.72,1.98-0.96c2.45-2.4,3.93-6.04,3.27-9.47c-1.39-2.09-2.91-4.1-4.47-6.07c-0.79-0.84-1.51-1.74-2.15-2.69c-2.13-1.1-0.01-3.44,1.2-1.3c0.34,0.14,1.01,0.42,1.35,0.56c1.54,0.69,1.79,1.7,0.75,3.04l-0.41,0.53c0.32,0.09,0.97,0.28,1.29,0.38c1.87,0.56,3.75,1.08,5.64,1.59c0.72-2.99,2.35-6.14,1.49-9.25c-0.72-0.89-1.31-1.87-1.66-2.95c-0.62-1.77-2.39-2.69-4.08-3.14c-1.02-0.13-1.83-0.61-2.44-1.42l-0.71-0.38c-1.87-0.3-2.59-2.03-1.34-3.48c1.17-1.91-0.47-3.89-1.54-5.42c-1.67-1.75-3.41-3.44-5.21-5.05c-2.09-1.45-4.52-2.33-6.93-3.09c-1.18-0.17-2.16-0.89-2.66-1.97c-1.34-1.99-2.99-4.55-5.76-4.2c-2.88,0.07-5.78,0.27-8.64,0.4c-0.28-0.95-0.55-1.89-0.83-2.83c-0.39-1.31-0.78-2.61-1.16-3.91l-0.91-0.04c-2.99-0.08-6-0.26-8.97-0.41c-2-0.11-3.99-0.22-5.98-0.35c0.34,1.1-0.08,1.84-1.24,2.24c-1.83,0.94-4.07,2.22-3.44,4.67c0.01,1.39,0.02,4.16,0.02,5.55v1.65c1.32,0.73,2.41,1.8,3.37,2.95l0.52,0.57c1.78,1.89,3.5,3.83,5.19,5.8l0.59,0.65c1.18,0.65,1.15,2.14,0.08,2.89c-1.08,1.62-1.93,3.38-2.82,5.12c-0.47-1.42-0.98-2.82-1.55-4.2c-0.84-1.05-1.68-2.1-2.52-3.14c-0.92-0.63-1.84-1.25-2.78-1.84c-2.03-1.28-3.91-2.82-5.42-4.69c-2.34-3.72-1.01-8.14,0.93-11.74c0.48-1.26,1.53-2.16,2.48-3.08l0.52-0.86c0.54-1.3,1.06-2.61,1.71-3.87c-4.5-0.35-9.01-0.53-13.5-0.77c0.33,3.29,0.67,6.56,1.03,9.86c0.79,1.74,0.37,5.85-1.53,3.4c-0.52-1.8-0.85-3.64-1.27-5.46c-0.37-1.33-0.54-2.75-0.08-4.08l0.2-0.83c-0.66-0.63-1.99-1.91-2.66-2.55c-2.68,0.97-5.37,1.91-8.09,2.8l0.73,1.25c1.63,1.58-0.23,3.44-2.02,2.41l-1.4-0.29c0.14,0.55,0.43,1.66,0.58,2.21c-0.07,1.32,0.38,2.41,1.35,3.26c1.23,1.06,2.44,2.13,3.64,3.23c1.93,1.33,3.99,2.45,6.18,3.36c-0.18,1.2-0.54,3.58-0.71,4.77c-0.09,1.33-0.77,2.49-1.37,3.64l-0.21,0.75c-0.55,1.73,0.23,4.73-1.9,5.06c-1.77,0.26-3.56,0.39-5.34,0.51c-2.41,0.82-1.84-2.77,0.25-1.51c0.16-1.29,0.27-2.59,0.33-3.89c-0.13-1.01,0.12-1.93,0.74-2.73c0.44-0.86,1.32-2.56,1.76-3.41c-2.41-0.77-4.82-1.56-7.21-2.35c-1.07-2.78-2.1-5.6-3.54-8.21c-0.71-1.14-1.31-2.34-1.83-3.57l-0.57-0.93c-0.87-0.81-1.06-1.7-0.57-2.67c-0.56,0.26-1.67,0.78-2.23,1.04c-1.16,0.64-2.42,1.07-3.73,1.25c-1.56,0.32-3.11,0.71-4.59,1.3c-0.51,1.26-2.01,1.35-2.8,0.31c-2.05-1.15-4.24-2-6.39-2.95c-1.49-0.42-2.39-1.76-2.83-3.17c-0.23-0.56-0.7-1.7-0.93-2.26c-0.7,0.85-1.58,1.02-2.64,0.51c-1.57-0.41-3.16-0.66-4.78-0.73c-1.38,0-2.76-0.17-4.06-0.67c-0.98-0.31-2.96-0.92-3.95-1.23c-1.11,1.67-2.21,3.34-3.19,5.09c-0.72,1.52-1.22,3.19-1.16,4.88c0.21,1,0.05,1.94-0.47,2.82c-0.17,0.48-0.51,1.43-0.68,1.91c-0.27,0.49-0.81,1.46-1.08,1.94l1.45,0.17c1.57,0.01,2.94,0.84,4.11,1.83c0.55,0.42,1.66,1.25,2.22,1.67c1.45-0.74,2.97-1.35,4.45-2.03c0.44-0.29,1.34-0.87,1.78-1.16c1.21-1.49,3.39-1.11,3.28,1.04c0.46,1.97,0.93,3.95,1.64,5.86c0.63,1.68,1.31,3.35,1.98,5.02c-1.55-0.32-4.65-0.96-6.21-1.28l-0.78-0.17c-1.49-0.22-2.7-1.15-3.94-1.92c-0.65,0-1.94-0.01-2.59-0.02c-0.58,0.91-1.39,1.39-2.44,1.44l-1.09,0.13c-1.8,0.49-3.98,0.2-4.71-1.77c-0.67-1.09-1.33-2.17-1.98-3.26c-0.3,0.47-0.89,1.41-1.19,1.88c-0.39,0.38-1.19,1.15-1.59,1.53c-0.33-0.03-0.99-0.09-1.33-0.13c-2.13-0.22-4.28-0.26-6.43-0.32l-0.64,0.86c-0.67,1.22-1.97,1.87-3.33,1.92c-2.62,0.42-5.23,0.9-7.86,1.3c-1.76,0.58-3.34,0.42-4.74-0.49c-1.27-0.72-2.54-1.44-3.9-1.98c-2.91-0.98-5.88-1.77-8.84-2.56c-2.48-0.6-5.07-0.64-7.6-0.74c-1.11,0-3.32-0.01-4.43-0.01l-0.43-0.39c-1.47-1.27-3.03-2.67-4.99-3.07c-1.03,0-1.91-0.36-2.62-1.09l-0.8-0.55c-3.01-0.08-6.03-0.02-9.03,0.07c-1.48,0.5-2.85,1.26-4.15,2.11c-0.91,0.67-1.96,1.38-3.16,1.15l-1.17-0.04c0.47,1.06,0.17,1.87-0.9,2.45c-0.85,0.64-1.68,1.31-2.48,2.01c-2.47,2.23-4.9,4.51-7.38,6.72c-0.05,0.71-0.14,2.15-0.18,2.86c2.14,0.98,4.26,1.98,6.39,2.98c-0.13,0.68-0.38,2.04-0.5,2.72c-1.64,0.98-3.28,1.96-4.88,3l-0.68,0.47c-1.25,0.94-2.49,1.89-3.82,2.72c0.56,1.04,1.16,2.05,1.8,3.04c2.23,1.52,4.57,2.87,6.96,4.1c1.76-0.04,3.51-0.32,5.25-0.53c2.18-1.18,4.07,2.1,1.22,2.51c-1.65,0.48-3.32,0.83-4.99,1.19c-1.98,3.8-4.07,7.55-5.56,11.57c3.6,4.66,8.7,9.03,14.52,10.34c0.56,0.06,1.68,0.18,2.24,0.24c0.73,0.05,2.18,0.16,2.91,0.21l1.31,0.03c-1.57,2.04-3.23,4.03-4.96,5.95l-0.46,0.55c-0.79,1.03-1.75,1.94-2.9,2.57l-0.8,0.52c0.99-0.38,1.87-0.13,2.62,0.75l0.97,0.5c0.53,0.21,1.59,0.64,2.13,0.85l0.61,0.36c1.54-2.01,3.15-3.95,4.83-5.82l0.46-0.53c0.8-1.02,1.75-1.9,2.75-2.73l0.42-0.57c0.27-0.98,0.84-1.73,1.72-2.23c0.61-0.99,1.1-2.03,1.48-3.12c0.36-0.95,0.71-1.9,1.07-2.85c2.33,0.83,4.68,1.61,7.05,2.33c0.81-0.38,2.42-1.14,3.23-1.52c-0.14-0.51-0.41-1.52-0.55-2.03c-0.81-1.22,0.19-3.21,1.7-2.16c1.89,0.66,3.8,1.37,5.81,1.51c1.01-0.12,1.93,0.11,2.77,0.69c0.73,0.14,2.2,0.43,2.93,0.57c1.02-0.03,1.88,0.34,2.56,1.12c1.74,0.99,3.71,1.48,5.62,2.04c1.35,0.17,2.33,1.14,3.14,2.16c0.72,0.89,1.59,1.59,2.6,2.11c1.67,0.69,3.31,1.46,4.91,2.32l0.78,0.43c0.98,0.43,1.54,1.18,1.69,2.27l0.34,0.91c0.85,0.58,1.37,1.36,1.57,2.37l0.29,0.73c0.92,0.44,1.53,1.15,1.83,2.13l0.33,0.64c2.2,3.86,5.06,7.42,6.47,11.69c0.37,2.61,0.62,5.25,0.75,7.9c1.43,0.72,2.69,1.74,3.72,2.98c0.45,0.51,1.34,1.54,1.79,2.06c1.46,3.03,1.53,6.45,1.91,9.74l0.06,0.87c0.08,3.9-0.08,7.8-0.12,11.7c0.09,4.67-0.44,9.82,2.34,13.86c0.78,1.11,1.41,2.32,1.83,3.63l0.4,0.96c0.6,1.22,1.06,2.52,1.24,3.88c0.04,4.18,2.96,7.21,7.13,7.43c1.13,0.12,1.74,0.75,1.84,1.9c0.43,2.14,1.01,4.33,2.3,6.13c0.7,0.73,1.06,1.61,1.06,2.63c0.87,1.88,2.33,3.39,3.62,4.99c1.05,0.95,1.24,2.41,1.2,3.76c0,2.61,0.3,5.51,2.48,7.27c0.98,0.86,1.85,1.85,2.56,2.95c0.43,0.5,1.28,1.51,1.7,2.01c1.21,1.09,2.4,2.19,3.54,3.35c0.48,0.44,1.44,1.33,1.92,1.77c-0.01-1.13-0.07-2.25-0.19-3.37c-0.89-0.56-1.35-1.35-1.4-2.36c-0.25-1.72-0.61-3.42-0.93-5.11c-0.27-1.41-0.52-2.82-0.77-4.23c0.95,1.41,1.9,2.82,2.84,4.24c0.57,0.9,1.21,1.76,1.91,2.57c0.82,0.6,1.29,1.42,1.42,2.43l0.23,0.76c0.96,0.37,1.64,1.03,2.05,1.98l0.51,0.72c0.78,1.01,1.8,2.07,1.67,3.46c0.07,1.77,0.19,5.29,0.25,7.05c1.55,1.72,3.06,3.47,4.5,5.29l0.77-0.12c1.19-0.4,2.27,0.37,3.06,1.18c1.23,1.09,2.66,1.95,4.21,2.52c1.14,0.2,1.75,0.85,1.83,1.95c0.03,0.23,0.09,0.7,0.11,0.93c3.98,0.29,7.94,0.73,11.89,1.31c2.31,1.2,4.04,3.26,6.36,4.46c1.13,0.17,2.28,0.46,3.2,1.2c2.2,1.37,4.42,2.7,6.52,4.23c1.07,0.54,1.59,1.65,1.94,2.75l0.35,0.77c0.82,0.6,1.31,1.4,1.48,2.41c0.47,1.4,1.42,2.63,2.56,3.56c3.62,1.77,7.67,2.93,11.7,2.06c0.65,0.53,1.31,1.07,1.97,1.61c0.89,0.61,1.22,1.47,1,2.58c0.02,0.95,0.05,2.85,0.07,3.8c0.07,0.97,0.2,2.91,0.27,3.88l-0.47,0.43l-0.81,0.82c-1.12,1.29-2.29,2.53-3.47,3.76c-0.92,1.14-1.57,2.54-1.78,4c0.07,1.02-0.21,1.93-0.86,2.72c0.07,0.51,0.21,1.54,0.29,2.05c0.58,0.86,0.76,1.8,0.53,2.81c-0.06,0.58-0.19,1.75-0.25,2.33c0,1.35-0.42,2.65-0.99,3.87c-3.28,4.89,0.22,10.28,4.09,13.3c0.87,0.59,1.3,1.43,1.29,2.51l0.21,0.99c0.55,0.86,0.74,1.8,0.57,2.82c-0.08,1.57,0.61,3.05,1.41,4.37c0.74,1.11,1.33,2.32,1.76,3.59c0.22,0.46,0.66,1.37,0.88,1.83c1,1.31,1.99,2.63,2.89,4.02c0.6,0.88,1.28,1.69,2.05,2.43c2.23,1.97,4.52,3.84,6.84,5.71l0.82,0.58c0.26,0.18,0.79,0.54,1.05,0.72c-0.06,0.89-0.16,2.66-0.22,3.55c-0.12,2.02-0.36,6.06-0.48,8.08c-0.12,1.19-0.36,3.56-0.48,4.74c-0.21,1.66-0.35,3.34-0.42,5.02c0.07,1.17-0.16,2.33-0.58,3.43c-0.36,1.29-0.57,2.61-0.65,3.95c-0.52,7.56-0.05,15.36-2.29,22.68c-0.4,1.31-0.83,2.61-1.12,3.96c-0.08,1.01-0.49,1.86-1.25,2.54l-0.54,0.76c-0.29,6.19-0.28,12.4-0.39,18.62c0.01,2.93,0.4,5.85,0.73,8.77c0.19,1.04-0.13,1.9-0.98,2.61l-0.66,0.85c-0.53,1.09-1.32,1.45-2.38,1.07c0.65,2.08,1.4,4.14,1.89,6.28c0.64,3.28,0.71,6.58,0.98,9.93c0.15,2.62,0.29,5.26,0.4,7.91c0.89,0.75,1.78,1.51,2.67,2.28c2.52,2.16,4.89,4.47,7.35,6.71c3.25,2.62,7.76,0.42,11.53,0.34c-0.84-0.93-1.7-1.83-2.57-2.7c-0.99-0.88-1.81-1.92-2.51-3.02l-0.5-0.65c-0.87-0.56-1.4-1.34-1.58-2.34c-0.35-1.06-0.73-2.11-1.16-3.13c-0.54-1.31-1.08-2.61-1.61-3.91c0.82-0.91,1.65-1.8,2.46-2.71c2.79-3.28,5.16-7.31,5.64-11.61c-0.45-0.81-0.87-1.63-1.25-2.45c-0.59-1.18-1.23-2.32-1.84-3.47c1.52-1.89,3.13-3.7,4.71-5.54c1.06-1.29,1.89-2.75,2.6-4.25c1.08-2.38,2.16-4.75,3.27-7.11l0.33-0.74c0.52-1.36,1.29-2.76,2.75-3.27c0.51-0.26,1.53-0.79,2.04-1.05c2.54-1.33,5.07-2.68,7.52-4.15c0.69-2.65,0.41-5.4,0.36-8.09c2.11-1.02,4.38-1.89,6.13-3.5c0.87-0.96,1.81-1.84,2.83-2.64c1.96-1.62,2.4-4.29,2.74-6.66c0.04-1.07,0.56-1.83,1.56-2.27l0.61-0.45c0.57-0.84,1.34-1.37,2.34-1.57c1.67-1.77,2-4.3,2.48-6.58c0.51-2.74,0.96-5.53,1.55-8.23l0.14-0.59c0.38-1.78,2.18-2.65,3.49-3.67l0.84-0.63c1-0.87,2.12-1.64,3.42-1.98c1.65-0.61,3.34-1.18,4.9-2.02c0.92-1.1,1.88-2.18,2.89-3.2c1.86-1.98,3.01-4.53,3.57-7.16c0.23-1.3,0.65-2.56,1.14-3.78c1.35-4.8,0.75-9.98,2.15-14.75c0.97-1.95,2.17-3.77,3.39-5.58C318.94,360.125,320.97,355.295,320.03,350.335z M201.62,108.035c1.3-1.03,2.87,1.21,1.56,2.15C201.86,111.255,200.3,108.975,201.62,108.035z M160.23,91.855l-1.2,0.51c-2.9,2.15-6.3,3.57-9.96,3.77l0.76-0.25c-2.64,0.37-5.3,0.58-7.97,0.64c-2.68-0.07-1.45-5.11,1.01-3.92c2.06-0.02,4.12-0.03,6.19-0.08c3.98-1.16,8.33-2.5,12.34-0.78L160.23,91.855 M220.38,271.435c1.05-0.17,1.87,0.23,2.46,1.2l0.57,0.55c3.09,2.48,6.34,4.75,9.63,6.97c3.54,0.04,7-0.77,10.46-1.43c0-1.01,0.01-3.04,0.01-4.06c-0.29,0.02-0.89,0.05-1.18,0.07c-1.05,0.11-1.86-0.32-2.43-1.27c-0.5-0.45-1.51-1.37-2.02-1.82c-1.31-0.98-2.58-2.01-3.76-3.12c-0.88-0.78-1.76-1.53-2.66-2.26l-0.34,1.07c-0.08,2.57-2.4,2.54-3.98,1.18l-0.85-0.41c-0.98-0.33-1.68-0.96-2.1-1.91c-0.72-0.78-1.55-1.41-2.49-1.9c-2.11-1-4.26-1.93-6.44-2.74c-1.16-0.25-2.31-0.19-3.43,0.16c-2.3,0.78-4.55,1.68-6.82,2.49c0.46,1.39,0.93,2.79,1.4,4.18c3.95-0.84,8.1-1.22,11.75,0.89c1.19,0.34,1.6,1.09,1.23,2.26L220.38,271.435z'/></svg>"
	          ], [
	            "sub_saharan_africa",
	            "Sub-Saharan Africa",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='sub_saharan_africa' d='M488.08,345.035c5.11-10.88,14.33-19.02,20.83-28.98c3.28-6.75,5.42-14.26,5.12-21.82c-4.56,1.59-9.14,3.19-13.67,4.84c-1.21,0.87-2.79,0.27-3.09-1.19l-0.48-0.92c-1.47-2.71-2.98-5.4-4.4-8.13c-4.72-7.55-8.46-15.7-11.36-24.12c-6.5-0.32-12.99-1.01-19.5-0.67c-3.83,1.29-6.55,4.65-10.11,6.5c-5.98-1.5-10.87-5.94-16.83-7.39c-11.42-0.79-19.79,8.42-28.23,14.57c-6.29-6.06-12.33-12.36-18.54-18.5c-1.77-1.59-3.57-3.15-5.43-4.62c-4.34-2.86-9.65-3.57-14.65-4.58c-5.4,4.16-7.36,11.61-9.44,17.91c0.35,8.3,0.43,16.66-1.15,24.89c1.67,0.73,3.35,1.49,5.09,2.06c1.04,0.24,2.42,0.78,2.33,2.1c0.89,6.5,1.7,13.87,7.64,17.84c2.9,4.07,9.61,6.35,13.61,2.58c0.89-1.13,2.41-1.25,3.58-0.46c5.3,2.98,10.55-1.13,15.91-1.18c4.74,1.87,8.9,4.86,13.16,7.6c-0.62,4.54-1.44,9.09-1.16,13.7c2.11,5.98,8.03,10.05,9.24,16.42c2.56,8.84-1.93,17.43-2.92,26.09c-0.65,8.14,3.8,15.16,6.28,22.58c0.52,1.8,0.77,3.67,0.76,5.63c-0.33,7.45,3.61,13.84,5.72,20.7c0.43,4.23,3.12,7.44,5.54,10.67c5.88-2.56,13.43-1.47,18.23-6c0.35-0.95,0.99-1.63,1.92-2.04c5.03-4.33,8.65-10.45,10.18-16.92c0.91-3.6,3.23-6.52,5.33-9.49c3.47-5.2-0.62-11.99,2.91-17.22c2.82-4.1,7.5-6.21,11.65-8.73C490.87,367.495,486.8,356.435,488.08,345.035 M511.44,359.355c-1.12,0.4-2.23,0.81-3.34,1.22c2,8.17-7.02,12.62-10.6,18.7c-1.28,6.86-2.24,13.9-2.13,20.91c0.09,1.22,0.14,2.44,0.17,3.67c-0.27,1.6,0.69,3.59,2.54,3.48c0.97-0.01,1.95,0.05,2.93,0.16c1.47,0.12,2.95,0.22,4.44,0.31c2.46-9.41,4.82-18.85,7.04-28.32c1.41-5.41-1.91-11.14,0.56-16.4C512.51,361.835,511.97,360.595,511.44,359.355z'/></svg>"
	          ], [
	            "east_asia_pacific",
	            "East Asia & Pacific",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='east_asia_pacific' d='M673.78,359.585c1.46,1.17,2.93,2.37,4.62,3.23c2.09-2.16,4.08-4.44,5.93-6.82c-8.72,2.34-16.34-5.53-25.18-1.45c-1.03,0.4-1.94,0.24-2.73-0.46c-4.84-4.17-10.66-6.75-17.2-6.55c-1.27-0.05-1.79-0.68-1.57-1.9c0.17-1.64,0.37-3.28,0.48-4.91c0.03-1.18,0.1-2.34,0.2-3.5c-1.12-1.44-2.53-2.6-3.85-3.81c-1.09-6.14-1.85-12.37-3.76-18.33c-1.72-3.65-5.16-6.21-6.8-9.9c-0.54-3.21,0.4-6.45,0.62-9.65c4.63,2.68,7.54,7.26,10.73,11.39c3.93-2.52,7.66-5.55,10.13-9.58c0.92-6.9-2.27-13.36-5.55-19.17c-1.79-2.71-0.06-5.83,0.57-8.6c1.45,0,2.91,0,4.37,0.01c-1.13,2.28-2.32,4.52-3.45,6.79c1.75,1.14,3.52,2.28,5.3,3.41c2.72-4.47,3.4-10.99,8.99-12.92c5.66-1.83,11.2-5.22,12.78-11.45c0.19-1.01,0.74-1.76,1.65-2.26c2.63-2.21,3.59-5.83,3.45-9.15c-0.05-1-0.05-1.99,0.01-2.97c0.36-5.74-2.52-10.9-4.7-16.01c2.42-2.33,4.68-4.82,6.89-7.34c-1.89-0.71-3.8-1.39-5.69-2.07c2.26-1.55,4.64-2.92,6.99-4.34c2.78,5.42,4.8,11.15,6.72,16.92c2.27-1.04,4.51-2.18,6.7-3.41c-1.55-7.61,0.35-15.09,1.16-22.61c0.2-3.31,0.58-6.58,1.13-9.83c1.93-2.68,4.22-5.09,6.48-7.51c-5.43-1.11-9.5-5.07-13.27-8.84c-3.16-3.51-3.2-8.54-4.13-12.93c-2.61-0.44-5.08-0.84-7.64-1.26c-2.02,4.14-2.97,9.41-6.5,12.45c-7.78,0.26-15.41,1.65-23.11,2.61c-7.94-2.57-15.44-6.53-23.21-9.66c-0.96,2.69-1.6,5.48-2.53,8.19c-5.15-1.23-10.96-3.49-16.05-0.7c-6.92,3.8-12.21,9.89-17.81,15.33c-4.57,3.74-2.78,10.8-7.27,14.61c-2.84,3.03-7.1,4.04-10.66,5.8c0.78,2.66,1.56,5.35,2.66,7.9c3.58,6.07,10.11,11.34,9.06,19.04c1.46,0.12,2.04,0.91,1.74,2.36c1.68,0.49,3.34,1.04,5,1.62c1.47,0.32,2.05,1.18,1.75,2.57c3.69,1.22,7.36,2.51,11.14,3.41c0.09-1.88,2.77-2.14,3.26-0.34c5.16-1.63,10.4-3.01,15.74-3.96c-0.39,10.36-6.57,18.96-10.55,28.14c-0.57,3.1,1.76,5.75,3.84,7.74c1.24,0.74,1.48,2.33,0.57,3.44c-0.34,0.73-1.04,2.2-1.38,2.93c2.27-0.22,4.55-0.47,6.83-0.72c1.46,4.8,3.78,9.65,2.78,14.77c-1.06,6.75,2.27,12.96,4.23,19.18c-3.76-1.78-7.58-3.45-11.61-4.52c0.85,3.8,1.4,7.78,3.87,10.94c6.44,9.51,11.34,20.71,21.1,27.36c1.07,0.44,1.51,1.21,1.33,2.3c-0.06,0.47-0.17,1.4-0.23,1.87c1.86-0.17,3.72-0.34,5.6-0.5c1.8-0.41,3.47,0.45,5.02,1.27c6.09,1.79,12.33,3.25,18.58,4.49C669.74,362.315,671.77,360.595,673.78,359.585 M691.93,240.635c1.09-0.46,2.19-0.91,3.31-1.35c0.229-1.49,0.479-2.96,0.74-4.44c0.14-1.11,0.81-1.68,2.01-1.69c6.03-1.36,11.64-4.12,17.6-5.75c1.32-5.8,3.39-11.49,3.68-17.47c-0.03-1,0.07-1.98,0.3-2.95c0.21-1.17,0.43-2.33,0.66-3.49c3.38-2.03,5.46-5.39,6.98-8.93c-2.29-1.45-4.49-3.07-6.96-4.2c-0.58-0.22-1.74-0.65-2.32-0.87c-2.2,5.1-7.26,10.67-3.86,16.32c0.82,1.06,1.22,2.59,0.17,3.67c-2.01,4.77-6.88,6.98-10.1,10.75c-4.21,4.14-9.85,6.39-14.81,9.44C690.25,233.325,691.12,236.955,691.93,240.635 M672.63,254.455c-4.63,3.53-5.19,9.39-3.15,14.67c2.53-0.86,3.6-3.21,3.04-5.76c-0.23-1-0.06-1.93,0.5-2.79C673.27,258.525,672.84,256.475,672.63,254.455 M684.31,305.865c-1.21-2.6-4.32-3.46-6.51-4.89c-0.41-1.04-0.82-2.07-1.22-3.1c0.61,0.07,1.84,0.22,2.45,0.29c1.17,0.01,1.81,0.6,1.91,1.77l0.11,0.62c-0.18-6.63-5.98-11.05-6.71-17.51c-0.29-0.97-0.33-1.95-0.1-2.94c0.12-1.02,0.37-3.08,0.49-4.11c-2.31,0.86-4.56,1.83-6.77,2.89c1.53-0.78,1.98,1.32,1.05,2.18c-2.58,4.38,0.16,9.5,1.25,13.88c1.79,5.69,2.71,11.61,3.67,17.47c2.35,1.86,5.14,3.06,7.74,4.54C683.42,313.545,685.43,309.925,684.31,305.865 M667.62,296.795c-3.66,2.94-7.17,6.78-7.05,11.79c1.01-0.04,3.03-0.11,4.04-0.14C665.91,304.645,667.07,300.785,667.62,296.795 M770.41,322.895c-0.63,0.21-1.9,0.62-2.53,0.82c2.58,3.25,5.3,6.39,7.44,9.97c1.87-3,5.92-6.7,2.96-10.29c-0.68-0.78-0.98-1.67-0.89-2.69c-0.27-2.58-1.59-4.87-2.62-7.19c-2.53,0.54-5.05,1.13-7.6,1.51c0.02-1.65,0.04-3.31,0.02-4.95c0.14-0.55,0.42-1.65,0.56-2.2c-0.81-0.11-2.43-0.32-3.24-0.43c-0.05,4.21-0.07,8.42-0.08,12.64c2.34,0.16,4.68,0.02,7.03,0.17C773.84,320.375,771.94,323.065,770.41,322.895 M651.81,319.775c-2.78,3-6.91,4.45-9.38,7.72c-1.84,2.22,0.1,4.87,0.92,7.09c2.32,4.22,4.22,11.11,10.73,9.48c4.49,1.37,7.38-2.16,10.35-4.63c0.79,3.51,1.47,7.03,2.24,10.56c2.42-1.41,5.85-2.03,7.44-4.36c-0.31-8.07,5.5-14.08,7.37-21.54c-3.15,0.98-6.43,1.8-9.61,2.57c-1.14-0.18-3.43-0.54-4.58-0.72c-0.46-0.16-1.37-0.48-1.83-0.65c0.87-3.49,1.63-7.03,1.88-10.63c-1.52-1.11-4.58-3.35-6.1-4.47C657.38,312.615,655.24,316.865,651.81,319.775 M716.22,314.735c-0.7,2.41-1.53,4.75-2.14,7.19c2.21-0.34,4.45-0.56,6.7-0.62c2.33-0.21,4.66-0.43,6.99-0.69c0.86-0.11,1.75-0.23,2.64-0.35c2.13,3.19,4.69,6.06,7.35,8.83c0.61-5.42-2.51-10.07-5.11-14.5C727.25,315.965,721.66,315.605,716.22,314.735 M745.38,325.445c0.99-0.68,1.98-1.36,2.99-2.03c0.01-0.85,0.05-2.55,0.07-3.39c-1.24,0.36-2.47,0.74-3.68,1.14c-0.55,0.02-1.66,0.04-2.21,0.06c0.06,0.83,0.18,2.51,0.24,3.34C743.76,324.505,744.63,324.795,745.38,325.445 M754.89,329.085c1.41-1.37,2.81-2.76,4.18-4.18c-1.57-0.18-3.14-0.35-4.69-0.51C754.54,325.955,754.71,327.515,754.89,329.085 M784,335.575c0.54,0.85,0.73,1.78,0.55,2.79c0.04,4.68,0.6,11.77,6.25,13.2c1.24,0.42,2.42,1.11,3.15,2.25l0.54,0.66c-0.1-4.59-3.38-7.58-5.36-11.28c-1.65-5.98,0.69-13.84-5.5-17.62C783.7,328.915,783.47,332.245,784,335.575 M738.22,351.265c2.28-1.87,2.94-4.92,3.98-7.54c-3.94,1.24-7.93,2.31-12,3c-2.32-3.02-4.71-6.29-8.55-7.44c-4.96-2.08-10.62-5.53-16.02-2.74c-3.32-3.38-7.52-5.99-12.54-5.71c0.63,4.98,1.42,10.02,3.73,14.54l1.31-0.02c1.86-0.06,3.72,0.2,5.58,0.77c1.35,0.38,2.71,0.78,4.08,1.2c0.16,3.48,0.17,6.98-0.01,10.46c5.79,1.61,12.23,3.66,17.67-0.04c3.17,3.67,7.41,5.98,12.14,7.12c0.23-1.55,0.71-4.65,0.94-6.19c-2.38-1.46-4.77-2.91-7.15-4.37c0.24-0.97,0.5-1.92,0.77-2.88C734.16,351.565,736.26,351.985,738.22,351.265 M747.51,336.595c1.25-0.08,2.51-0.15,3.77-0.21c0.43-1.03,0.86-2.05,1.31-3.06c-1.69-0.35-3.38-0.7-5.05-1.06C747.53,333.705,747.52,335.145,747.51,336.595 M740.72,357.255c3.73,5.23,7.87,12.81,15.28,12.14c-0.18-0.56-0.54-1.67-0.72-2.22C755.01,360.005,746.17,358.795,740.72,357.255 M732.82,389.945c-3.18-4.36-3.65-9.92-6.24-14.55c-2.65-4.47-3.5-10.4-8.64-12.82c-1.37,5.26-2.32,10.61-3.11,16c0.24,1.43-1.62,2.05-2.38,0.88c-3.72-2.13-5.71-5.84-5.91-10.22c-0.44-1.1-0.59-2.38,0.05-3.43l0.46-1.11c-3.66-0.73-7.43-1.31-11.17-0.83c-4.22,1.41-5.51,6.3-7.89,9.56c-1.01-1.29-2-2.6-2.96-3.91c-4.9,4.1-13.1,6.94-12.4,14.59c-0.05,1.28-0.33,2.89-1.77,3.29c-5.3,2.55-10.89,4.52-15.89,7.66c-1.5,0.99-2.58,2.57-2.64,4.42c-1.65,13.09,5.13,25.3,5.65,38.3c1.33-0.09,2.68-0.18,4.03-0.28c0.97-0.11,1.96-0.14,2.96-0.08c9.6-0.06,17.45-6.79,26.521-8.85c4.88-1.58,8,2.36,10.39,5.67c2.44,3.52,6.3,5.52,9.75,7.89c1.16,3,1.44,6.91,4.12,9.14c3.58,0.61,7.22-0.03,10.8-0.46c3.5-0.72,8.19-0.65,10.47-4.02c0.55-1.06,1.34-1.39,2.38-0.98c-0.11-7.39,2.05-14.43,5.78-20.78c0.08-0.56,0.23-1.68,0.31-2.24c0.56-5.14-0.03-10.4-0.92-15.45C742.11,400.645,735.92,396.295,732.82,389.945 M774.13,387.045c-2.23-1.19-4.52-2.24-6.85-3.19c0.84,6.64,1.34,13.59,4.35,19.7C777.2,399.325,771.4,392.495,774.13,387.045 M794.97,401.925c-2.66,2.09,1.33,2.19,2.9,2.5c0.57,0.02,1.71,0.05,2.27,0.07c2.72-0.38,3.11-4.32,4.28-6.4c-2.6,0.35-5.12,0.95-7.56,1.79C796.5,400.815,795.87,401.495,794.97,401.925 M813.64,398.695c-2.08,2.31-3.9,4.88-5.24,7.7c-1.62,2.94,1.29,5.67,2.64,8.08c1.5-3.68,3.25-7.48,3.15-11.53C813.98,401.525,813.75,400.115,813.64,398.695 M788.49,435.135c1.1,4.84,3.229,9.63,2.34,14.71c-1.56,4.38-5.11,7.65-7.52,11.56c-2.55,4.47-7.13,7.01-11.11,9.98c0.12,4.16,2.72,9.01,7.91,6.7c3.73,0.13,5.64-3.56,5.23-6.87c-0.18-1.11,0.19-1.94,1.1-2.52c7.36-4.71,12.74-12.19,14.63-20.71c0.09-0.96,0.33-1.89,0.71-2.76C795.11,445.265,792.08,439.535,788.49,435.135 M723.63,455.055c1,4.84,2.04,9.71,3.71,14.37c5.46-2.19,8.23-7.54,7.8-13.37C731.27,456.055,727.42,455.755,723.63,455.055z'/></svg>"
	          ], [
	            "south_asia",
	            "South Asia",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='south_asia' d='M601.63,246.995c-1.07,0.51-2.16,0.62-3.26,0.34c-3.78-0.9-7.45-2.19-11.14-3.41c-1.28-0.34-1.86-1.2-1.75-2.57c-1.66-0.58-3.32-1.13-5-1.62c-1.29-0.26-1.88-1.04-1.74-2.36c1.05-7.7-5.48-12.97-9.06-19.04c-3.8,0.06-7.53,0.15-11.31,0.2c-0.73-0.14-2.2-0.42-2.94-0.56c-6.29,1.78-12.33,4.28-18.51,6.36c-3.12,8.02,0.28,16.11,2.42,23.86c2.17,4.11-1.04,7.46-2.88,10.72c3.76,0.44,7.52,0.82,11.31,1.26c3.44,5.13,8.18,9.16,12.36,13.65c2.5,5.67,2.57,12.13,5.07,17.83c2.35,5.49,3.82,11.29,5.51,17.01c1.95-0.71,3.89-1.43,5.83-2.16c0.76,2.94,1.48,5.9,2.28,8.86c1.94-0.91,3.93-1.79,5.63-3.12c0.2-5.39-4.38-9.48-4.46-14.8c-0.021-4.48-1.46-9.7,2.32-13.11c4.66-5.32,9.59-10.53,15.38-14.64c3.07,0.03,6.11,0.85,9.13,1.48c3.98-9.18,10.16-17.78,10.55-28.14C612.03,243.985,606.79,245.365,601.63,246.99 M591.761,303.9c0,6.72,0.83,13.56-0.69,20.19c1.29,0.4,2.56,0.81,3.87,1.2c3.3-6.65,2.56-14.28,0.82-21.29C594.421,303.96,593.091,303.93,591.761,303.9z'/></svg>"
	          ], [
	            "middle_east_north_africa",
	            "Middle East & North Africa",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='middle_east_north_africa' d='M539.34,248.195c-2.14-7.75-5.54-15.84-2.42-23.86c-2.55-2.9-4.72-6.23-7.82-8.55c-3.76,0.07-7.32,1.15-10.88,2.17c-3.09-0.28-5.96-1.47-8.81-2.57c-3.41-1.2-6.9-2.16-10.37-3.16c-0.29,1.63-0.88,4.87-1.17,6.5c-5.93,0.71-11.98,0.86-17.75,2.52c-2.52,0.6-2.94,3.38-3.46,5.49c-0.93,3.22-1.05,7.96-4.96,9.05c-8.68,2.12-17.59-0.32-25.24-4.46c-2.21,2.25-4.4,4.52-6.57,6.8c-4.71-2.71-9.39-5.47-14.02-8.3c-1.19-3.9-1.29-8.46-3.94-11.78c-3.08-2.15-7.27-0.19-10.57-0.3c-8.18,0.62-16.06,2.8-24.04,4.54c-1.61,0.37-3.24,0.7-4.85,1.04c-3.75,5.03-8.11,9.99-8.7,16.54c-0.25,3.94-4.05,5.46-7.03,7.06c-0.11,0.71-0.32,2.14-0.42,2.85c0.35,0.06,1.06,0.18,1.42,0.25c5,1.01,10.31,1.72,14.65,4.58c1.96,1.35,3.73,2.96,5.43,4.62c6.21,6.14,12.25,12.44,18.54,18.5c8.44-6.15,16.81-15.36,28.23-14.57c5.96,1.45,10.85,5.89,16.83,7.39c3.56-1.85,6.28-5.21,10.11-6.5c6.51-0.34,13,0.35,19.5,0.67c-1.49-4.16-3.04-8.29-4.39-12.49c7.47,11.08,12.24,23.78,15.75,36.61c1.42,2.73,2.93,5.42,4.4,8.13c9.35-5.37,19.76-9.02,27.99-16.19c3.55-4.15,6.63-8.67,9.82-13.09c-2.02-3.28-3.91-6.63-5.5-10.14c2.46,0.42,4.91,0.88,7.36,1.37C538.3,255.655,541.51,252.305,539.34,248.195z M514.19,255.825c-2.91-3.79-4.66-8.33-5.75-12.95c4.8,4.17,9.01,9.01,12.95,14C519.02,256.865,515.88,258.145,514.19,255.825z'/></svg>"
	          ], [
	            "europe_central_asia",
	            "Europe & Central Asia",
	            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='europe_central_asia' d='M527.62,81.815c-1.81-4.6-3.69-9.97-0.39-14.54c5.21-8.59,15.11-11.99,24.07-15.18c3.03-0.96,3.76-4.4,5-6.91c-7.53-0.09-14.66,2.35-21.78,4.44c-3.29,1.39-7.55,2.13-9.06,5.83c-4.25,6.76-8.13,13.75-12.72,20.29C515.48,81.435,521.66,83.515,527.62,81.815 M341.44,55.475c2.64-5.77,2.33-12.32,3.2-18.47c2.12-5.6,7.66-8.51,12.64-11.14c-2.48-4.16-7.41-4.5-11.73-5.39c-1.93-4.7-5.32-9.04-10.31-10.7c-6.87-3.27-14.33,0.62-21.45-1.67c-0.25,1.23-0.74,3.68-0.99,4.91c-9.18-5.71-20.98-4.25-30.18,0.55c-2.57,2.44-4.15,5.811-7.13,7.86c-0.84,0.83-1.73,0.88-2.67,0.14l-1-0.64c0.11,2.5,0.33,7.51,0.44,10.01c2.76,5.82,9.96,5.83,15.44,6.91c1.62,8.65,2.63,17.41,3.47,26.16c-0.36,4.92-3.41,9.54-2.26,14.57c0.59,0.83,0.8,1.76,0.63,2.77c-1.49,7.83,3.9,13.85,10.46,16.91c2.5-5.38,5.09-10.73,7.75-16.03c6.5-1.83,12.02-5.88,18.47-7.86c3.54-1.57,8.57-2.06,9.74-6.47c1.76-4-1.85-7.38-4.19-10.16C334.89,56.945,339.65,58.825,341.44,55.475 M782.56,84.155c-0.47,1.66-0.93,3.31-1.37,4.97c-7.42-4.41-16.63-3.57-24.01-8.03c-3.6-1.87-8.34-4.57-11.86-1.13c-0.67,1.11-2.27,1.19-2.73-0.14c-1.93-2.52-4.26-4.72-6.5-6.93c-2.9-1.18-6.16-0.08-9.1-1.11c-2.08-0.67-4.09-1.6-6.23-2.06c-1.22-0.07-2.43-0.15-3.63-0.26c-3.82-0.47-6.46,2.71-8.73,5.25c-0.65,0.86-1.51,1.19-2.58,0.99c-5.28-0.07-10.45,1.31-15.52,2.62c-1.25-3.96-2.14-8.02-3.06-12.05c-3.4-0.93-6.9-1.53-10.4-1.78c-1.15,1.67-2.18,3.45-3.67,4.83c-7.39-2.12-14.71-4.59-22.08-6.8c4.31-4.31,3.24-10.23,1.69-15.56c-4.26-1.08-9.13-0.43-12.88-3.02c-2.73-1.15-5.55-4.33-8.78-2.89c-4.63,1.89-7.72,6.08-11.67,8.99c-0.94,1.22-2.53,0.86-3.63,0.13c-3.57-2.12-7.39,0.33-10.92,1.18c-3.15,1.06-6.58,1.43-9.43,3.17c-1.81,2.24-2.25,5.26-3.29,7.9c-3.35,0.92-6.69,1.79-9.97,2.88c-1.07,0.46-2.38,0.73-3.38-0.02c0.26,1.85,0.56,3.69,0.9,5.52c-1.38,0.87-2.76,1.75-4.07,2.7c-1.01,1.03-2.92,1.68-3.77,0.1c-1.22-1.48-2.42-2.97-3.62-4.46c-1.52,1.45-3,2.93-4.49,4.39c-0.29-1.5-0.56-3-0.83-4.5l-0.86,0.32c-0.58,0.08-1.73,0.23-2.3,0.31c-0.68-0.02-2.04-0.06-2.72-0.08c-1,0.05-1.99,0.06-2.97,0.03c-6.52,2.06-5,11.43-6.64,16.52c-2.74,0.12-8.21,0.37-10.95,0.49c-0.51,0.22-1.51,0.66-2.02,0.88c-6.07,4.03-13.7,2.67-20.54,3.83c-3.68,0.95-6.63,3.67-8.44,6.92c-0.37,1.29-2.96,3.74-3.3,1.27c-0.13-2.59,0.18-5.17,0.1-7.75c-1.56,0.02-3.09,0.22-4.62,0.42c-0.48,3.08-0.89,6.17-1.35,9.26c-0.96-0.03-1.91-0.06-2.85-0.08l-0.69-0.01c-0.12-0.56-0.35-1.69-0.47-2.25c0.55-4.48-4.63-5.86-7.42-8.12c-4.37-3.11-10.29-2.92-14.51-6.16c-1.89-3-4.35-6.24-8.3-5.63c-1.74,0.02-3.44,0.04-5.11,0.04c-3.89,0.05-7.2,2.34-10.38,4.3c-6.12,4.05-13.19,7.44-17,14.05c-3.09,3.72-4.11,8.54-6.6,12.59c-3.87,4.99-9.23,8.49-14.39,11.98c0.13,0.45,0.39,1.33,0.52,1.77c0.49,1.64,0.45,3.33-0.13,5.08c-0.65,4.67,0.22,9.36,1.08,13.95c3.49-1.03,7.01-2.11,10.44-3.38c-5.19,4.58-4.51,11.72-4.79,18.07c-5.61,0.48-9.03,4.69-12.28,8.67c-2.82-4.04-4.19-8.88-6.79-13.04c-3.39-4.97-2.78-11.3-4.86-16.78c-3.85,0.59-7.93,2.12-9.09,6.15c-1.5,5.26-5.89,8.7-8.52,13.26c-0.29,3.7-1.17,7.83,0.59,11.34c2.66,2.02,5.88,0.05,8.62-0.7c-1.86-2.64,2.4-3.49,1.38-0.3c-0.23,2.29-0.66,4.54-1.09,6.8c1.13,0.05,2.27,0.09,3.41,0.12c0.99-0.04,1.96,0.08,2.92,0.36c0.53,0.12,1.58,0.37,2.1,0.5c0.13,0.61,0.38,1.83,0.51,2.44c-1.7,0.42-5.09,1.26-6.79,1.68c2.46,4.73,5.97,8.77,9.08,13.07c-1.47,1.59-2.98,3.15-4.37,4.82c-0.56,1.31-2.18,1.05-2.73-0.11c-3.2-4.36-8.71-1.13-12.91-0.28l0.48,1.12c0.09,0.57,0.27,1.71,0.36,2.28c-0.18,3.27-0.21,6.55-0.1,9.82c-0.01,0.57-0.02,1.72-0.03,2.29c-1.01,5.3,2.93,9.34,6.84,12.16c1.61-0.34,3.24-0.67,4.85-1.04c3.93-1.6,8.15-3.58,10.14-7.58c3.83-9.05,11.45-15.77,20.29-19.76c4.51,6.36,11.12,11,14.27,18.37c-2.63,1.19-5.01,2.52-7.52,3.83c1.89,1.64,3.78,3.28,5.67,4.93c3.3-4.19,6.63-8.35,9.97-12.5c3.01,4.11,6.6,7.86,10.98,10.53c0.91-4.43,1.8-8.87,2.67-13.31c1.78,4.45,2.93,9.16,5.18,13.4c2.92,2.5,7.44,1.3,10.68,3.28c1.37,1.03,2.51,2.34,3.73,3.57c1.09-0.1,2.18-0.21,3.28-0.31c0.52-2.11,0.94-4.89,3.46-5.49c5.77-1.66,11.82-1.81,17.75-2.52c0.29-1.63,0.88-4.87,1.17-6.5c3.47,1,6.96,1.96,10.37,3.16c0.64-2.84,2.22-5.83,1.09-8.77c-1.88-5.67-4.27-11.17-5.61-17.01c3.46-1.03,6.89-2.32,10.5-2.77c2.05-0.38,0.94,2.57-0.5,2.53c-1.54,0.77-3.07,1.55-4.6,2.33c3.51,8.47,6.25,17.23,7.93,26.26c3.56-1.02,7.12-2.1,10.88-2.17c3.1,2.32,5.27,5.65,7.82,8.55c6.18-2.08,12.22-4.58,18.51-6.36c0.76-1.34,2.85-1.13,2.94,0.56c3.78-0.05,7.51-0.14,11.31-0.2c-1.1-2.55-1.88-5.24-2.66-7.9c3.56-1.76,7.82-2.77,10.66-5.8c4.49-3.81,2.7-10.87,7.27-14.61c5.6-5.44,10.89-11.53,17.81-15.33c5.09-2.79,10.9-0.53,16.05,0.7c0.93-2.71,1.57-5.5,2.53-8.19c7.77,3.13,15.27,7.09,23.21,9.66c7.7-0.96,15.33-2.35,23.11-2.61c3.53-3.04,4.48-8.31,6.5-12.45c2.56,0.42,5.03,0.82,7.64,1.26c0.93,4.39,0.97,9.42,4.13,12.93c3.77,3.77,7.84,7.73,13.27,8.84c-2.26,2.42-4.55,4.83-6.48,7.51c-0.55,3.25-0.93,6.52-1.13,9.83c3.57-2.16,7.68-3,11.79-3.44c2.33-3.44,4.73-6.82,7.14-10.21c3.52-4.73,3.61-10.92,5-16.44c0.34-0.46,1.02-1.38,1.36-1.84c0.11,0.38,0.34,1.14,0.46,1.52c0.39,5.9,0.36,11.82,0.59,17.73c0.58,0.22,1.74,0.65,2.32,0.87c2.51-2.36,2.13-6.16,2.76-9.21c1.33-7.43-0.54-15.01-1.69-22.31c-5.5-1.67-11.51-1.6-16.57-4.55c5.84-5.93,10.54-13.37,17.71-17.81c0.88-0.58,1.81-0.55,2.77,0.07c7.14,1.65,14.66,1.2,21.97,1.84c1.84-4.42,4.28-8.54,7.23-12.31c0.42-1.44,2.35-1.05,2.44,0.37c0.84,2.23,2.18,4.23,3.7,6.07c-4.17,5.31-8.48,10.49-13.43,15.09c0.47,7.37,1.65,14.67,3.36,21.85c0.76,0.01,2.28,0.04,3.04,0.05c5.11-6.79,9.88-13.92,13.45-21.65c1.55-3.07-0.6-6.21-1.42-9.16c3.15-1.99,6.47-3.78,9.42-6.09l0.49-0.41c0.91,0.25,2.74,0.73,3.65,0.98c0.94,0.28,1.89,0.56,2.85,0.84c5.1-6.6,13-10.06,21.08-11.21c-0.07-3.26-0.09-6.53,0.34-9.77c1.03-4.41,5.51-6.65,7.16-10.73c1.1-2.65,2.43-5.21,4.03-7.59C807.19,85.225,793.68,84.225,782.56,84.155z M385.7,162.815c-0.05-1.84-0.16-5.51-0.22-7.34c1.02,0.46,2.04,0.91,3.07,1.37C387.59,158.835,386.64,160.815,385.7,162.815z M394.6,173.925c-0.14-0.32-0.43-0.97-0.57-1.29C395.45,170.455,397.2,174.535,394.6,173.925z M438.12,204.965c-4.42-3.76-8.85-7.77-11.23-13.19c4.05,3.22,8.12,6.42,12.41,9.32C438.91,202.385,438.5,203.665,438.12,204.965z M444.704,121.556c0.179,3.023,0.504,6.094,0.636,9.14c1.19,2.4,2.7,4.63,4.09,6.94c-2.52,5.01-4.77,10.14-7.13,15.22c-5.5,0.7-10.72,2.77-16.23,3.35c1.14,1.52-2.28,2.63-2.17,0.7c-0.88-1.14-1.76-2.27-2.64-3.41c3.78,0.49,7.87,0.2,10.98-2.27c4.32-4.67,5.93-11.02,7.99-16.85c1.12-4.25-3.12-9.2,0.27-12.85c3.62-4.56,6.96-9.32,10.1-14.22c0.16,1.45,0.49,4.35,0.65,5.8C448.83,115.624,444.943,117.717,444.704,121.556z M454.54,132.865c0.94-1.11,2.72-1.21,4.05-0.85C460.19,133.855,454.77,134.815,454.54,132.865z M483.39,105.225c0.79,1.46,1.61,2.91,2.41,4.37c-3.5-0.36-7.11-0.62-10.28-2.27C478.12,106.565,480.75,105.865,483.39,105.225z M479.47,188.485c-1.11,1.45-3.02-0.54-1.66-1.66C478.93,185.465,480.92,187.385,479.47,188.485z M476.26,200.025c-1.23,1.23-2.44,1.22-3.64-0.01c-3.07,1.83-6.33,3.33-9.57,4.82c-0.51-2.02-1.2-4.04-1.19-6.15c1.32-3.52,3.58-6.61,5.46-9.86c4.19,5.28,11.54,2.83,16.76,6.08c2.16,2.88,4.09,5.95,5.91,9.07C485.23,203.475,480.48,202.345,476.26,200.025z M563.81,93.445c-1.04-1.29-1.04-3.57,0-4.86C565.41,89.035,565.41,92.995,563.81,93.445 M444.69,121.695c0.002-0.048,0.011-0.092,0.014-0.14c-0.011-0.173-0.025-0.348-0.034-0.521L444.69,121.695 M340.98,105.145c2.18,5.34,3.83,15.85,11.97,12.85c1.13-0.39,2.32-0.61,3.53-0.52c0.59,0.01,1.77,0.03,2.36,0.04c7,1.57,9.34-6.93,9.48-12.13C359.71,101.875,349.59,101.475,340.98,105.145 M413.6,206.395c0.53,2.06,1.9,4.81,4.19,5.07c0.56-0.03,1.68-0.08,2.25-0.11c0.35-0.23,1.05-0.68,1.4-0.9c-0.04-4.44-1.94-8.54-3.5-12.6C416.23,200.505,413.58,203.055,413.6,206.395 M450.56,221.285c-1.37,2.07-0.08,4.49,0.33,6.65c1.83-0.41,5.49-1.24,7.32-1.65C456.09,224.075,453.87,221.435,450.56,221.285z'/></svg>"
	          ]],
	          income_groups: [[
	            "lower_middle_income",
	            "Lower middle income",
	            null
	          ], [
	            "low_income",
	            "Low income",
	            null
	          ], [
	            "upper_middle_income",
	            "Upper middle income",
	            null
	          ], [
	            "high_income",
	            "High income",
	            null
	          ]],
	          landlocked: [[
	            "landlocked",
	            "Landlocked",
	            null
	          ], [
	            "coastline",
	            "Coastline",
	            null
	          ]],
	          g77_and_oecd_countries: [[
	            "others",
	            "Others",
	            null
	          ], [
	            "oecd",
	            "OECD",
	            null
	          ], [
	            "g77",
	            "G77",
	            null
	          ]],
	          main_religion_2008: [[
	            "eastern_religions",
	            "Eastern religions",
	            null
	          ], [
	            "muslim",
	            "Muslim",
	            null
	          ], [
	            "christian",
	            "Christian",
	            null
	          ]]
	        };
	
	        return shapes[geoCat];
	      }
	
	      var DDF1CSVReader = Reader.extend({
	
	        /**
	         * Initializes the reader.
	         * @param {Object} reader_info Information about the reader
	         */
	        init: function (reader_info) {
	          this._name = 'ddf1-csv';
	          this._data = [];
	          this._ddfPath = reader_info.path;
	          this.ddf = new Ddf(this._ddfPath);
	        },
	
	        /**
	         * Reads from source
	         * @param {Object} query to be performed
	         * @param {String} language language
	         * @returns a promise that will be resolved when data is read
	         */
	        read: function (queryPar, language) {
	          var _this = this;
	          var query = deepExtend({}, queryPar);
	          var p = new Promise();
	
	          function isShapeQuery() {
	            return queryPar.select.indexOf('shape_lores_svg') >= 0 && queryPar.where['geo.cat'].length > 0;
	          }
	
	          if (isShapeQuery()) {
	            _this._data = getShapes(queryPar.where['geo.cat']);
	            p.resolve();
	          }
	
	          if (!isShapeQuery()) {
	            _this.ddf.getIndex(function () {
	              // get `concepts` and `entities` in any case
	              // this data needed for query's kind (service, data point) detection
	              _this.ddf.getConceptsAndEntities(query, function (err, concepts, entities) {
	                if (err) {
	                  p.reject(err);
	                }
	
	                // service query: it was detected by next criteria:
	                // all of `select` section of query parts are NOT measures
	                if (!err && _this.ddf.divideByQuery(query).measures.length <= 0) {
	                  _this._data = entities;
	                  p.resolve();
	                }
	
	                // data point query: it was detected by next criteria:
	                // at least one measure was detected in `select` section of the query
	                if (_this.ddf.divideByQuery(query).measures.length > 0) {
	                  _this.ddf.getDataPoints(query, function (err, data) {
	                    if (err) {
	                      p.reject(err);
	                    }
	
	                    if (!err) {
	                      _this._data = data;
	                      p.resolve();
	                    }
	                  });
	                }
	              });
	            });
	          }
	
	          return p;
	        },
	
	        /**
	         * Gets the data
	         * @returns all data
	         */
	        getData: function () {
	          return this._data;
	        }
	      });
	
	      var FILE_CACHED$1 = {}; //caches files from this reader
	      var FILE_REQUESTED$1 = {}; //caches files from this reader
	      // temporal hack for https problem
	
	      var GraphReader = Reader.extend({
	
	        /**
	         * Initializes the reader.
	         * @param {Object} reader_info Information about the reader
	         */
	        init: function (reader_info) {
	          this._name = 'graph';
	          this._data = [];
	          this._basepath = reader_info.path;
	          this._parsers = reader_info.parsers;
	          if (!this._basepath) {
	            error$1("Missing base path for graph reader");
	          }
	        },
	
	        /**
	         * Reads from source
	         * @param {Object} query to be performed
	         * @param {String} language language
	         * @returns a promise that will be resolved when data is read
	         */
	        read: function (query, language) {
	          var _this = this;
	          var p = new Promise();
	          var path = this._basepath;
	          //format time query if existing
	          if (query.where.time) {
	            var time = query.where.time[0];
	            var t = typeof time.join !== 'undefined' && time.length === 2 ?
	              // {from: time, to: time}
	              JSON.stringify({from: getYear(time[0]), to: getYear(time[1])}) :
	              getYear(time[0]);
	            path += '?time=' + t;
	          }
	
	          function getYear(time) {
	            if (typeof time === 'string') {
	              return time;
	            }
	
	            return time.getUTCFullYear();
	          }
	
	          _this._data = [];
	
	          (function (query, p) {
	            //if cached, retrieve and parse
	            if (FILE_CACHED$1.hasOwnProperty(path)) {
	              parse(FILE_CACHED$1[path]);
	              return p;
	            }
	            //if requested by another hook, wait for the response
	            if (FILE_REQUESTED$1.hasOwnProperty(path)) {
	              FILE_REQUESTED$1[path].then(function () {
	                parse(FILE_CACHED$1[path]);
	              });
	              return p;
	            }
	            //if not, request and parse
	            FILE_REQUESTED$1[path] = new Promise();
	            get(path, [], onSuccess, console.error.bind(console), true);
	            function onSuccess(resp) {
	              if (!resp) {
	                error$1("Empty json: " + path, error);
	                return;
	              }
	
	              resp = format(uzip(resp.data));
	              //cache and resolve
	              FILE_CACHED$1[path] = resp;
	              FILE_REQUESTED$1[path].resolve();
	              FILE_REQUESTED$1[path] = void 0;
	
	              parse(resp);
	            }
	
	            return p;
	
	            function uzip(table) {
	              var rows = table.rows;
	              var headers = table.headers;
	              var result = new Array(rows.length);
	              // unwrap compact data into json collection
	              for (var i = 0; i < rows.length; i++) {
	                result[i] = {};
	                for (var j = 0; j < headers.length; j++) {
	                  result[i][headers[j]] = (rows[i][j] || '').toString();
	                  if (headers[j] === 'geo.cat') {
	                    result[i][headers[j]] = [result[i][headers[j]]];
	                  }
	                }
	              }
	              return result;
	            }
	
	            function format(res) {
	              //format data
	              res = mapRows(res, _this._parsers);
	
	              //TODO: fix this hack with appropriate ORDER BY
	              //order by formatted
	              //sort records by time
	              var keys = Object.keys(_this._parsers);
	              var order_by = keys[0];
	              res.sort(function (a, b) {
	                return a[order_by] - b[order_by];
	              });
	              //end of hack
	
	              return res;
	            }
	
	            function parse(res) {
	
	              var data = res;
	              //rename geo.category to geo.cat
	              var where = query.where;
	              if (where['geo.category']) {
	                where['geo.cat'] = clone(where['geo.category']);
	                delete where['geo.category'];
	              }
	
	              //format values in the dataset and filters
	              where = mapRows([where], _this._parsers)[0];
	
	              //make sure conditions don't contain invalid conditions
	              var validConditions = [];
	              forEach(where, function (v, p) {
	                for (var i = 0, s = data.length; i < s; i++) {
	                  if (data[i].hasOwnProperty(p)) {
	                    validConditions.push(p);
	                    return true;
	                  }
	                }
	              });
	              //only use valid conditions
	              where = clone(where, validConditions);
	
	              //filter any rows that match where condition
	              data = filterAny(data, where);
	
	              //warn if filtering returns empty array
	              if (data.length === 0) warn("data reader returns empty array, that's bad");
	
	              //only selected items get returned
	              data = data.map(function (row) {
	                return clone(row, query.select);
	              });
	              _this._data = data;
	              p.resolve();
	            }
	
	          })(query, p);
	
	          return p;
	        },
	
	        /**
	         * Gets the data
	         * @returns all data
	         */
	        getData: function () {
	          return this._data;
	        }
	      });
	
	      /*!
	       * Inline Reader
	       * the simplest reader possible
	       */
	
	      var InlineReader = Reader.extend({
	          init: function (reader_info) {
	            this.name = "inline";
	            this._super(reader_info);
	          }
	        });
	
	      var FILE_CACHED$2 = {}; //caches files from this reader
	      var FILE_REQUESTED$2 = {}; //caches files from this reader
	
	      var JSONReader = Reader.extend({
	
	        /**
	         * Initializes the reader.
	         * @param {Object} reader_info Information about the reader
	         */
	        init: function(reader_info) {
	          this._name = 'json';
	          this._data = [];
	          this._basepath = reader_info.path;
	          this._parsers = reader_info.parsers;
	          if(!this._basepath) {
	            error$1("Missing base path for json reader");
	          };
	        },
	
	        /**
	         * Reads from source
	         * @param {Object} query to be performed
	         * @param {String} language language
	         * @returns a promise that will be resolved when data is read
	         */
	        read: function(query, language) {
	          var _this = this;
	          var p = new Promise();
	
	          //this specific reader has support for the tag {{LANGUAGE}}
	          var path = this._basepath.replace("{{LANGUAGE}}", language);
	          _this._data = [];
	
	          (function(query, p) {
	
	            //if cached, retrieve and parse
	            if(FILE_CACHED$2.hasOwnProperty(path)) {
	              parse(FILE_CACHED$2[path]);
	            }
	            //if requested by another hook, wait for the response
	            else if(FILE_REQUESTED$2.hasOwnProperty(path)) {
	              FILE_REQUESTED$2[path].then(function() {
	                parse(FILE_CACHED$2[path]);
	              });
	            }
	            //if not, request and parse
	            else {
	              d3.json(path, function(error, res) {
	
	                if(!res) {
	                  error$1("No permissions or empty file: " + path, error);
	                  return;
	                }
	
	                if(error) {
	                  error$1("Error Happened While Loading JSON File: " + path, error);
	                  return;
	                }
	                //fix JSON response
	                res = format(res);
	
	                //cache and resolve
	                FILE_CACHED$2[path] = res;
	                FILE_REQUESTED$2[path].resolve();
	                FILE_REQUESTED$2[path] = void 0;
	
	                parse(res);
	              });
	              FILE_REQUESTED$2[path] = new Promise();
	            }
	
	            function format(res) {
	              //TODO: Improve local json filtering
	              //make category an array and fix missing regions
	              res = res[0].map(function(row) {
	                row['geo.cat'] = [row['geo.cat']];
	                row['geo.world_4region'] = row['geo.world_4region'] || row['geo'];
	                return row;
	              });
	
	              //format data
	              res = mapRows(res, _this._parsers);
	
	              //TODO: fix this hack with appropriate ORDER BY
	              //order by formatted
	              //sort records by time
	              var keys = Object.keys(_this._parsers);
	              var order_by = keys[0];
	              res.sort(function(a, b) {
	                return a[order_by] - b[order_by];
	              });
	              //end of hack
	
	              return res;
	            }
	
	            function parse(res) {
	              var data = res;
	              //rename geo.category to geo.cat
	              var where = query.where;
	              if(where['geo.category']) {
	                where['geo.cat'] = clone(where['geo.category']);
	                where['geo.category'] = void 0;
	              }
	
	              //format values in the dataset and filters
	              where = mapRows([where], _this._parsers)[0];
	
	              //make sure conditions don't contain invalid conditions
	              var validConditions = [];
	              forEach(where, function(v, p) {
	                for(var i = 0, s = data.length; i < s; i++) {
	                  if(data[i].hasOwnProperty(p)) {
	                    validConditions.push(p);
	                    return true;
	                  }
	                };
	              });
	              //only use valid conditions
	              where = clone(where, validConditions);
	
	              data = filterAny(data, where);
	
	              //warn if filtering returns empty array
	              if(data.length == 0) {
	                p.reject("data reader returns empty array, that's bad");
	                return;
	              }
	
	              //only selected items get returned
	              data = data.map(function(row) {
	                return clone(row, query.select);
	              });
	
	              _this._data = data;
	
	              p.resolve();
	            }
	
	          })(query, p);
	
	          return p;
	        },
	
	        /**
	         * Gets the data
	         * @returns all data
	         */
	        getData: function() {
	          return this._data;
	        }
	      });
	
	      var FILE_CACHED$3 = {}; //caches files from this reader
	      var FILE_REQUESTED$3 = {}; //caches files from this reader
	      // temporal hack for https problem
	
	      var WSReader = Reader.extend({
	
	        ERROR_NETWORK     : 'Connection Problem',
	        ERROR_RESPONSE    : 'Bad Response',
	        ERROR_ORDERING    : 'Cannot sort response. Column does not exist in result.',
	        ERROR_PARAM_PATH  : 'Missing base path for waffle reader',
	
	        /**
	         * Initializes the reader.
	         * @param {Object} reader_info Information about the reader
	         */
	        init: function (reader_info) {
	          this._name = 'waffle';
	          this._data = [];
	          this._basepath = reader_info.path;
	          this._parsers = reader_info.parsers;
	
	          if (!this._basepath) {
	            error$1(this.ERROR_PARAM_PATH);
	          }
	        },
	
	        /**
	         * Reads from source
	         * @param {Object} query to be performed
	         * @param {String} language language
	         * @returns a promise that will be resolved when data is read
	         */
	        read: function (query, language) {
	
	          var p = new Promise();
	          var path = this._basepath;
	
	          path += '?' + this._encodeQuery(query);
	
	          this._data = [];
	
	          //if cached, retrieve and parse
	          if (FILE_CACHED$3.hasOwnProperty(path)) {
	            this._parse(p, query, FILE_CACHED$3[path]);
	            return p;
	          }
	          //if requested by another hook, wait for the response
	          if (FILE_REQUESTED$3.hasOwnProperty(path)) {
	            return FILE_REQUESTED$3[path];
	          }
	          //if not, request and parse
	          FILE_REQUESTED$3[path] = p;
	
	          get(
	            path,
	            [],
	            this._readCallbackSuccess.bind(this, p, path, query),
	            this._readCallbackError.bind(this, p, path, query),
	            true
	          );
	
	          return p;
	        },
	
	        /**
	         * Encode query parameters into readable string
	         * @param {Object} query to be performed
	         * @returns encoded query params
	         * `select=geo,time,population&geo=afr,chn&time=1800,1950:2000,2015&geo.cat=country,region`
	         */
	        _encodeQuery: function (params) {
	          var _params = deepExtend({}, params.where);
	          _params.select = params.select;
	          _params.gapfilling = params.gapfilling;
	
	          // todo: WS doesn't support value `*` for geo parameter
	          // remove this condition when geo will be removed from params.where (when you need all geo props)
	          if (_params.geo && _params.geo.length === 1 && _params.geo[0] === '*') {
	            delete _params.geo;
	          }
	
	          var result = [];
	
	          // create `key=value` pairs for url query string
	          Object.keys(_params).map(function (key) {
	            var value = QueryEncoder.encodeQuery(_params[key]);
	            if (value) {
	              result.push(key + '=' + value);
	            }
	          });
	
	          return result.join('&');
	        },
	
	        /**
	         * Gets the data
	         * @returns all data
	         */
	        getData: function () {
	          return this._data;
	        },
	
	        _readCallbackSuccess: function (p, path, query, resp) {
	
	          if (!resp) {
	            error$1("Empty json: " + path);
	            p.reject({
	              'message' : this.ERROR_RESPONSE,
	              'data': path
	            });
	            return;
	          }
	          
	          if(path.indexOf("?geo.cat=world_4region&select=geo,geo.name,shape_lores_svg")>-1) {
	            warn("WAFFLE READER: APPLYING STUB FUNCTIONALITY TO GET DATA world_4region, WHICH IS NOT YET IN WS");
	            resp.rows = [[
	                "africa",
	                "Africa",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='africa' d='M322.7,114.7l-1-1.8l-6.5,2.3l-16-4.8l-2.3,1.7l-1.8,4.5l-16.9-8.6l-0.2-0.6l-0.3-5.5l-2-2.8l-29,4.4l-0.2-0.4 l-1.7,0.2l-0.1,1.1l-6.7,7l-0.5,1.9l-0.6,0.7l-0.3,3.3l-15.3,23.7l0.6,13.2l-1.4,3l1.1,7.6l12.1,17.9l6,2.8l7.1-1.9l4.5,0.8 l13.7-3.3l3.9,4.5h3.5l1.6,1.4l1.8,3.6l-1.1,10.7l9.2,27.4l-4,14.6l8.5,30.7l1.1,1.1v0.7h0.5l3.5,12.5l2,1.7l11.9-0.6l15-18.2v-3.9 l5.1-4.5l1.1-4.2l-1.1-5.9l10.5-12.2l0.6-0.3l1.6-3.7l-3.4-24l25-43.3l-13.1,1.1l-1.8-1.1l-24.7-48.6l0.9-0.4l0.6-1L322.7,114.7  M360.1,233.2l2.3,1.7l-8.6,30.5l-4.3-0.6l-2-7.6l2.8-14.6l6.4-4.4l2.8-4.9L360.1,233.2z'/></svg>"
	              ],[
	                "americas",
	                "Americas",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='americas' d='M134.8,152l-11.4,1.8l-3.1-1.7l5.3-1.3l-0.7-1.1l-3.3-1.4h-0.1l-8.1-0.9l-0.3-0.3l-0.3-1.5l-6.2-3.6l-3.4,0.8 l-1.6,1.3l-1.2-0.5l-0.7-1.7l3.8-1.6l9.1,0.7l9.5,5.3l0,0l3.3,1.8l1.7-0.5l6.6,2.8L134.8,152 M183.7,25.4l-0.5-1.5l-2.6-2.2 l-2.1-0.6l-2.9-2.2l-18.2-2.2l-5.1,3.7l2,4.3l-6,2.2l1-1.7l-4.6-1.9l-0.5-1.7l-1.1-1.2l-2.9,0.5l-2.1,4.2l-5.8,2.5l-15.5-2.2 l10.5-1.7l-1.3-4l-11.6-0.4l-3.2-1.5L96,20.7h5.8l4,1.9l-1.7,1l0.8,1l7.2,2.3l-78.9-5.3l-10,3.6l-0.4,4.4L18,31.1l1,1.8l1.7,1.2 l-5.5,4.5l-0.4,5.6L13.8,46l1.8,1.8l-4.4,6.2L22,43.7l1.8-0.5l1.3-1.2l13.4,4l4,4.2l-1.3,14l1.6,2.6l-3.3,1.3L39.4,70l2.7,2.6 L28.6,96.9l1.6,11.2l4.8,5.6l-0.2,3.4l2.5,6.1l-0.5,5l6.6,11.9L38,121.5l1.7-4l3.4,6.1l0.3,2.2l7.1,13.1l1.1,9.2l11.1,8.7l1.6,0.3 l1.3,0.9l5.5,1.2l3.4-0.9l5.5,4.2l0.3,0.5l0.8,0.3l2.1,1.9l5.5,0.5l0.2,0.6l0.8,0.3l4.8,8.9l2.3,1.5l0.2,0.5l7.1,3.4l1.6-1.7 l-5.1-2.2l-1.3-15.6l-6.3-2.2l-3.7,0.3v-4.6l3.7-8.9l-5.2-0.9l-0.5,0.3L83,151l-6.3,2.2l-4-2.8l-3.2-8.9l3.2-11.8l0.5-0.3l0.2-1.2 l2.6-3.1l8.5-3.6l6.3,1.8l4.5-3.1l9.2,1.1l2.5,3.1l1.5,7.8l1.3,1.8l2.1-4.5l-1.1-5l1.6-7l13.7-12.3l0.2-3.7l0.8-1.7l0.9-0.2l0.7,0.5 l0.6-1.9l15-8.8l2.2-3.9l11.9-5.1l-2.2,3.6l11.4-3.8l-5.2-1.7l-1.8-2.8l1.6-4.2l-0.8-0.9h-4.2l0.8-1.5l19.5-3.2l1.6,2.8l-4.5,4.2 l6,1.7l5.3-2.2l-6.3-7.6l4.5-6.1l-1.1-0.6l-0.2-0.5h-3.2l-3.7-13.4l-7.7,3.1l-1.8-1.9l0.2-3.9l-2.3-2.5l-3.4-1.5l-6.6,1.9l-2.1,4.2 l-1.1,0.6l-1.3,2.2l-0.3,3.4l-10,9.5l-0.8,2.8l-1.8,1.9l-2.1,0.3l-1.8-2.5l1.1-4.8l-11.9-6.1l-3.1-5.1l15-12l1.3,0.3l5.1-1.2 l1.1-1.2l0.4-1.2l3.4-0.3l-1.7,4.8L147,34l4.6,0.7l-2.2-2.9l-2.1-1.2l8.2-2.8l0.3-0.6l2-1.7l0.7,0.1l8.1-4.2l7.4,5.3l0.2,1.5l-6,1.5 l-1.8,2.2l3.7,5.3l3.4,1.2l2.3-2.2l2.9-1.2L179,33l-0.2-1.9l7.7-1.7L183.7,25.4 M119.7,74.5l0.8,3.1l1.7,1.8l3.3-0.2l5.4,4.7 l2.7,0.2l-0.5,1.7l-4.7-0.4l0.2-1.2l-2.6-0.9l-2,0.6l-2.6,3.4l3.1,1.7l-3.2,2.3l-2.6-1.2l0.1-9.3l-9.6,9.9L108,88l4.5-7l4.3-2 l-5.1-2.1l-4.8,0.5l0.2-1.7l1.3-1.2l8.7-2.2L119.7,74.5 M205.9,223.1l-1.3,3.1H204l-7.1,11.2l-1.9,18.2l-3.1,6.1h-0.5v0.6l-0.8,0.3 l-1.1,1.2l-2.7-0.3l-9.4,6.7l-7.7,21.6l-3.9,3.3l-5.1-1.1l2.1,3.3l0.5,5.3l-7.9,3.3l-1.4,1.5l-0.5,3.6l-1.1,0.6l-1.1-0.3l-1.8,0.9 l1.8,6.1l-1.8,5.6l3.4,6.1l-2,5.9l0.5,3.1l11.1,8.2l-0.2,0.5l-9.3-0.6l-4.3-5.1l-4.7-1.7l-8.6-17.1l0.5-1.7l-6-12.3l-4.5-56.7 l-12.4-10.2l-4.2-8.1l-0.8-0.6l-9.8-21.5l1.1-2.2l-0.3-2.6l-0.5-0.8l7.9-15.3l0.3-5.6l-1-2.8l1-3.9l1.8-0.3l9.7-8.2l2.1,0.3l0.8,5.1 l2.7-5.1l1.3-0.3l4.2,2.8h0.9l0.2,0.6l14.8,3.9l1.6,1.4l0.3,0.6l7.9,6.7l7.7,0.9l4.3,4l2,6.3l-1,4.6l4.4,1.4l1.1,2.2l5.2-1.1 l2.1,1.1l2.6,4l2.9-0.9l9,1.9l8.6,5.8L205.9,223.1'/></svg>"
	              ],[
	                "asia",
	                "Asia",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='asia' d='M322.9,118.9l22.8,42.5l13.5-5.9l16.8-19l-7.3-6.5l-0.7-3.4h-0.1l-5.7,5.2l-0.9,0.1l-3.2-4.4l-0.4-0.2l-0.7,1.7 l-1.2-0.4l-4.1-11.4l0.2-0.5l1.9-1.2l5.1,6.8l6.2,2.7l0.8-0.2l1.1-1.1l1.6,0.4l2.9,2.6l0.4,0.8l16.4,0.8l6.9,6.5l0.4,0.1l1.4-0.3 l0.3,0.1l-1.7,2.5l2.9,2.8h0.7l3.3-3.3l0.5,0.3l9.2,32.1l4,3.7l1.3-1.3h0.2l1.7,1.3l1.4,6.6l1.6,0.9l1.7-2.9l-2.3-7.3l-0.1,0.3v-0.2 l-1.7,0.6l-1.3-1.1l1.2-14.3l14.3-17.6l5.9-1.7l0.3,0.1l3.1,4.5l0.8,0.2l0.9,1.5l0.8,0.3l4.7,10.3l0.2,0.1l2-0.6l5.4,10.1l-0.3,10.5 l2.8,3.7l0,0l4.2,10.8l1.8,1.7l-1.1,2.4l-0.8-0.6l-1.9-4l-1.7-1.4l-0.3-0.9l-5.5-3.5l-2.4-0.3l-0.2,1.2l19.8,28.5l2.6-3.6l-5.7-11.2 l0.9-4l0.7-0.2l0.2-2.3l-9.3-18.6l-0.3-8.9l1.4-1.5l6.7,7.8l1.4,0.3l1.1-0.6l0.1,0.1l-0.2,3.4l0.6,0.5l0.5,0.2l7.4-7.9l-2-10.4 l-6.9-9.5l4.9-6l0.8,0.2l0.8,0.5l1.7,3.9l2.9-4.7l10.1-3.6l5.1-8.1l1.6-9.9l-2.5-2l1.1-1.7l-7.5-11.5l3.5-4.7l-6.1-0.9l-3.5-3.7 l4.1-4.3l0.8-0.1l1.4,0.9l0.6,2.9l2.8-1.3l3.9,1.4l0.9,3.2l2.3,0.5l5,9h0.4l2.3-2.4h0.3l1-1.5l-1.7-3.8l-5.8-5.9l2.1-4v-3.6l2.6-2.4 l0.5,0.1l0.2-0.1l-3.5-15.2l-0.2,0.1v-0.1l-9.3,1.2l-7.3-9.3L464,58.8l-0.8,1.9L441.2,60l-1.5-1.8l-0.2,0.1l0,0l-7.3,4.1l-7.5-3 l-0.5,0.3l-1.8-0.8l-0.9-1.2l-0.3,0.1l-0.1-0.1l-5.7-0.4l-0.3-0.2l0,0l0,0l-1,0.5l-1.5,4.5l-4.2,2.7l-16.8-4.4L377.5,50l0,0l-0.2,1 l1.8,6.7l-13.3,3l-9.2-3.8l-1.1,3.1l-6.7-1.6l-0.1,0.1h-0.2l-4.4,6.8l3.8,3.8l0.6,2.7l0,0l0,0L352,71l2.6,2.2V74l-2.3,1.9l-0.8,1.6 l1.6,3.9l0.9,0.3l1,1.1l2.6,0.9l1.7,1.7l-0.2,1.1l-1.5,2.8l2.1,3.7v4.5l-1.3,1.4l-3.8-0.9l-4.7-5.1v-0.6l-1.4-1.4l-3.9,2.1l-2.4-2.1 l-1.6,0.9l-0.3,5.1l-15.2,4.7l-1.7,9.8l-2.5,1.7L322.9,118.9 M531.1,99.3l-1,2l-4,1.7l-2.4,3l-3.3-2.5l-6.4,0.2l-0.2-0.7l8.9-4.2 l3.7-4.9l-0.6-3.3l-3.2-5.1l-0.7-0.4v-5.1l1.4-2.6l1.7,0.3l0.6,0.7h0.8l1.1,0.8l1.3,0.3l0.6,1.9l-1.7,2l-2.6-1.2L531.1,99.3  M500.5,130.3l1.9-0.9l-0.8,6.3l-1.6-0.3L500.5,130.3 M515.9,180.5l-1.7,0.4l-2.2-3.3l-3.6-2.2l4.3-2.5l0.9-3.1l-0.3-4.1l-4.6-2.1 l-2,0.5l-5.1,8.5l-2.4,0.3l-0.2-3.4l0.8-0.7l4.2-9.3l-1.8-3.7l1.4-9.3l2.4,1.8l1.6,3.6l-0.5,4.8l8,6.4l0.1-0.1l3.1,11.2L515.9,180.5 L515.9,180.5L515.9,180.5 M497.7,179.5l2.6,0.9l1.1,1.9l-1.8,5.1l0.8,7l-6,10.9l-9.2-1.7l-2.9-10.9L497.7,179.5L497.7,179.5  M509,194.8l-1.8,0.1L509,194.8 M515,193.9l-1.7,2.2l-2.4-0.2l-1.9-1.1l-3.3,1.3l-0.3,1.9l1.2,1.4l2.1-0.3l0.9-0.7l1.1,0.1l0.3,1.2 l-1.9,2.6l0.7,5.6l-2.3-2l-1-2l-1.5,1l0.9,5.2l-3.1-0.4l0.2-2.8l-1.4-2.5l2.9-10.5l3.2-1.6l3.8,1.2l3.4-1.1L515,193.9 M530.7,198.1 l2.5,0.5l0.4,0.4l2,5.3l2.1-2.2l4.2-1.7l14.5,11.5l2.4,0.5l4-2.6l-1.2,4.7l-3.5,1.4l-0.5,1.4l0.1,1.3l4.4,6.5l-4.4-1.5l-5.2-7.5 l-5.6,4.4l-5.6-2l-1.2-1.5l1.3-1.5l-1.9-2.4l-0.3-0.8l-8.5-5l-0.9-4.7l-3.4-3.1l2.4-1.4H530.7 M476.6,212.1l19.1,5l3.1-0.8l4.4,1.4 l3.3-0.9l12.4,2.1l-0.1,0.6l-8.2,4v-1.9l-35.4-5.6l-1.5-1.8l2.5-1.9H476.6 M569.4,280.1l-19,14.6l-0.7-1.1l2.2-4.6l5.1-3l7.4-9.7 l0.9-4.3l4.8,5.1L569.4,280.1 M554.3,267.3l-11.1,18.2l-5.7,3.1l-4.8,7.7l-2.5,0.5l-0.6-1.9l0.5-3.4l2.8-2.9l-6.6-0.8l-1.6-1.4 l-1.7-8.4l-0.9-0.9l-3.1,1.1l-5.2-3.9l-32.3,7.3l-2.3-1.9l2.3-4.5l0.6-21.9l1.8-2.5l13.9-6.4l4.3-4.8l0.3-0.9l10-9.2l4.2,1.9l5.5-7 l4.2-1.4l4.9,2l-1.1,5l2.8,4.8l4.5,2.8l3.2-4.5l2.5-11.7l4.6,10.8v7.6l7.7,18.5L554.3,267.3L554.3,267.3L554.3,267.3L554.3,267.3 L554.3,267.3L554.3,267.3'/></svg>"
	              ],[
	                "europe",
	                "Europe",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 584.5 364.5'><path id='europe' d='M556.7,26.9l-35.5-7.3l-3.5,1.4l-49.9-5.2l-2.7,2l-45.8-4.1l-1.3-1.9l-15.3-2.2l-0.2,0.1h-0.1l-0.2,0.2l-6,0.6 l-0.5,0.5L372.4,17l-1.7,1.7l-5.8-3.1h-1.7l-1.5,3.7l1.8,2.5l-0.4,0.2l-10.1-1.5l-6.8,1.9l-5.3-0.6l-7.2,2.6l-4.2-1h-0.1l-3.1,3.2 l-0.9,0.2l-2.6,2.2l-2.3,0.8l-1.6,2h-1.7l-5.1-5.1l-1-0.2l-0.1-0.5l1.3-0.9l8.4,1.6l0.5-0.1l2.4-1.8l-0.8-0.9l-20.2-5.5l-16.9,3.4 L268,37l0.8,6.1l3.2,1.7l4-1l1.5,0.9l2.6,5.5h0.8l0.7,1.2l0.8,0.2l7.9-9.7l-2.9-5.4l8.5-8.9h0.5l1.3,1.7l-2.7,6.6l0.8,2.8l11.9,2.4 l-4,1.8l-3.5-0.3l-1.5,1.2l1,1.6l-0.1,2.2l-0.9-0.6H297l-1.8,1.2l-0.5,3.9l-2.3,2.2h-4.3l-4.2,1.9l-6.8-0.7l-0.6-0.4l2.5-1.7 l0.5-1.2l-0.9-1.7l-0.2-0.1l-2.3,0.5l-0.2-0.1l-0.2-3.4l-0.4-0.1l-2.6,3.9l1.3,3.7l-1.4,1.7L269,57l-18.9,13.1l0.1,1l1.7,1.6 l0.8,0.3l1.3,2.2l0.3,3.6l-3.1,4.5l-9.7-0.9l-1.3,1.5L239,97.9l0.4,1.1l5.1,3.1l0.2,0.8l1.6-0.2l0.1-0.2h0.1v-0.1l7.9-4.5l10-14.3 l10-2.8l1.2,0.5l11,11.5l0.2,2.3l-2,1.8l-1.9-0.4l-1.8,0.5l3.8,3.9l1.1-0.7l3.7-5.6l0.2-0.5l-0.9-1.9l0.2-0.4l2.3,0.3l0.8-1 l-1.7-0.9l-8.7-7.6l-0.5-4.5l1.4,0.2l10.4,8l3.4,9l1,0.5l0.5,0.6v1.5l4.5,6.1v0.4l0.7,1.1l3.7,1.3l1.4-1.6l-3.8-2.3l-0.1-1.7 l2.2-2.6l-6.3-6.3l5.6-2.2L306,90l5.8,8l4.2-0.6l2.7,0.9l1,4.7l0.7-0.1l1.8-2l-1.3-1.7l0.2-0.9h4.3l0.3,2.7l15.2-4.7l0.4-5.1 l1.5-0.9l2.5,2l3.9-2.1l1.4,1.5l0.3-3.9l-3.1-5.3l-1.3-8.6l2.9-2.5l-0.6-2.7l-3.8-3.8l4.5-6.9l6.8,1.6l1.1-3.1l9.2,3.8l13.3-3.1 l-1.8-6.7l0.2-1l8.7,7.4l22.2,7.4l4.3-2.7l1.5-4.5l1-0.5l0.2,0.2l6,0.4l1,1.2l1.7,0.8l0.5-0.3l7.5,2.9l7.5-4.2l1.5,1.8l22.1,0.8 l0.7-1.8l23.5-1.4l7,9.2l9.6-1.2l3.4,15.2l1,1.1l-0.2,0.2l1.7,1.7l0.5,0.1l1.8-2.2l1.6-5.3L508,56.7l-2.9-2.2l-5.5,0.3l-2.6-2.5 l1.8-7.8l0.5-0.3l0.2-0.9l3.4-1.7l14.2,0.6l1.3-4.8l1.6-1.2l0.4-0.1l4.3,1.2l0.1-0.1l0.2,0.1l3.1-2.5l1.7,0.9l-1,12l6.9,15.9l3.1-3 l0.1-0.3l2.3,1.1l0.8-2.2l-1.1-8.7l-4.8-5.8l0.1-2.6l0.8-1.5l4.5-2.2l2.2,0.2l4-3.7l2.1-0.3l1.1-1.7l-5.2-2.5l-0.5-1.7l2.9-1.7 l8.2,2.2l0.9-0.2l0.8-1.2L556.7,26.9 M331,87l-11.6-3.1l-8.9,2.9l-0.2-0.1l-0.5-1.9l2.9-7l2.9-2.5h1.7l2.1,1.1l2.3-1.7l1.8-3.4 l1.8-0.6l2.1,0.6l-0.8,3.9l7.7,7.3L331,87 M252.8,18.2l-5.8,5.6l-3.7,1.1l-1.1,4.3l-2.2,1.7l-0.2,1.2l0.9,1.7l7.8,1.2l-2.4,2.9 l-4.6,1.7l-5.9-2.9l2-1.8l1.9-0.8l-2.5-2.1l-11.4,1.7l-4.7,3.1l-8,1.7L203,49l-3.4,0.3l-3.7-2.8l-1.3-10.6l5.2-4.5l1.1-2l-1.9-3.3 l-0.5-0.3v-0.6l-0.5-0.3v-0.6l-0.6-0.3l-1.1-1.4l-3.1-1.4h-5.5l-4-1.7l71.2-3.4L252.8,18.2 M258.9,60.7l0.7,1.2l-10.5,1.5l3.4-1.5 l-0.1-1.5l-2.7-0.9l4.2-4.9l-2.7-2.7l-5.9,7.4l-4.4,0.8l1.1-2.7l-0.2-2.7l8.5-4.8l0.3-3.8l1-1.3l1.3,0.4l0.2,1.1l1.3,0.3l-0.8,3.2 l3.3,2.4l1.7,5.1l2.6,0.9L258.9,60.7'/></svg>"
	            ]];
	          }
	
	            
	          if(path.indexOf("?geo.cat=geographic_regions&select=geo,geo.name,shape_lores_svg")>-1) {
	            warn("WAFFLE READER: APPLYING STUB FUNCTIONALITY TO GET DATA geographic_regions, WHICH IS NOT YET IN WS");
	            resp.rows = [[
	                "america",
	                "America",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='america' d='M189.96,40.495c1.3,0.72,2.56,1.51,3.82,2.32l1.04,0.23c0.57,0.13,1.7,0.39,2.27,0.52c0.55,0.18,1.64,0.55,2.18,0.73c-0.13,1.2-0.26,2.41-0.36,3.61c-4.66,0.37-9.34,0.55-14,0.8c0.06,1.15,0.11,2.3,0.16,3.45c0.58-0.04,1.74-0.11,2.32-0.14c1.6-0.47,2.8,0.77,3.51,2.04l0.63,0.8c0.88,0.68,1.23,1.54,1.06,2.59l-0.11,1.04c1.27-0.13,1.89,0.44,1.87,1.71c2.21,0.13,4.42,0.26,6.65,0.27c1.38-0.07,2.75,0.11,4.1,0.43c1.94,0.35,3.91,0.45,5.88,0.44c0.57,0.09,1.72,0.27,2.29,0.35l1.24,0.46c0.12-1.63,0.31-3.27,0.3-4.91c-0.29-1.27,0.12-2.87,1.7-2.85c1.17-0.31,2.33-0.63,3.5-0.96c-0.16-0.53-0.46-1.58-0.61-2.1c-0.42-1.05-0.16-1.91,0.76-2.6c1.85-1.74,3.41-3.76,5.09-5.66c2.13-2.35,5.27-3.21,8.07-4.51l0.62-0.31c1.1-0.64,2.26-1.21,3.49-1.58c1.25-0.46,2.52-0.97,3.57-1.83c0.51-0.9,1.27-1.43,2.28-1.59c2.35-0.65,4.6-1.6,6.83-2.58l-0.65-1.11c-0.6-0.83-0.87-1.75-0.81-2.76c-2.47-0.83-4.94-1.79-7.54-2.09c-1.18-0.02-2.34-0.27-3.43-0.68c-0.87-0.11-2.59-0.34-3.45-0.46c-1.18,0.08-2.35-0.12-3.47-0.479c-2.02-0.15-6.06-0.46-8.09-0.62c-1.35,0.04-4.07,0.11-5.43,0.14c-0.54,0.18-1.64,0.54-2.18,0.71c-0.62,0.89-1.44,1.311-2.48,1.271l-0.72,0.03c-4.64,0.31-9.27,0.63-13.89,1.02l-0.78,0.38c-2.28,1.27-4.54,2.55-6.82,3.82l-0.7,0.42c-0.93,0.689-1.95,1.24-3.04,1.6l-0.93,0.521c-0.83,0.83-1.72,1.02-2.7,0.56C184.92,35.785,186.99,38.645,189.96,40.495z M203.85,33.395l-1.02,0.57c2.36,1.12-1.66,3.47-1.3,0.83c-0.15-1.15-0.3-2.311-0.43-3.46C201.77,28.755,206.22,32.025,203.85,33.395z M204.82,54.435c-2.256-0.119-4.503-0.26-6.75-0.442c-0.075-1.56,0.615-2.036,2.07-1.438C201.7,53.195,203.26,53.815,204.82,54.435 M162.94,36.825c0.44,0.12,1.3,0.36,1.74,0.48c1.02-0.1,1.92,0.2,2.7,0.88c1.21,0.82,2.51,1.5,3.83,2.14c1.16,0.36,1.59,1.11,1.31,2.23c0.15-0.36,0.43-1.09,0.58-1.46c0.31-1.14,1.05-1.58,2.22-1.31c1.21,0.15,2.43,0.26,3.66,0.33c0.56,0.1,1.69,0.29,2.25,0.39c0.49,0.17,1.46,0.5,1.95,0.66c0.19-1.6,0.38-3.21,0.57-4.81l-0.66-0.3c-2.57-1.13-5.11-2.33-7.64-3.53l0.2,1.09c0.74,1.38-1.02,2.32-2.03,1.35c-1.1-0.49-2.23-0.92-3.38-1.28c-1.12-0.23-2.15-0.77-2.95-1.6c-0.99-0.82-1.99-1.62-3-2.4c-1.93,0.89-3.85,1.8-5.74,2.74c0.42,0.4,1.28,1.2,1.71,1.6C161.26,34.855,162.13,35.815,162.94,36.825 M146.08,43.795c0.74-1.05,1.6-2.01,2.57-2.86c0.47-0.47,1.42-1.42,1.89-1.89c-3.31-0.11-6.59-0.23-9.88-0.37c0.93,2.65,1.99,5.26,3.18,7.8C144.61,45.605,145.35,44.705,146.08,43.795 M126.03,51.835c2.62-0.65,5.14-1.52,7.75-2.24c-0.52,1.48-1.03,2.97-1.56,4.45c-0.15,0.4-0.43,1.2-0.57,1.6c1.2,0,2.12,1.06,2.04,2.24c0.42,0.14,1.27,0.42,1.7,0.56c2.78,0.89,5.5,1.98,8.13,3.25c0.76-0.15,2.27-0.46,3.03-0.62c0.85-0.58,1.77-0.78,2.78-0.58c3.31,0.26,6.48-1.06,9.3-2.65c0.95-0.74,1.82-0.69,2.61,0.13c0.27-1.58,0.55-3.16,0.84-4.74c-2.61-1.72-5.18-3.49-7.79-5.21l-0.6-0.39c-1.13-0.69-2.22-1.45-3.19-2.35c-0.19,0.48-0.57,1.45-0.76,1.93c-0.33,1.19-1.07,1.63-2.23,1.33l0.36,1.28c0.87,1.17-0.63,2.79-1.7,1.55c-2.62-1.55-5.39-2.82-7.95-4.47c-2.48-1.64-4.97-3.27-7.46-4.89c-2.52,0.64-4.88,1.82-6.94,3.4c-0.82,0.75-1.98,1.45-3.11,0.91c-0.15,1.61-0.31,3.23-0.47,4.84C122.14,51.535,124.08,52.215,126.03,51.835 M176.44,48.955l-0.4-1.49c-3.84,0.58-7.59,1.65-11.2,3.1c0.39,0.4,1.18,1.19,1.58,1.59c1.19,1.11,2.27,2.34,3.31,3.6c1.17,2.14,3.56,2.08,5.56,1.21c0.73-1.21,1.51-2.4,2.29-3.58c0.25-0.73,0.75-2.2,1-2.94C177.36,50.695,176.65,50.195,176.44,48.955 M320.03,350.335c-0.43-1.08-0.7-2.22-0.76-3.37c-0.96-1.18-2.23-2.02-3.43-2.9c-2.29-1.58-4.56-3.18-6.87-4.71c-6.17-1.83-12.18-4.11-18.19-6.42c-1.25-0.35-2.65-0.8-3.27-2.05c-1.73-2.42-2.9-5.17-3.72-8.02c-0.54-1.74-0.94-3.49-1.21-5.25l-0.97,0.03c-1.07,0.09-1.87-0.35-2.4-1.34c-0.73-0.86-1.54-1.63-2.44-2.3c-1.07-0.54-1.41-1.33-1.01-2.36c-2.81-0.28-5.71-0.37-8.45-0.97c-1.79-1.51-3.28-3.33-4.68-5.18l-0.42-0.53c-3.22-4.75-8.95-8.5-14.85-7.28c-1.59,0.11-3.24,0.24-4.77-0.29c-3.42-1.09-6.75-2.48-10.11-3.67c-0.86,0.83-1.69,1.68-2.5,2.55c-0.83,0.98-1.75,1.87-2.72,2.7c-0.92,1.06-1.58,2.3-2.16,3.57c-0.15,1.4-1.72,1.69-2.63,0.76c-0.61-0.01-1.82-0.05-2.43-0.07c-2.08,0.09-4.21-0.19-6.23-0.36l-1.3-0.14c-1.27-0.02-1.85-0.64-1.74-1.87c0.11-4.16,0.39-8.36-0.12-12.5c0.09-1.47-0.99-2.41-2.32-2.7c-1.12-0.2-2.19-0.59-3.16-1.18c-0.72-0.35-2.16-1.04-2.89-1.39c-0.38-0.2-1.15-0.59-1.53-0.78c0.19-2.24,0.58-6.7,0.77-8.94c0.17-1.35,0.45-2.68,0.71-4.01c-0.73-1.02-1.3-2.16-1.69-3.35c-1.41-0.13-2.82-0.25-4.22-0.37c-0.07,1.19-1.18,2.11-2.36,1.93c-0.49,1.16-0.96,2.32-1.44,3.49c-0.45,1.52-1.59,2.7-2.99,3.41l-1.12,0.7c-1.02,0.89-2.69,1.36-3.71,0.2l-0.8-0.63c-2.7-1.79-4.49-4.5-5.88-7.35l-0.46-0.82c-0.61-0.88-0.7-1.81-0.29-2.8c0.95-4.01,1.78-8.05,2.24-12.15c0.18-1.43,0.56-4.28,0.74-5.71c0.51-0.12,1.53-0.38,2.05-0.5c4.34-0.98,8.8-0.27,13.19,0.1c0.4-0.88,0.98-1.61,1.74-2.2l0.86-0.78c1.29-1.25,2.9-1.47,4.81-0.66c7.01,0.89,5.82,9.64,10.35,13.31c0.98,0.58,1.98,1.14,2.94,1.78c0.85-1.45,1.68-2.91,2.54-4.35c1.59,0.13,3.18,0.29,4.78,0.45c0.05-0.72,0.15-2.16,0.2-2.88c-0.68-0.6-1.31-1.25-1.89-1.93c-0.83,0.05-2.48,0.14-3.3,0.18c-1.15,0.15-1.85-0.36-2.12-1.52c-0.48-1.21-1.02-2.38-1.64-3.51c-0.69-0.84-0.86-1.76-0.52-2.75c0.45-1.72,0.81-3.47,1.39-5.14c1.92-3.29,5.11-5.51,7.9-8c3.73-2.83,5-7.82,4.94-12.3c-0.17-1.02,0.05-1.95,0.65-2.79l0.3-0.99c0.05-1.04,0.45-1.92,1.21-2.63l0.61-0.85c0.94-1.39,1.91-3.09,3.76-3.31c1.39-0.36,2.78-0.7,4.18-1.04c-0.01-1.86,0.26-3.64,0.82-5.35c1.01-1.68,1.96-3.64,3.86-4.47c3.43-1.92,5.49,2.56,7.97,4.13c0.34-0.5,1.02-1.48,1.37-1.97c0.63-1.18,1.73-1.96,2.9-2.55c3.53-1.93,5.72-5.48,8.29-8.44c-1.73-0.08-3.47-0.14-5.2-0.13l-0.69,0.42c-1.16,0.68-3.49,2.03-4.65,2.7c-0.18-2.73-0.37-5.46-0.56-8.19c-0.16-1.88-0.4-3.76-0.64-5.63c3.98-1.15,9.02,0.07,12.39-2.86c0.65-0.67,2.51-2.1,2.9-0.45c-0.49,1.17-1.38,1.52-2.67,1.07c-0.13,2.38-0.34,4.76-0.33,7.14c0.02,1.15,0.03,2.32-0.15,3.46c3.36,0.98,6.79,2.07,10.34,1.83c1.45-0.11,2.9-0.21,4.36-0.17c-0.22-1.62-0.53-3.23-0.93-4.81c-0.55-0.93-0.62-1.87-0.2-2.83l0.42-1.16c-0.98,0.56-1.86,0.39-2.64-0.5c-0.99-0.79-1.99-1.55-3.01-2.29c-0.17-1.03-0.34-2.06-0.5-3.09c-0.39-1.14,0.12-2.29,0.81-3.19c0.26-0.41,0.77-1.23,1.02-1.65c-1.23,0.19-1.89-0.34-1.99-1.58c-0.26-1.61-0.52-3.22-0.75-4.83c-2.32-1.69-4.63-3.4-6.9-5.15l-0.61-0.49c-3.13-2.6-3.67-6.84-5.2-10.39l-0.33-0.76c-0.79-1.49-1.58-2.99-2.33-4.5l-0.5-0.78c-0.93-0.52-1.46-1.3-1.59-2.33c-0.16-0.71-0.49-2.13-0.66-2.84c-1.89,1.68-3.82,3.34-5.9,4.78c-1.01,0.73-2.21,1.13-3.38,1.52c-1.21,0.35-1.87-0.14-1.99-1.5l-0.29-1.46c-0.38-1.91-0.65-3.83-0.82-5.76c-0.37-0.28-1.13-0.83-1.51-1.11c-1.97-1.44-3.84-2.99-5.77-4.47c-2.81-1.52-6.83-4.98-9.96-2.68c-0.82,0.99-1.68,1.98-2.81,2.63l-0.48,0.32c1.23,0.07,1.76,0.73,1.62,1.98c-0.02,0.59-0.05,1.77-0.06,2.36c0.13,1.22-0.43,2.32-1,3.34l-0.35,1.23c-0.16,1.45-0.48,4.34-0.64,5.78l1,1c1.06,0.86,1.74,2.08,2.08,3.4c0.2,0.55,0.61,1.65,0.82,2.19c1.07,0.76,1,2.28-0.25,2.81c-0.13,0.52-0.39,1.55-0.51,2.06c-0.09,1.05-0.61,1.82-1.56,2.3c-0.52,0.46-1.55,1.38-2.07,1.84c-0.63,0.99-1.46,1.32-2.5,0.98l0.86,0.89c0.84,0.72,1.08,1.61,0.72,2.68c-0.09,0.51-0.28,1.52-0.37,2.03c-0.33,1.91-0.66,3.83-0.99,5.75c-2.6-2.17-4.47-5.01-5.64-8.17c-0.67-1.56-1.46-3.12-2.87-4.13c-1.31-1.02-2.56-2.12-3.75-3.27c-0.49-0.36-1.47-1.1-1.96-1.46c-0.97-0.34-1.67-0.96-2.09-1.88l-0.54-0.47c-2.16-1.24-4.37-2.39-6.62-3.44c-0.56-0.03-1.68-0.09-2.24-0.11c-1.42,0.43-2.59-0.58-2.73-1.97c-0.45-1.25-1.33-2.26-2.19-3.23c-0.88-0.76-1.5-1.84-1.29-3.03c-0.02-1.82-0.05-5.44-0.07-7.25c-0.15-1.06,0.23-1.89,1.14-2.49l0.56-0.51c2.08-2.03,4.12-4.09,6.26-6.06l0.59-0.53c1.88-1.6,3.89-3.03,5.88-4.48c1.43,1.48,2.86,2.97,4.31,4.44l0.7,0.71c1.06-0.53,2.21-0.87,3.38-1.01l1.1-0.19c1.52-0.33,3.08-0.32,4.62-0.14c0.74,0.05,2.22,0.15,2.95,0.2l-0.47-0.85c-0.49-0.82-0.88-1.68-1.18-2.58c-0.52-1.42-1.36-2.96-2.95-3.34c-1-0.16-1.8-0.65-2.39-1.47c-0.5-0.38-1.5-1.13-2-1.5c-1.4-0.39-2.09-2.31-0.38-2.85l0.61-0.39c2.4-1.55,4.78-3.12,7.19-4.66c-0.09-4.37,0.03-8.75,0.43-13.1c2.47-0.39,4.87-0.71,7.4-0.95c0.1,0.38,0.31,1.15,0.41,1.53c1.18,3.42,0.01,6.92-1.29,10.1c1.73,0.26,3.47,0.5,5.22,0.74c0.88-1.42,1.76-2.84,2.67-4.25l0.23,0.87c0.51,1.48,1.12,2.93,1.68,4.4c0.69,1.19,0.26,2.77-0.95,3.44c-3.19,2.63-7,4.34-10.61,6.29c-0.06,1.3-0.11,2.59-0.15,3.89c0.44,0.16,1.32,0.48,1.77,0.64c1.19,0.31,1.61,1.06,1.26,2.23c0.65-0.32,1.95-0.96,2.6-1.28c0.96-0.65,2.12-0.99,3.28-0.73c0.8,0.05,2.39,0.16,3.19,0.22c1.14-0.03,1.85,0.52,2.14,1.66l0.45,1.03c0.65,1.35,1.3,2.72,1.68,4.19c1.31,0.26,2.63,0.5,3.96,0.72c1.19,0.04,2.25,0.59,3.16,1.33l0.74,0.45c0.98,0.37,1.64,1.04,1.98,2.03c0.37,0.03,1.09,0.08,1.45,0.1c0.5-0.24,1.49-0.72,1.98-0.96c2.45-2.4,3.93-6.04,3.27-9.47c-1.39-2.09-2.91-4.1-4.47-6.07c-0.79-0.84-1.51-1.74-2.15-2.69c-2.13-1.1-0.01-3.44,1.2-1.3c0.34,0.14,1.01,0.42,1.35,0.56c1.54,0.69,1.79,1.7,0.75,3.04l-0.41,0.53c0.32,0.09,0.97,0.28,1.29,0.38c1.87,0.56,3.75,1.08,5.64,1.59c0.72-2.99,2.35-6.14,1.49-9.25c-0.72-0.89-1.31-1.87-1.66-2.95c-0.62-1.77-2.39-2.69-4.08-3.14c-1.02-0.13-1.83-0.61-2.44-1.42l-0.71-0.38c-1.87-0.3-2.59-2.03-1.34-3.48c1.17-1.91-0.47-3.89-1.54-5.42c-1.67-1.75-3.41-3.44-5.21-5.05c-2.09-1.45-4.52-2.33-6.93-3.09c-1.18-0.17-2.16-0.89-2.66-1.97c-1.34-1.99-2.99-4.55-5.76-4.2c-2.88,0.07-5.78,0.27-8.64,0.4c-0.28-0.95-0.55-1.89-0.83-2.83c-0.39-1.31-0.78-2.61-1.16-3.91l-0.91-0.04c-2.99-0.08-6-0.26-8.97-0.41c-2-0.11-3.99-0.22-5.98-0.35c0.34,1.1-0.08,1.84-1.24,2.24c-1.83,0.94-4.07,2.22-3.44,4.67c0.01,1.39,0.02,4.16,0.02,5.55v1.65c1.32,0.73,2.41,1.8,3.37,2.95l0.52,0.57c1.78,1.89,3.5,3.83,5.19,5.8l0.59,0.65c1.18,0.65,1.15,2.14,0.08,2.89c-1.08,1.62-1.93,3.38-2.82,5.12c-0.47-1.42-0.98-2.82-1.55-4.2c-0.84-1.05-1.68-2.1-2.52-3.14c-0.92-0.63-1.84-1.25-2.78-1.84c-2.03-1.28-3.91-2.82-5.42-4.69c-2.34-3.72-1.01-8.14,0.93-11.74c0.48-1.26,1.53-2.16,2.48-3.08l0.52-0.86c0.54-1.3,1.06-2.61,1.71-3.87c-4.5-0.35-9.01-0.53-13.5-0.77c0.33,3.29,0.67,6.56,1.03,9.86c0.79,1.74,0.37,5.85-1.53,3.4c-0.52-1.8-0.85-3.64-1.27-5.46c-0.37-1.33-0.54-2.75-0.08-4.08l0.2-0.83c-0.66-0.63-1.99-1.91-2.66-2.55c-2.68,0.97-5.37,1.91-8.09,2.8l0.73,1.25c1.63,1.58-0.23,3.44-2.02,2.41l-1.4-0.29c0.14,0.55,0.43,1.66,0.58,2.21c-0.07,1.32,0.38,2.41,1.35,3.26c1.23,1.06,2.44,2.13,3.64,3.23c1.93,1.33,3.99,2.45,6.18,3.36c-0.18,1.2-0.54,3.58-0.71,4.77c-0.09,1.33-0.77,2.49-1.37,3.64l-0.21,0.75c-0.55,1.73,0.23,4.73-1.9,5.06c-1.77,0.26-3.56,0.39-5.34,0.51c-2.41,0.82-1.84-2.77,0.25-1.51c0.16-1.29,0.27-2.59,0.33-3.89c-0.13-1.01,0.12-1.93,0.74-2.73c0.44-0.86,1.32-2.56,1.76-3.41c-2.41-0.77-4.82-1.56-7.21-2.35c-1.07-2.78-2.1-5.6-3.54-8.21c-0.71-1.14-1.31-2.34-1.83-3.57l-0.57-0.93c-0.87-0.81-1.06-1.7-0.57-2.67c-0.56,0.26-1.67,0.78-2.23,1.04c-1.16,0.64-2.42,1.07-3.73,1.25c-1.56,0.32-3.11,0.71-4.59,1.3c-0.51,1.26-2.01,1.35-2.8,0.31c-2.05-1.15-4.24-2-6.39-2.95c-1.49-0.42-2.39-1.76-2.83-3.17c-0.23-0.56-0.7-1.7-0.93-2.26c-0.7,0.85-1.58,1.02-2.64,0.51c-1.57-0.41-3.16-0.66-4.78-0.73c-1.38,0-2.76-0.17-4.06-0.67c-0.98-0.31-2.96-0.92-3.95-1.23c-1.11,1.67-2.21,3.34-3.19,5.09c-0.72,1.52-1.22,3.19-1.16,4.88c0.21,1,0.05,1.94-0.47,2.82c-0.17,0.48-0.51,1.43-0.68,1.91c-0.27,0.49-0.81,1.46-1.08,1.94l1.45,0.17c1.57,0.01,2.94,0.84,4.11,1.83c0.55,0.42,1.66,1.25,2.22,1.67c1.45-0.74,2.97-1.35,4.45-2.03c0.44-0.29,1.34-0.87,1.78-1.16c1.21-1.49,3.39-1.11,3.28,1.04c0.46,1.97,0.93,3.95,1.64,5.86c0.63,1.68,1.31,3.35,1.98,5.02c-1.55-0.32-4.65-0.96-6.21-1.28l-0.78-0.17c-1.49-0.22-2.7-1.15-3.94-1.92c-0.65,0-1.94-0.01-2.59-0.02c-0.58,0.91-1.39,1.39-2.44,1.44l-1.09,0.13c-1.8,0.49-3.98,0.2-4.71-1.77c-0.67-1.09-1.33-2.17-1.98-3.26c-0.3,0.47-0.89,1.41-1.19,1.88c-0.39,0.38-1.19,1.15-1.59,1.53c-0.33-0.03-0.99-0.09-1.33-0.13c-2.13-0.22-4.28-0.26-6.43-0.32l-0.64,0.86c-0.67,1.22-1.97,1.87-3.33,1.92c-2.62,0.42-5.23,0.9-7.86,1.3c-1.76,0.58-3.34,0.42-4.74-0.49c-1.27-0.72-2.54-1.44-3.9-1.98c-2.91-0.98-5.88-1.77-8.84-2.56c-2.48-0.6-5.07-0.64-7.6-0.74c-1.11,0-3.32-0.01-4.43-0.01l-0.43-0.39c-1.47-1.27-3.03-2.67-4.99-3.07c-1.03,0-1.91-0.36-2.62-1.09l-0.8-0.55c-3.01-0.08-6.03-0.02-9.03,0.07c-1.48,0.5-2.85,1.26-4.15,2.11c-0.91,0.67-1.96,1.38-3.16,1.15l-1.17-0.04c0.47,1.06,0.17,1.87-0.9,2.45c-0.85,0.64-1.68,1.31-2.48,2.01c-2.47,2.23-4.9,4.51-7.38,6.72c-0.05,0.71-0.14,2.15-0.18,2.86c2.14,0.98,4.26,1.98,6.39,2.98c-0.13,0.68-0.38,2.04-0.5,2.72c-1.64,0.98-3.28,1.96-4.88,3l-0.68,0.47c-1.25,0.94-2.49,1.89-3.82,2.72c0.56,1.04,1.16,2.05,1.8,3.04c2.23,1.52,4.57,2.87,6.96,4.1c1.76-0.04,3.51-0.32,5.25-0.53c2.18-1.18,4.07,2.1,1.22,2.51c-1.65,0.48-3.32,0.83-4.99,1.19c-1.98,3.8-4.07,7.55-5.56,11.57c3.6,4.66,8.7,9.03,14.52,10.34c0.56,0.06,1.68,0.18,2.24,0.24c0.73,0.05,2.18,0.16,2.91,0.21l1.31,0.03c-1.57,2.04-3.23,4.03-4.96,5.95l-0.46,0.55c-0.79,1.03-1.75,1.94-2.9,2.57l-0.8,0.52c0.99-0.38,1.87-0.13,2.62,0.75l0.97,0.5c0.53,0.21,1.59,0.64,2.13,0.85l0.61,0.36c1.54-2.01,3.15-3.95,4.83-5.82l0.46-0.53c0.8-1.02,1.75-1.9,2.75-2.73l0.42-0.57c0.27-0.98,0.84-1.73,1.72-2.23c0.61-0.99,1.1-2.03,1.48-3.12c0.36-0.95,0.71-1.9,1.07-2.85c2.33,0.83,4.68,1.61,7.05,2.33c0.81-0.38,2.42-1.14,3.23-1.52c-0.14-0.51-0.41-1.52-0.55-2.03c-0.81-1.22,0.19-3.21,1.7-2.16c1.89,0.66,3.8,1.37,5.81,1.51c1.01-0.12,1.93,0.11,2.77,0.69c0.73,0.14,2.2,0.43,2.93,0.57c1.02-0.03,1.88,0.34,2.56,1.12c1.74,0.99,3.71,1.48,5.62,2.04c1.35,0.17,2.33,1.14,3.14,2.16c0.72,0.89,1.59,1.59,2.6,2.11c1.67,0.69,3.31,1.46,4.91,2.32l0.78,0.43c0.98,0.43,1.54,1.18,1.69,2.27l0.34,0.91c0.85,0.58,1.37,1.36,1.57,2.37l0.29,0.73c0.92,0.44,1.53,1.15,1.83,2.13l0.33,0.64c2.2,3.86,5.06,7.42,6.47,11.69c0.37,2.61,0.62,5.25,0.75,7.9c1.43,0.72,2.69,1.74,3.72,2.98c0.45,0.51,1.34,1.54,1.79,2.06c1.46,3.03,1.53,6.45,1.91,9.74l0.06,0.87c0.08,3.9-0.08,7.8-0.12,11.7c0.09,4.67-0.44,9.82,2.34,13.86c0.78,1.11,1.41,2.32,1.83,3.63l0.4,0.96c0.6,1.22,1.06,2.52,1.24,3.88c0.04,4.18,2.96,7.21,7.13,7.43c1.13,0.12,1.74,0.75,1.84,1.9c0.43,2.14,1.01,4.33,2.3,6.13c0.7,0.73,1.06,1.61,1.06,2.63c0.87,1.88,2.33,3.39,3.62,4.99c1.05,0.95,1.24,2.41,1.2,3.76c0,2.61,0.3,5.51,2.48,7.27c0.98,0.86,1.85,1.85,2.56,2.95c0.43,0.5,1.28,1.51,1.7,2.01c1.21,1.09,2.4,2.19,3.54,3.35c0.48,0.44,1.44,1.33,1.92,1.77c-0.01-1.13-0.07-2.25-0.19-3.37c-0.89-0.56-1.35-1.35-1.4-2.36c-0.25-1.72-0.61-3.42-0.93-5.11c-0.27-1.41-0.52-2.82-0.77-4.23c0.95,1.41,1.9,2.82,2.84,4.24c0.57,0.9,1.21,1.76,1.91,2.57c0.82,0.6,1.29,1.42,1.42,2.43l0.23,0.76c0.96,0.37,1.64,1.03,2.05,1.98l0.51,0.72c0.78,1.01,1.8,2.07,1.67,3.46c0.07,1.77,0.19,5.29,0.25,7.05c1.55,1.72,3.06,3.47,4.5,5.29l0.77-0.12c1.19-0.4,2.27,0.37,3.06,1.18c1.23,1.09,2.66,1.95,4.21,2.52c1.14,0.2,1.75,0.85,1.83,1.95c0.03,0.23,0.09,0.7,0.11,0.93c3.98,0.29,7.94,0.73,11.89,1.31c2.31,1.2,4.04,3.26,6.36,4.46c1.13,0.17,2.28,0.46,3.2,1.2c2.2,1.37,4.42,2.7,6.52,4.23c1.07,0.54,1.59,1.65,1.94,2.75l0.35,0.77c0.82,0.6,1.31,1.4,1.48,2.41c0.47,1.4,1.42,2.63,2.56,3.56c3.62,1.77,7.67,2.93,11.7,2.06c0.65,0.53,1.31,1.07,1.97,1.61c0.89,0.61,1.22,1.47,1,2.58c0.02,0.95,0.05,2.85,0.07,3.8c0.07,0.97,0.2,2.91,0.27,3.88l-0.47,0.43l-0.81,0.82c-1.12,1.29-2.29,2.53-3.47,3.76c-0.92,1.14-1.57,2.54-1.78,4c0.07,1.02-0.21,1.93-0.86,2.72c0.07,0.51,0.21,1.54,0.29,2.05c0.58,0.86,0.76,1.8,0.53,2.81c-0.06,0.58-0.19,1.75-0.25,2.33c0,1.35-0.42,2.65-0.99,3.87c-3.28,4.89,0.22,10.28,4.09,13.3c0.87,0.59,1.3,1.43,1.29,2.51l0.21,0.99c0.55,0.86,0.74,1.8,0.57,2.82c-0.08,1.57,0.61,3.05,1.41,4.37c0.74,1.11,1.33,2.32,1.76,3.59c0.22,0.46,0.66,1.37,0.88,1.83c1,1.31,1.99,2.63,2.89,4.02c0.6,0.88,1.28,1.69,2.05,2.43c2.23,1.97,4.52,3.84,6.84,5.71l0.82,0.58c0.26,0.18,0.79,0.54,1.05,0.72c-0.06,0.89-0.16,2.66-0.22,3.55c-0.12,2.02-0.36,6.06-0.48,8.08c-0.12,1.19-0.36,3.56-0.48,4.74c-0.21,1.66-0.35,3.34-0.42,5.02c0.07,1.17-0.16,2.33-0.58,3.43c-0.36,1.29-0.57,2.61-0.65,3.95c-0.52,7.56-0.05,15.36-2.29,22.68c-0.4,1.31-0.83,2.61-1.12,3.96c-0.08,1.01-0.49,1.86-1.25,2.54l-0.54,0.76c-0.29,6.19-0.28,12.4-0.39,18.62c0.01,2.93,0.4,5.85,0.73,8.77c0.19,1.04-0.13,1.9-0.98,2.61l-0.66,0.85c-0.53,1.09-1.32,1.45-2.38,1.07c0.65,2.08,1.4,4.14,1.89,6.28c0.64,3.28,0.71,6.58,0.98,9.93c0.15,2.62,0.29,5.26,0.4,7.91c0.89,0.75,1.78,1.51,2.67,2.28c2.52,2.16,4.89,4.47,7.35,6.71c3.25,2.62,7.76,0.42,11.53,0.34c-0.84-0.93-1.7-1.83-2.57-2.7c-0.99-0.88-1.81-1.92-2.51-3.02l-0.5-0.65c-0.87-0.56-1.4-1.34-1.58-2.34c-0.35-1.06-0.73-2.11-1.16-3.13c-0.54-1.31-1.08-2.61-1.61-3.91c0.82-0.91,1.65-1.8,2.46-2.71c2.79-3.28,5.16-7.31,5.64-11.61c-0.45-0.81-0.87-1.63-1.25-2.45c-0.59-1.18-1.23-2.32-1.84-3.47c1.52-1.89,3.13-3.7,4.71-5.54c1.06-1.29,1.89-2.75,2.6-4.25c1.08-2.38,2.16-4.75,3.27-7.11l0.33-0.74c0.52-1.36,1.29-2.76,2.75-3.27c0.51-0.26,1.53-0.79,2.04-1.05c2.54-1.33,5.07-2.68,7.52-4.15c0.69-2.65,0.41-5.4,0.36-8.09c2.11-1.02,4.38-1.89,6.13-3.5c0.87-0.96,1.81-1.84,2.83-2.64c1.96-1.62,2.4-4.29,2.74-6.66c0.04-1.07,0.56-1.83,1.56-2.27l0.61-0.45c0.57-0.84,1.34-1.37,2.34-1.57c1.67-1.77,2-4.3,2.48-6.58c0.51-2.74,0.96-5.53,1.55-8.23l0.14-0.59c0.38-1.78,2.18-2.65,3.49-3.67l0.84-0.63c1-0.87,2.12-1.64,3.42-1.98c1.65-0.61,3.34-1.18,4.9-2.02c0.92-1.1,1.88-2.18,2.89-3.2c1.86-1.98,3.01-4.53,3.57-7.16c0.23-1.3,0.65-2.56,1.14-3.78c1.35-4.8,0.75-9.98,2.15-14.75c0.97-1.95,2.17-3.77,3.39-5.58C318.94,360.125,320.97,355.295,320.03,350.335z M201.62,108.035c1.3-1.03,2.87,1.21,1.56,2.15C201.86,111.255,200.3,108.975,201.62,108.035z M160.23,91.855l-1.2,0.51c-2.9,2.15-6.3,3.57-9.96,3.77l0.76-0.25c-2.64,0.37-5.3,0.58-7.97,0.64c-2.68-0.07-1.45-5.11,1.01-3.92c2.06-0.02,4.12-0.03,6.19-0.08c3.98-1.16,8.33-2.5,12.34-0.78L160.23,91.855 M220.38,271.435c1.05-0.17,1.87,0.23,2.46,1.2l0.57,0.55c3.09,2.48,6.34,4.75,9.63,6.97c3.54,0.04,7-0.77,10.46-1.43c0-1.01,0.01-3.04,0.01-4.06c-0.29,0.02-0.89,0.05-1.18,0.07c-1.05,0.11-1.86-0.32-2.43-1.27c-0.5-0.45-1.51-1.37-2.02-1.82c-1.31-0.98-2.58-2.01-3.76-3.12c-0.88-0.78-1.76-1.53-2.66-2.26l-0.34,1.07c-0.08,2.57-2.4,2.54-3.98,1.18l-0.85-0.41c-0.98-0.33-1.68-0.96-2.1-1.91c-0.72-0.78-1.55-1.41-2.49-1.9c-2.11-1-4.26-1.93-6.44-2.74c-1.16-0.25-2.31-0.19-3.43,0.16c-2.3,0.78-4.55,1.68-6.82,2.49c0.46,1.39,0.93,2.79,1.4,4.18c3.95-0.84,8.1-1.22,11.75,0.89c1.19,0.34,1.6,1.09,1.23,2.26L220.38,271.435z'/></svg>"
	              ],[
	                "sub_saharan_africa",
	                "Sub-Saharan Africa",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='sub_saharan_africa' d='M488.08,345.035c5.11-10.88,14.33-19.02,20.83-28.98c3.28-6.75,5.42-14.26,5.12-21.82c-4.56,1.59-9.14,3.19-13.67,4.84c-1.21,0.87-2.79,0.27-3.09-1.19l-0.48-0.92c-1.47-2.71-2.98-5.4-4.4-8.13c-4.72-7.55-8.46-15.7-11.36-24.12c-6.5-0.32-12.99-1.01-19.5-0.67c-3.83,1.29-6.55,4.65-10.11,6.5c-5.98-1.5-10.87-5.94-16.83-7.39c-11.42-0.79-19.79,8.42-28.23,14.57c-6.29-6.06-12.33-12.36-18.54-18.5c-1.77-1.59-3.57-3.15-5.43-4.62c-4.34-2.86-9.65-3.57-14.65-4.58c-5.4,4.16-7.36,11.61-9.44,17.91c0.35,8.3,0.43,16.66-1.15,24.89c1.67,0.73,3.35,1.49,5.09,2.06c1.04,0.24,2.42,0.78,2.33,2.1c0.89,6.5,1.7,13.87,7.64,17.84c2.9,4.07,9.61,6.35,13.61,2.58c0.89-1.13,2.41-1.25,3.58-0.46c5.3,2.98,10.55-1.13,15.91-1.18c4.74,1.87,8.9,4.86,13.16,7.6c-0.62,4.54-1.44,9.09-1.16,13.7c2.11,5.98,8.03,10.05,9.24,16.42c2.56,8.84-1.93,17.43-2.92,26.09c-0.65,8.14,3.8,15.16,6.28,22.58c0.52,1.8,0.77,3.67,0.76,5.63c-0.33,7.45,3.61,13.84,5.72,20.7c0.43,4.23,3.12,7.44,5.54,10.67c5.88-2.56,13.43-1.47,18.23-6c0.35-0.95,0.99-1.63,1.92-2.04c5.03-4.33,8.65-10.45,10.18-16.92c0.91-3.6,3.23-6.52,5.33-9.49c3.47-5.2-0.62-11.99,2.91-17.22c2.82-4.1,7.5-6.21,11.65-8.73C490.87,367.495,486.8,356.435,488.08,345.035 M511.44,359.355c-1.12,0.4-2.23,0.81-3.34,1.22c2,8.17-7.02,12.62-10.6,18.7c-1.28,6.86-2.24,13.9-2.13,20.91c0.09,1.22,0.14,2.44,0.17,3.67c-0.27,1.6,0.69,3.59,2.54,3.48c0.97-0.01,1.95,0.05,2.93,0.16c1.47,0.12,2.95,0.22,4.44,0.31c2.46-9.41,4.82-18.85,7.04-28.32c1.41-5.41-1.91-11.14,0.56-16.4C512.51,361.835,511.97,360.595,511.44,359.355z'/></svg>"
	              ],[
	                "east_asia_pacific",
	                "East Asia & Pacific",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='east_asia_pacific' d='M673.78,359.585c1.46,1.17,2.93,2.37,4.62,3.23c2.09-2.16,4.08-4.44,5.93-6.82c-8.72,2.34-16.34-5.53-25.18-1.45c-1.03,0.4-1.94,0.24-2.73-0.46c-4.84-4.17-10.66-6.75-17.2-6.55c-1.27-0.05-1.79-0.68-1.57-1.9c0.17-1.64,0.37-3.28,0.48-4.91c0.03-1.18,0.1-2.34,0.2-3.5c-1.12-1.44-2.53-2.6-3.85-3.81c-1.09-6.14-1.85-12.37-3.76-18.33c-1.72-3.65-5.16-6.21-6.8-9.9c-0.54-3.21,0.4-6.45,0.62-9.65c4.63,2.68,7.54,7.26,10.73,11.39c3.93-2.52,7.66-5.55,10.13-9.58c0.92-6.9-2.27-13.36-5.55-19.17c-1.79-2.71-0.06-5.83,0.57-8.6c1.45,0,2.91,0,4.37,0.01c-1.13,2.28-2.32,4.52-3.45,6.79c1.75,1.14,3.52,2.28,5.3,3.41c2.72-4.47,3.4-10.99,8.99-12.92c5.66-1.83,11.2-5.22,12.78-11.45c0.19-1.01,0.74-1.76,1.65-2.26c2.63-2.21,3.59-5.83,3.45-9.15c-0.05-1-0.05-1.99,0.01-2.97c0.36-5.74-2.52-10.9-4.7-16.01c2.42-2.33,4.68-4.82,6.89-7.34c-1.89-0.71-3.8-1.39-5.69-2.07c2.26-1.55,4.64-2.92,6.99-4.34c2.78,5.42,4.8,11.15,6.72,16.92c2.27-1.04,4.51-2.18,6.7-3.41c-1.55-7.61,0.35-15.09,1.16-22.61c0.2-3.31,0.58-6.58,1.13-9.83c1.93-2.68,4.22-5.09,6.48-7.51c-5.43-1.11-9.5-5.07-13.27-8.84c-3.16-3.51-3.2-8.54-4.13-12.93c-2.61-0.44-5.08-0.84-7.64-1.26c-2.02,4.14-2.97,9.41-6.5,12.45c-7.78,0.26-15.41,1.65-23.11,2.61c-7.94-2.57-15.44-6.53-23.21-9.66c-0.96,2.69-1.6,5.48-2.53,8.19c-5.15-1.23-10.96-3.49-16.05-0.7c-6.92,3.8-12.21,9.89-17.81,15.33c-4.57,3.74-2.78,10.8-7.27,14.61c-2.84,3.03-7.1,4.04-10.66,5.8c0.78,2.66,1.56,5.35,2.66,7.9c3.58,6.07,10.11,11.34,9.06,19.04c1.46,0.12,2.04,0.91,1.74,2.36c1.68,0.49,3.34,1.04,5,1.62c1.47,0.32,2.05,1.18,1.75,2.57c3.69,1.22,7.36,2.51,11.14,3.41c0.09-1.88,2.77-2.14,3.26-0.34c5.16-1.63,10.4-3.01,15.74-3.96c-0.39,10.36-6.57,18.96-10.55,28.14c-0.57,3.1,1.76,5.75,3.84,7.74c1.24,0.74,1.48,2.33,0.57,3.44c-0.34,0.73-1.04,2.2-1.38,2.93c2.27-0.22,4.55-0.47,6.83-0.72c1.46,4.8,3.78,9.65,2.78,14.77c-1.06,6.75,2.27,12.96,4.23,19.18c-3.76-1.78-7.58-3.45-11.61-4.52c0.85,3.8,1.4,7.78,3.87,10.94c6.44,9.51,11.34,20.71,21.1,27.36c1.07,0.44,1.51,1.21,1.33,2.3c-0.06,0.47-0.17,1.4-0.23,1.87c1.86-0.17,3.72-0.34,5.6-0.5c1.8-0.41,3.47,0.45,5.02,1.27c6.09,1.79,12.33,3.25,18.58,4.49C669.74,362.315,671.77,360.595,673.78,359.585 M691.93,240.635c1.09-0.46,2.19-0.91,3.31-1.35c0.229-1.49,0.479-2.96,0.74-4.44c0.14-1.11,0.81-1.68,2.01-1.69c6.03-1.36,11.64-4.12,17.6-5.75c1.32-5.8,3.39-11.49,3.68-17.47c-0.03-1,0.07-1.98,0.3-2.95c0.21-1.17,0.43-2.33,0.66-3.49c3.38-2.03,5.46-5.39,6.98-8.93c-2.29-1.45-4.49-3.07-6.96-4.2c-0.58-0.22-1.74-0.65-2.32-0.87c-2.2,5.1-7.26,10.67-3.86,16.32c0.82,1.06,1.22,2.59,0.17,3.67c-2.01,4.77-6.88,6.98-10.1,10.75c-4.21,4.14-9.85,6.39-14.81,9.44C690.25,233.325,691.12,236.955,691.93,240.635 M672.63,254.455c-4.63,3.53-5.19,9.39-3.15,14.67c2.53-0.86,3.6-3.21,3.04-5.76c-0.23-1-0.06-1.93,0.5-2.79C673.27,258.525,672.84,256.475,672.63,254.455 M684.31,305.865c-1.21-2.6-4.32-3.46-6.51-4.89c-0.41-1.04-0.82-2.07-1.22-3.1c0.61,0.07,1.84,0.22,2.45,0.29c1.17,0.01,1.81,0.6,1.91,1.77l0.11,0.62c-0.18-6.63-5.98-11.05-6.71-17.51c-0.29-0.97-0.33-1.95-0.1-2.94c0.12-1.02,0.37-3.08,0.49-4.11c-2.31,0.86-4.56,1.83-6.77,2.89c1.53-0.78,1.98,1.32,1.05,2.18c-2.58,4.38,0.16,9.5,1.25,13.88c1.79,5.69,2.71,11.61,3.67,17.47c2.35,1.86,5.14,3.06,7.74,4.54C683.42,313.545,685.43,309.925,684.31,305.865 M667.62,296.795c-3.66,2.94-7.17,6.78-7.05,11.79c1.01-0.04,3.03-0.11,4.04-0.14C665.91,304.645,667.07,300.785,667.62,296.795 M770.41,322.895c-0.63,0.21-1.9,0.62-2.53,0.82c2.58,3.25,5.3,6.39,7.44,9.97c1.87-3,5.92-6.7,2.96-10.29c-0.68-0.78-0.98-1.67-0.89-2.69c-0.27-2.58-1.59-4.87-2.62-7.19c-2.53,0.54-5.05,1.13-7.6,1.51c0.02-1.65,0.04-3.31,0.02-4.95c0.14-0.55,0.42-1.65,0.56-2.2c-0.81-0.11-2.43-0.32-3.24-0.43c-0.05,4.21-0.07,8.42-0.08,12.64c2.34,0.16,4.68,0.02,7.03,0.17C773.84,320.375,771.94,323.065,770.41,322.895 M651.81,319.775c-2.78,3-6.91,4.45-9.38,7.72c-1.84,2.22,0.1,4.87,0.92,7.09c2.32,4.22,4.22,11.11,10.73,9.48c4.49,1.37,7.38-2.16,10.35-4.63c0.79,3.51,1.47,7.03,2.24,10.56c2.42-1.41,5.85-2.03,7.44-4.36c-0.31-8.07,5.5-14.08,7.37-21.54c-3.15,0.98-6.43,1.8-9.61,2.57c-1.14-0.18-3.43-0.54-4.58-0.72c-0.46-0.16-1.37-0.48-1.83-0.65c0.87-3.49,1.63-7.03,1.88-10.63c-1.52-1.11-4.58-3.35-6.1-4.47C657.38,312.615,655.24,316.865,651.81,319.775 M716.22,314.735c-0.7,2.41-1.53,4.75-2.14,7.19c2.21-0.34,4.45-0.56,6.7-0.62c2.33-0.21,4.66-0.43,6.99-0.69c0.86-0.11,1.75-0.23,2.64-0.35c2.13,3.19,4.69,6.06,7.35,8.83c0.61-5.42-2.51-10.07-5.11-14.5C727.25,315.965,721.66,315.605,716.22,314.735 M745.38,325.445c0.99-0.68,1.98-1.36,2.99-2.03c0.01-0.85,0.05-2.55,0.07-3.39c-1.24,0.36-2.47,0.74-3.68,1.14c-0.55,0.02-1.66,0.04-2.21,0.06c0.06,0.83,0.18,2.51,0.24,3.34C743.76,324.505,744.63,324.795,745.38,325.445 M754.89,329.085c1.41-1.37,2.81-2.76,4.18-4.18c-1.57-0.18-3.14-0.35-4.69-0.51C754.54,325.955,754.71,327.515,754.89,329.085 M784,335.575c0.54,0.85,0.73,1.78,0.55,2.79c0.04,4.68,0.6,11.77,6.25,13.2c1.24,0.42,2.42,1.11,3.15,2.25l0.54,0.66c-0.1-4.59-3.38-7.58-5.36-11.28c-1.65-5.98,0.69-13.84-5.5-17.62C783.7,328.915,783.47,332.245,784,335.575 M738.22,351.265c2.28-1.87,2.94-4.92,3.98-7.54c-3.94,1.24-7.93,2.31-12,3c-2.32-3.02-4.71-6.29-8.55-7.44c-4.96-2.08-10.62-5.53-16.02-2.74c-3.32-3.38-7.52-5.99-12.54-5.71c0.63,4.98,1.42,10.02,3.73,14.54l1.31-0.02c1.86-0.06,3.72,0.2,5.58,0.77c1.35,0.38,2.71,0.78,4.08,1.2c0.16,3.48,0.17,6.98-0.01,10.46c5.79,1.61,12.23,3.66,17.67-0.04c3.17,3.67,7.41,5.98,12.14,7.12c0.23-1.55,0.71-4.65,0.94-6.19c-2.38-1.46-4.77-2.91-7.15-4.37c0.24-0.97,0.5-1.92,0.77-2.88C734.16,351.565,736.26,351.985,738.22,351.265 M747.51,336.595c1.25-0.08,2.51-0.15,3.77-0.21c0.43-1.03,0.86-2.05,1.31-3.06c-1.69-0.35-3.38-0.7-5.05-1.06C747.53,333.705,747.52,335.145,747.51,336.595 M740.72,357.255c3.73,5.23,7.87,12.81,15.28,12.14c-0.18-0.56-0.54-1.67-0.72-2.22C755.01,360.005,746.17,358.795,740.72,357.255 M732.82,389.945c-3.18-4.36-3.65-9.92-6.24-14.55c-2.65-4.47-3.5-10.4-8.64-12.82c-1.37,5.26-2.32,10.61-3.11,16c0.24,1.43-1.62,2.05-2.38,0.88c-3.72-2.13-5.71-5.84-5.91-10.22c-0.44-1.1-0.59-2.38,0.05-3.43l0.46-1.11c-3.66-0.73-7.43-1.31-11.17-0.83c-4.22,1.41-5.51,6.3-7.89,9.56c-1.01-1.29-2-2.6-2.96-3.91c-4.9,4.1-13.1,6.94-12.4,14.59c-0.05,1.28-0.33,2.89-1.77,3.29c-5.3,2.55-10.89,4.52-15.89,7.66c-1.5,0.99-2.58,2.57-2.64,4.42c-1.65,13.09,5.13,25.3,5.65,38.3c1.33-0.09,2.68-0.18,4.03-0.28c0.97-0.11,1.96-0.14,2.96-0.08c9.6-0.06,17.45-6.79,26.521-8.85c4.88-1.58,8,2.36,10.39,5.67c2.44,3.52,6.3,5.52,9.75,7.89c1.16,3,1.44,6.91,4.12,9.14c3.58,0.61,7.22-0.03,10.8-0.46c3.5-0.72,8.19-0.65,10.47-4.02c0.55-1.06,1.34-1.39,2.38-0.98c-0.11-7.39,2.05-14.43,5.78-20.78c0.08-0.56,0.23-1.68,0.31-2.24c0.56-5.14-0.03-10.4-0.92-15.45C742.11,400.645,735.92,396.295,732.82,389.945 M774.13,387.045c-2.23-1.19-4.52-2.24-6.85-3.19c0.84,6.64,1.34,13.59,4.35,19.7C777.2,399.325,771.4,392.495,774.13,387.045 M794.97,401.925c-2.66,2.09,1.33,2.19,2.9,2.5c0.57,0.02,1.71,0.05,2.27,0.07c2.72-0.38,3.11-4.32,4.28-6.4c-2.6,0.35-5.12,0.95-7.56,1.79C796.5,400.815,795.87,401.495,794.97,401.925 M813.64,398.695c-2.08,2.31-3.9,4.88-5.24,7.7c-1.62,2.94,1.29,5.67,2.64,8.08c1.5-3.68,3.25-7.48,3.15-11.53C813.98,401.525,813.75,400.115,813.64,398.695 M788.49,435.135c1.1,4.84,3.229,9.63,2.34,14.71c-1.56,4.38-5.11,7.65-7.52,11.56c-2.55,4.47-7.13,7.01-11.11,9.98c0.12,4.16,2.72,9.01,7.91,6.7c3.73,0.13,5.64-3.56,5.23-6.87c-0.18-1.11,0.19-1.94,1.1-2.52c7.36-4.71,12.74-12.19,14.63-20.71c0.09-0.96,0.33-1.89,0.71-2.76C795.11,445.265,792.08,439.535,788.49,435.135 M723.63,455.055c1,4.84,2.04,9.71,3.71,14.37c5.46-2.19,8.23-7.54,7.8-13.37C731.27,456.055,727.42,455.755,723.63,455.055z'/></svg>"
	              ],[
	                "south_asia",
	                "South Asia",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='south_asia' d='M601.63,246.995c-1.07,0.51-2.16,0.62-3.26,0.34c-3.78-0.9-7.45-2.19-11.14-3.41c-1.28-0.34-1.86-1.2-1.75-2.57c-1.66-0.58-3.32-1.13-5-1.62c-1.29-0.26-1.88-1.04-1.74-2.36c1.05-7.7-5.48-12.97-9.06-19.04c-3.8,0.06-7.53,0.15-11.31,0.2c-0.73-0.14-2.2-0.42-2.94-0.56c-6.29,1.78-12.33,4.28-18.51,6.36c-3.12,8.02,0.28,16.11,2.42,23.86c2.17,4.11-1.04,7.46-2.88,10.72c3.76,0.44,7.52,0.82,11.31,1.26c3.44,5.13,8.18,9.16,12.36,13.65c2.5,5.67,2.57,12.13,5.07,17.83c2.35,5.49,3.82,11.29,5.51,17.01c1.95-0.71,3.89-1.43,5.83-2.16c0.76,2.94,1.48,5.9,2.28,8.86c1.94-0.91,3.93-1.79,5.63-3.12c0.2-5.39-4.38-9.48-4.46-14.8c-0.021-4.48-1.46-9.7,2.32-13.11c4.66-5.32,9.59-10.53,15.38-14.64c3.07,0.03,6.11,0.85,9.13,1.48c3.98-9.18,10.16-17.78,10.55-28.14C612.03,243.985,606.79,245.365,601.63,246.99 M591.761,303.9c0,6.72,0.83,13.56-0.69,20.19c1.29,0.4,2.56,0.81,3.87,1.2c3.3-6.65,2.56-14.28,0.82-21.29C594.421,303.96,593.091,303.93,591.761,303.9z'/></svg>"
	              ],[
	                "middle_east_north_africa",
	                "Middle East & North Africa",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='middle_east_north_africa' d='M539.34,248.195c-2.14-7.75-5.54-15.84-2.42-23.86c-2.55-2.9-4.72-6.23-7.82-8.55c-3.76,0.07-7.32,1.15-10.88,2.17c-3.09-0.28-5.96-1.47-8.81-2.57c-3.41-1.2-6.9-2.16-10.37-3.16c-0.29,1.63-0.88,4.87-1.17,6.5c-5.93,0.71-11.98,0.86-17.75,2.52c-2.52,0.6-2.94,3.38-3.46,5.49c-0.93,3.22-1.05,7.96-4.96,9.05c-8.68,2.12-17.59-0.32-25.24-4.46c-2.21,2.25-4.4,4.52-6.57,6.8c-4.71-2.71-9.39-5.47-14.02-8.3c-1.19-3.9-1.29-8.46-3.94-11.78c-3.08-2.15-7.27-0.19-10.57-0.3c-8.18,0.62-16.06,2.8-24.04,4.54c-1.61,0.37-3.24,0.7-4.85,1.04c-3.75,5.03-8.11,9.99-8.7,16.54c-0.25,3.94-4.05,5.46-7.03,7.06c-0.11,0.71-0.32,2.14-0.42,2.85c0.35,0.06,1.06,0.18,1.42,0.25c5,1.01,10.31,1.72,14.65,4.58c1.96,1.35,3.73,2.96,5.43,4.62c6.21,6.14,12.25,12.44,18.54,18.5c8.44-6.15,16.81-15.36,28.23-14.57c5.96,1.45,10.85,5.89,16.83,7.39c3.56-1.85,6.28-5.21,10.11-6.5c6.51-0.34,13,0.35,19.5,0.67c-1.49-4.16-3.04-8.29-4.39-12.49c7.47,11.08,12.24,23.78,15.75,36.61c1.42,2.73,2.93,5.42,4.4,8.13c9.35-5.37,19.76-9.02,27.99-16.19c3.55-4.15,6.63-8.67,9.82-13.09c-2.02-3.28-3.91-6.63-5.5-10.14c2.46,0.42,4.91,0.88,7.36,1.37C538.3,255.655,541.51,252.305,539.34,248.195z M514.19,255.825c-2.91-3.79-4.66-8.33-5.75-12.95c4.8,4.17,9.01,9.01,12.95,14C519.02,256.865,515.88,258.145,514.19,255.825z'/></svg>"
	              ],[          
	                "europe_central_asia",
	                "Europe & Central Asia",
	                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 833 532'><path id='europe_central_asia' d='M527.62,81.815c-1.81-4.6-3.69-9.97-0.39-14.54c5.21-8.59,15.11-11.99,24.07-15.18c3.03-0.96,3.76-4.4,5-6.91c-7.53-0.09-14.66,2.35-21.78,4.44c-3.29,1.39-7.55,2.13-9.06,5.83c-4.25,6.76-8.13,13.75-12.72,20.29C515.48,81.435,521.66,83.515,527.62,81.815 M341.44,55.475c2.64-5.77,2.33-12.32,3.2-18.47c2.12-5.6,7.66-8.51,12.64-11.14c-2.48-4.16-7.41-4.5-11.73-5.39c-1.93-4.7-5.32-9.04-10.31-10.7c-6.87-3.27-14.33,0.62-21.45-1.67c-0.25,1.23-0.74,3.68-0.99,4.91c-9.18-5.71-20.98-4.25-30.18,0.55c-2.57,2.44-4.15,5.811-7.13,7.86c-0.84,0.83-1.73,0.88-2.67,0.14l-1-0.64c0.11,2.5,0.33,7.51,0.44,10.01c2.76,5.82,9.96,5.83,15.44,6.91c1.62,8.65,2.63,17.41,3.47,26.16c-0.36,4.92-3.41,9.54-2.26,14.57c0.59,0.83,0.8,1.76,0.63,2.77c-1.49,7.83,3.9,13.85,10.46,16.91c2.5-5.38,5.09-10.73,7.75-16.03c6.5-1.83,12.02-5.88,18.47-7.86c3.54-1.57,8.57-2.06,9.74-6.47c1.76-4-1.85-7.38-4.19-10.16C334.89,56.945,339.65,58.825,341.44,55.475 M782.56,84.155c-0.47,1.66-0.93,3.31-1.37,4.97c-7.42-4.41-16.63-3.57-24.01-8.03c-3.6-1.87-8.34-4.57-11.86-1.13c-0.67,1.11-2.27,1.19-2.73-0.14c-1.93-2.52-4.26-4.72-6.5-6.93c-2.9-1.18-6.16-0.08-9.1-1.11c-2.08-0.67-4.09-1.6-6.23-2.06c-1.22-0.07-2.43-0.15-3.63-0.26c-3.82-0.47-6.46,2.71-8.73,5.25c-0.65,0.86-1.51,1.19-2.58,0.99c-5.28-0.07-10.45,1.31-15.52,2.62c-1.25-3.96-2.14-8.02-3.06-12.05c-3.4-0.93-6.9-1.53-10.4-1.78c-1.15,1.67-2.18,3.45-3.67,4.83c-7.39-2.12-14.71-4.59-22.08-6.8c4.31-4.31,3.24-10.23,1.69-15.56c-4.26-1.08-9.13-0.43-12.88-3.02c-2.73-1.15-5.55-4.33-8.78-2.89c-4.63,1.89-7.72,6.08-11.67,8.99c-0.94,1.22-2.53,0.86-3.63,0.13c-3.57-2.12-7.39,0.33-10.92,1.18c-3.15,1.06-6.58,1.43-9.43,3.17c-1.81,2.24-2.25,5.26-3.29,7.9c-3.35,0.92-6.69,1.79-9.97,2.88c-1.07,0.46-2.38,0.73-3.38-0.02c0.26,1.85,0.56,3.69,0.9,5.52c-1.38,0.87-2.76,1.75-4.07,2.7c-1.01,1.03-2.92,1.68-3.77,0.1c-1.22-1.48-2.42-2.97-3.62-4.46c-1.52,1.45-3,2.93-4.49,4.39c-0.29-1.5-0.56-3-0.83-4.5l-0.86,0.32c-0.58,0.08-1.73,0.23-2.3,0.31c-0.68-0.02-2.04-0.06-2.72-0.08c-1,0.05-1.99,0.06-2.97,0.03c-6.52,2.06-5,11.43-6.64,16.52c-2.74,0.12-8.21,0.37-10.95,0.49c-0.51,0.22-1.51,0.66-2.02,0.88c-6.07,4.03-13.7,2.67-20.54,3.83c-3.68,0.95-6.63,3.67-8.44,6.92c-0.37,1.29-2.96,3.74-3.3,1.27c-0.13-2.59,0.18-5.17,0.1-7.75c-1.56,0.02-3.09,0.22-4.62,0.42c-0.48,3.08-0.89,6.17-1.35,9.26c-0.96-0.03-1.91-0.06-2.85-0.08l-0.69-0.01c-0.12-0.56-0.35-1.69-0.47-2.25c0.55-4.48-4.63-5.86-7.42-8.12c-4.37-3.11-10.29-2.92-14.51-6.16c-1.89-3-4.35-6.24-8.3-5.63c-1.74,0.02-3.44,0.04-5.11,0.04c-3.89,0.05-7.2,2.34-10.38,4.3c-6.12,4.05-13.19,7.44-17,14.05c-3.09,3.72-4.11,8.54-6.6,12.59c-3.87,4.99-9.23,8.49-14.39,11.98c0.13,0.45,0.39,1.33,0.52,1.77c0.49,1.64,0.45,3.33-0.13,5.08c-0.65,4.67,0.22,9.36,1.08,13.95c3.49-1.03,7.01-2.11,10.44-3.38c-5.19,4.58-4.51,11.72-4.79,18.07c-5.61,0.48-9.03,4.69-12.28,8.67c-2.82-4.04-4.19-8.88-6.79-13.04c-3.39-4.97-2.78-11.3-4.86-16.78c-3.85,0.59-7.93,2.12-9.09,6.15c-1.5,5.26-5.89,8.7-8.52,13.26c-0.29,3.7-1.17,7.83,0.59,11.34c2.66,2.02,5.88,0.05,8.62-0.7c-1.86-2.64,2.4-3.49,1.38-0.3c-0.23,2.29-0.66,4.54-1.09,6.8c1.13,0.05,2.27,0.09,3.41,0.12c0.99-0.04,1.96,0.08,2.92,0.36c0.53,0.12,1.58,0.37,2.1,0.5c0.13,0.61,0.38,1.83,0.51,2.44c-1.7,0.42-5.09,1.26-6.79,1.68c2.46,4.73,5.97,8.77,9.08,13.07c-1.47,1.59-2.98,3.15-4.37,4.82c-0.56,1.31-2.18,1.05-2.73-0.11c-3.2-4.36-8.71-1.13-12.91-0.28l0.48,1.12c0.09,0.57,0.27,1.71,0.36,2.28c-0.18,3.27-0.21,6.55-0.1,9.82c-0.01,0.57-0.02,1.72-0.03,2.29c-1.01,5.3,2.93,9.34,6.84,12.16c1.61-0.34,3.24-0.67,4.85-1.04c3.93-1.6,8.15-3.58,10.14-7.58c3.83-9.05,11.45-15.77,20.29-19.76c4.51,6.36,11.12,11,14.27,18.37c-2.63,1.19-5.01,2.52-7.52,3.83c1.89,1.64,3.78,3.28,5.67,4.93c3.3-4.19,6.63-8.35,9.97-12.5c3.01,4.11,6.6,7.86,10.98,10.53c0.91-4.43,1.8-8.87,2.67-13.31c1.78,4.45,2.93,9.16,5.18,13.4c2.92,2.5,7.44,1.3,10.68,3.28c1.37,1.03,2.51,2.34,3.73,3.57c1.09-0.1,2.18-0.21,3.28-0.31c0.52-2.11,0.94-4.89,3.46-5.49c5.77-1.66,11.82-1.81,17.75-2.52c0.29-1.63,0.88-4.87,1.17-6.5c3.47,1,6.96,1.96,10.37,3.16c0.64-2.84,2.22-5.83,1.09-8.77c-1.88-5.67-4.27-11.17-5.61-17.01c3.46-1.03,6.89-2.32,10.5-2.77c2.05-0.38,0.94,2.57-0.5,2.53c-1.54,0.77-3.07,1.55-4.6,2.33c3.51,8.47,6.25,17.23,7.93,26.26c3.56-1.02,7.12-2.1,10.88-2.17c3.1,2.32,5.27,5.65,7.82,8.55c6.18-2.08,12.22-4.58,18.51-6.36c0.76-1.34,2.85-1.13,2.94,0.56c3.78-0.05,7.51-0.14,11.31-0.2c-1.1-2.55-1.88-5.24-2.66-7.9c3.56-1.76,7.82-2.77,10.66-5.8c4.49-3.81,2.7-10.87,7.27-14.61c5.6-5.44,10.89-11.53,17.81-15.33c5.09-2.79,10.9-0.53,16.05,0.7c0.93-2.71,1.57-5.5,2.53-8.19c7.77,3.13,15.27,7.09,23.21,9.66c7.7-0.96,15.33-2.35,23.11-2.61c3.53-3.04,4.48-8.31,6.5-12.45c2.56,0.42,5.03,0.82,7.64,1.26c0.93,4.39,0.97,9.42,4.13,12.93c3.77,3.77,7.84,7.73,13.27,8.84c-2.26,2.42-4.55,4.83-6.48,7.51c-0.55,3.25-0.93,6.52-1.13,9.83c3.57-2.16,7.68-3,11.79-3.44c2.33-3.44,4.73-6.82,7.14-10.21c3.52-4.73,3.61-10.92,5-16.44c0.34-0.46,1.02-1.38,1.36-1.84c0.11,0.38,0.34,1.14,0.46,1.52c0.39,5.9,0.36,11.82,0.59,17.73c0.58,0.22,1.74,0.65,2.32,0.87c2.51-2.36,2.13-6.16,2.76-9.21c1.33-7.43-0.54-15.01-1.69-22.31c-5.5-1.67-11.51-1.6-16.57-4.55c5.84-5.93,10.54-13.37,17.71-17.81c0.88-0.58,1.81-0.55,2.77,0.07c7.14,1.65,14.66,1.2,21.97,1.84c1.84-4.42,4.28-8.54,7.23-12.31c0.42-1.44,2.35-1.05,2.44,0.37c0.84,2.23,2.18,4.23,3.7,6.07c-4.17,5.31-8.48,10.49-13.43,15.09c0.47,7.37,1.65,14.67,3.36,21.85c0.76,0.01,2.28,0.04,3.04,0.05c5.11-6.79,9.88-13.92,13.45-21.65c1.55-3.07-0.6-6.21-1.42-9.16c3.15-1.99,6.47-3.78,9.42-6.09l0.49-0.41c0.91,0.25,2.74,0.73,3.65,0.98c0.94,0.28,1.89,0.56,2.85,0.84c5.1-6.6,13-10.06,21.08-11.21c-0.07-3.26-0.09-6.53,0.34-9.77c1.03-4.41,5.51-6.65,7.16-10.73c1.1-2.65,2.43-5.21,4.03-7.59C807.19,85.225,793.68,84.225,782.56,84.155z M385.7,162.815c-0.05-1.84-0.16-5.51-0.22-7.34c1.02,0.46,2.04,0.91,3.07,1.37C387.59,158.835,386.64,160.815,385.7,162.815z M394.6,173.925c-0.14-0.32-0.43-0.97-0.57-1.29C395.45,170.455,397.2,174.535,394.6,173.925z M438.12,204.965c-4.42-3.76-8.85-7.77-11.23-13.19c4.05,3.22,8.12,6.42,12.41,9.32C438.91,202.385,438.5,203.665,438.12,204.965z M444.704,121.556c0.179,3.023,0.504,6.094,0.636,9.14c1.19,2.4,2.7,4.63,4.09,6.94c-2.52,5.01-4.77,10.14-7.13,15.22c-5.5,0.7-10.72,2.77-16.23,3.35c1.14,1.52-2.28,2.63-2.17,0.7c-0.88-1.14-1.76-2.27-2.64-3.41c3.78,0.49,7.87,0.2,10.98-2.27c4.32-4.67,5.93-11.02,7.99-16.85c1.12-4.25-3.12-9.2,0.27-12.85c3.62-4.56,6.96-9.32,10.1-14.22c0.16,1.45,0.49,4.35,0.65,5.8C448.83,115.624,444.943,117.717,444.704,121.556z M454.54,132.865c0.94-1.11,2.72-1.21,4.05-0.85C460.19,133.855,454.77,134.815,454.54,132.865z M483.39,105.225c0.79,1.46,1.61,2.91,2.41,4.37c-3.5-0.36-7.11-0.62-10.28-2.27C478.12,106.565,480.75,105.865,483.39,105.225z M479.47,188.485c-1.11,1.45-3.02-0.54-1.66-1.66C478.93,185.465,480.92,187.385,479.47,188.485z M476.26,200.025c-1.23,1.23-2.44,1.22-3.64-0.01c-3.07,1.83-6.33,3.33-9.57,4.82c-0.51-2.02-1.2-4.04-1.19-6.15c1.32-3.52,3.58-6.61,5.46-9.86c4.19,5.28,11.54,2.83,16.76,6.08c2.16,2.88,4.09,5.95,5.91,9.07C485.23,203.475,480.48,202.345,476.26,200.025z M563.81,93.445c-1.04-1.29-1.04-3.57,0-4.86C565.41,89.035,565.41,92.995,563.81,93.445 M444.69,121.695c0.002-0.048,0.011-0.092,0.014-0.14c-0.011-0.173-0.025-0.348-0.034-0.521L444.69,121.695 M340.98,105.145c2.18,5.34,3.83,15.85,11.97,12.85c1.13-0.39,2.32-0.61,3.53-0.52c0.59,0.01,1.77,0.03,2.36,0.04c7,1.57,9.34-6.93,9.48-12.13C359.71,101.875,349.59,101.475,340.98,105.145 M413.6,206.395c0.53,2.06,1.9,4.81,4.19,5.07c0.56-0.03,1.68-0.08,2.25-0.11c0.35-0.23,1.05-0.68,1.4-0.9c-0.04-4.44-1.94-8.54-3.5-12.6C416.23,200.505,413.58,203.055,413.6,206.395 M450.56,221.285c-1.37,2.07-0.08,4.49,0.33,6.65c1.83-0.41,5.49-1.24,7.32-1.65C456.09,224.075,453.87,221.435,450.56,221.285z'/></svg>"
	            ]];
	            console.log(resp);
	          }      
	          
	          if(path.indexOf("?geo.cat=income_groups&select=geo,geo.name,shape_lores_svg")>-1) {
	            warn("WAFFLE READER: APPLYING STUB FUNCTIONALITY TO GET DATA income_groups, WHICH IS NOT YET IN WS");
	            resp.rows = [[
	                "lower_middle_income",
	                "Lower middle income",
	                null
	              ],[
	                "low_income",
	                "Low income",
	                null
	              ],[
	                "upper_middle_income",
	                "Upper middle income",
	                null
	              ],[
	                "high_income",
	                "High income",
	                null
	            ]];
	            console.log(resp);
	          }
	          
	          if(path.indexOf("?geo.cat=landlocked&select=geo,geo.name,shape_lores_svg")>-1) {
	            warn("WAFFLE READER: APPLYING STUB FUNCTIONALITY TO GET DATA landlocked, WHICH IS NOT YET IN WS");
	            resp.rows = [[
	                "landlocked",
	                "Landlocked",
	                null
	              ],[
	                "coastline",
	                "Coastline",
	                null
	            ]];
	            console.log(resp);
	          }
	
	          if(path.indexOf("?geo.cat=g77_and_oecd_countries&select=geo,geo.name,shape_lores_svg")>-1) {
	            warn("WAFFLE READER: APPLYING STUB FUNCTIONALITY TO GET DATA g77_and_oecd_countries, WHICH IS NOT YET IN WS");
	            resp.rows = [[
	                "others",
	                "Others",
	                null
	              ],[
	                "oecd",
	                "OECD",
	                null
	              ],[
	                "g77",
	                "G77",
	                null
	            ]];
	            console.log(resp);
	          }
	
	          if(path.indexOf("?geo.cat=main_religion_2008&select=geo,geo.name,shape_lores_svg")>-1) {
	            warn("WAFFLE READER: APPLYING STUB FUNCTIONALITY TO GET DATA main_religion_2008, WHICH IS NOT YET IN WS");
	            resp.rows = [[
	                "eastern_religions",
	                "Eastern religions",
	                null
	              ],[
	                "muslim",
	                "Muslim",
	                null
	              ],[
	                "christian",
	                "Christian",
	                null
	            ]];
	            console.log(resp);
	          }
	
	          //format data
	          resp = mapRows(this._uzip(resp.data || resp), this._parsers);
	
	          //cache and resolve
	          FILE_CACHED$3[path] = resp;
	
	          this._parse(p, query, resp);
	          FILE_REQUESTED$3[path] = void 0;
	        },
	
	        _readCallbackError: function (p, path, query, resp) {
	          p.reject({
	            'message' : this.ERROR_NETWORK,
	            'data': path
	          });
	        },
	
	        _uzip: function (table) {
	          var header;
	          var rows = table.rows;
	          var headers = table.headers;
	          var result = new Array(rows.length);
	          // unwrap compact data into json collection
	          for (var i = 0; i < rows.length; i++) {
	            result[i] = {};
	            for (var headerIndex = 0; headerIndex < headers.length; headerIndex++) {
	              header = headers[headerIndex];
	              result[i][header] = '';
	              if (!(typeof rows[i][headerIndex] == 'undefined' || rows[i][headerIndex] === null)) {
	                result[i][header] = rows[i][headerIndex].toString();
	              }
	              if (header === 'geo.cat') {
	                result[i][header] = [result[i][header]];
	              }
	            }
	          }
	          return result;
	        },
	
	        _parse: function (p, query, resp) {
	
	          var data = resp;
	
	          // sorting
	          // one column, one direction (ascending) for now
	          if(query.orderBy && data[0]) {
	            if (data[0][query.orderBy]) {
	              data.sort(function(a, b) {
	                return a[query.orderBy] - b[query.orderBy];
	              });
	            } else {
	              return p.reject({
	                'message' : this.ERROR_ORDERING,
	                'data': query.orderBy
	              });
	            }
	          }
	
	          this._data = data;
	          p.resolve();
	        }
	
	      });
	
	      var QueryEncoder = (function() {
	        return {
	          encodeQuery: encodeQuery
	        };
	
	        function encodeQuery(param) {
	          return mapParams()(param);
	        }
	
	        function mapParams(depth) {
	          if (!depth) {
	            return _map;
	          }
	
	          return _mapRange;
	        }
	
	        function _map(v, i) {
	          // if falsy value
	          if (!v) {
	            return v;
	          }
	
	          // if value is string or number
	          if (v.toString() === v || _isNumber(v)) {
	            return v;
	          }
	
	          // if value is array
	          if (Array.isArray(v)) {
	            return v.map(mapParams(1)).join();
	          }
	
	          if (typeof v === 'object') {
	            return _toArray(v).map(mapParams(1)).join();
	          }
	
	          return v;
	        }
	
	        function _mapRange(v) {
	          return encodeURI(v).replace(/,/g, ':')
	        }
	
	        function _isNumber(value) {
	          return parseInt(value, 10) == value;
	        }
	
	        function _toArray(object) {
	          return Object.keys(object).map(function(key) {
	            if (object[key] === true) {
	              return [key];
	            }
	
	            return [key, object[key]];
	          })
	        }
	      })();
	
	      var _index$1 = {
	      csv : CSVReader,
	      ddf : Ddf,
	      ddf1csv : DDF1CSVReader,
	      graph : GraphReader,
	      inline : InlineReader,
	      json : JSONReader,
	      waffle : WSReader,
	      };
	
	var readers = Object.freeze({
	      	csv: CSVReader,
	      	ddf: Ddf,
	      	ddf1csv: DDF1CSVReader,
	      	graph: GraphReader,
	      	inline: InlineReader,
	      	json: JSONReader,
	      	waffle: WSReader,
	      	default: _index$1
	      });
	
	      /*!
	       * VIZABI BUBBLE SIZE slider
	       * Reusable bubble size slider
	       */
	
	      var OPTIONS = {
	        EXTENT_MIN: 0,
	        EXTENT_MAX: 1,
	        TEXT_PARAMS: { TOP: 11, LEFT: 10, MAX_WIDTH: 42, MAX_HEIGHT: 16 },
	        BAR_WIDTH: 6,
	        THUMB_RADIUS: 10,
	        THUMB_STROKE_WIDTH: 4,
	        INTRO_DURATION: 250
	      }
	
	      var profiles = {
	          "small": {
	            minRadius: 0.5,
	            maxRadius: 40
	          },
	          "medium": {
	            minRadius: 1,
	            maxRadius: 55
	          },
	          "large": {
	            minRadius: 1,
	            maxRadius: 65
	          }
	      };
	
	
	      var BubbleSize = Component.extend({
	
	        /**
	         * Initializes the timeslider.
	         * Executed once before any template is rendered.
	         * @param config The options passed to the component
	         * @param context The component's parent
	         */
	        init: function (config, context) {
	
	          this.name = 'bubblesize';
	
	          this.template = this.template || "bubblesize.html";
	
	          this.model_expects = [{
	            name: "size",
	            type: "size"
	          }];
	
	          var _this = this;
	          this.model_binds = {
	            'change:size.domainMin': changeMinMaxHandler,
	            'change:size.domainMax': changeMinMaxHandler,
	            'change:size.extent': changeMinMaxHandler,
	            'ready': readyHandler
	          };
	          function changeMinMaxHandler(evt, path) {
	            var size = _this.model.size.extent||[OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
	            _this._updateLabels(size);
	            _this.sliderEl.call(_this.brush.extent(size));
	            if(size[0] == size[1]){
	              _this.sliderEl.selectAll(".resize")
	                .style("display", "block");
	            }
	          }
	          function readyHandler(evt) {
	              _this.sizeScaleMinMax = _this.model.size.getScale().domain();
	              _this._setLabelsText();
	          }
	
	          this._setModel = throttle(this._setModel, 50);
	          //contructor is the same as any component
	          this._super(config, context);
	        },
	
	        /**
	         * Executes after the template is loaded and rendered.
	         * Ideally, it contains HTML instantiations related to template
	         * At this point, this.element and this.placeholder are available as a d3 object
	         */
	        readyOnce: function () {
	          var _this = this;
	          var values = _this.model.size.extent||[OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
	          this.showArcs = _this.model.size.showArcs !== false;
	
	          this.element = d3.select(this.element);
	          this.sliderSvg = this.element.select(".vzb-bs-svg");
	          this.sliderWrap = this.sliderSvg.select(".vzb-bs-slider-wrap");
	          this.sliderEl = this.sliderWrap.select(".vzb-bs-slider");
	
	          var
	            textMargin = { v: OPTIONS.TEXT_PARAMS.TOP, h: OPTIONS.TEXT_PARAMS.LEFT },
	            textMaxWidth = OPTIONS.TEXT_PARAMS.MAX_WIDTH,
	            textMaxHeight = OPTIONS.TEXT_PARAMS.MAX_HEIGHT,
	            barWidth = OPTIONS.BAR_WIDTH,
	            thumbRadius = OPTIONS.THUMB_RADIUS,
	            thumbStrokeWidth = OPTIONS.THUMB_STROKE_WIDTH,
	            padding = {
	              top: thumbStrokeWidth,
	              left: textMargin.h + textMaxWidth,
	              right: textMargin.h + textMaxWidth,
	              bottom: barWidth + textMaxHeight
	            }
	
	          this.padding = padding;
	
	          var minMaxBubbleRadius = this.getMinMaxBubbleRadius();
	
	          this.xScale = d3.scale.linear()
	            .domain([OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX])
	            .range([minMaxBubbleRadius.min * 2, minMaxBubbleRadius.max * 2])
	            .clamp(true)
	
	          this.brush = d3.svg.brush()
	            .x(this.xScale)
	            .extent([OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MIN])
	            .on("brush", function () {
	              _this._setFromExtent(true, false, false); // non persistent change
	            })
	            .on("brushend", function () {
	               _this.sliderEl.selectAll(".resize")
	                .style("display", null);
	
	              _this._setFromExtent(true, true); // force a persistent change
	            });
	
	          this.sliderEl
	            .call(_this.brush);
	            
	          this.sliderEl.selectAll('.background').attr('style','');
	
	          //For return to round thumbs
	          //var thumbArc = d3.svg.arc()
	          //  .outerRadius(thumbRadius)
	          //  .startAngle(0)
	          //  .endAngle(2 * Math.PI)
	
	          this.sliderThumbs = this.sliderEl.selectAll(".resize").sort(d3.descending)
	            .classed("vzb-bs-slider-thumb", true)
	
	          this.sliderThumbs.append("g")
	            .attr("class", "vzb-bs-slider-thumb-badge")
	            .append("path")
	            .attr("d", "M0 " + (barWidth * .5) + "l" + (-thumbRadius) + " " + (thumbRadius * 1.5) + "h" + (thumbRadius * 2) + "Z")
	
	            //For return to circles
	            //.attr("d", "M0 0 l" + (thumbRadius * 2) + " " + (-thumbRadius) + "v" + (thumbRadius * 2) + "Z")
	
	            //For return to round thumbs
	            //.attr("d", thumbArc)
	
	          if (_this.showArcs) {
	            this.sliderThumbs.append("path")
	              .attr("class", "vzb-bs-slider-thumb-arc")
	          }
	          this.sliderEl.selectAll("text").data([0,0]).enter()
	            .append("text")
	            .attr("class", "vzb-bs-slider-thumb-label")
	            .attr("text-anchor", function(d, i) {
	              return i ? "start" : "end"})
	            .attr("dy", function(d, i) {
	              return i ? "-0.7em" : "1.4em"})
	
	          this.sliderLabelsEl = this.sliderEl.selectAll("text.vzb-bs-slider-thumb-label");
	
	          this.sliderEl.selectAll("rect")
	            .attr("height", barWidth)
	            .attr("rx", barWidth * 0.25)
	            .attr("ry", barWidth * 0.25)
	            .attr("transform", "translate(0," + (-barWidth * 0.5) + ")")
	          this.sliderEl.select(".extent")
	            .classed("vzb-bs-slider-extent", true)
	
	          //For return to circles
	          // var circleLabelTransform = function(d, i) {
	          //    var dX = i ? textMargin.h + _this.xScale(d) : -textMargin.h,
	          //        dY = -textMargin.v;
	          //    return "translate(" + (dX) + "," + (dY) + ")";
	          // }
	
	          this.on("resize", function() {
	            //console.log("EVENT: resize");
	
	            _this.xScale.range([_this.getMinMaxBubbleRadius().min * 2, _this.getMinMaxBubbleRadius().max * 2]);
	            _this._updateSize();
	
	            _this.sliderEl
	              .call(_this.brush.extent(_this.brush.extent()));
	            _this._setFromExtent(false, false, false); // non persistent change
	          });
	
	          this._updateSize();
	          this.sliderEl
	            .call(this.brush.extent(values));
	          _this._setFromExtent(false, false, false); // non persistent change
	
	          _this.sizeScaleMinMax = _this.model.size.getScale().domain();
	
	          if(_this.sizeScaleMinMax) {
	            _this._setLabelsText();
	          }
	        },
	
	        getMinMaxBubbleRadius: function() {
	          return { min: profiles[this.getLayoutProfile()].minRadius, max: profiles[this.getLayoutProfile()].maxRadius};
	        },
	
	        /*
	         * RESIZE:
	         * Executed whenever the container is resized
	         */
	        _updateSize: function() {
	          var maxBubbleRadius = this.showArcs ? this.getMinMaxBubbleRadius().max : OPTIONS.TEXT_PARAMS.TOP * 2;
	          this.sliderSvg
	            .attr("height", maxBubbleRadius + this.padding.top + this.padding.bottom)
	            .attr("width", this.getMinMaxBubbleRadius().max * 2 + this.padding.left + this.padding.right)
	          this.sliderWrap
	            .attr("transform", "translate(" + this.padding.left + "," + (maxBubbleRadius + this.padding.top) + ")")
	        },
	
	        _updateArcs: function(s) {
	          if (!this.showArcs) return;
	          var _this = this;
	          var valueArc = d3.svg.arc()
	            .outerRadius(function (d) { return _this.xScale(d) * 0.5 })
	            .innerRadius(function (d) { return _this.xScale(d) * 0.5 })
	            .startAngle(-Math.PI * 0.5)
	            .endAngle(Math.PI * 0.5);
	          this.sliderThumbs.select('.vzb-bs-slider-thumb-arc').data(s)
	            .attr("d", valueArc)
	            .attr("transform", function (d) {return "translate(" + (-_this.xScale(d) * 0.5) + ",0)"; })
	        },
	
	        _updateLabels: function(s) {
	          var _this = this;
	          var arcLabelTransform = function(d, i) {
	            var textMargin = { v: OPTIONS.TEXT_PARAMS.TOP, h: OPTIONS.TEXT_PARAMS.LEFT },
	                dX = textMargin.h * (i ? .5 : -1.0) + _this.xScale(d),
	                dY = 0;
	             return "translate(" + (dX) + "," + (dY) + ")";
	          }
	          this.sliderLabelsEl.data(s)
	            .attr("transform", arcLabelTransform);
	        },
	
	        _setLabelsText: function() {
	            var _this = this;
	            _this.sliderLabelsEl
	              .data([_this.model.size.getTickFormatter()(_this.sizeScaleMinMax[0]),_this.model.size.getTickFormatter()(_this.sizeScaleMinMax[1])])
	              .text(function (d) { return d; });
	        },
	
	        /**
	         * Prepares setting of the current model with the values from extent.
	         * @param {boolean} set model
	         * @param {boolean} force force firing the change event
	         * @param {boolean} persistent sets the persistency of the change event
	         */
	        _setFromExtent: function(setModel, force, persistent) {
	          var s = this.brush.extent();
	          this._updateArcs(s);
	          this._updateLabels(s);
	          if(setModel) this._setModel(s, force, persistent);
	        },
	
	        /**
	         * Sets the current value in model. avoid updating more than once in framerate
	         * @param {number} value
	         * @param {boolean} force force firing the change event
	         * @param {boolean} persistent sets the persistency of the change event
	         */
	        _setModel: function (value, force, persistent) {
	          value = [+value[0].toFixed(2), +value[1].toFixed(2)];
	          this.model.size.set({"extent": value}, force, persistent);
	        }
	
	      });
	
	      /*!
	       * VIZABI BUTTONLIST
	       * Reusable buttonlist component
	       */
	
	      //default existing buttons
	      var class_active = "vzb-active";
	      var class_hidden = "vzb-hidden";
	      var class_active_locked = "vzb-active-locked";
	      var class_unavailable = "vzb-unavailable";
	      var class_vzb_fullscreen = "vzb-force-fullscreen";
	      var class_container_fullscreen = "vzb-container-fullscreen";
	
	      var ButtonList = Component.extend({
	
	        /**
	         * Initializes the buttonlist
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, context) {
	
	          //set properties
	          var _this = this;
	          this.name = this.name || 'gapminder-buttonlist';
	      //    this.template = '<div class="vzb-buttonlist"></div>';
	
	          this.model_expects = [{
	            name: "state",
	            type: "model"
	          }, {
	            name: "ui",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	          this._available_buttons = {
	            'find': {
	              title: "buttons/find",
	              icon: "search",
	              required: false
	            },
	            'show': {
	              title: "buttons/show",
	              icon: "asterisk",
	              required: false
	            },
	            'moreoptions': {
	              title: "buttons/more_options",
	              icon: "gear",
	              required: true
	            },
	            'colors': {
	              title: "buttons/colors",
	              icon: "paintbrush",
	              required: false
	            },
	            'size': {
	              title: "buttons/size",
	              icon: "circle",
	              required: false
	            },
	            'fullscreen': {
	              title: "buttons/expand",
	              icon: "expand",
	              func: this.toggleFullScreen.bind(this),
	              required: true
	            },
	            'trails': {
	              title: "buttons/trails",
	              icon: "trails",
	              func: this.toggleBubbleTrails.bind(this),
	              required: false,
	              statebind: "ui.chart.trails",
	              statebindfunc: this.setBubbleTrails.bind(this)
	            },
	            'lock': {
	              title: "buttons/lock",
	              icon: "lock",
	              func: this.toggleBubbleLock.bind(this),
	              required: false,
	              statebind: "ui.chart.lockNonSelected",
	              statebindfunc: this.setBubbleLock.bind(this)
	            },
	            'inpercent': {
	              title: "buttons/inpercent",
	              icon: "percent",
	              func: this.toggleInpercent.bind(this),
	              required: false,
	              statebind: "ui.chart.inpercent",
	              statebindfunc: this.setInpercent.bind(this)
	            },
	            'presentation': {
	              title: "buttons/presentation",
	              icon: "presentation",
	              func: this.togglePresentationMode.bind(this),
	              required: false,
	              statebind: "ui.presentation",
	              statebindfunc: this.setPresentationMode.bind(this)
	            },
	            'about': {
	              title: "buttons/about",
	              icon: "about",
	              required: false
	            },
	            'axes': {
	              title: "buttons/axes",
	              icon: "axes",
	              required: false
	            },
	            'axesmc': {
	              title: "buttons/axesmc",
	              icon: "axes",
	              required: false
	            },
	            'stack': {
	              title: "buttons/stack",
	              icon: "stack",
	              required: false
	            },
	            '_default': {
	              title: "Button",
	              icon: "asterisk",
	              required: false
	            }
	          };
	
	          this._active_comp = false;
	
	          this.model_binds = {
	            "change:state.entities.select": function(evt) {
	              if(!_this._readyOnce) return;
	
	              _this.setBubbleTrails();
	              _this.setBubbleLock();
	              _this._toggleButtons();
	
	
	              //scroll button list to end if bottons appeared or disappeared
	              // if(_this.entitiesSelected_1 !== (_this.model.state.entities.select.length > 0)) {
	              //   _this.scrollToEnd();
	              // }
	              // _this.entitiesSelected_1 = _this.model.state.entities.select.length > 0;
	            },
	            "change:ui.chart": function(evt, path) {
	              if(path.indexOf("lockActive") > -1) {
	                _this.setBubbleLock();
	              }
	            }
	          }      
	              
	          config.ui.buttons.forEach(function(buttonId) {
	            var button = _this._available_buttons[buttonId];
	            if(button && button.statebind) {
	              _this.model_binds['change:' + button.statebind] = function(evt) {
	                button.statebindfunc(buttonId, evt.source.value);
	              }
	            }
	          });    
	
	
	          
	          this.validatePopupButtons(config.ui.buttons, config.ui.dialogs);
	
	          this._super(config, context);
	
	        },
	
	        readyOnce: function() {
	          var _this = this;
	          
	          this.element = d3.select(this.placeholder);
	          this.element.selectAll("div").remove();
	          
	          this.root.findChildByName("gapminder-dialogs").on('close', function( evt, params) {
	            _this.setButtonActive(params.id, false);
	          });
	          
	          var button_expand = (this.model.ui.dialogs||{}).sidebar || [];
	          
	          // // if button_expand has been passed in with boolean param or array must check and covert to array
	          // if (button_expand){
	          //   this.model.ui.dialogs.sidebar = (button_expand === true) ? this.model.ui.buttons : button_expand;
	          // }
	
	          // if (button_expand && button_expand.length !== 0) {
	          //     d3.select(this.root.element).classed("vzb-dialog-expand-true", true);
	          // }
	          
	          var button_list = [].concat(this.model.ui.buttons);
	
	          // (button_expand||[]).forEach(function(button) {
	          //   if (button_list.indexOf(button) === -1) {
	          //     button_list.push(button);
	          //   }
	          // });
	
	          this.model.ui.buttons = button_list;
	
	          //add buttons and render components
	          this._addButtons(button_list, button_expand);
	
	          //store body overflow
	          this._prev_body_overflow = document.body.style.overflow;
	
	          this.setBubbleTrails();
	          this.setBubbleLock();
	          this.setInpercent();
	          this.setPresentationMode();
	
	          this._toggleButtons();
	
	        },
	        
	        proceedClick: function(id) {
	          var _this = this;
	          var btn = _this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']"),
	            classes = btn.attr("class"),
	            btn_config = _this._available_buttons[id];
	
	          if(btn_config && btn_config.func) {
	            btn_config.func(id);
	          } else {
	            var btn_active = classes.indexOf(class_active) === -1;
	
	            btn.classed(class_active, btn_active);
	            var evt = {};
	            evt['id'] = id;
	            evt['active'] = btn_active;
	            _this.trigger('click', evt);
	          }    
	        },
	        
	        validatePopupButtons: function (buttons, dialogs) {
	          var _this = this;
	          
	          var popupDialogs = dialogs.popup;
	          var popupButtons = buttons.filter(function(d) {
	            return (_this._available_buttons[d] && !_this._available_buttons[d].func); 
	            });
	          for(var i = 0, j = popupButtons.length; i < j; i++) {
	             if(popupDialogs.indexOf(popupButtons[i]) == -1) {
	                 return error$1('Buttonlist: bad buttons config: "' + popupButtons[i] + '" is missing in popups list');
	             }
	          }
	          return false; //all good
	        },
	
	        /*
	         * reset buttons show state
	         */
	        _showAllButtons: function() {
	          // show all existing buttons
	          var _this = this;
	          var buttons = this.element.selectAll(".vzb-buttonlist-btn");
	          buttons.each(function(d,i) {
	            var button = d3.select(this);
	            button.style('display', '');
	          });
	        },
	
	        /*
	        * determine which buttons are shown on the buttonlist
	        */
	        _toggleButtons: function() {
	          var _this = this;
	          var parent = this.parent.element.node ? this.parent.element : d3.select(this.parent.element);
	
	          //HERE
	          var button_expand = (this.model.ui.dialogs||{}).sidebar || [];
	          _this._showAllButtons();
	
	          var buttons = this.element.selectAll(".vzb-buttonlist-btn");
	
	          var container = this.element.node().getBoundingClientRect();
	
	          var not_required = [];
	          var required = [];
	
	          var button_width = 80;
	          var button_height = 80;
	          var container_width = this.element.node().getBoundingClientRect().width;
	          var container_height = this.element.node().getBoundingClientRect().height;
	          var buttons_width = 0;
	          var buttons_height = 0;
	
	          buttons.each(function(d,i) {
	            var button_data = d;
	            var button = d3.select(this);
	            var expandable = button_expand.indexOf(button_data.id) !== -1;
	            var button_margin = {top: parseInt(button.style("margin-top")), right: parseInt(button.style("margin-right")), left: parseInt(button.style("margin-left")), bottom: parseInt(button.style("margin-bottom"))};
	            button_width = button.node().getBoundingClientRect().width + button_margin.right + button_margin.left;
	            button_height = button.node().getBoundingClientRect().height + button_margin.top + button_margin.bottom;
	
	            if(!button.classed(class_hidden)) {
	              if(!expandable || (_this.getLayoutProfile() !== 'large')){
	                buttons_width += button_width;
	                buttons_height += button_height;
	                //sort buttons between required and not required buttons.
	                // Not required buttons will only be shown if there is space available
	                if(button_data.required){
	                  required.push(button);
	                } else {
	                  not_required.push(button);
	                }
	              } else {
	                button.style("display", "none");
	              }
	            }
	          });
	          var width_diff = buttons_width - container_width;
	          var height_diff = buttons_height - container_height;
	          var number_of_buttons = 1;
	
	          //check if container is landscape or portrait
	          // if portrait small or large with expand, use width
	          if(parent.classed("vzb-large") && parent.classed("vzb-dialog-expand-true")
	          || parent.classed("vzb-small") && parent.classed("vzb-portrait")) {
	            //check if the width_diff is small. If it is, add to the container
	            // width, to allow more buttons in a way that is still usable
	            if(width_diff > 0 && width_diff <=10){
	              container_width += width_diff;
	            }
	            number_of_buttons = Math.floor(container_width / button_width) - required.length;
	            if(number_of_buttons < 0){
	              number_of_buttons = 0;
	            }
	          // else, use height
	          } else {
	            //check if the width_diff is small. If it is, add to the container
	            // width, to allow more buttons in a way that is still usable
	            if(height_diff > 0 && height_diff <=10){
	              container_height += height_diff;
	            }
	            number_of_buttons = Math.floor(container_height / button_height) - required.length;
	            if(number_of_buttons < 0){
	              number_of_buttons = 0;
	            }
	          }
	          //change the display property of non required buttons, from right to
	          // left
	          not_required.reverse();
	          var hiddenButtons = [];
	          for (var i = 0, j = not_required.length - number_of_buttons; i < j ; i++) {
	              not_required[i].style("display", "none");
	              hiddenButtons.push(not_required[i].attr("data-btn"));
	          }
	          
	          var evt = {};
	          evt['hiddenButtons'] = hiddenButtons;
	          _this.trigger('toggle', evt);
	
	        },
	
	        /*
	         * adds buttons configuration to the components and template_data
	         * @param {Array} button_list list of buttons to be added
	         */
	        _addButtons: function(button_list, button_expand) {
	          var _this = this;
	          this._components_config = [];
	          var details_btns = [];
	          if(!button_list.length) return;
	          //add a component for each button
	          for(var i = 0; i < button_list.length; i++) {
	
	            var btn = button_list[i];
	            var btn_config = this._available_buttons[btn];
	
	            //add template data
	            var d = (btn_config) ? btn : "_default";
	            var details_btn = clone(this._available_buttons[d]);
	
	            details_btn.id = btn;
	            details_btn.icon = iconset[details_btn.icon];
	            details_btns.push(details_btn);
	          };
	
	          var t = this.getTranslationFunction(true);
	
	          this.element.selectAll('button').data(details_btns)
	            .enter().append("button")
	            .attr('class', function (d) {
	              var cls = 'vzb-buttonlist-btn';
	              if (button_expand.length > 0) {
	                if (button_expand.indexOf(d.id) > -1) {
	                  cls += ' vzb-dialog-side-btn';
	                }
	              }
	
	              return cls;
	            })
	            .attr('data-btn', function(d) {
	              return d.id;
	            })
	            .html(function(btn) {
	              return "<span class='vzb-buttonlist-btn-icon fa'>" +
	                btn.icon + "</span><span class='vzb-buttonlist-btn-title'>" +
	                t(btn.title) + "</span>";
	            });
	
	          var buttons = this.element.selectAll(".vzb-buttonlist-btn");
	
	          //clicking the button
	          buttons.on('click', function() {
	
	            d3.event.preventDefault();
	            d3.event.stopPropagation();
	            
	            var id = d3.select(this).attr("data-btn");
	            _this.proceedClick(id);
	          });
	
	        },
	
	
	        scrollToEnd: function() {
	          var target = 0;
	          var parent = d3.select(".vzb-tool");
	
	          if(parent.classed("vzb-portrait") && parent.classed("vzb-small")) {
	            if(this.model.state.entities.select.length > 0) target = this.element[0][0].scrollWidth
	            this.element[0][0].scrollLeft = target;
	          } else {
	            if(this.model.state.entities.select.length > 0) target = this.element[0][0].scrollHeight
	            this.element[0][0].scrollTop = target;
	          }
	        },
	
	
	        /*
	         * RESIZE:
	         * Executed whenever the container is resized
	         * Ideally, it contains only operations related to size
	         */
	        resize: function() {
	          //TODO: what to do when resizing?
	
	          //toggle presentaion off is switch to 'small' profile
	          if(this.getLayoutProfile() === 'small' && this.model.ui.presentation) {
	            this.togglePresentationMode();
	          }
	
	          this._toggleButtons();
	        },
	
	        setButtonActive: function(id, boolActive) {
	          var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
	
	          btn.classed(class_active, boolActive);
	        },
	
	        toggleBubbleTrails: function() {
	          this.model.ui.chart.trails = !this.model.ui.chart.trails;
	          this.setBubbleTrails();
	        },
	        setBubbleTrails: function() {
	          var trails = (this.model.ui.chart||{}).trails;
	          if(!trails && trails !== false) return; 
	          var id = "trails";
	          var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
	          if(!btn.node()) return warn("setBubbleTrails: no button '" +id+ "' found in DOM. doing nothing");
	
	          btn.classed(class_active_locked, trails);
	          btn.classed(class_hidden, this.model.state.entities.select.length == 0);
	        },
	        toggleBubbleLock: function(id) {
	          var active = (this.model.ui.chart||{}).lockActive;
	
	          if(this.model.state.entities.select.length == 0 && !active) return;
	
	          var locked = this.model.ui.chart.lockNonSelected;
	          var time = this.model.state.time;
	          locked = locked ? 0 : time.timeFormat(time.value);
	          this.model.ui.chart.lockNonSelected = locked;
	
	          this.setBubbleLock();
	        },
	        setBubbleLock: function() {
	          var locked = (this.model.ui.chart||{}).lockNonSelected;
	          var active = (this.model.ui.chart||{}).lockActive;
	          if(!locked && locked !== 0) return;
	
	          if(locked !== 0 && this.model.state.entities.select.length === 0 && !active) {
	             locked = this.model.ui.chart.lockNonSelected = 0;
	          }
	
	          var id = "lock";
	          var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
	          if(!btn.node()) return warn("setBubbleLock: no button '" +id+ "' found in DOM. doing nothing");
	            
	          var translator = this.model.language.getTFunction();
	
	          btn.classed(class_unavailable, this.model.state.entities.select.length == 0 && !active);
	          if (typeof active == "undefined") {
	            btn.classed(class_hidden, this.model.state.entities.select.length == 0);
	          } else {
	            btn.classed(class_hidden, !active);
	          }
	
	          btn.classed(class_active_locked, locked)
	          btn.select(".vzb-buttonlist-btn-title")
	            .text(locked ? locked : translator("buttons/lock"));
	
	          btn.select(".vzb-buttonlist-btn-icon")
	            .html(iconset[locked ? "lock" : "unlock"]);
	        },
	        toggleInpercent: function() {
	          this.model.ui.chart.inpercent = !this.model.ui.chart.inpercent;
	          this.setInpercent();
	        },
	        setInpercent: function() {
	          if (typeof((this.model.ui.chart||{}).inpercent) == "undefined") return;
	          var id = 'inpercent';
	          var translator = this.model.language.getTFunction();
	          var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
	
	          btn.classed(class_active_locked, this.model.ui.chart.inpercent);
	        },
	        togglePresentationMode: function() {
	          this.model.ui.presentation = !this.model.ui.presentation;
	          this.setPresentationMode();
	        },
	        setPresentationMode: function() {
	          var id = 'presentation';
	          var translator = this.model.language.getTFunction();
	          var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
	
	          btn.classed(class_active_locked, this.model.ui.presentation);
	        },
	        toggleFullScreen: function(id) {
	
	          if(!window) return;
	
	          var component = this;
	          var pholder = component.placeholder;
	          var pholder_found = false;
	          var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
	          var fs = !this.model.ui.fullscreen;
	          var body_overflow = (fs) ? "hidden" : this._prev_body_overflow;
	
	          while(!(pholder_found = hasClass(pholder, 'vzb-placeholder'))) {
	            component = component.parent;
	            pholder = component.placeholder;
	          }
	
	          //TODO: figure out a way to avoid fullscreen resize delay in firefox
	          if(fs) {
	            launchIntoFullscreen(pholder);
	            subscribeFullscreenChangeEvent.call(this, this.toggleFullScreen.bind(this, id));
	          } else {
	            exitFullscreen.call(this);
	          }
	          classed(pholder, class_vzb_fullscreen, fs);
	          if (typeof container != 'undefined') {
	            classed(container, class_container_fullscreen, fs);
	          }
	
	          this.model.ui.fullscreen = fs;
	          var translator = this.model.language.getTFunction();
	          btn.classed(class_active_locked, fs);
	
	          btn.select(".vzb-buttonlist-btn-icon").html(iconset[fs ? "unexpand" : "expand"]);
	
	          btn.select(".vzb-buttonlist-btn-title>span").text(
	            translator("buttons/" + (fs ? "unexpand" : "expand"))
	          )
	          .attr("data-vzb-translate", "buttons/" + (fs ? "unexpand" : "expand"));
	
	          //restore body overflow
	          document.body.style.overflow = body_overflow;
	
	          this.root.layout.resizeHandler();
	
	          //force window resize event
	          // utils.defer(function() {
	          //   event = window.document.createEvent("HTMLEvents");
	          //   event.initEvent("resize", true, true);
	          //   event.eventName = "resize";
	          //   window.dispatchEvent(event);
	          // });
	        }
	
	      });
	
	      function isFullscreen() {
	        if(!window) return false;
	        if(window.document.webkitIsFullScreen !== undefined)
	          return window.document.webkitIsFullScreen;
	        if(window.document.mozFullScreen !== undefined)
	          return window.document.mozFullScreen;
	        if(window.document.msFullscreenElement !== undefined)
	          return window.document.msFullscreenElement;
	
	        return false;
	      }
	
	      function exitHandler(emulateClickFunc) {
	        if(!isFullscreen()) {
	          emulateClickFunc();
	        }
	      }
	
	      function subscribeFullscreenChangeEvent(exitFunc) {
	        if(!window) return;
	        var doc = window.document;
	
	        this.exitFullscreenHandler = exitHandler.bind(this, exitFunc);
	        doc.addEventListener('webkitfullscreenchange', this.exitFullscreenHandler, false);
	        doc.addEventListener('mozfullscreenchange', this.exitFullscreenHandler, false);
	        doc.addEventListener('fullscreenchange', this.exitFullscreenHandler, false);
	        doc.addEventListener('MSFullscreenChange', this.exitFullscreenHandler, false);
	      }
	
	      function removeFullscreenChangeEvent() {
	        var doc = window.document;
	
	        doc.removeEventListener('webkitfullscreenchange', this.exitFullscreenHandler);
	        doc.removeEventListener('mozfullscreenchange', this.exitFullscreenHandler);
	        doc.removeEventListener('fullscreenchange', this.exitFullscreenHandler);
	        doc.removeEventListener('MSFullscreenChange', this.exitFullscreenHandler);
	      }
	
	      function launchIntoFullscreen(elem) {
	        if(elem.requestFullscreen) {
	          elem.requestFullscreen();
	        } else if(elem.msRequestFullscreen) {
	          elem.msRequestFullscreen();
	        } else if(elem.mozRequestFullScreen) {
	          elem.mozRequestFullScreen();
	        } else if(elem.webkitRequestFullscreen) {
	          if (!(navigator.vendor && navigator.vendor.indexOf('Apple') > -1 &&
	          navigator.userAgent && !navigator.userAgent.match('CriOS'))) {
	            elem.webkitRequestFullscreen();
	          }
	
	        }
	      }
	
	      function exitFullscreen() {
	        removeFullscreenChangeEvent.call(this);
	
	        if(document.exitFullscreen) {
	          document.exitFullscreen();
	        } else if(document.msExitFullscreen) {
	          document.msExitFullscreen();
	        } else if(document.mozCancelFullScreen) {
	          document.mozCancelFullScreen();
	        } else if(document.webkitExitFullscreen) {
	          document.webkitExitFullscreen();
	        }
	      }
	
	      //d3.svg.colorPicker
	
	
	      var instance = null;
	
	      function colorPicker() {
	
	
	        return function getInstance() {
	          if (instance == null) {
	            instance = d3_color_picker();
	          }
	          return instance;
	        }();
	
	        function d3_color_picker() {
	          // tuning defaults
	          var nCellsH = 15;
	          // number of cells by hues (angular)
	          var minH = 0;
	          // which hue do we start from: 0 to 1 instead of 0 to 365
	          var nCellsL = 4;
	          // number of cells by lightness (radial)
	          var minL = .5;
	          // which lightness to start from: 0 to 1. Recommended .3...0.5
	          var satConstant = .7;
	          // constant saturation for color wheel: 0 to 1. Recommended .7...0.8
	          var outerL_display = .4;
	          // ecxeptional saturation of the outer circle. the one displayed 0 to 1
	          var outerL_meaning = .3;
	          // ecxeptional saturation of the outer circle. the one actually ment 0 to 1
	          var firstAngleSat = 0;
	          // exceptional saturation at first angular segment. Set 0 to have shades of grey
	          var minRadius = 15;
	          //radius of the central hole in color wheel: px
	          var maxWidth = 280;
	          var maxHeight = 323;
	          var margin = {
	            top: .1,
	            bottom: .1,
	            left: .1,
	            right: .1
	          };
	          //margins in % of container's width and height
	          var colorOld = '#000';
	          var colorDef = '#000';
	          var colorWhite = '#f8f8f8';
	          // names of CSS classes
	          var css = {
	            INVISIBLE: 'vzb-invisible',
	            COLOR_POINTER: 'vzb-colorpicker-pointer',
	            COLOR_BUTTON: 'vzb-colorpicker-cell',
	            COLOR_DEFAULT: 'vzb-colorpicker-default',
	            COLOR_SAMPLE: 'vzb-colorpicker-sample',
	            COLOR_PICKER: 'vzb-colorpicker-svg',
	            COLOR_CIRCLE: 'vzb-colorpicker-circle',
	            COLOR_CIRCLES: 'vzb-colorpicker-circles',
	            COLOR_SEGMENT: 'vzb-colorpicker-segment',
	            COLOR_BACKGR: 'vzb-colorpicker-background'
	          };
	          var colorData = [];
	          //here we store color data. formatted as follows:
	          /*
	           [
	           [ // outer circle
	           {display: "#123456", meaning: "#123456"}, // first angle
	           ...
	           {display: "#123456", meaning: "#123456"} // last angle, clockwise
	           ],
	           [ // next circle
	           {display: "#123456", meaning: "#123456"}, // first angle
	           ...
	           {display: "#123456", meaning: "#123456"} // last angle, clockwise
	           ],
	
	           ...
	
	           [ // inner circle
	           {display: "#123456", meaning: "#123456"}, // first angle
	           ...
	           {display: "#123456", meaning: "#123456"} // last angle, clockwise
	           ]
	           ]
	           */
	          var arc = d3.svg.arc();
	          var pie = d3.layout.pie().sort(null).value(function(d) {
	            return 1;
	          });
	          var svg = null;
	          var container = null;
	          var colorPointer = null;
	          var showColorPicker = false;
	          var sampleRect = null;
	          var sampleText = null;
	          var background = null;
	          var callback = function(value) {
	            console.info('Color picker callback example. Setting color to ' + value);
	          };
	
	          function _generateColorData() {
	            var result = [];
	            // loop across circles
	            for(var l = 0; l < nCellsL; l++) {
	              var lightness = minL + (1 - minL) / nCellsL * l;
	              // new circle of cells
	              result.push([]);
	              // loop across angles
	              for(var h = 0; h <= nCellsH; h++) {
	                var hue = minH + (1 - minH) / nCellsH * h;
	                // new cell
	                result[l].push({
	                  display: _hslToRgb(hue, h == 0 ? firstAngleSat : satConstant, l == 0 ? outerL_display : lightness),
	                  meaning: _hslToRgb(hue, h == 0 ? firstAngleSat : satConstant, l == 0 ? outerL_meaning : lightness)
	                });
	              }
	            }
	            return result;
	          }
	
	          function _hslToRgb(h, s, l) {
	            var r, g, b;
	            if(s == 0) {
	              r = g = b = l; // achromatic
	            } else {
	              var _hue2rgb = function _hue2rgb(p, q, t) {
	                if(t < 0)
	                  t += 1;
	                if(t > 1)
	                  t -= 1;
	                if(t < 1 / 6)
	                  return p + (q - p) * 6 * t;
	                if(t < 1 / 2)
	                  return q;
	                if(t < 2 / 3)
	                  return p + (q - p) * (2 / 3 - t) * 6;
	                return p;
	              };
	              var q = l < .5 ? l * (1 + s) : l + s - l * s;
	              var p = 2 * l - q;
	              r = _hue2rgb(p, q, h + 1 / 3);
	              g = _hue2rgb(p, q, h);
	              b = _hue2rgb(p, q, h - 1 / 3);
	            }
	            return '#' + Math.round(r * 255).toString(16) + Math.round(g * 255).toString(16) + Math.round(b * 255).toString(
	              16);
	          }
	
	          // this is init function. call it once after you are satisfied with parameters tuning
	          // container should be a D3 selection that has a div where we want to render color picker
	          // that div should have !=0 width and height in its style
	          function colorPicker(container) {
	            colorPicker.container = container;
	            svg = container.select('.' + css.COLOR_PICKER);
	            if(!svg.empty()) {
	              return;
	            }
	            container.on('click', function() {
	              colorPicker.show(false);
	              d3.event.stopPropagation();
	            });
	            colorData = _generateColorData();
	
	            svg = container.append('svg')
	              .style('position', 'absolute')
	              .style('top', '0')
	              .style('left', '0')
	              .style('width', '100%')
	              .style('max-width', maxWidth + "px")
	              .style('height', '100%')
	              .style('max-height', maxHeight + "px")
	              .style('z-index', 9999)
	              .attr('class', css.COLOR_PICKER + " vzb-dialog-shadow")
	              .classed(css.INVISIBLE, !showColorPicker)
	              .on('mouseout', function(d) { _cellHover(colorOld); });
	
	            var width = parseInt(svg.style('width'));
	            var height = parseInt(svg.style('height'));
	            var maxRadius = width / 2 * (1 - margin.left - margin.right);
	            background = svg.append('rect')
	              .attr('width', width)
	              .attr('height', maxHeight)
	              .attr('class', css.COLOR_BUTTON +' '+ css.COLOR_BACKGR)
	              .on('mouseover',
	                function(d) {
	                  _cellHover(colorOld);
	                });          
	            var circles = svg.append('g')
	              .attr('class', css.COLOR_CIRCLES)
	              .attr('transform', 'translate(' + (maxRadius + width * margin.left) +
	              ',' + (maxRadius + height * margin.top) + ')');
	
	            svg.append('rect')
	              .attr('class', css.COLOR_SAMPLE)
	              .attr('width', width / 2)
	              .attr('height', height * margin.top / 2);
	
	            sampleRect = svg.append('rect')
	              .attr('class', css.COLOR_SAMPLE)
	              .attr('width', width / 2)
	              .attr('x', width / 2)
	              .attr('height', height * margin.top / 2);
	
	            svg.append('text')
	              .attr('x', width * margin.left)
	              .attr('y', height * margin.top / 2)
	              .attr('dy', '1.3em')
	              .attr('class', css.COLOR_SAMPLE)
	              .style('text-anchor', 'start');
	
	            sampleText = svg.append('text').attr('x', width * (1 - margin.right))
	              .attr('y', height * margin.top / 2)
	              .attr('dy', '1.3em')
	              .attr('class', css.COLOR_SAMPLE)
	              .style('text-anchor', 'end');
	
	            svg.append('text')
	              .attr('x', width * .1)
	              .attr('y', height * (1 - margin.bottom))
	              .attr('dy', '1.2em')
	              .attr('class', "vzb-default-label")
	              .style('text-anchor', 'start')
	              .text('default');
	
	            svg.append('circle')
	              .attr('class', css.COLOR_DEFAULT + ' ' + css.COLOR_BUTTON)
	              .attr('r', width * margin.left / 2)
	              .attr('cx', width * margin.left * 1.5)
	              .attr('cy', height * (1 - margin.bottom * 1.5))
	              .on('mouseover',
	                function() {
	                  d3.select(this).style('stroke', '#444');
	                  _cellHover(colorDef);
	              })
	              .on('mouseout', function() {
	                d3.select(this).style('stroke', 'none');
	              });
	
	            circles.selectAll('.' + css.COLOR_CIRCLE)
	              .data(colorData).enter().append('g')
	                .attr('class', css.COLOR_CIRCLE)
	                  .each(
	                    function(circleData, index) {
	                      arc.outerRadius(minRadius + (maxRadius - minRadius) / nCellsL *
	                        (nCellsL - index)).innerRadius(minRadius +
	                        (maxRadius - minRadius) / nCellsL * (nCellsL - index - 1));
	                      var segment = d3.select(this).selectAll('.' + css.COLOR_SEGMENT)
	                        .data(pie(circleData)).enter().append('g')
	                          .attr('class', css.COLOR_SEGMENT);
	
	                    segment.append('path')
	                      .attr('class', css.COLOR_BUTTON)
	                      .attr('d', arc)
	                      .style('fill', function(d) {
	                        return d.data.display;
	                      })
	                      .style('stroke', function(d) {
	                        return d.data.display;
	                      })
	                      .on('mouseover', function(d) {
	                        _cellHover(d.data.meaning, this);
	                      })
	                      .on('mouseout', function(d) {
	                        _cellUnHover();
	                      });
	                  });
	
	            circles.append('circle')
	              .attr('r', minRadius)
	              .attr('fill', colorWhite)
	              .attr('class', css.COLOR_BUTTON)
	              .on('mouseover',
	                function() {
	                  d3.select(this).style('stroke', "#555");
	                  _cellHover(colorWhite);
	              })
	              .on('mouseout', function() {
	                d3.select(this).style('stroke', 'none');
	              });        
	
	            colorPointer = circles.append('path')
	              .attr('class', css.COLOR_POINTER + ' ' + css.INVISIBLE);
	
	            svg.selectAll('.' + css.COLOR_BUTTON)
	              .on('click', function() {
	                d3.event.stopPropagation();
	                _this.show(false);
	              });
	            _doTheStyling(svg);
	            colorPicker.resize(svg);
	          }
	
	          var _doTheStyling = function(svg) {
	            //styling
	            svg.select('.' + css.COLOR_BACKGR)
	              .style('fill', 'white');
	
	            svg.select('.' + css.COLOR_POINTER)
	              .style('stroke-width', 2)
	              .style('stroke', colorWhite)
	              .style('pointer-events', 'none')
	              .style('fill', 'none');
	
	            svg.selectAll('.' + css.COLOR_BUTTON)
	              .style('cursor', 'pointer');
	
	            svg.selectAll('text')
	              .style('fill', '#D9D9D9')
	              .style('font-size', '0.7em')
	              .style('text-transform', 'uppercase');
	
	            svg.selectAll('circle.' + css.COLOR_BUTTON)
	              .style('stroke-width', 2);
	          };
	
	          var _this = colorPicker;
	          var _cellHover = function(value, view) {
	            // show color pointer if the view is set (a cell of colorwheel)
	            if(view != null)
	              colorPointer.classed(css.INVISIBLE, false)
	                .attr('d', d3.select(view)
	                .attr('d'));
	
	            sampleRect.style('fill', value);
	            sampleText.text(value);
	            callback(value);
	          };
	          var _cellUnHover = function() {
	            colorPointer.classed(css.INVISIBLE, true);
	          };
	          //Use this function to hide or show the color picker
	          //true = show, false = hide, "toggle" or TOGGLE = toggle
	          var TOGGLE = 'toggle';
	          colorPicker.show = function(arg) {
	            if(!arguments.length)
	              return showColorPicker;
	            if(svg == null)
	              console.warn('Color picker is missing SVG element. Was init sequence performed?');
	            showColorPicker = arg == TOGGLE ? !showColorPicker : arg;
	            if (!showColorPicker) {
	              callback = function() {};
	            }
	            svg.classed(css.INVISIBLE, !showColorPicker);
	          };
	          // getters and setters
	          colorPicker.nCellsH = function(arg) {
	            if(!arguments.length)
	              return nCellsH;
	            nCellsH = arg;
	            return colorPicker;
	          };
	          colorPicker.minH = function(arg) {
	            if(!arguments.length)
	              return minH;
	            minH = arg;
	            return colorPicker;
	          };
	          colorPicker.nCellsL = function(arg) {
	            if(!arguments.length)
	              return nCellsL;
	            nCellsL = arg;
	            return colorPicker;
	          };
	          colorPicker.minL = function(arg) {
	            if(!arguments.length)
	              return minL;
	            minL = arg;
	            return colorPicker;
	          };
	          colorPicker.outerL_display = function(arg) {
	            if(!arguments.length)
	              return outerL_display;
	            outerL_display = arg;
	            return colorPicker;
	          };
	          colorPicker.outerL_meaning = function(arg) {
	            if(!arguments.length)
	              return outerL_meaning;
	            outerL_meaning = arg;
	            return colorPicker;
	          };
	          colorPicker.satConstant = function(arg) {
	            if(!arguments.length)
	              return satConstant;
	            satConstant = arg;
	            return colorPicker;
	          };
	          colorPicker.firstAngleSat = function(arg) {
	            if(!arguments.length)
	              return firstAngleSat;
	            firstAngleSat = arg;
	            return colorPicker;
	          };
	          colorPicker.minRadius = function(arg) {
	            if(!arguments.length)
	              return minRadius;
	            minRadius = arg;
	            return colorPicker;
	          };
	          colorPicker.margin = function(arg) {
	            if(!arguments.length)
	              return margin;
	            margin = arg;
	            return colorPicker;
	          };
	          colorPicker.callback = function(arg) {
	            if(!arguments.length)
	              return callback;
	            callback = arg;
	            return colorPicker;
	          };
	          colorPicker.colorDef = function(arg) {
	            if(!arguments.length)
	              return colorDef;
	            if (typeof arg !== 'undefined') {
	              colorDef = arg;
	            }
	            if(svg == null)
	              console.warn('Color picker is missing SVG element. Was init sequence performed?');
	            svg.select('.' + css.COLOR_DEFAULT).style('fill', colorDef);
	            return colorPicker;
	          };
	          /**
	           * @param {ClientRect} screen parent element
	           * @param {int[]} arg [x,y] of color picker position
	           */
	          colorPicker.fitToScreen = function(arg) {
	            var screen = colorPicker.container.node().getBoundingClientRect();
	            var xPos, yPos;
	
	            var width = parseInt(svg.style('width'));
	            var height = parseInt(svg.style('height'));
	
	            if (!arg) {
	              xPos = screen.width - parseInt(svg.style('right')) - width;
	              yPos = parseInt(svg.style('top'));
	            } else {
	              xPos = arg[0] - screen.left;
	              yPos = arg[1] - screen.top;
	            }
	
	            var styles = {left: ''};
	            if (screen.width * 0.8 <= width) {
	              styles.right = (screen.width - width) * 0.5 + "px";
	            } else if (xPos + width > screen.width) {
	              styles.right = Math.min(screen.width * 0.1, 20) + "px";
	            } else {
	              styles.right = screen.width - xPos - width + "px";
	            }
	            if (screen.height * 0.8 <= height) {
	              styles.top = (screen.height - height) * 0.5 + "px";
	            } else if (yPos + height * 1.2 > screen.height) {
	              styles.top = screen.height * 0.9 - height + "px";
	            } else {
	              styles.top = yPos + "px";
	            }
	
	            svg.style(styles);
	            return colorPicker;
	          };
	          colorPicker.colorOld = function(arg) {
	            if(!arguments.length)
	              return colorOld;
	            colorOld = arg;
	            if(svg == null)
	              console.warn('Color picker is missing SVG element. Was init sequence performed?');
	            svg.select('rect.' + css.COLOR_SAMPLE).style('fill', colorOld);
	            svg.select('text.' + css.COLOR_SAMPLE).text(colorOld);
	            return colorPicker;
	          };
	
	          colorPicker.resize = function(arg) {
	
	            if(!arguments.length)
	              return resize;
	            if (typeof arg !== 'undefined') {
	              var svg = arg;
	              var width = parseInt(svg.style('width'));
	              var height = parseInt(svg.style('height'));
	              var maxRadius = width / 2 * (1 - margin.left - margin.right);
	              var selectedColor = svg.select('.'+css.COLOR_DEFAULT);
	              var defaultLabel = svg.select('.vzb-default-label');
	              var circles = svg.select('.' + css.COLOR_CIRCLES);
	             
	              var hPos = maxRadius + height * margin.top;
	              var hPosCenter = (1 + margin.top * .5) * height * .5;
	              hPos = hPos > hPosCenter ? hPosCenter : hPos; 
	              circles.attr('transform', 'translate(' + (maxRadius + width * margin.left) +
	              ',' + hPos + ')');
	              selectedColor.attr('cx', width * margin.left * 1.5)
	                           .attr('cy', height * (1 - margin.bottom * 1.5));
	              defaultLabel.attr('x', width * .1)
	                          .attr('y', height * (1 - margin.bottom));
	            }
	            colorPicker.fitToScreen();
	
	            return colorPicker;
	          };
	          return colorPicker;
	        };
	      };
	
	      //d3.svg.axisSmart
	
	      function axisSmart() {
	
	        return function d3_axis_smart(_super) {
	
	          var VERTICAL = 'vertical axis';
	          var HORIZONTAL = 'horizontal axis';
	          var X = 'labels stack side by side';
	          var Y = 'labels stack top to bottom';
	
	          var OPTIMISTIC = 'optimistic approximation: labels have different lengths';
	          var PESSIMISTIC = 'pessimistic approximation: all labels have the largest length';
	          var DEFAULT_LOGBASE = 10;
	
	          function onlyUnique(value, index, self) {
	            return self.indexOf(value) === index;
	          }
	
	          function axis(g) {
	            if(highlightValue != null) {
	              axis.highlightValueRun(g);
	              return;
	            }
	
	            // measure the width and height of one digit
	            var widthSampleG = g.append("g").attr("class", "tick widthSampling");
	            var widthSampleT = widthSampleG.append('text').text('0');
	
	            options.cssMarginTop = widthSampleT.style("margin-top");
	            options.cssMarginBottom = widthSampleT.style("margin-bottom");
	            options.cssMarginLeft = widthSampleT.style("margin-left");
	            options.cssMarginRight = widthSampleT.style("margin-right");
	            options.widthOfOneDigit = widthSampleT[0][0].getBBox().width;
	            options.heightOfOneDigit = widthSampleT[0][0].getBBox().height;
	            widthSampleG.remove();
	
	
	            // run label factory - it will store labels in tickValues property of axis
	            axis.labelFactory(options);
	
	            //if(axis.orient()=="bottom") console.log("ordered", axis.tickValues())
	            // construct the view (d3 constructor is used)
	            if(options.transitionDuration > 0) {
	              _super(g.transition().duration(options.transitionDuration));
	            } else {
	              _super(g);
	            }
	            //if(axis.orient()=="bottom") console.log("received", g.selectAll("text").each(function(d){console.log(d)}))
	
	            var orient = axis.orient() == "top" || axis.orient() == "bottom" ? HORIZONTAL : VERTICAL;
	            var dimension = (orient == HORIZONTAL && axis.pivot() || orient == VERTICAL && !axis.pivot()) ? Y : X;
	
	            g.selectAll('.vzb-axis-value')
	              .data([null])
	              .enter().append('g')
	              .attr("class", 'vzb-axis-value')
	              .classed("vzb-hidden", true)
	              .append("text");
	
	            // patch the label positioning after the view is generated
	            g.selectAll("text")
	              .each(function(d, i) {
	                var view = d3.select(this);
	
	                if(axis.pivot() == null) return;
	                view.attr("transform", "rotate(" + (axis.pivot() ? -90 : 0) + ")");
	                view.style("text-anchor", dimension == X ? "middle" : "end");
	                view.attr("x", dimension == X ? 0 : (-axis.tickPadding() - axis.tickSize()));
	                view.attr("y", dimension == X ? (orient == VERTICAL ? -1 : 1) * (axis.tickPadding() + axis.tickSize()) :
	                  0);
	                view.attr("dy", dimension == X ? (orient == VERTICAL ? 0 : ".72em") : ".32em");
	              })
	            
	            if(axis.repositionLabels() != null){
	                g.selectAll(".tick")
	                  .each(function(d, i) {
	                    var view = d3.select(this).select("text");
	                    var shift = axis.repositionLabels()[i] || {x: 0, y: 0};
	                    view.attr("x", +view.attr("x") + shift.x);
	                    view.attr("y", +view.attr("y") + shift.y);
	                  })
	            }
	
	            if(axis.tickValuesMinor() == null) axis.tickValuesMinor([]);
	            // add minor ticks
	            var minorTicks = g.selectAll(".tickMinor").data(tickValuesMinor);
	            minorTicks.exit().remove();
	            minorTicks.enter().append("line")
	              .attr("class", "tickMinor");
	
	            var tickLengthOut = axis.tickSizeMinor().outbound;
	            var tickLengthIn = axis.tickSizeMinor().inbound;
	            var scale = axis.scale();
	            minorTicks
	              .attr("y1", orient == HORIZONTAL ? (axis.orient() == "top" ? 1 : -1) * tickLengthIn : scale)
	              .attr("y2", orient == HORIZONTAL ? (axis.orient() == "top" ? -1 : 1) * tickLengthOut : scale)
	              .attr("x1", orient == VERTICAL ? (axis.orient() == "right" ? -1 : 1) * tickLengthIn : scale)
	              .attr("x2", orient == VERTICAL ? (axis.orient() == "right" ? 1 : -1) * tickLengthOut : scale)
	
	
	            //adjust axis rake 
	            g.selectAll("path").remove();
	            var rake = g.selectAll(".vzb-axis-line").data([0]);
	            rake.exit().remove();
	            rake.enter().append("line")
	                .attr("class", "vzb-axis-line");
	              
	            if(options.constantRakeLength){
	                rake 
	                  .attr("x1", orient == VERTICAL ? 0 : -1)
	                  .attr("x2", orient == VERTICAL ? 0 : options.constantRakeLength)
	                  .attr("y1", orient == HORIZONTAL ? 0 : 0)
	                  .attr("y2", orient == HORIZONTAL ? 0 : options.constantRakeLength)      
	            }else{
	                //TODO: this will not work for the "ordinal" scaleType
	                rake 
	                  .attr("x1", orient == VERTICAL ? 0 : d3.min(scale.range()) - (options.bump||0) - 1)
	                  .attr("x2", orient == VERTICAL ? 0 : d3.max(scale.range()) + (options.bump||0))
	                  .attr("y1", orient == HORIZONTAL ? 0 : d3.min(scale.range()) - (options.bump||0))
	                  .attr("y2", orient == HORIZONTAL ? 0 : d3.max(scale.range()) + (options.bump||0))
	            }
	
	          };
	
	
	          axis.highlightValueRun = function(g) {
	            var orient = axis.orient() == "top" || axis.orient() == "bottom" ? HORIZONTAL : VERTICAL;
	
	            g.select('.vzb-axis-value')
	              .classed("vzb-hidden", highlightValue == "none")
	              .select("text")
	              .text(options.formatter(highlightValue == "none" ? 0 : highlightValue));
	              
	            var getTransform = function(){
	              return highlightValue == "none" ? "translate(0,0)" : 
	                  "translate(" 
	                  + (orient == HORIZONTAL ? axis.scale()(highlightValue) : 0) + "," 
	                  + (orient == VERTICAL ? axis.scale()(highlightValue) : 0) 
	                  + ")"
	            }
	            
	            var getOpacity = function(d, t){
	              return highlightValue == "none" ? 1 : 
	                  Math.min(1, Math.pow( Math.abs(axis.scale()(d) - axis.scale()(highlightValue)) / (axis.scale().range()[1] - axis.scale().range()[0]) * 5, 2))
	            }
	              
	            if(highlightTransDuration){
	              g.selectAll(".tick").each(function(d, t) {
	                d3.select(this).select("text")
	                  .transition()
	                  .duration(highlightTransDuration)
	                  .ease("linear")
	                  .style("opacity", getOpacity(d,t))
	              })
	                
	              g.select('.vzb-axis-value')
	                .transition()
	                .duration(highlightTransDuration)
	                .ease("linear")
	                .attr("transform", getTransform);
	                
	            }else{
	                
	              g.selectAll(".tick").each(function(d, t) {
	                d3.select(this).select("text")
	                  .interrupt()
	                  .style("opacity", getOpacity(d,t))
	              })
	                
	              g.select('.vzb-axis-value')
	                .interrupt()
	                .attr("transform", getTransform);
	                
	            }
	
	            highlightValue = null;
	          }
	
	
	          var highlightValue = null;
	          axis.highlightValue = function(arg) {
	            if(!arguments.length) return highlightValue;
	            highlightValue = arg;
	            return axis;
	          }
	
	          var highlightTransDuration = 0;
	          axis.highlightTransDuration = function(arg) {
	            if(!arguments.length) return highlightTransDuration;
	            highlightTransDuration = arg;
	            return axis;
	          }
	
	          var repositionLabels = null;
	          axis.repositionLabels = function(arg) {
	            if(!arguments.length) return repositionLabels;
	            repositionLabels = arg;
	            return axis;
	          };
	
	          var pivot = false;
	          axis.pivot = function(arg) {
	            if(!arguments.length) return pivot;
	            pivot = !!arg;
	            return axis;
	          };
	
	          var tickValuesMinor = [];
	          axis.tickValuesMinor = function(arg) {
	            if(!arguments.length) return tickValuesMinor;
	            tickValuesMinor = arg;
	            return axis;
	          };
	
	          var tickSizeMinor = {
	            outbound: 0,
	            inbound: 0
	          };
	          axis.tickSizeMinor = function(arg1, arg2) {
	            if(!arguments.length) return tickSizeMinor;
	            tickSizeMinor = {
	              outbound: arg1,
	              inbound: arg2 || 0
	            };
	            meow("setting", tickSizeMinor)
	            return axis;
	          };
	
	          var options = {};
	          axis.labelerOptions = function(arg) {
	            if(!arguments.length) return options;
	            options = arg;
	            return axis;
	          };
	
	          axis.METHOD_REPEATING = 'repeating specified powers';
	          axis.METHOD_DOUBLING = 'doubling the value';
	
	          axis.labelFactory = function(options) {
	            if(options == null) options = {}
	            if(options.scaleType != "linear" &&
	              options.scaleType != "time" &&
	              options.scaleType != "genericLog" &&
	              options.scaleType != "log" &&
	              options.scaleType != "ordinal") {
	              return axis.ticks(ticksNumber)
	                .tickFormat(null)
	                .tickValues(null)
	                .tickValuesMinor(null)
	                .pivot(null)
	                .repositionLabels(null);
	            };
	            if(options.scaleType == 'ordinal') return axis.tickValues(null);
	
	            if(options.logBase == null) options.logBase = DEFAULT_LOGBASE;
	            if(options.stops == null) options.stops = [1, 2, 5, 3, 7, 4, 6, 8, 9];
	
	
	
	            if(options.removeAllLabels == null) options.removeAllLabels = false;
	
	            if(options.formatter == null) options.formatter = axis.tickFormat()?
	              axis.tickFormat() : function(d) {return d+"";}
	            options.cssLabelMarginLimit = 5; //px
	            if(options.cssMarginLeft == null || parseInt(options.cssMarginLeft) < options.cssLabelMarginLimit) options.cssMarginLeft =
	              options.cssLabelMarginLimit + "px";
	            if(options.cssMarginRight == null || parseInt(options.cssMarginRight) < options.cssLabelMarginLimit) options.cssMarginRight =
	              options.cssLabelMarginLimit + "px";
	            if(options.cssMarginTop == null || parseInt(options.cssMarginTop) < options.cssLabelMarginLimit) options.cssMarginTop =
	              options.cssLabelMarginLimit + "px";
	            if(options.cssMarginBottom == null || parseInt(options.cssMarginBottom) < options.cssLabelMarginLimit) options
	              .cssMarginBottom = options.cssLabelMarginLimit + "px";
	            if(options.toolMargin == null) options.toolMargin = {
	              left: 30,
	              bottom: 30,
	              right: 30,
	              top: 30
	            };
	            if(options.bump == null) options.bump = 0;
	            if(options.constantRakeLength == null) options.constantRakeLength = 0;
	
	            if(options.pivotingLimit == null) options.pivotingLimit = options.toolMargin[this.orient()];
	
	            if(options.showOuter == null) options.showOuter = false;
	            if(options.limitMaxTickNumber == null) options.limitMaxTickNumber = 0; //0 is unlimited
	
	            var orient = this.orient() == "top" || this.orient() == "bottom" ? HORIZONTAL : VERTICAL;
	
	            if(options.isPivotAuto == null) options.isPivotAuto = orient == VERTICAL;
	
	            if(options.cssFontSize == null) options.cssFontSize = "13px";
	            if(options.widthToFontsizeRatio == null) options.widthToFontsizeRatio = .75;
	            if(options.heightToFontsizeRatio == null) options.heightToFontsizeRatio = 1.20;
	            if(options.widthOfOneDigit == null) options.widthOfOneDigit =
	              parseInt(options.cssFontSize) * options.widthToFontsizeRatio;
	            if(options.heightOfOneDigit == null) options.heightOfOneDigit =
	              parseInt(options.cssFontSize) * options.heightToFontsizeRatio;
	            if(options.fitIntoScale == null || options.fitIntoScale == 'pessimistic') options.fitIntoScale = PESSIMISTIC;
	            if(options.fitIntoScale == 'optimistic') options.fitIntoScale = OPTIMISTIC;
	
	
	            meow("********** " + orient + " **********");
	
	            var domain = axis.scale().domain();
	            var range = axis.scale().range();
	            var lengthDomain = Math.abs(domain[domain.length - 1] - domain[0]);
	            var lengthRange = Math.abs(range[range.length - 1] - range[0]);
	
	            var min = d3.min([domain[0], domain[domain.length - 1]]);
	            var max = d3.max([domain[0], domain[domain.length - 1]]);
	            var bothSidesUsed = (min <= 0 && max >= 0) && options.scaleType != "time";
	
	            var tickValues = options.showOuter ? [min, max] : [];
	            var tickValuesMinor = []; //[min, max];
	            var ticksNumber = 5;
	
	            function getBaseLog(x, base) {
	              if (x == 0 || base == 0) {
	                return 0;
	              }
	              if(base == null) base = options.logBase;
	              return Math.log(x) / Math.log(base);
	            };
	
	            // estimate the longest formatted label in pixels
	            var estLongestLabelLength =
	              //take 17 sample values and measure the longest formatted label
	              d3.max(d3.range(min, max, (max - min) / 17).concat(max).map(function(d) {
	                return options.formatter(d).length
	              })) * options.widthOfOneDigit + parseInt(options.cssMarginLeft);
	
	            var pivot = options.isPivotAuto && (
	              (estLongestLabelLength + axis.tickPadding() + axis.tickSize() > options.pivotingLimit) && (orient ==
	                VERTICAL) ||
	              !(estLongestLabelLength + axis.tickPadding() + axis.tickSize() > options.pivotingLimit) && !(orient ==
	                VERTICAL)
	            );
	
	            var labelsStackOnTop = (orient == HORIZONTAL && pivot || orient == VERTICAL && !pivot);
	
	
	
	
	            // conditions to remove labels altogether
	            var labelsJustDontFit = (!labelsStackOnTop && options.heightOfOneDigit > options.pivotingLimit);
	            if(options.removeAllLabels) return axis.tickValues([]);
	
	            // return a single tick if have only one point in the domain
	            if(min == max) return axis.tickValues([min]).ticks(1).tickFormat(options.formatter);
	
	
	
	
	
	
	            // LABELS FIT INTO SCALE
	            // measure if all labels in array tickValues can fit into the allotted lengthRange
	            // approximationStyle can be OPTIMISTIC or PESSIMISTIC
	            // in optimistic style the length of every label is added up and then we check if the total pack of symbols fit
	            // in pessimistic style we assume all labels have the length of the longest label from tickValues
	            // returns TRUE if labels fit and FALSE otherwise
	            var labelsFitIntoScale = function(tickValues, lengthRange, approximationStyle, rescalingLabels) {
	              if(tickValues == null || tickValues.length <= 1) return true;
	              if(approximationStyle == null) approximationStyle = PESSIMISTIC;
	              if(rescalingLabels == null) scaleType = "none";
	
	
	
	              if(labelsStackOnTop) {
	                //labels stack on top of each other. digit height matters
	                return lengthRange >
	                  tickValues.length * (
	                    options.heightOfOneDigit +
	                    parseInt(options.cssMarginTop) +
	                    parseInt(options.cssMarginBottom)
	                  );
	              } else {
	                //labels stack side by side. label width matters
	                var marginsLR = parseInt(options.cssMarginLeft) + parseInt(options.cssMarginRight);
	                var maxLength = d3.max(tickValues.map(function(d) {
	                  return options.formatter(d).length
	                }));
	
	                // log scales need to rescale labels, so that 9 takes more space than 2
	                if(rescalingLabels == "log") {
	                  // sometimes only a fragment of axis is used. in this case we want to limit the scope to that fragment
	                  // yes, this is hacky and experimental
	                  lengthRange = Math.abs(axis.scale()(d3.max(tickValues)) - axis.scale()(d3.min(tickValues)));
	
	                  return lengthRange >
	                    d3.sum(tickValues.map(function(d) {
	                      return(
	                          options.widthOfOneDigit * (approximationStyle == PESSIMISTIC ? maxLength : options.formatter(
	                            d).length) + marginsLR
	                        )
	                        // this is a logarithmic rescaling of labels
	                        * (1 + Math.log(d.toString().replace(/([0\.])/g, "")[0])/Math.LN10)
	                    }))
	
	                } else {
	                  return lengthRange + options.toolMargin.left + options.toolMargin.right >
	                    tickValues.length * marginsLR + (approximationStyle == PESSIMISTIC ?
	                      options.widthOfOneDigit * tickValues.length * maxLength : 0) + (approximationStyle == OPTIMISTIC ?
	                      options.widthOfOneDigit * (
	                        tickValues.map(function(d) {
	                          return options.formatter(d)
	                        }).join("").length
	                      ) : 0);
	                }
	              }
	            }
	
	
	
	
	
	            // COLLISION BETWEEN
	            // Check is there is a collision between labels ONE and TWO
	            // ONE is a value, TWO can be a value or an array
	            // returns TRUE if collision takes place and FALSE otherwise
	            var collisionBetween = function(one, two) {
	              if(two == null || two.length == 0) return false;
	              if(!(two instanceof Array)) two = [two];
	
	              for(var i = 0; i < two.length; i++) {
	                if(
	                  one != two[i] && one != 0 &&
	                  Math.abs(axis.scale()(one) - axis.scale()(two[i])) <
	                  (labelsStackOnTop ?
	                    (options.heightOfOneDigit) :
	                    (options.formatter(one).length + options.formatter(two[i]).length) * options.widthOfOneDigit / 2
	                  )
	                ) return true;
	
	              }
	              return false;
	            }
	
	            if(options.scaleType == "genericLog" || options.scaleType == "log") {
	              var eps = axis.scale().eps ? axis.scale().eps() : 0;
	
	              var spawnZero = bothSidesUsed ? [0] : [];
	
	              // check if spawn positive is needed. if yes then spawn!
	              var spawnPos = max < eps ? [] : (
	                d3.range(
	                  Math.floor(getBaseLog(Math.max(eps, min))),
	                  Math.ceil(getBaseLog(max)),
	                  1)
	                .concat(Math.ceil(getBaseLog(max)))
	                .map(function(d) {
	                  return Math.pow(options.logBase, d)
	                })
	              );
	
	              // check if spawn negative is needed. if yes then spawn!
	              var spawnNeg = min > -eps ? [] : (
	                d3.range(
	                  Math.floor(getBaseLog(Math.max(eps, -max))),
	                  Math.ceil(getBaseLog(-min)),
	                  1)
	                .concat(Math.ceil(getBaseLog(-min)))
	                .map(function(d) {
	                  return -Math.pow(options.logBase, d)
	                })
	              );
	
	
	              // automatic chosing of method if it's not explicitly defined
	              if(options.method == null) {
	                var coverage = bothSidesUsed ?
	                  Math.max(Math.abs(max), Math.abs(min)) / eps :
	                  Math.max(Math.abs(max), Math.abs(min)) / Math.min(Math.abs(max), Math.abs(min));
	                options.method = 10 <= coverage && coverage <= 1024 ? this.METHOD_DOUBLING : this.METHOD_REPEATING;
	              };
	
	
	              //meow('spawn pos/neg: ', spawnPos, spawnNeg);
	
	
	              if(options.method == this.METHOD_DOUBLING) {
	                var doublingLabels = [];
	                if(bothSidesUsed) tickValues.push(0);
	                var avoidCollidingWith = [].concat(tickValues);
	
	                // start with the smallest abs number on the scale, rounded to nearest nice power
	                //var startPos = max<eps? null : Math.pow(options.logBase, Math.floor(getBaseLog(Math.max(eps,min))));
	                //var startNeg = min>-eps? null : -Math.pow(options.logBase, Math.floor(getBaseLog(Math.max(eps,-max))));
	
	                var startPos = max < eps ? null : 4 * spawnPos[Math.floor(spawnPos.length / 2) - 1];
	                var startNeg = min > -eps ? null : 4 * spawnNeg[Math.floor(spawnNeg.length / 2) - 1];
	
	                //meow('starter pos/neg: ', startPos, startNeg);
	
	                if(startPos) {
	                  for(var l = startPos; l <= max; l *= 2) doublingLabels.push(l);
	                }
	                if(startPos) {
	                  for(var l = startPos / 2; l >= Math.max(min, eps); l /= 2) doublingLabels.push(l);
	                }
	                if(startNeg) {
	                  for(var l = startNeg; l >= min; l *= 2) doublingLabels.push(l);
	                }
	                if(startNeg) {
	                  for(var l = startNeg / 2; l <= Math.min(max, -eps); l /= 2) doublingLabels.push(l);
	                }
	
	                doublingLabels = doublingLabels
	                  .sort(d3.ascending)
	                  .filter(function(d) {
	                    return min <= d && d <= max
	                  });
	
	                tickValuesMinor = tickValuesMinor.concat(doublingLabels);
	
	                doublingLabels = groupByPriorities(doublingLabels, false); // don't skip taken values
	
	                var tickValues_1 = tickValues;
	                for(var j = 0; j < doublingLabels.length; j++) {
	
	                  // compose an attempt to add more axis labels
	                  var trytofit = tickValues_1.concat(doublingLabels[j])
	                    .filter(function(d) {
	                      return !collisionBetween(d, avoidCollidingWith);
	                    })
	                    .filter(onlyUnique)
	
	                  // stop populating if labels don't fit
	                  if(!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "none")) break;
	
	                  // apply changes if no blocking instructions
	                  tickValues = trytofit
	                }
	              }
	
	
	              if(options.method == this.METHOD_REPEATING) {
	
	                var spawn = spawnZero.concat(spawnPos).concat(spawnNeg).sort(d3.ascending);
	
	                options.stops.forEach(function(stop, i) {
	                  tickValuesMinor = tickValuesMinor.concat(spawn.map(function(d) {
	                    return d * stop
	                  }));
	                });
	
	                spawn = groupByPriorities(spawn);
	                var avoidCollidingWith = spawnZero.concat(tickValues);
	
	                var stopTrying = false;
	
	                options.stops.forEach(function(stop, i) {
	                  if(i == 0) {
	                    for(var j = 0; j < spawn.length; j++) {
	
	                      // compose an attempt to add more axis labels
	                      var trytofit = tickValues
	                        .concat(spawn[j].map(function(d) {
	                          return d * stop
	                        }))
	                        // throw away labels that collide with "special" labels 0, min, max
	                        .filter(function(d) {
	                          return !collisionBetween(d, avoidCollidingWith);
	                        })
	                        .filter(function(d) {
	                          return min <= d && d <= max
	                        })
	                        .filter(onlyUnique);
	
	                      // stop populating if labels don't fit
	                      if(!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "none")) break;
	
	                      // apply changes if no blocking instructions
	                      tickValues = trytofit;
	                    }
	
	                    //flatten the spawn array
	                    spawn = [].concat.apply([], spawn);
	                  } else {
	                    if(stopTrying) return;
	
	                    // compose an attempt to add more axis labels
	                    var trytofit = tickValues
	                      .concat(spawn.map(function(d) {
	                        return d * stop
	                      }))
	                      .filter(function(d) {
	                        return min <= d && d <= max
	                      })
	                      .filter(onlyUnique);
	
	                    // stop populating if the new composition doesn't fit
	                    if(!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "log")) {
	                      stopTrying = true;
	                      return;
	                    }
	                    // stop populating if the number of labels is limited in options
	                    if(tickValues.length > options.limitMaxTickNumber && options.limitMaxTickNumber != 0) {
	                      stopTrying = true;
	                      return;
	                    }
	
	                    // apply changes if no blocking instructions
	                    tickValues = trytofit;
	                  }
	                })
	
	
	              } //method
	
	
	            } //logarithmic
	
	
	
	
	            if(options.scaleType == "linear" || options.scaleType == "time") {
	              if(bothSidesUsed) tickValues.push(0);
	              var avoidCollidingWith = [].concat(tickValues);
	
	              if(labelsStackOnTop){
	                  ticksNumber = Math.max(Math.floor(lengthRange / (options.heightOfOneDigit + parseInt(options.cssMarginTop))), 2);
	              }else{
	                  ticksNumber = Math.max(Math.floor(lengthRange / estLongestLabelLength), 2);
	              }
	
	              // limit maximum ticks number
	              if(options.limitMaxTickNumber != 0 && ticksNumber > options.limitMaxTickNumber) ticksNumber = options.limitMaxTickNumber;
	
	              var addLabels = axis.scale().ticks.apply(axis.scale(), [ticksNumber])
	                .sort(d3.ascending)
	                .filter(function(d) {
	                  return min <= d && d <= max
	                });
	
	              tickValuesMinor = tickValuesMinor.concat(addLabels);
	
	              addLabels = groupByPriorities(addLabels, false);
	
	              var tickValues_1 = tickValues;
	              for(var j = 0; j < addLabels.length; j++) {
	
	                // compose an attempt to add more axis labels
	                var trytofit = tickValues_1.concat(addLabels[j])
	                  .filter(function(d) {
	                    return !collisionBetween(d, avoidCollidingWith);
	                  })
	                  .filter(onlyUnique);
	
	                // stop populating if labels don't fit
	                if(!labelsFitIntoScale(trytofit, lengthRange, options.fitIntoScale, "none")) break;
	
	                // apply changes if no blocking instructions
	                tickValues = trytofit
	              }
	
	              tickValues = tickValues //.concat(addLabels)
	                .filter(function(d) {
	                  return !collisionBetween(d, avoidCollidingWith);
	                })
	                .filter(onlyUnique);
	
	
	            }
	
	
	
	
	            if(tickValues != null && tickValues.length <= 2 && !bothSidesUsed) tickValues = [min, max];
	
	            if(tickValues != null && tickValues.length <= 3 && bothSidesUsed) {
	              if(!collisionBetween(0, [min, max])) {
	                tickValues = [min, 0, max];
	              } else {
	                tickValues = [min, max];
	              }
	            }
	
	            if(tickValues != null) tickValues.sort(function(a, b) {
	              return(orient == HORIZONTAL ? -1 : 1) * (axis.scale()(b) - axis.scale()(a))
	            });
	
	            if(labelsJustDontFit) tickValues = [];
	            tickValuesMinor = tickValuesMinor.filter(function(d) {
	              return tickValues.indexOf(d) == -1 && min <= d && d <= max
	            });
	
	
	            meow("final result", tickValues);
	
	            return axis
	              .ticks(ticksNumber)
	              .tickFormat(options.formatter)
	              .tickValues(tickValues)
	              .tickValuesMinor(tickValuesMinor)
	              .pivot(pivot)
	              .repositionLabels(
	                repositionLabelsThatStickOut(tickValues, options, orient, axis.scale(), labelsStackOnTop ? "y" : "x")
	              );
	          };
	
	
	
	
	
	
	
	
	
	
	
	          // GROUP ELEMENTS OF AN ARRAY, SO THAT...
	          // less-prio elements are between the high-prio elements
	          // Purpose: enable adding axis labels incrementally, like this for 9 labels:
	          // PRIO 1: +--------, concat result: +-------- first we show only 1 label
	          // PRIO 2: ----+---+, concat result: +---+---+ then we add 2 more, that are maximally spaced
	          // PRIO 3: --+---+--, concat result: +-+-+-+-+ then we fill spaces with 2 more labels
	          // PRIO 4: -+-+-+-+-, concat result: +++++++++ then we fill the remaing spaces and show all labels
	          // exception: zero jumps to the front, if it's on the list
	          // example1: [1 2 3 4 5 6 7] --> [[1][4 7][2 3 5 6]]
	          // example2: [1 2 3 4 5 6 7 8 9] --> [[1][5 9][3 7][2 4 6 8]]
	          // example3: [-4 -3 -2 -1 0 1 2 3 4 5 6 7] --> [[0][-4][2][-1 5][-3 -2 1 3 4 6 7]]
	          // inputs:
	          // array - the source array to be processed. Only makes sense if sorted
	          // removeDuplicates - return incremental groups (true, default), or return concatinated result (false)
	          // returns:
	          // the nested array
	          function groupByPriorities(array, removeDuplicates) {
	            if(removeDuplicates == null) removeDuplicates = true;
	
	            var result = [];
	            var taken = [];
	
	            //zero is an exception, if it's present we manually take it to the front
	            if(array.indexOf(0) != -1) {
	              result.push([0]);
	              taken.push(array.indexOf(0));
	            }
	
	            for(var k = array.length; k >= 1; k = k < 4 ? k - 1 : k / 2) {
	              // push the next group of elements to the result
	              result.push(array.filter(function(d, i) {
	                if(i % Math.floor(k) == 0 && (taken.indexOf(i) == -1 || !removeDuplicates)) {
	                  taken.push(i);
	                  return true;
	                }
	                return false;
	              }));
	            }
	
	            return result;
	          }
	
	
	
	
	
	
	
	
	          // REPOSITION LABELS THAT STICK OUT
	          // Purpose: the outer labels can easily be so large, they stick out of the allotted area
	          // Example:
	          // Label is fine:    Label sticks out:    Label sticks out more:    Solution - label is shifted:
	          //      12345 |           1234|                123|5                   12345|
	          // _______.   |      _______. |           _______.|                 _______.|
	          //
	          // this is what the function does on the first step (only outer labels)
	          // on the second step it shifts the inner labels that start to overlap with the shifted outer labels
	          //
	          // requires tickValues array to be sorted from tail-first
	          // tail means left or bottom, head means top or right
	          //
	          // dimension - which dimension requires shifting
	          // X if labels stack side by side, Y if labels stack on top of one another
	          //
	          // returns the array of recommended {x,y} shifts
	
	          function repositionLabelsThatStickOut(tickValues, options, orient, scale, dimension) {
	            if(tickValues == null) return null;
	
	            // make an abstraction layer for margin sizes
	            // tail means left or bottom, head means top or right
	            var margin =
	              orient == VERTICAL ? {
	                head: options.toolMargin.top,
	                tail: options.toolMargin.bottom
	              } : {
	                head: options.toolMargin.right,
	                tail: options.toolMargin.left
	              };
	
	
	            var result = {};
	
	
	            // STEP 1:
	            // for outer labels: avoid sticking out from the tool margin
	            tickValues.forEach(function(d, i) {
	              if(i != 0 && i != tickValues.length - 1) return;
	
	              // compute the influence of the axis head
	              var repositionHead = margin.head + options.bump 
	                + (orient == HORIZONTAL ? 1 : 0) * d3.max(scale.range()) 
	                - (orient == HORIZONTAL ? 0 : 1) * d3.min(scale.range()) 
	                + (orient == HORIZONTAL ? -1 : 1) * scale(d) 
	                - (dimension == "x") * options.formatter(d).length * options.widthOfOneDigit / 2 
	                - (dimension == "y") * options.heightOfOneDigit / 2
	                // we may consider or not the label margins to give them a bit of spacing from the edges
	                - (dimension == "x") * parseInt(options.cssMarginRight) 
	                - (dimension == "y") * parseInt(options.cssMarginTop);
	
	              // compute the influence of the axis tail
	              var repositionTail = Math.min(margin.tail, options.widthOfOneDigit) + options.bump 
	                + (orient == VERTICAL ? 1 : 0) * d3.max(scale.range()) 
	                - (orient == VERTICAL ? 0 : 1) * d3.min(scale.range()) 
	                + (orient == VERTICAL ? -1 : 1) * scale(d) - (dimension == "x") 
	                * options.formatter(d).length * options.widthOfOneDigit / 2 - (dimension == "y") * options.heightOfOneDigit / 2
	                // we may consider or not the label margins to give them a bit of spacing from the edges
	                - (dimension == "x") * parseInt(options.cssMarginLeft) 
	                - (dimension == "y") * parseInt(options.cssMarginBottom);
	
	              // apply limits in order to cancel repositioning of labels that are good
	              if(repositionHead > 0) repositionHead = 0;
	              if(repositionTail > 0) repositionTail = 0;
	
	              // add them up with appropriate signs, save to the axis
	              result[i] = {
	                x: 0,
	                y: 0
	              };
	              result[i][dimension] = (dimension == "y" && orient == VERTICAL ? -1 : 1) * (repositionHead -
	                repositionTail);
	            });
	
	
	            // STEP 2:
	            // for inner labels: avoid collision with outer labels
	            tickValues.forEach(function(d, i) {
	              if(i == 0 || i == tickValues.length - 1) return;
	
	              // compute the influence of the head-side outer label
	              var repositionHead =
	                // take the distance between head and the tick at hand
	                Math.abs(scale(d) - scale(tickValues[tickValues.length - 1]))
	              
	                // substract the shift of the head TODO: THE SIGN CHOICE HERE MIGHT BE WRONG. NEED TO TEST ALL CASES
	                - (dimension == "y") * (orient == HORIZONTAL ? -1 : 1) * result[tickValues.length - 1][dimension]
	                - (dimension == "x") * (orient == HORIZONTAL ? 1 : -1) * result[tickValues.length - 1][dimension]
	              
	                // substract half-length of the overlapping labels
	                - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(d).length 
	                - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(tickValues[tickValues.length - 1]).length 
	                - (dimension == "y") * options.heightOfOneDigit * .7 //TODO remove magic constant - relation of actual font height to BBox-measured height
	                
	                // we may consider or not the label margins to give them a bit of spacing from the edges
	                - (dimension == "x") * parseInt(options.cssMarginLeft) 
	                - (dimension == "y") * parseInt(options.cssMarginBottom);
	                
	              // compute the influence of the tail-side outer label
	              var repositionTail =
	                // take the distance between tail and the tick at hand
	                Math.abs(scale(d) - scale(tickValues[0]))
	              
	                // substract the shift of the tail TODO: THE SIGN CHOICE HERE MIGHT BE WRONG. NEED TO TEST ALL CASES
	                - (dimension == "y") * (orient == VERTICAL ? -1 : 1) * result[0][dimension]
	                - (dimension == "x") * (orient == VERTICAL ? 1 : -1) * result[0][dimension]
	              
	                // substract half-length of the overlapping labels
	                - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(d).length 
	                - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(tickValues[0]).length 
	                - (dimension == "y") * options.heightOfOneDigit * .7 //TODO remove magic constant - relation of actual font height to BBox-measured height
	              
	                // we may consider or not the label margins to give them a bit of spacing from the edges
	                - (dimension == "x") * parseInt(options.cssMarginLeft) 
	                - (dimension == "y") * parseInt(options.cssMarginBottom);
	
	              // apply limits in order to cancel repositioning of labels that are good
	              if(repositionHead > 0) repositionHead = 0;
	              if(repositionTail > 0) repositionTail = 0;
	
	              // add them up with appropriate signs, save to the axis
	              result[i] = {
	                x: 0,
	                y: 0
	              };
	              result[i][dimension] = (dimension == "y" && orient == VERTICAL ? -1 : 1) * (repositionHead -
	                repositionTail);
	            });
	
	
	            return result;
	          } // function repositionLabelsThatStickOut()
	
	
	
	
	          axis.copy = function() {
	            return d3_axis_smart(d3.svg.axis());
	          };
	
	          return d3.rebind(axis, _super,
	            "scale", "orient", "ticks", "tickValues", "tickFormat",
	            "tickSize", "innerTickSize", "outerTickSize", "tickPadding",
	            "tickSubdivide"
	          );
	
	
	          function meow(l1, l2, l3, l4, l5) {
	            if(!axis.labelerOptions().isDevMode) return;
	            if(l5 != null) {
	              console.log(l1, l2, l3, l4, l5);
	              return;
	            }
	            if(l4 != null) {
	              console.log(l1, l2, l3, l4);
	              return;
	            }
	            if(l3 != null) {
	              console.log(l1, l2, l3);
	              return;
	            }
	            if(l2 != null) {
	              console.log(l1, l2);
	              return;
	            }
	            if(l1 != null) {
	              console.log(l1);
	              return;
	            }
	          }
	
	        }(d3.svg.axis());
	
	      };
	
	      /*!
	       * VIZABI BUBBLE COLOR LEGEND COMPONENT
	       */
	
	      var OPACITY_REGULAR = 0.8;
	      var OPACITY_DIM = 0.5;
	      var OPACITY_HIGHLIGHT = 1;
	
	      var ColorLegend = Component.extend({
	
	        init: function(config, context) {
	          var _this = this;
	          this.template = '<div class="vzb-cl-outer"></div>';
	          this.name = 'colorlegend';
	
	          this.model_expects = [{
	            name: "state",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	          this.needsUpdate = false;
	          this.which_1 = false;
	          this.scaleType_1 = false;
	
	          this.model_binds = {
	            "change:state.marker.color.scaleType": function(evt, path) {
	              if(!_this._readyOnce) return;
	              _this.updateView();
	            },
	            "change:state.marker.color.which": function(evt, path) {
	              if(!_this._readyOnce) return;
	              if(_this.model.state.entities_minimap) {
	                _this.forwardModelUpdate();
	              }else{
	                _this.updateView();
	              }
	            },
	            "change:state.marker.color.palette": function(evt, path) {
	              if(!_this._readyOnce) return;
	              _this.updateView();
	            },
	            "change:language.strings": function(evt) {
	              this.translator = this.model.language.getTFunction();
	              _this.updateView();
	            }
	          }
	          
	          //contructor is the same as any component
	          this._super(config, context);
	        },
	        
	        forwardModelUpdate: function(){
	          if(this.colorModel.use === "property"){
	            this.model.state.entities_minimap.show[this.KEY + ".cat"] = [this.colorModel.which.replace(this.KEY+".","")];
	          }
	        },
	
	
	        readyOnce: function() {
	          var _this = this;
	          this.element = d3.select(this.element);
	          
	          this.translator = this.model.language.getTFunction();
	          
	          this.markerModel = this.model.state.marker_minimap ? this.model.state.marker_minimap : this.model.state.marker;
	          this.listColorsEl = this.element
	            .append("div").attr("class", "vzb-cl-holder")
	            .append("div").attr("class","vzb-cl-colorlist");
	          this.rainbowEl = this.listColorsEl.append("div").attr("class", "vzb-cl-rainbow");
	          this.minimapEl = this.listColorsEl.append("div").attr("class", "vzb-cl-minimap");
	          this.labelScaleEl = this.listColorsEl.append("div").attr("class", "vzb-cl-labelscale");
	          this.labelScaleSVG = this.labelScaleEl.append("svg");
	          this.labelScaleG = this.labelScaleSVG.append("g");
	          this.unitDiv = this.listColorsEl.append("div").attr("class", "vzb-cl-unit");
	          this.unitText = this.unitDiv.append("text").attr("class", "vzb-cl-unit-text");
	
	          this.minimapSVG = this.minimapEl.append("svg");
	          this.minimapG = this.minimapSVG.append("g");
	
	          this.colorPicker = colorPicker();
	          
	          // append color picker to the tool DOM. need to check if element is already a d3 selection to not do it twice
	          this.root.element instanceof Array? this.root.element : d3.select(this.root.element)
	            .call(this.colorPicker);
	
	          this.KEY = this.model.state.entities.getDimension();
	          this.colorModel = this.model.state.marker.color;
	          
	          OPACITY_REGULAR = this.model.state.entities.opacityRegular;
	          OPACITY_DIM = this.model.state.entities.opacitySelectDim;
	          OPACITY_HIGHLIGHT = 1;
	          
	        },
	        
	        
	        ready: function(){
	          var _this = this;
	          if(this.model.state.marker_minimap){
	            var minimapDim = this.model.state.marker_minimap._getFirstDimension();
	            var timeModel = this.model.state.time;
	            var filter = {};
	            filter[timeModel.getDimension()] = timeModel.value;
	            _this.frame = this.model.state.marker_minimap.getValues(filter,[minimapDim]);
	          }
	          _this.updateView();
	        },
	
	
	        updateView: function() {
	          var _this = this;
	          var KEY = this.KEY;
	
	          var palette = this.colorModel.getPalette();
	          var canShowMap = keys((this.frame||{}).geoshape||{}).length && this.colorModel.use == "property";
	
	          var minimapKeys = [];
	
	          if(this.model.state.marker_minimap){
	            var minimapDim = this.model.state.marker_minimap._getFirstDimension();
	            var minimapKeys = this.model.state.marker_minimap.getKeys(minimapDim);
	          }
	          
	          minimapKeys.forEach(function(d){
	            if(!((_this.frame||{}).geoshape||{})[d[_this.KEY]]) canShowMap = false;
	          });
	          
	
	          var colorOptions = this.listColorsEl.selectAll(".vzb-cl-option");
	          
	          //Hide and show elements of the color legend
	          //Hide color legend entries if showing minimap or if color hook is a constant
	          colorOptions.classed("vzb-hidden", canShowMap || this.colorModel.which == "_default");
	          //Hide rainbow element if showing minimap or if color is discrete
	          //TODO: indocators-properties are incorrectly used here.
	          this.rainbowEl.classed("vzb-hidden", canShowMap || this.colorModel.use !== "indicator");
	          //Hide minimap if no data to draw it
	          this.minimapEl.classed("vzb-hidden", !canShowMap);
	          
	          this.labelScaleEl.classed("vzb-hidden", canShowMap || this.colorModel.use !== "indicator")
	          this.unitDiv.classed("vzb-hidden", true);
	
	          //Check if geoshape is provided
	          if(!canShowMap) {
	            if(this.colorModel.which == "_default") {
	              colorOptions = colorOptions.data([]); 
	            }else if(this.colorModel.use == "indicator" || !minimapKeys.length) {
	              colorOptions = colorOptions.data(keys(this.colorModel.getScale().range()), function(d) {return d});
	            }else{
	              colorOptions = colorOptions.data(minimapKeys, function(d) {return d[minimapDim]});
	            }
	
	            colorOptions.exit().remove();
	            
	            colorOptions.enter().append("div").attr("class", "vzb-cl-option")
	              .each(function() {
	                d3.select(this).append("div").attr("class", "vzb-cl-color-sample");
	                d3.select(this).append("div").attr("class", "vzb-cl-color-legend");
	              })
	              .on("mouseover", _this._interact().mouseover)
	              .on("mouseout", _this._interact().mouseout)
	              .on("click", _this._interact().click);
	
	            colorOptions.each(function(d, index) {
	              d3.select(this).select(".vzb-cl-color-sample")
	                .style("background-color", palette[d[_this.KEY]||d[minimapDim]||d])
	                .style("border", "1px solid " + palette[d[_this.KEY]||d[minimapDim]||d]);
	            }); 
	            
	            if(this.colorModel.use == "indicator") {
	        
	              var gradientWidth = this.rainbowEl.node().getBoundingClientRect().width;
	              var paletteKeys = Object.keys(palette).map(parseFloat);
	              
	              var domain;
	              var range;
	              var labelScale;
	              var formatter = this.colorModel.getTickFormatter();
	              var fitIntoScale = null;
	                
	              var paletteLabels = this.colorModel.paletteLabels;
	
	              if(paletteLabels) {
	
	                fitIntoScale = "optimistic";
	                
	                domain = paletteLabels.map(function(val) {
	                  return parseFloat(val);
	                });
	                var paletteMax = d3.max(domain);
	                range = domain.map(function(val) {
	                  return val / paletteMax * gradientWidth;
	                });  
	
	              } else {
	
	                domain = _this.colorModel.getScale().domain();
	                var paletteMax = d3.max(paletteKeys);
	                range = paletteKeys.map(function(val) {
	                  return val / paletteMax * gradientWidth;
	                });
	
	              }
	                
	              labelScale = d3.scale[this.colorModel.scaleType == "time" ? "linear" : this.colorModel.scaleType]()
	                .domain(domain)
	                .range(range);
	                
	              var marginLeft = parseInt(this.rainbowEl.style('left'), 10) || 0;
	              var marginRight = parseInt(this.rainbowEl.style('right'), 10) || marginLeft;
	
	              this.labelScaleSVG.style("width", marginLeft + gradientWidth + marginRight + "px");
	              this.labelScaleG.attr("transform","translate(" + marginLeft + ",0)");
	
	              var labelsAxis = axisSmart();
	              labelsAxis.scale(labelScale)
	                .orient("bottom")
	                //.tickFormat(formatter)
	                .tickSize(6, 0)
	                .tickSizeMinor(3, 0)
	                .labelerOptions({
	                  scaleType: this.colorModel.scaleType,
	                  toolMargin: {
	                    right: marginRight,
	                    left: marginLeft
	                  },
	                  showOuter: true,
	                  //bump: this.activeProfile.maxRadius/2,
	                  //constantRakeLength: gradientWidth,
	                  formatter: formatter,
	                  bump: marginLeft,
	                  cssFontSize: "11px",
	                  fitIntoScale: fitIntoScale
	                });
	                    
	              this.labelScaleG.call(labelsAxis);
	
	              var colorRange = _this.colorModel.getScale().range();
	              var gColors = paletteKeys.map(function(val, i) {
	                return colorRange[i] + " " + d3.format("%")(val * .01);
	              }).join(", ");
	
	              //Calculate the hight for the rainbow gradient
	              // var gradientHeight;
	              // if(colorOptions && colorOptions[0]) {
	              //   var firstOptionSize = colorOptions[0][0].getBoundingClientRect();
	              //   var  = colorOptions[0][colorOptions[0].length - 1].getBoundingClientRect();
	              //   gradientHeight = lastOptionSize.bottom - firstOptionSize.top;
	              // }
	              // if(!isFinite(gradientHeight)) gradientHeight = utils.keys(palette).length * 25 + 5;
	              
	              this.rainbowEl
	                .style("background", "linear-gradient(90deg," + gColors + ")");
	              
	              var unit = this.translator("unit/" + this.colorModel.which)
	              
	              this.unitDiv.classed("vzb-hidden", unit == "");
	              this.unitText.text(unit);
	
	              //Apply names as formatted numbers 
	              // colorOptions.each(function(d, index) {
	              //   d3.select(this).select(".vzb-cl-color-legend")
	              //     .text(_this.colorModel.getTickFormatter()(domain[index]))
	              // });
	              colorOptions.classed("vzb-hidden", true);
	
	            } else {
	              
	              //Apply names to color legend entries if color is a property
	              colorOptions.each(function(d, index) {
	                d3.select(this).select(".vzb-cl-color-legend")
	                  .text(_this.frame.label[d[_this.KEY]||d[minimapDim]]);
	              });
	              
	              
	              //if using a discrete palette that is not supplied from concept properties but from defaults
	              colorOptions.classed("vzb-cl-compact", !(this.colorModel.getConceptprops().color||{}).palette );
	            }
	            
	
	          }else{
	            
	            //Drawing a minimap from the hook data
	            
	            var tempdivEl = this.minimapEl.append("div").attr("class","vzb-temp");
	            
	            this.minimapSVG.attr("viewBox",null)
	            this.minimapSVG.selectAll("g").remove()
	            this.minimapG = this.minimapSVG.append("g");
	            this.minimapG.selectAll("path")
	              .data(minimapKeys, function(d) {return d[KEY]})
	              .enter().append("path")
	              .style("opacity", OPACITY_REGULAR)
	              .on("mouseover", _this._interact().mouseover)
	              .on("mouseout", _this._interact().mouseout)
	              .on("click", _this._interact().click)
	              .each(function(d){
	                tempdivEl.html(_this.frame.geoshape[d[_this.KEY]]);
	                var color = palette[d[_this.KEY]];
	                
	                d3.select(this)
	                  .attr("d", tempdivEl.select("svg").select("path").attr("d"))
	                  .style("fill", isArray(color)? color[0] : color)
	              
	                tempdivEl.html("");
	              })
	            
	            var gbbox = this.minimapG.node().getBBox();
	            this.minimapSVG.attr("viewBox", "0 0 " + gbbox.width*1.05 + " " + gbbox.height*1.05);
	            tempdivEl.remove();
	          }
	            
	        },
	        
	        
	        _interact: function() {
	          var _this = this;
	          var KEY = this.KEY;
	          var palette = this.colorModel.getPalette();
	          var paletteDefault = this.colorModel.getDefaultPalette();
	
	          return {
	            mouseover: function(d, i) {
	              //disable interaction if so stated in concept properties
	              if(_this.colorModel.use === "indicator") return;
	              
	              var view = d3.select(this);
	              var target = d[KEY];
	              _this.listColorsEl.selectAll(".vzb-cl-option").style("opacity", OPACITY_DIM);
	              _this.minimapG.selectAll("path").style("opacity", OPACITY_DIM);
	              view.style("opacity", OPACITY_HIGHLIGHT);
	
	              var filtered = _this.colorModel.getNestedItems([KEY]);
	              var highlight = values(filtered)
	                //returns a function over time. pick the last time-value
	                .map(function(d) {
	                  return d[d.length - 1]
	                })
	                //filter so that only countries of the correct target remain
	                .filter(function(f) {
	                  return f[_this.colorModel.which] == target
	                })
	                //fish out the "key" field, leave the rest behind
	                .map(function(d) {
	                  return clone(d, [KEY])
	                });
	
	              _this.model.state.entities.setHighlight(highlight);
	            },
	
	            mouseout: function(d, i) {
	              //disable interaction if so stated in concept properties
	              if(_this.colorModel.use === "indicator") return;
	
	              _this.listColorsEl.selectAll(".vzb-cl-option").style("opacity", OPACITY_REGULAR);
	              _this.minimapG.selectAll("path").style("opacity", OPACITY_REGULAR);
	              _this.model.state.entities.clearHighlighted();
	            },
	            click: function(d, i) {
	              //disable interaction if so stated in concept properties
	              if(!_this.colorModel.isUserSelectable()) return;
	              var view = d3.select(this);
	              var target = _this.colorModel.use === "indicator"? d : (d[KEY]||d);
	
	              _this.colorPicker
	                .colorOld(palette[target])
	                .colorDef(paletteDefault[target])
	                .callback(function(value) {
	                  _this.colorModel.setColor(value, target)
	                })
	                .fitToScreen([d3.event.pageX, d3.event.pageY])
	                .show(true);
	            }
	          }
	        },
	        
	
	        resize: function() {
	          if(this.colorModel.use == "indicator") {
	            this.updateView();
	          }
	          this.colorPicker.resize(d3.select('.vzb-colorpicker-svg'));
	        }
	
	      });
	
	      var hidden = true;
	      var showNotes = false;
	      var pin = false;
	      var left = 0;
	      var top = 0;
	      var hookName = null;
	      var newHookName = null;
	
	      var DataNotes = Component.extend({
	
	        init: function(config, context) {
	          var _this = this;
	
	          this.name = 'gapminder-datanotes';
	
	          this.model_expects = [{
	            name: "marker",
	            type: "model"
	          },{
	            name: "language",
	            type: "language"
	          }];
	
	          this.context = context;
	
	          this.model_binds = {
	            "change:language.strings": function(evt) {
	              _this.ready();
	            }
	          }
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.ui = extend({
	            //...add properties here
	          }, this.ui);
	
	          this.close = this.close.bind(this);
	        },
	
	        ready: function() {
	          this.translator = this.model.language.getTFunction();
	          //this.setValues();
	        },
	
	        readyOnce: function() {
	          var _this = this;
	          this.element = d3.select(this.placeholder);
	
	          this.element.selectAll("div").remove();
	
	          var container = this.element;
	
	          container.append("div")
	            .html(iconClose)
	            .on("click", function() {
	              d3.event.stopPropagation();
	              _this.close();
	            })
	            .select("svg")
	            .attr("width", "0px")
	            .attr("height", "0px")
	            .attr("class", "vzb-data-notes-close")
	            .classed('vzb-hidden', true);
	
	          container.append("div")
	            .attr("class", "vzb-data-notes-body vzb-dialog-scrollable")
	
	          container.append("div")
	            .attr("class", "vzb-data-notes-link")
	
	        },
	
	        resize: function() {
	          this.close();
	        },
	
	        close: function() {
	          if(!hidden) {
	            this.pin(false).hide();
	          }
	        },
	
	        setHook: function(_hookName) {
	          if(!this._readyOnce) return this; 
	          if(pin) {
	            newHookName = _hookName;
	            return this;
	          }
	          if(hookName) this.model.marker[hookName].off('change:which', this.close);
	          hookName = newHookName = _hookName;
	          this.model.marker[hookName].on('change:which', this.close);
	          
	          this.setValues();
	
	          return this;
	        },
	
	        setValues: function() {
	          if(!hookName) return;
	          var hook = this.model.marker[hookName];
	          var description = this.translator('description/' + hook.which);
	          var showDescription = description != ('description/' + hook.which);
	          if(showDescription) this.element.select('.vzb-data-notes-body').text(description);
	          this.element.select('.vzb-data-notes-body').classed('vzb-hidden', !showDescription);
	         
	          var sourceLink = hook.getConceptprops().sourceLink;
	          this.element.select('.vzb-data-notes-link').classed('vzb-hidden', !sourceLink);
	
	          if(sourceLink) {
	            var _source = this.translator('hints/source');
	            var sourceName = this.translator('sourceName/' + hook.which);
	            var showSourceName = sourceName != ('sourceName/' + hook.which);
	            this.element.select('.vzb-data-notes-link').html('<span>' + (showSourceName ? (_source + ':') : '') +
	              '<a href="' + sourceLink + '" target="_blank">' + (showSourceName ? sourceName : _source) + '</a></span>');
	          }
	          showNotes = sourceLink != null || showDescription;
	        },
	
	        setPos: function(_left, _top, force) {
	          left = _left;
	          top = _top;
	          if(pin && !force) return this;
	          var parentHeight = this.parent.element.offsetHeight;
	          var width = this.element.node().offsetWidth;
	          var height = this.element.node().offsetHeight;
	          var leftMove;
	          var topMove;
	          var leftPos = left - width;
	          var topPos = top;
	          if(leftPos < 10) {
	            leftPos = 10;
	            leftMove = true;
	          }
	          if((topPos + height + 10) > parentHeight) {
	            topPos = parentHeight - height - 10;
	            topMove = true;
	          }
	
	          if(leftMove && topMove) {
	            topPos = top - height - 30;
	          }
	
	          this.element.style({'top': topPos + 'px', 'left': leftPos + 'px'});
	
	          return this;
	        },
	
	        pin: function(arg) {
	          if(hidden) return this;
	          pin = !pin;
	          if(arg != null) pin = arg;
	          this.element.select('.vzb-data-notes-close').classed('vzb-hidden', !pin);
	          this.element.classed('vzb-data-notes-pinned', pin);
	          if(hookName != newHookName) this.setHook(newHookName);  
	          this.element.select('.vzb-data-notes-body').node().scrollTop = 0;
	          if(!showNotes) {
	            return this.hide();
	          } else {
	            return this.setPos(left, top, true);      
	          }
	        },
	
	        toggle: function(arg) {
	          if(pin || !hookName) return this;
	          if(arg == null) arg = !hidden;
	          hidden = arg;
	          this.element.classed("vzb-hidden", hidden || !showNotes);
	          return this;
	        },
	
	        show: function() {
	          return this.toggle(false);
	        },
	
	        hide: function() {
	          return this.toggle(true);
	        }
	
	      });
	
	      var hidden$1 = true;
	
	      var DataWarning = Component.extend({
	
	        init: function(config, context) {
	          var _this = this;
	
	          this.name = 'gapminder-datawarning';
	
	          this.model_expects = [{
	            name: "language",
	            type: "language"
	          }];
	
	          this.context = context;
	
	          this.model_binds = {
	            "change:language.strings": function(evt) {
	              _this.ready();
	            }
	          }
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.ui = extend({
	            //...add properties here
	          }, this.ui);
	
	        },
	
	        ready: function() {},
	
	        readyOnce: function() {
	          var _this = this;
	          this.element = d3.select(this.placeholder);
	          this.translator = this.model.language.getTFunction();
	
	          this.element.selectAll("div").remove();
	
	          this.element.append("div")
	            .attr("class", "vzb-data-warning-background")
	            .on("click", function() {
	              _this.toggle(true)
	            });
	
	          var container = this.element.append("div")
	            .attr("class", "vzb-data-warning-box");
	
	          container.append("div")
	            .html(iconClose)
	            .on("click", function() {
	              _this.toggle()
	            })
	            .select("svg")
	            .attr("width", "0px")
	            .attr("height", "0px")
	            .attr("class", "vzb-data-warning-close");
	
	          var icon = container.append("div")
	            .attr("class", "vzb-data-warning-link")
	            .html(iconWarn)
	
	          icon.append("div")
	            .text("Data doubts");
	
	          if(this.parent.datawarning_content.title) {
	            container.append("div")
	              .attr("class", "vzb-data-warning-title")
	              .html(this.parent.datawarning_content.title);
	          }
	
	          container.append("div")
	            .attr("class", "vzb-data-warning-body vzb-dialog-scrollable")
	            .html(this.parent.datawarning_content.body);
	
	        },
	
	        toggle: function(arg) {
	          if(arg == null) arg = !hidden$1;
	          hidden$1 = arg;
	          this.element.classed("vzb-hidden", hidden$1);
	
	          var _this = this;
	          this.parent.components.forEach(function(c) {
	            c.element.classed("vzb-blur", c != _this && !hidden$1);
	          })
	        }
	
	      });
	
	      /*!
	       * VIZABI DIALOG
	       * Reusable Dialog component
	       */
	
	      var Dialog = Component.extend({
	        /**
	         * Initializes the dialog
	         * @param {Object} config Initial config, with name and placeholder
	         * @param {Object} parent Reference to tool
	         */
	        init: function(config, parent) {
	          this.name = this.name || '';
	
	          this.model_expects = this.model_expects || [{
	            name: "state",
	            type: "model"
	          }, {
	            name: "ui",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	          this.template = this.name + '.html';
	
	          this._super(config, parent);
	        },
	
	        /**
	         * Executed when the dialog has been rendered
	         */
	        readyOnce: function() {
	          this.element = d3.select(this.element);
	          this.titleEl = this.element.selectAll('.vzb-top-dialog > .vzb-dialog-modal > .vzb-dialog-title');
	          this.buttonsEl = this.element.selectAll('.vzb-top-dialog > .vzb-dialog-modal > .vzb-dialog-buttons');
	          this.contentEl = this.element.selectAll('.vzb-top-dialog > .vzb-dialog-modal > .vzb-dialog-content');
	        },
	
	        ready: function() {
	          var _this = this;
	          this.placeholderEl = d3.select(this.placeholder);
	          this.rootEl = this.root.element instanceof Array? this.root.element : d3.select(this.root.element)
	          this.dragHandler = this.placeholderEl.select("[data-click='dragDialog']");
	          this.dragHandler.html(iconDrag);
	          this.pinIcon = this.placeholderEl.select("[data-click='pinDialog']");
	          this.pinIcon.html(iconPin);
	          this.dragContainerEl = d3.select('.vzb-tool');
	          this.topPos = '';
	          var profile = this.getLayoutProfile();
	
	          var dg = dialogDrag(this.placeholderEl, this.dragContainerEl, 10);
	          var dragBehavior = d3.behavior.drag()
	            .on('dragstart', function D3dialogDragStart() {
	              var topPos = _this.placeholderEl.node().offsetTop;
	              _this.placeholderEl.style({'top': topPos + 'px', 'bottom': 'auto'});
	              _this.trigger('dragstart');
	              dg.dragStart(d3.event);
	            })
	            .on('drag', function D3dialogDrag() {
	              _this.trigger('drag');
	              dg.drag(d3.event);
	            })
	            .on('dragend', function D3dialogDrag() {
	              _this.rightPos = _this.placeholderEl.style('right');
	              _this.topPos = _this.placeholderEl.style('top');
	              _this.trigger('dragend');
	            });
	          this.dragHandler.call(dragBehavior);
	
	          this.dragHandler.classed("vzb-hidden", profile === 'small');
	          this.pinIcon.classed("vzb-hidden", profile === 'small');
	          this.resize();
	        },
	
	        resize: function() {
	          if(this.placeholderEl && this.dragContainerEl && this.placeholderEl.classed('vzb-top-dialog')) {
	            this.placeholderEl.classed('notransition', true);
	
	            var profile = this.getLayoutProfile();
	
	            if(profile !== 'small') {
	              var chartWidth = parseInt(this.dragContainerEl.style('width'), 10);
	              var dialogRight = parseInt(this.rightPos, 10);
	              var chartHeight = parseInt(this.rootEl.style('height'), 10);
	              var dialogTop = parseInt(this.topPos, 10);
	              var dialogWidth = parseInt(this.placeholderEl.style('width'), 10);
	              var dialogHeight = parseInt(this.placeholderEl.style('height'), 10);
	              var dialogRightMargin = parseInt(this.placeholderEl.style('margin-right'), 10) || 0;
	              if(isNumber(dialogRight) && dialogRight > chartWidth - dialogWidth - dialogRightMargin) {
	                if(this.rightPos) {
	                  this.rightPos = (chartWidth - dialogWidth - dialogRightMargin) + 'px';
	                  if(this.isOpen) this.placeholderEl.style('right', this.rightPos);
	                }
	              }
	              if(isNumber(dialogTop) && isNumber(dialogHeight) && dialogTop >= 0 && dialogTop > chartHeight - dialogHeight) {
	                if(this.topPos) {
	                  this.topPos = ((chartHeight - dialogHeight) > 0 ? (chartHeight - dialogHeight) : 0)  + 'px';
	                  if(this.isOpen) this.placeholderEl.style('top', this.topPos);
	                }
	              }
	              
	              if(this.topPos && (this.getLayoutProfile() === 'large' && this.rootEl.classed("vzb-dialog-expand-true"))) {
	                  this.placeholderEl.style('bottom', 'auto');
	              }
	
	              if(this.rootEl.classed('vzb-landscape')) {
	                // var contentHeight = parseInt(this.rootEl.style('height'));
	                // var placeholderHeight = parseInt(this.placeholderEl.style('height'));
	                // if (contentHeight < placeholderHeight) {
	                //   this.topPos = (-contentHeight + 50) + 'px';
	                //   this.rightPos = '';
	                //   this.placeholderEl.style('right', this.rightPos);
	                //   this.placeholderEl.style('bottom', 'auto');
	                // } else {
	                //   //this.topPos = '';
	                //   this.placeholderEl.style('bottom', '');
	                // }
	              }
	              //this.placeholderEl.style('top', this.topPos);
	              this.element.style('max-height', '');
	            } else {
	              this.rightPos = '';
	              this.topPos = '';
	              this.placeholderEl.attr('style', '');
	              // var totalHeight = this.root.element.offsetHeight;
	              // if(this.rootEl.classed('vzb-portrait')) totalHeight = totalHeight - 50;
	              // this.element.style('max-height', (totalHeight - 10) + 'px');
	            }
	
	            this.dragHandler.classed("vzb-hidden", profile === 'small');
	            this.pinIcon.classed("vzb-hidden", profile === 'small');
	
	            this._setMaxHeight();
	          }
	        },
	
	        _setMaxHeight: function() {
	          var totalHeight = this.root.element.offsetHeight;
	          if(this.getLayoutProfile() !== 'small') {
	            if(!this.topPos && (this.getLayoutProfile() === 'large' && this.rootEl.classed("vzb-dialog-expand-true"))) {
	              var dialogBottom = parseInt(this.placeholderEl.style('bottom'), 10);
	              totalHeight = totalHeight - dialogBottom;
	            } else {
	              var topPos = this.topPos ? parseInt(this.topPos, 10) : this.placeholderEl[0][0].offsetTop; 
	              totalHeight = totalHeight - topPos;
	            }
	          } else {
	              totalHeight = this.rootEl.classed('vzb-portrait') ? totalHeight - 50 : totalHeight - 10;
	          }
	
	          this.element.style('max-height', totalHeight + 'px');
	          
	          //set 'max-height' to content for IE11
	          var contentHeight = totalHeight - this.titleEl.node().offsetHeight - this.buttonsEl.node().offsetHeight;
	          this.contentEl.style('max-height', contentHeight + 'px');
	        },
	
	        beforeOpen: function() {
	          var _this = this;
	          
	          this.transitionEvents = ['webkitTransitionEnd', 'transitionend', 'msTransitionEnd', 'oTransitionEnd'];
	          this.transitionEvents.forEach(function(event) {
	            _this.placeholderEl.on(event, _this.transitionEnd.bind(_this, event));
	          });
	
	          this.placeholderEl.classed('notransition', true);
	          
	          this.placeholderEl.style({'top': '', 'bottom': ''}); // issues: 369 & 442
	          
	          if(this.topPos && this.getLayoutProfile() === 'large' && this.rootEl.classed("vzb-dialog-expand-true")) {
	            var topPos = this.placeholderEl.node().offsetTop;
	            this.placeholderEl.style({'top': topPos + 'px', 'bottom': 'auto'}); // issues: 369 & 442
	          } else if(this.getLayoutProfile() !== 'small') {
	            //if(this.rightPos) this.placeholderEl.style('right', this.rightPos);
	          }
	
	          this.placeholderEl.node().offsetTop;            
	          this.placeholderEl.classed('notransition', false);
	
	          if(this.getLayoutProfile() === 'small') {
	            this.placeholderEl.style('top', ''); // issues: 369 & 442
	          } else if(this.rootEl.classed('vzb-landscape')) { // need to recalculate popup position (Safari 8 bug)
	            // var contentHeight = parseInt(this.rootEl.style('height'));
	            // var placeholderHeight = parseInt(this.placeholderEl.style('height'));
	            // if (contentHeight < placeholderHeight) {
	            //   this.topPos = (-contentHeight + 50) + 'px';
	            //   this.rightPos = '';
	            //   this.placeholderEl.style('right', this.rightPos);
	            //   this.placeholderEl.style('bottom', 'auto');
	            // } else {
	            //   this.topPos = '';
	            //   this.placeholderEl.style('bottom', '');
	            // }
	            //this.placeholderEl.style('top', this.topPos);
	          }
	          
	        },
	
	        /**
	         * User has clicked to open this dialog
	         */
	        open: function() {
	          this.isOpen = true;
	          if(this.getLayoutProfile() !== 'small') {
	            if(this.topPos) {
	              this.placeholderEl.style('top', this.topPos);
	              this.placeholderEl.style('right', this.rightPos);
	            }
	          }
	        },
	
	        beforeClose: function() {
	      //issues: 369 & 442
	          if(this.rootEl.classed('vzb-portrait') && this.getLayoutProfile() === 'small') {
	            this.placeholderEl.style('top', 'auto'); // issues: 369 & 442
	          } 
	          if(this.getLayoutProfile() === 'large' && this.rootEl.classed("vzb-dialog-expand-true")) {
	            this.topPos0 = this.topPos ? (this.placeholderEl.node().parentNode.offsetHeight - this.placeholderEl.node().offsetHeight) + 'px' : '';
	          }   
	          this.placeholderEl.classed('notransition', false);
	          this.placeholderEl.node().offsetHeight; // trigger a reflow (flushing the css changes)
	        },
	
	        /**
	         * User has closed this dialog
	         */
	        close: function() {
	      //issues: 369 & 442
	          if(!(this.rootEl.classed('vzb-portrait') && this.getLayoutProfile() === 'small')) {
	            this.placeholderEl.style('top', ''); // issues: 369 & 442
	            this.placeholderEl.style('right', ''); // issues: 369 & 442
	          }
	          
	          if(this.getLayoutProfile() === 'large' && this.rootEl.classed("vzb-dialog-expand-true")) {
	            this.placeholderEl.style({'top' : this.topPos0, 'right' : ''});    
	          }
	          this.isOpen = false;
	          this.trigger('close');
	        },
	
	
	        transitionEnd: function(eventName) {
	          var _this = this;
	
	          this.transitionEvents.forEach(function(event) {
	            _this.placeholderEl.on(event, null);
	          });
	          if(this.isOpen) {
	            this.placeholderEl.classed('notransition', true);
	          }
	        }
	
	      });
	
	      function dialogDrag(element, container, xOffset) {
	        var posX, posY, divTop, divRight, marginRight, eWi, eHe, cWi, cHe, diffX, diffY;
	
	        return {
	          move: function(x, y) {
	            element.style('right', x + 'px');
	            element.style('top', y + 'px');
	          },
	
	          dragStart: function(evt) {
	            if(!isTouchDevice()) {
	              posX = evt.sourceEvent.clientX;
	              posY = evt.sourceEvent.clientY;
	            } else {
	              var touchCoord = d3.touches(container.node());
	              posX = touchCoord[0][0];
	              posY = touchCoord[0][1];
	            }
	            divTop = parseInt(element.style('top')) || 0;
	            divRight = parseInt(element.style('right')) || 0;
	            marginRight = parseInt(element.style('margin-right')) || 0;
	            eWi = parseInt(element.style('width'));
	            eHe = parseInt(element.style('height'));
	            cWi = parseInt(container.style('width')) - marginRight;
	            cHe = parseInt(container.style('height'));
	            diffX = posX + divRight;
	            diffY = posY - divTop;
	          },
	
	          drag: function(evt) {
	            if(!isTouchDevice()) {
	              posX = evt.sourceEvent.clientX;
	              posY = evt.sourceEvent.clientY;
	            } else {
	              var touchCoord = d3.touches(container.node());
	              posX = touchCoord[0][0];
	              posY = touchCoord[0][1];
	            }
	            var aX = -posX + diffX,
	              aY = posY - diffY;
	            if(aX < -xOffset) aX = -xOffset;
	            if(aY < 0) aY = 0;
	            if(aX + eWi > cWi) aX = cWi - eWi;
	            if(aY + eHe > cHe) aY = cHe - eHe;
	
	            this.move(aX, aY);
	          }
	        }
	      }
	
	      /*
	       * Size dialog
	       */
	
	      var About = Dialog.extend({
	
	      /**
	       * Initializes the dialog component
	       * @param config component configuration
	       * @param context component context (parent)
	       */
	      init: function(config, parent) {
	        this.name = 'about';
	
	        this._super(config, parent);
	      },
	          
	      readyOnce: function(){
	        var version = globals.version;
	        var updated = new Date(parseInt(globals.build));
	          
	        this.element = d3.select(this.element);
	        this.element.select(".vzb-about-text0")
	            .html("This chart is made with Vizabi,")
	        this.element.select(".vzb-about-text1")
	            .html("a project by <a href='http://gapminder.org'>Gapminder Foundation</a>")
	        this.element.select(".vzb-about-version")
	            .html("<a href='https://github.com/Gapminder/vizabi/releases/tag/v"+version+"'>Version: "+version+" (alpha)</a>");  
	        this.element.select(".vzb-about-updated")
	            .html("Build: " + d3.time.format("%Y-%m-%d at %H:%M")(updated));    
	        this.element.select(".vzb-about-text2")
	            .html("Alpha version: don't expect too much!");
	        this.element.select(".vzb-about-report")
	            .html("<a href='https://getsatisfaction.com/gapminder/'>Report a problem</a>");
	        this.element.select(".vzb-about-credits")
	            .html("<a href='https://github.com/Gapminder/vizabi/graphs/contributors'>Contributors</a>");
	      }
	          
	          
	      });
	
	      /*
	       * Axes dialog
	       */
	
	      var Axes = Dialog.extend({
	
	        /**
	         * Initializes the dialog component
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, parent) {
	          this.name = 'axes';
	          var _this = this;
	
	          this.components = [{
	            component: IndPicker,
	            placeholder: '.vzb-xaxis-selector',
	            model: ["state.marker", "language"],
	            markerID: "axis_x"
	          },{
	            component: MinMaxInputs,
	            placeholder: '.vzb-xaxis-minmax',
	            model: ["state.marker", "state.time", "language"],
	            markerID: "axis_x",
	            ui: {
	              selectDomainMinMax: false,
	              selectZoomedMinMax: true
	            }
	          }, {
	            component: IndPicker,
	            placeholder: '.vzb-yaxis-selector',
	            model: ["state.marker", "language"],
	            markerID: "axis_y"
	          }, {
	            component: MinMaxInputs,
	            placeholder: '.vzb-yaxis-minmax',
	            model: ["state.marker", "state.time", "language"],
	            markerID: "axis_y",
	            ui: {
	              selectDomainMinMax: false,
	              selectZoomedMinMax: true
	            }
	          }];
	
	          this._super(config, parent);
	        }
	      });
	
	      /*
	       * Axes dialog
	       */
	
	
	      var Axes$1 = Dialog.extend({
	
	        /**
	         * Initializes the dialog component
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, parent) {
	          this.name = 'axesmc'; 
	          var _this = this;
	
	          this.model_binds = {
	            'change:ui.chart.xLogStops': function() {
	              _this.updateView();
	            },
	            'change:ui.chart.yMaxMethod': function() {
	              _this.updateView();
	            }
	          };
	
	          this.components = [{
	            component: MinMaxInputs,
	            placeholder: '.vzb-xlimits-container',
	            model: ["state.marker", "state.time", "language"],
	            markerID: "axis_x",
	            ui: {
	              selectDomainMinMax: false,
	              selectZoomedMinMax: true 
	            }
	          }]
	
	
	          this._super(config, parent);
	        },
	
	        readyOnce: function() {
	          this._super();
	
	          var _this = this;
	
	          this.yMaxRadio = this.element.select('.vzb-yaxis-container').selectAll('input')
	            .on("change", function() {
	              _this.setModel("yMaxMethod", d3.select(this).node().value);
	            })
	
	          this.xLogStops = this.element.select('.vzb-xaxis-container').selectAll('input')
	            .on("change", function() {
	              _this.setModel("xLogStops", d3.select(this).node().value);
	            })
	
	          this.probeFieldEl = this.element.select(".vzb-probe-field")
	            .on("change", function() {
	              var result = parseFloat(this.value.replace(",", "."));
	              if(!result || result <= _this.model.state.marker.axis_x.tailCutX) {
	                this.value = _this.model.ui.chart.probeX;
	                return;
	              } else if(result > _this.model.state.marker.axis_x.domainMax) {
	                result = _this.model.state.marker.axis_x.domainMax;
	              }
	              this.value = result;
	              _this.setModel("probeX", result);
	            });
	
	          this.updateView();
	
	        },
	
	        updateView: function() {
	          var _this = this;
	
	          this.yMaxRadio.property('checked', function() {
	            return d3.select(this).node().value === _this.model.ui.chart.yMaxMethod;
	          })
	          this.xLogStops.property('checked', function() {
	            return _this.model.ui.chart.xLogStops.indexOf(+d3.select(this).node().value) !== -1;
	          })
	          this.probeFieldEl.property("value", this.model.ui.chart.probeX);
	        },
	
	        setModel: function(what, value) {
	          var result;
	
	          if(what == "yMaxMethod") {
	            result = value;
	          }
	          if(what == "xLogStops") {
	            result = [];
	            this.xLogStops.each(function() {
	              if(d3.select(this).property('checked')) result.push(+d3.select(this).node().value);
	            })
	          }
	          if(what == "probeX") {
	            result = value;
	          }
	
	          this.model.ui.chart[what] = result;
	        }
	      });
	
	      /*!
	       * VIZABI COLOR DIALOG
	       */
	
	      var Colors = Dialog.extend({
	
	        /**
	         * Initializes the dialog component
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, parent) {
	          this.name = 'colors';
	
	          this.components = [{
	            component: IndPicker,
	            placeholder: '.vzb-caxis-selector',
	            model: ["state.marker", "language"],
	            markerID: "color"
	          }, {
	            component: ColorLegend,
	            placeholder: '.vzb-clegend-container',
	            model: ["state", "language"]
	          }];
	
	
	          this._super(config, parent);
	        }
	
	      });
	
	      /*!
	       * VIZABI FIND CONTROL
	       * Reusable find dialog
	       */
	
	      var Find = Dialog.extend({
	
	        init: function(config, parent) {
	          this.name = 'find';
	          var _this = this;
	
	          this.components = [{
	            component: SimpleSlider,
	            placeholder: '.vzb-dialog-bubbleopacity',
	            model: ["state.entities"],
	            arg: "opacitySelectDim",
	            properties: {step: 0.01}
	          }];
	
	          this.model_binds = {
	            "change:state.entities.select": function(evt) {
	              _this.selectDataPoints();
	              _this.showHideDeselect();
	            },
	            "change:state.time.playing": function(evt) {
	              if(!_this.model.state.time.playing) {
	                _this.time = _this.model.state.time.value;
	            
	                _this.model.state.marker.getFrame(_this.time, function(values, time) {
	                  if (!values || (_this.time - time)) return;          
	                  _this.redrawDataPoints(values);
	                });
	              }
	            },
	            "change:state.time.value": function(evt) {
	              // hide changes if the dialog is not visible
	              if(!_this.placeholderEl.classed('vzb-active') && !_this.placeholderEl.classed('vzb-sidebar')) return;
	              
	              _this.time = _this.model.state.time.value;
	            
	              _this.model.state.marker.getFrame(_this.time, function(values) {
	                if (!values) return;          
	                _this.redrawDataPoints(values);
	              });
	            },
	            "change:language.strings": function() {
	              _this.translator = _this.model.language.getTFunction();
	              _this.input_search.attr("placeholder", _this.translator("placeholder/search") + "...");
	            }
	          }
	
	          this._super(config, parent);
	        },
	
	        /**
	         * Grab the list div
	         */
	        readyOnce: function() {
	          this._super();
	
	          this.list = this.element.select(".vzb-find-list");
	          this.input_search = this.element.select("#vzb-find-search");
	          this.deselect_all = this.element.select("#vzb-find-deselect");
	          this.opacity_nonselected = this.element.select(".vzb-dialog-bubbleopacity");
	
	          this.KEY = this.model.state.entities.getDimension();
	
	          var _this = this;
	
	          this.input_search.on("keyup", function() {
	            var event = d3.event;
	            if(event.keyCode == 13 && _this.input_search.node().value == "select all") {
	              _this.input_search.node().value = "";
	              //clear highlight so it doesn't get in the way when selecting an entity
	              if(!isTouchDevice()) _this.model.state.entities.clearHighlighted();        
	              _this.model.state.entities.selectAll();
	            }
	          });
	
	          this.input_search.on("input", function() {
	            _this.showHideSearch();
	          });
	
	          this.deselect_all.on("click", function() {
	            _this.deselectEntities();
	          });
	
	          this.translator = this.model.language.getTFunction();
	          this.input_search.attr("placeholder", this.translator("placeholder/search") + "...");
	
	          //make sure it refreshes when all is reloaded
	          this.root.on('ready', function() {
	            _this.ready();
	          })
	
	        },
	
	        open: function() {
	          var _this = this;
	          this._super();
	
	          this.input_search.node().value = "";
	          this.showHideSearch();
	            
	          this.time = this.model.state.time.value;
	            
	          this.model.state.marker.getFrame(this.time, function(values) {
	            if (!values) return;          
	            _this.redrawDataPoints(values);
	          });      
	        },
	
	        /**
	         * Build the list everytime it updates
	         */
	        //TODO: split update in render and update methods
	        ready: function() {
	          this._super();
	
	          var _this = this;
	          var KEY = this.KEY;
	          
	          this.time = this.model.state.time.value;
	          this.model.state.marker.getFrame(this.time, function(values) {
	            if (!values) return;
	              
	            var data = _this.model.state.marker.getKeys().map(function(d) {
	              var pointer = {};
	              pointer[KEY] = d[KEY];
	              pointer.brokenData = false;
	              pointer.name = values.label[d[KEY]];
	                
	              return pointer;
	            });
	
	            //sort data alphabetically
	            data.sort(function(a, b) {
	              return(a.name < b.name) ? -1 : 1;
	            });
	
	            _this.list.html("");
	
	            _this.items = _this.list.selectAll(".vzb-find-item")
	              .data(data)
	              .enter()
	              .append("div")
	              .attr("class", "vzb-find-item vzb-dialog-checkbox")
	
	            _this.items.append("input")
	              .attr("type", "checkbox")
	              .attr("class", "vzb-find-item")
	              .attr("id", function(d) {
	                return "-find-" + d[KEY];
	              })
	              .on("change", function(d) {
	                //clear highlight so it doesn't get in the way when selecting an entity
	                if(!isTouchDevice()) _this.model.state.entities.clearHighlighted();        
	                _this.model.state.entities.selectEntity(d);        
	                //return to highlighted state
	                if(!isTouchDevice() && !d.brokenData) _this.model.state.entities.highlightEntity(d); 
	              });
	
	            _this.items.append("label")
	              .attr("for", function(d) {
	                return "-find-" + d[KEY];
	              })
	              .text(function(d){return d.name})
	              .on("mouseover", function(d) {
	                if(!isTouchDevice() && !d.brokenData) _this.model.state.entities.highlightEntity(d);
	              })
	              .on("mouseout", function(d) {
	                if(!isTouchDevice()) _this.model.state.entities.clearHighlighted();
	              });
	              preventAncestorScrolling(_this.element.select('.vzb-dialog-scrollable'));
	              
	              _this.redrawDataPoints(values);
	              _this.selectDataPoints();
	              _this.showHideSearch();
	              _this.showHideDeselect();
	              
	          });
	        },
	          
	        redrawDataPoints: function(values){
	          var _this = this;
	          var KEY = this.KEY;
	              
	          _this.items
	            .each(function(d){
	              var view = d3.select(this).select("label");
	            
	              d.brokenData = false;
	              forEach(values, function(hook, name) {
	                //TODO: remove the hack with hardcoded hook names (see discussion in #1389)
	                if(name!=="color" && name!=="size_label" && _this.model.state.marker[name].use!=="constant" && !hook[d[KEY]] && hook[d[KEY]] !== 0) {
	                  d.brokenData = true;
	                }
	              });
	          
	              view
	                .classed("vzb-find-item-brokendata", d.brokenData)
	                .attr("title", d.brokenData? _this.model.state.time.timeFormat(_this.time) + ": " + _this.translator("hints/nodata") : "");
	            })
	        },
	          
	        selectDataPoints: function(){
	          var KEY = this.KEY;
	          var selected = this.model.state.entities.getSelected();
	          this.items.selectAll("input")
	              .property("checked", function(d) {
	                return(selected.indexOf(d[KEY]) !== -1);
	              });
	        },
	          
	        showHideSearch: function() {
	          var search = this.input_search.node().value || "";
	          search = search.toLowerCase();
	
	          this.list.selectAll(".vzb-find-item")
	            .classed("vzb-hidden", function(d) {
	              var lower = (d.name||"").toLowerCase();
	              return(lower.indexOf(search) === -1);
	            });
	        },
	
	        showHideDeselect: function() {
	          var someSelected = !!this.model.state.entities.select.length;
	          this.deselect_all.classed('vzb-hidden', !someSelected);
	          this.opacity_nonselected.classed('vzb-hidden', !someSelected);
	        },
	
	        deselectEntities: function() {
	          this.model.state.entities.clearSelected();
	        },
	
	        transitionEnd: function(event) {
	          this._super(event);
	
	          if(!isTouchDevice()) this.input_search.node().focus();
	        }
	
	      });
	
	      /*
	       * Label dialog
	       */
	
	      var Label = Dialog.extend({
	
	      /**
	       * Initializes the dialog component
	       * @param config component configuration
	       * @param context component context (parent)
	       */
	      init: function(config, parent) {
	        this.name = 'label';
	
	        // in dialog, this.model_expects = ["state", "data"];
	
	        this.components = [
	        {
	          component: SizeSlider,
	          placeholder: '.vzb-dialog-sizeslider',
	          model: ["state.marker.size_label",  "language"],
	          propertyname: 'LabelTextSize',
	          ui: {
	            constantUnit: "unit/pixels"
	          }
	        },
	        {
	          component: IndPicker,
	          placeholder: '.vzb-saxis-selector',
	          model: ["state.marker", "language"],
	          markerID: "size_label"
	        },
	        {
	          component: simplecheckbox,
	          placeholder: '.vzb-removelabelbox-switch',
	          model: ["ui.chart", "language"],
	          checkbox: 'removeLabelBox',
	          submodel: 'labels'
	        }
	        ];
	
	        this._super(config, parent);
	      }
	      });
	
	      /*!
	       * VIZABI OPTIONSBUTTONLIST
	       * Reusable optionsbuttonlist component
	       */
	
	      //default existing buttons
	      var class_active$2 = "vzb-active";
	      // var class_active_locked = "vzb-active-locked";
	      // var class_expand_dialog = "vzb-dialog-side";
	      // var class_hide_btn = "vzb-dialog-side-btn";
	      // var class_unavailable = "vzb-unavailable";
	      // var class_vzb_fullscreen = "vzb-force-fullscreen";
	      // var class_container_fullscreen = "vzb-container-fullscreen";
	
	      var OptionsButtonList = ButtonList.extend({
	
	        /**
	         * Initializes the buttonlist
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, context) {
	
	          //set properties
	          var _this = this;
	          this.name = 'gapminder-optionsbuttonlist';
	          
	          this._super(config, context);
	        },
	        
	        readyOnce: function() {
	          var _this = this;
	          Object.keys(this._available_buttons).forEach(function(buttonId) {
	            var button = _this._available_buttons[buttonId];
	            button.required = !button.required;
	          });
	          
	          this.buttonListComp = this.root.findChildByName("gapminder-buttonlist");
	          
	          this.buttonListComp.on("click", function(evt, button) {
	            var btn = _this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + button.id + "']");
	            btn.classed(class_active$2, button.active);
	          });
	          
	          this.buttonListComp.on("toggle", function(evt, params) {
	            var btn = _this.element.selectAll(".vzb-buttonlist-btn");
	            var visibleButton = 0;
	            btn.each(function(d) {
	              var button = d3.select(this);
	              var isHidden = params.hiddenButtons.indexOf(d.id) == -1;
	              button.style('display', isHidden ? 'none' : '');
	              if(!isHidden) visibleButton++; 
	            });
	          });
	
	          this._super();
	        },  
	        
	        proceedClick: function(id) {
	          var _this = this;
	          this.buttonListComp.proceedClick(id);
	          var btn_data = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']").datum();
	          if(btn_data.func) {
	            delay(function() {
	              _this.root.findChildByName("gapminder-dialogs").closeAllDialogs();
	            }, 200);
	          }
	        },
	         
	        _toggleButtons: function() {
	          //
	        }
	        
	      });
	
	      /*
	       * More options dialog
	       */
	
	      var MoreOptions = Dialog.extend({
	
	        /**
	         * Initializes the dialog component
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, parent) {
	          this.name = 'moreoptions';
	          
	          //specifying components
	          this.components = [{
	            component: OptionsButtonList,
	            placeholder: '.vzb-dialog-options-buttonlist',
	            model: ['state', 'ui', 'language']
	          }];
	
	          this._super(config, parent);
	        },
	
	        readyOnce: function() {
	          this._super();
	          
	          var _this = this;
	          this.accordionEl = this.contentEl.select('.vzb-accordion');
	
	          this.on('dragend', function() {
	            _this._setMaxHeight();
	          });
	              
	          var dialog_popup = (this.model.ui.dialogs||{}).popup || [];
	          var dialog_moreoptions = (this.model.ui.dialogs||{}).moreoptions || [];
	                  
	          // if dialog_moreoptions has been passed in with boolean param or array must check and covert to array
	          if (dialog_moreoptions === true) {
	            dialog_moreoptions = dialog_popup;
	            (this.model.ui.dialogs||{}).moreoptions = dialog_moreoptions;
	          }
	          
	          this._addDialogs(dialog_moreoptions);
	          
	          //accordion
	          if(this.accordionEl) {
	            var titleEl = this.accordionEl.selectAll('.vzb-accordion-section')
	              .select('.vzb-dialog-title>span:first-child')
	            titleEl.on('click', function(d) {
	              var element = _this.components[d.component].element;
	              var sectionEl = _this.components[d.component].placeholderEl;
	              var activeEl = _this.accordionEl.select('.vzb-accordion-active');
	              if(activeEl) {
	                activeEl.classed('vzb-accordion-active', false);
	              }
	              if(sectionEl.node() !== activeEl.node()) {
	                sectionEl.classed('vzb-accordion-active', true);
	              }
	            })
	          }
	        },
	        
	        _addDialogs: function(dialog_list) {
	          this._components_config = [];
	          var details_dlgs = [];
	          if(!dialog_list.length) return;
	          //add a component for each dialog
	          for(var i = 0; i < dialog_list.length; i++) {
	
	            //check moreoptions in dialog.moreoptions
	            if(dialog_list[i] === "moreoptions") continue;
	            
	            var dlg = dialog_list[i];
	            var dlg_config = deepClone(this.parent._available_dialogs[dlg]);
	
	            //if it's a dialog, add component
	            if(dlg_config && dlg_config.dialog) {
	              var comps = this._components_config;
	
	              //add corresponding component
	              comps.push({
	                component: dlg_config.dialog,
	                placeholder: '.vzb-dialogs-dialog[data-dlg="' + dlg + '"]',
	                model: ["state", "ui", "language"]
	              });
	
	              dlg_config.component = comps.length - 1;
	            
	              dlg_config.id = dlg;
	              details_dlgs.push(dlg_config);
	            }
	          };
	
	          this.accordionEl.selectAll('div').data(details_dlgs)
	            .enter().append("div")
	            .attr('class', function (d) {
	              var cls = 'vzb-dialogs-dialog vzb-moreoptions vzb-accordion-section';
	              return cls;
	            })
	            .attr('data-dlg', function(d) {
	              return d.id;
	            });
	
	          this.loadComponents();
	
	          var _this = this;
	          //render each subcomponent
	          forEach(this.components, function(subcomp) {
	            subcomp.render();
	            _this.on('resize', function() {
	              subcomp.trigger('resize');
	            });
	          });
	        }
	      });
	
	      /*
	       * Size dialog
	       */
	
	      var Opacity = Dialog.extend({
	
	      /**
	       * Initializes the dialog component
	       * @param config component configuration
	       * @param context component context (parent)
	       */
	      init: function(config, parent) {
	        this.name = 'opacity';
	
	        // in dialog, this.model_expects = ["state", "data"];
	
	        this.components = [
	        {
	          component: SimpleSlider,
	          placeholder: '.vzb-dialog-bubbleopacity-regular',
	          model: ["state.entities"],
	          arg: "opacityRegular",
	          properties: {step: 0.01}
	        }, {
	          component: SimpleSlider,
	          placeholder: '.vzb-dialog-bubbleopacity-selectdim',
	          model: ["state.entities"],
	          arg: "opacitySelectDim",
	          properties: {step: 0.01}
	        }
	        ];
	
	        this._super(config, parent);
	      }
	      });
	
	      /*
	       * Size dialog
	       */
	
	      var Presentation = Dialog.extend({
	
	      /**
	       * Initializes the dialog component
	       * @param config component configuration
	       * @param context component context (parent)
	       */
	      init: function(config, parent) {
	        this.name = 'presentation';
	
	        // in dialog, this.model_expects = ["state", "data"];
	
	        this.components = [
	        {
	          component: simplecheckbox,
	          placeholder: '.vzb-presentationmode-switch',
	          model: ["ui", "language"],
	          checkbox: 'presentation'
	        }];
	
	        this._super(config, parent);
	      }
	      });
	
	      /*!
	       * VIZABI SHOW CONTROL
	       * Reusable show dialog
	       */
	
	      var Show = Dialog.extend({
	
	        init: function(config, parent) {
	          this.name = 'show';
	          var _this = this;
	
	          this.model_binds = {
	            "change:state.entities.show": function(evt) {
	              _this.redraw();
	            }
	          }
	
	          this._super(config, parent);
	        },
	
	        /**
	         * Grab the list div
	         */
	        readyOnce: function() {
	          this._super();
	          this.list = this.element.select(".vzb-show-list");
	          this.input_search = this.element.select("#vzb-show-search");
	          this.deselect_all = this.element.select("#vzb-show-deselect");
	
	          this.KEY = this.model.state.entities.getDimension();
	          this.TIMEDIM = this.model.state.time.getDimension();
	
	          var _this = this;
	          this.input_search.on("input", function() {
	            _this.showHideSearch();
	          });
	
	          this.deselect_all.on("click", function() {
	            _this.deselectEntities();
	          });
	
	
	          //make sure it refreshes when all is reloaded
	          this.root.on('ready', function() {
	            _this.redraw();
	          })
	        },
	
	        open: function() {
	          this._super();
	
	          this.input_search.node().value = "";
	          this.showHideSearch();
	        },
	
	        ready: function() {
	          this._super();
	          this.redraw();
	          preventAncestorScrolling(this.element.select('.vzb-dialog-scrollable'));
	
	        },
	
	        redraw: function(){
	
	          var _this = this;
	          this.translator = this.model.language.getTFunction();
	
	          this.model.state.marker_allpossible.getFrame(this.model.state.time.value, function(values) {
	          if(!values) return;
	          var data = keys(values.label)
	              .map(function(d){
	                  var result = {};
	                  result[_this.KEY] = d;
	                  result["label"] = values.label[d];
	                  return result;
	              });
	
	          //sort data alphabetically
	          data.sort(function(a, b) {
	            return(a.label < b.label) ? -1 : 1;
	          });
	
	            _this.list.html("");
	
	          var items = _this.list.selectAll(".vzb-show-item")
	            .data(data)
	            .enter()
	            .append("div")
	            .attr("class", "vzb-show-item vzb-dialog-checkbox")
	
	          items.append("input")
	            .attr("type", "checkbox")
	            .attr("class", "vzb-show-item")
	            .attr("id", function(d) {
	              return "-show-" + d[_this.KEY];
	            })
	            .property("checked", function(d) {
	              return _this.model.state.entities.isShown(d);
	            })
	            .on("change", function(d) {
	              _this.model.state.entities.showEntity(d);
	              _this.showHideDeselect();
	            });
	
	          items.append("label")
	            .attr("for", function(d) {
	              return "-show-" + d[_this.KEY];
	            })
	            .text(function(d) {
	              return d.label;
	            });
	
	            _this.input_search.attr("placeholder", _this.translator("placeholder/search") + "...");
	
	            _this.showHideSearch();
	            _this.showHideDeselect();
	
	          });
	        },
	
	        showHideSearch: function() {
	
	          var search = this.input_search.node().value || "";
	          search = search.toLowerCase();
	
	          this.list.selectAll(".vzb-show-item")
	            .classed("vzb-hidden", function(d) {
	              var lower = d.label.toLowerCase();
	              return(lower.indexOf(search) === -1);
	            });
	        },
	
	        showHideDeselect: function() {
	          var show = this.model.state.entities.show[this.KEY];
	          this.deselect_all.classed('vzb-hidden', !show || show[0]==="*");
	        },
	
	        deselectEntities: function() {
	          this.model.state.entities.clearShow();
	          this.showHideDeselect();
	        },
	
	        transitionEnd: function(event) {
	          this._super(event);
	
	          if(!isTouchDevice()) this.input_search.node().focus();
	        }
	
	      });
	
	      /*
	       * Size dialog
	       */
	
	      var Size = Dialog.extend({
	
	      /**
	       * Initializes the dialog component
	       * @param config component configuration
	       * @param context component context (parent)
	       */
	      init: function(config, parent) {
	        this.name = 'size';
	
	        // in dialog, this.model_expects = ["state", "data"];
	
	        this.components = [
	        {
	          component: IndPicker,
	          placeholder: '.vzb-saxis-selector',
	          model: ["state.marker", "language"],
	          markerID: "size"
	        }
	        ];
	        if (!config.ui.chart || config.ui.chart.sizeSelectorActive !== 0) {
	          this.components.push(  {
	            component: BubbleSize,
	            placeholder: '.vzb-dialog-bubblesize',
	            model: ["state.marker.size"],
	            ui: {
	              show_button: false
	            }
	          })
	        }
	
	        this._super(config, parent);
	      }
	      });
	
	      /*
	       * Size dialog
	       */
	
	      var Speed = Dialog.extend({
	
	      /**
	       * Initializes the dialog component
	       * @param config component configuration
	       * @param context component context (parent)
	       */
	      init: function(config, parent) {
	        this.name = 'speed';
	
	        // in dialog, this.model_expects = ["state", "data"];
	
	        this.components = [
	        {
	          component: SimpleSlider,
	          placeholder: '.vzb-dialog-placeholder',
	          model: ["state.time"],
	          arg: "delay",
	          properties: {min:1, max:5, step:0.1, scale: d3.scale.linear()
	            .domain([1,2,3,4,5])
	            .range([1200,900,450,200,75])
	          }
	        }
	        ];
	
	        this._super(config, parent);
	      }
	      });
	
	      /*
	       * stack dialog
	       */
	
	      var Stack = Dialog.extend({
	
	          /**
	           * Initializes the dialog component
	           * @param config component configuration
	           * @param context component context (parent)
	           */
	          init: function(config, parent) {
	              this.name = 'stack';
	              var _this = this;
	
	              // in dialog, this.model_expects = ["state", "data"];
	
	              this.components = [{
	                  component: DraggableList,
	                  placeholder: '.vzb-dialog-draggablelist',
	                  model: ["state.marker.group", "language", "ui.chart"],
	                  groupID: "manualSorting",
	                  isEnabled: "manualSortingEnabled",
	                  dataArrFn: _this.manualSorting.bind(_this),
	                  lang: 'entity/geo.world_4region/'
	              }];
	
	              this.model_binds = {
	                  'change:state.marker.stack': function(evt) {
	                      //console.log("stack change " + evt);
	                      _this.updateView();
	                  },
	                  'change:state.marker.group': function(evt) {
	                      //console.log("group change " + evt);
	                      _this.updateView();
	                  }
	              };
	
	              this._super(config, parent);
	          },
	
	
	          readyOnce: function() {
	            this._super();
	
	            var _this = this;
	            this.group = this.model.state.marker.group;
	            this.stack = this.model.state.marker.stack;
	
	            this.howToStackEl = this.element.select('.vzb-howtostack').selectAll("input")
	                .on("change", function() {
	                    _this.setModel("stack", d3.select(this).node().value);
	                })
	            this.howToMergeEl = this.element.select('.vzb-howtomerge').selectAll("input")
	                .on("change", function() {
	                    _this.setModel("merge", d3.select(this).node().value);
	                })
	
	            this.updateView();
	          },
	
	          updateView: function() {
	              var _this = this;
	
	              this.howToStackEl
	                  .property('checked', function() {
	                      return d3.select(this).node().value === _this.stack.which;
	                  });
	              
	              _this.ui.chart.manualSortingEnabled = _this.stack.which == "all";
	              
	              this.howToMergeEl
	                  .property('checked', function() {
	                      if(d3.select(this).node().value === "none")  return !_this.group.merge && !_this.stack.merge;
	                      if(d3.select(this).node().value === "grouped") return _this.group.merge;
	                      if(d3.select(this).node().value === "stacked") return _this.stack.merge;
	                  })
	                  .attr('disabled', function(){
	                      if(d3.select(this).node().value === "none")  return null; // always enabled
	                      if(d3.select(this).node().value === "grouped") return _this.stack.which === "none" ? true : null;
	                      if(d3.select(this).node().value === "stacked") return _this.stack.which === "all" ? null : true;
	                  });
	
	
	          },
	
	          manualSorting: function(value) {
	              if(arguments.length === 0) return this.model.state.marker.group.manualSorting;
	              this.model.state.marker.group.manualSorting = value;
	          },
	
	          setModel: function(what, value) {
	
	              var obj = {stack: {}, group: {}};
	
	              if(what === "merge") {
	                  switch (value){
	                      case "none":
	                          obj.group.merge = false;
	                          obj.stack.merge = false;
	                          break;
	                      case "grouped":
	                          obj.group.merge = true;
	                          obj.stack.merge = false;
	                          break;
	                      case "stacked":
	                          obj.group.merge = false;
	                          obj.stack.merge = true;
	                          break;
	                  }
	              }
	              if(what === "stack") {
	
	                  obj.stack.which = value;
	
	                  //validate use of stack hook
	                  if(value !== "all" && value !== "none"){
	                      obj.stack.use = "property";
	                  } else {
	                      obj.stack.use = "constant";
	                  }
	
	                  //validate possible merge values in group and stack hooks
	                  if(value === "none" && this.group.merge) obj.group.merge = false;
	                  if(value !== "all" && this.stack.merge) obj.stack.merge = false;
	              }
	
	              this.model.state.marker.set(obj);
	          }
	      });
	
	      /*
	       * Zoom dialog
	       */
	
	      var Zoom = Dialog.extend({
	
	      /**
	       * Initializes the dialog component
	       * @param config component configuration
	       * @param context component context (parent)
	       */
	      init: function(config, parent) {
	        this.name = 'zoom';
	
	        // in dialog, this.model_expects = ["state", "data"];
	
	        this.components = [{
	          component: ZoomButtonList,
	          placeholder: '.vzb-dialog-zoom-buttonlist',
	          model: ["state", "ui", "language"]
	        }, {
	          component: simplecheckbox,
	          placeholder: '.vzb-zoomonscrolling-switch',
	          model: ["ui", "language"],
	          checkbox: 'zoomOnScrolling'
	        }, {
	          component: simplecheckbox,
	          placeholder: '.vzb-adaptminmaxzoom-switch',
	          model: ["ui", "language"],
	          checkbox: 'adaptMinMaxZoom'
	        }];
	
	        this._super(config, parent);
	      }
	      });
	
	      /*!
	       * VIZABI DIALOGS
	       * Reusable dialogs component
	       */
	
	      //default existing dialogs
	      var class_active$1 = "vzb-active";
	      var Dialogs = Component.extend({
	
	        /**
	         * Initializes the dialogs
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, context) {
	
	          //set properties
	          var _this = this;
	          this.name = 'gapminder-dialogs';
	          this._curr_dialog_index = 20;
	
	
	          this.model_expects = [{
	            name: "state",
	            type: "model"
	          }, {
	            name: "ui",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	          this._available_dialogs = {
	            'find': {
	              dialog: Find,
	            },
	            'show': {
	              dialog: Show,
	            },
	            'moreoptions': {
	              dialog: MoreOptions,
	            },
	            'colors': {
	              dialog: Colors,
	            },
	            'size': {
	              dialog: Size,
	            },
	            'label': {
	              dialog: Label,
	            },
	            'zoom': {
	              dialog: Zoom,
	            },
	            'axes': {
	              dialog: Axes,
	            },
	            'axesmc': {
	              dialog: Axes$1,
	            },
	            'stack': {
	              dialog: Stack,
	            },
	            'speed': {
	              dialog: Speed
	            },
	            'opacity': {
	              dialog: Opacity
	            },
	            'presentation': {
	              dialog: Presentation
	            },
	            'about': {
	              dialog: About
	            }
	          };
	
	          this._super(config, context);
	
	        },
	        
	        domReady: function() {
	          var dialog_popup = (this.model.ui.dialogs||{}).popup || [];
	          var dialog_sidebar = (this.model.ui.dialogs||{}).sidebar || [];
	          
	          this.rootEl = this.root.element instanceof Array? this.root.element : d3.select(this.root.element);
	          
	          // if dialog_sidebar has been passed in with boolean param or array must check and covert to array
	          if (dialog_sidebar === true) {
	            dialog_sidebar = dialog_popup;
	            (this.model.ui.dialogs||{}).sidebar = dialog_sidebar;
	          }
	          if (dialog_sidebar.length !== 0) {
	            this.rootEl.classed("vzb-dialog-expand-true", true);
	          }
	          this.dialog_popup = dialog_popup;
	          this.dialog_sidebar = dialog_sidebar;
	        },
	
	        readyOnce: function() {
	          var _this = this;
	
	          this.element = d3.select(this.placeholder);
	          this.element.selectAll("div").remove();
	
	          this._addDialogs(this.dialog_popup, this.dialog_sidebar);
	
	          this.resize();
	
	          if(this.dialog_popup.length !== 0) {
	            this.root.findChildByName("gapminder-buttonlist")
	              .on("click", function(evt, button) {
	                if(!_this._available_dialogs[button.id]) return;
	
	                if(button.active) {
	                  _this.openDialog(button.id)
	                } else {
	                  _this.closeDialog(button.id)
	                }
	              });
	
	            var popupDialogs = this.element.selectAll(".vzb-top-dialog").filter(function(d) {return _this.dialog_popup.indexOf(d.id) > -1});
	
	            var close_buttons = popupDialogs.select(".vzb-top-dialog>.vzb-dialog-modal>.vzb-dialog-buttons>[data-click='closeDialog']");
	            close_buttons.on('click', function(d, i) {
	              _this.closeDialog(d.id);
	            });
	
	            var pinDialog = popupDialogs.select(".vzb-top-dialog>.vzb-dialog-modal>[data-click='pinDialog']");
	            pinDialog.on('click', function(d, i) {
	              _this.pinDialog(d.id);
	            });
	
	            this.rootEl.node().addEventListener('click', function() {
	              _this.closeAllDialogs();
	            });
	
	            this.rootEl.on("mousedown", function(e) {
	              if(!this._active_comp) return; //don't do anything if nothing is open
	
	              var target = d3.event.target;
	              var closeDialog = true;
	              while(target) {
	                if(target.classList.contains("vzb-dialog-modal")) {
	                  closeDialog = false;
	                  break;
	                }
	                target = target.parentElement;
	              }
	              if(closeDialog) {
	                _this.closeAllDialogs();
	              }
	            });
	          }
	
	          this.element.on('click', function() {
	            d3.event.stopPropagation();
	          });
	
	        },
	
	        resize: function() {
	          var _this = this;
	          var profile = this.getLayoutProfile();
	
	          this.element.selectAll(".vzb-top-dialog").each(function(d) {
	            var dialogEl = d3.select(this);
	            var cls = dialogEl.attr('class').replace(' vzb-popup','').replace(' vzb-sidebar','');
	
	            if (profile === 'large' && _this.dialog_sidebar.indexOf(d.id) > -1) {
	              cls += ' vzb-sidebar';
	            } else if(_this.dialog_popup.indexOf(d.id) > -1) {
	              cls += ' vzb-popup';
	            }
	
	            dialogEl.attr('class', cls);
	          });
	
	        },
	
	        /*
	         * adds dialogs configuration to the components and template_data
	         * @param {Array} dialog_list list of dialogs to be added
	         */
	        _addDialogs: function(dialog_popup, dialog_sidebar) {
	
	          var profile = this.getLayoutProfile();
	          var dialog_list = [];
	
	          dialog_list = dialog_popup ? dialog_list.concat(dialog_popup) : dialog_list;
	          dialog_list = dialog_sidebar ? dialog_list.concat(dialog_sidebar) : dialog_list;
	
	          dialog_list = unique(dialog_list);
	
	          this._components_config = [];
	          var details_dlgs = [];
	          if(!dialog_list.length) return;
	          //add a component for each dialog
	          for(var i = 0; i < dialog_list.length; i++) {
	
	            var dlg = dialog_list[i];
	            var dlg_config = this._available_dialogs[dlg];
	
	            //if it's a dialog, add component
	            if(dlg_config && dlg_config.dialog) {
	              var comps = this._components_config;
	
	              //add corresponding component
	              comps.push({
	                component: dlg_config.dialog,
	                placeholder: '.vzb-dialogs-dialog[data-dlg="' + dlg + '"]',
	                model: ["state", "ui", "language"]
	              });
	
	              dlg_config.component = comps.length - 1;
	            }
	
	            dlg_config.id = dlg;
	            details_dlgs.push(dlg_config);
	          };
	
	          this.element.selectAll('div').data(details_dlgs)
	            .enter().append("div")
	            .attr('data-dlg', function(d) {
	              return d.id;
	            })
	            .attr('class', 'vzb-top-dialog vzb-dialogs-dialog vzb-dialog-shadow');
	
	          this.loadComponents();
	
	          var _this = this;
	          //render each subcomponent
	          forEach(this.components, function(subcomp) {
	            subcomp.render();
	            _this.on('resize', function() {
	              subcomp.trigger('resize');
	            });
	            subcomp.on('dragstart', function() {
	              _this.bringForward(subcomp.name);
	            });
	            subcomp.on('close', function() {
	              this.placeholderEl.each( function(d) {
	                var evt = {};
	                evt.id = d.id;
	                _this.trigger('close', evt);
	              });
	            });
	          });
	
	        },
	
	        bringForward: function(id) {
	          var dialog = this.element.select(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");
	          dialog.style('z-index', this._curr_dialog_index);
	          this._curr_dialog_index += 10;
	        },
	
	        //TODO: make opening/closing a dialog via update and model
	        /*
	         * Activate a dialog
	         * @param {String} id dialog id
	         */
	        openDialog: function(id) {
	          //close pinned dialogs for small profile
	          var forceClose = this.getLayoutProfile() === 'small' ? true : false;
	          this.closeAllDialogs(forceClose);
	
	          var dialog = this.element.selectAll(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");
	
	          this._active_comp = this.components[this._available_dialogs[id].component];
	
	          this._active_comp.beforeOpen();
	          //add classes
	          dialog.classed(class_active$1, true);
	
	          this.bringForward(id);
	
	          //call component function
	          this._active_comp.open();
	        },
	
	
	        pinDialog: function(id) {
	          var dialog = this.element.select(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");
	
	          if(this._available_dialogs[id].ispin) {
	            dialog.classed('pinned', false);
	            this._available_dialogs[id].ispin = false;
	          } else {
	            dialog.classed('pinned', true);
	            this._available_dialogs[id].ispin = true;
	          }
	        },
	
	
	        /*
	         * Closes a dialog
	         * @param {String} id dialog id
	         */
	        closeDialog: function(id) {
	          var dialog = this.element.selectAll(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");
	
	          this._active_comp = this.components[this._available_dialogs[id].component];
	
	          if(this._active_comp && !this._active_comp.isOpen) return;
	
	          if(this._available_dialogs[id].ispin)
	            this.pinDialog(id);
	
	          if(this._active_comp) {
	            this._active_comp.beforeClose();
	          }
	          //remove classes
	          dialog.classed(class_active$1, false);
	
	          //call component close function
	          if(this._active_comp) {
	            this._active_comp.close();
	          }
	          this._active_comp = false;
	
	        },
	
	        /*
	         * Close all dialogs
	         */
	        closeAllDialogs: function(forceclose) {
	          var _this = this;
	          //remove classes
	          var dialogClass = forceclose ? ".vzb-popup.vzb-dialogs-dialog.vzb-active" : ".vzb-popup.vzb-dialogs-dialog.vzb-active:not(.pinned)";
	          var all_dialogs = this.element.selectAll(dialogClass);
	            all_dialogs.each(function(d) {
	              _this.closeDialog(d.id)
	            });
	        }
	
	      });
	
	      var DraggableList = Component.extend({
	
	        init: function(config, context) {
	          this.template = '<span class="vzb-dl-holder"><ul class="vzb-draggable list vzb-dialog-scrollable"></ul></span>';
	          var _this = this;
	          this.name = 'draggableList';
	
	          this.dataArrFn = config.dataArrFn;
	          this.lang = config.lang;
	
	          this.model_expects = [{
	            name: "group",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }, {
	            name: "chart",
	            type: "model"
	          }];
	          
	          this.groupID = config.groupID;
	          this.isEnabled = config.isEnabled;
	          this.draggable = true; 
	
	          if(!config.groupID) warn("draggablelist.js complains on 'groupID' property: " + config.groupID);
	
	          this.model_binds = {
	            "change:language.strings": function(evt) {
	              _this.updateView();
	            }
	          };
	          
	          this.model_binds["change:group." + this.groupID] = function(evt) {
	              _this.updateView();
	          };
	          this.model_binds["change:chart." + this.isEnabled] = function(evt) {
	            _this.draggable = _this.model.chart[_this.isEnabled];
	            _this.updateView();
	          };
	          
	
	          this._super(config, context);
	
	          this.updateData = debounce(this.updateData, 1000);
	          
	          this.itemDragger = d3.behavior.drag()
	            .on('dragstart', function(draggedData, i) {
	              if(_this.dataUpdateFlag || !_this.draggable) return;
	              d3.event.sourceEvent.stopPropagation();
	              _this.parentBoundRect = _this.element.node().getBoundingClientRect();
	              _this.element
	                .selectAll('div')
	                .each(function(d, i) {
	                  var boundRect = this.getBoundingClientRect();
	                  d._y = boundRect.top;
	                  d._top = 0; 
	                  if(draggedData.data === d.data) {
	                    d._height = boundRect.height;
	                    _this.selectedNode = this;
	                  }
	                })
	              d3.select(_this.selectedNode)
	                .classed('dragged', true)
	            })
	            
	            .on('drag', function(draggedData, draggedIndex) {
	              if(_this.dataUpdateFlag || !_this.draggable) return;
	              draggedData._top += d3.event.dy;
	              var newDraggedY = draggedData._y + draggedData._top;
	              if(newDraggedY > _this.parentBoundRect.top 
	                && newDraggedY + draggedData._height < _this.parentBoundRect.top + _this.parentBoundRect.height)
	              {
	                _this.itemsEl
	                  .style('top', function(d, i) {
	                    var top = 0;
	                    
	                    if (i < draggedIndex && d._y + draggedData._height * .5 > newDraggedY) {
	                      top = draggedData._height;
	                    }
	                    else if(i > draggedIndex && d._y - draggedData._height * .5 < newDraggedY) {
	                      top = -draggedData._height;
	                    }
	                    
	                    if (i != draggedIndex) d._top = top;
	                    return d._top + "px";
	                 })
	              }
	            })
	            
	            .on('dragend', function(d, i) {
	              if(_this.dataUpdateFlag || !_this.draggable) return;
	              _this.getData();     
	            })
	            
	        },
	
	        ready: function() {
	          var _this = this;
	
	          this.updateView();
	
	          this.itemsEl = this.element
	            .selectAll('div')
	          
	          this.itemsEl
	            .call(_this.itemDragger);
	            
	          var test = this.itemsEl.select('li')
	            .on('mouseover', function() {
	              d3.select(this).classed('hover', true);
	            })
	            .on('mouseout', function() {
	              d3.select(this).classed('hover', false);        
	            })
	            .on('touchstart', function() {
	              d3.event.preventDefault();
	            })
	            
	        },
	
	        updateView: function() {
	          var _this = this;
	          this.translator = this.model.language.getTFunction();
	
	          this.items = this.element.selectAll('div').data(function() {
	            return _this.dataArrFn().map( function(d) { return {data:d};})});
	          var draggable = _this.draggable?true:null;
	          this.items.enter()
	            .append('div')
	            .append('li');
	          this.items.select('li').classed('hover', false).each(function(val, index) {
	              d3.select(this).attr('data', val['data']).text(_this.translator(_this.lang + val['data']));
	            });
	          this.items.exit().remove();
	          this.element.selectAll('div')
	            .style('top', '')
	            .attr('draggable', draggable)
	            .classed('dragged', false);
	          this.dataUpdateFlag = false;
	           
	        },
	        
	        getData: function() {
	          var dataArr = [];
	          var data = this.element
	            .selectAll('div').data();
	
	          dataArr = data
	            .sort(function(a, b) {
	              return (a._y + a._top) - (b._y + b._top);
	            })
	            .map(function(d) {
	              return d.data        
	            })
	          if(arrayEquals(this.dataArrFn(), dataArr)) {
	            this.updateView();
	          } else {
	            this.dataUpdateFlag = true;
	            this.updateData(dataArr);
	          }
	        },
	        
	        updateData: function(dataArr) {
	          this.dataArrFn(dataArr);    
	        },
	
	        readyOnce: function() {
	          var _this = this;
	
	          this.element = d3.select(this.element).select('.list');
	          
	        }
	
	      });
	
	      /*!
	       * VIZABI INDICATOR PICKER
	       * Reusable indicator picker component
	       */
	
	      var IndPicker = Component.extend({
	
	          /**
	           * Initializes the Indicator Picker.
	           * Executed once before any template is rendered.
	           * @param config The options passed to the component
	           * @param context The component's parent
	           */
	          init: function(config, context) {
	
	              this.name = 'gapminder-indicatorpicker';
	              this.template = '<span class="vzb-ip-holder"><span class="vzb-ip-select"></span><span class="vzb-ip-info"></span></span>';
	
	              var _this = this;
	
	              this.model_expects = [{
	                  name: "marker",
	                  type: "model"
	              }, {
	                  name: "language",
	                  type: "language"
	              }];
	
	              this.markerID = config.markerID;
	              if(!config.markerID) warn("indicatorpicker.js complains on 'markerID' property: " + config.markerID);
	
	              this.model_binds = {
	                  "change:language.strings": function(evt) {
	                      _this.updateView();
	                  },
	                  "ready": function(evt) {
	                      _this.updateView();
	                  }
	              };
	              
	              if(this.markerID) {
	                this.model_binds["change:marker." + this.markerID + ".which"] = function(evt) {
	                    _this.updateView();
	                  } 
	              }
	
	              //contructor is the same as any component
	              this._super(config, context);
	          },
	
	          ready: function() {
	              this.updateView();
	          },
	
	
	          readyOnce: function() {
	              var _this = this;
	
	              this.el_select = d3.select(this.element).select('.vzb-ip-select');
	
	              this.el_select.on("click", function() {
	                  var rect = _this.el_select.node().getBoundingClientRect();
	                  var rootEl = _this.root.element instanceof Array? _this.root.element : d3.select(_this.root.element);
	                  var rootRect = rootEl.node().getBoundingClientRect();
	                  var treemenuComp = _this.root.findChildByName("gapminder-treemenu");
	                  var treemenuColWidth = treemenuComp.activeProfile.col_width; 
	                  var treemenuPaddLeft = parseInt(treemenuComp.wrapper.style('padding-left'), 10) || 0; 
	                  var treemenuPaddRight = parseInt(treemenuComp.wrapper.style('padding-right'), 10) || 0; 
	                  var topPos = rect.bottom - rootRect.top;
	                  var leftPos = rect.left - rootRect.left - (treemenuPaddLeft + treemenuPaddRight + treemenuColWidth - rect.width) * .5;
	              
	                  treemenuComp
	                      .markerID(_this.markerID)
	                      .alignX("left")
	                      .alignY("top")
	                      .top(topPos)
	                      .left(leftPos)
	                      .updateView()
	                      .toggle();
	              });
	
	              this.infoEl = d3.select(this.element).select('.vzb-ip-info');
	              setIcon(this.infoEl, iconQuestion)
	                .select("svg").attr("width", "0px").attr("height", "0px");
	                
	              this.infoEl.on("click", function() {
	                _this.root.findChildByName("gapminder-datanotes").pin();
	              })
	              this.infoEl.on("mouseover", function() {
	                var rect = _this.el_select.node().getBoundingClientRect();
	                var rootRect = _this.root.element.getBoundingClientRect();
	                var topPos = rect.bottom - rootRect.top;
	                var leftPos = rect.left - rootRect.left + rect.width;
	                
	                _this.root.findChildByName("gapminder-datanotes").setHook(_this.markerID).show().setPos(leftPos, topPos);
	              })
	              this.infoEl.on("mouseout", function() {
	                _this.root.findChildByName("gapminder-datanotes").hide();
	              })
	
	
	          },
	
	          
	          updateView: function() {
	              if(!this._readyOnce) return;
	
	              var _this = this;
	              var translator = this.model.language.getTFunction();
	              
	              var which = this.model.marker[this.markerID].which;
	              var type = this.model.marker[this.markerID]._type;
	              
	              //Let the indicator "_default" in tree menu be translated differnetly for every hook type
	              this.el_select.text(translator("indicator" + (which==="_default" ? "/" + type : "") + "/" + which));
	              
	              // hide info el if no data is available for it to make sense
	              var hideInfoEl = ((translator("description/" + which) == "description/" + which)
	                  && (translator("sourceName/" + which) == "sourceName/" + which)
	                  && !_this.model.marker[_this.markerID].getConceptprops().sourceLink); 
	              this.infoEl.classed("vzb-hidden", hideInfoEl);
	          }
	          
	      });
	
	      var label = function(context) {
	
	        return function d3_label() {
	        
	          var _this = context;
	
	          var _cssPrefix;
	          label.setCssPrefix = function(cssPrefix) {
	            _cssPrefix = cssPrefix;
	            return label;
	          }    
	
	          var labelDragger = d3.behavior.drag()
	            .on("dragstart", function(d, i) {
	              d3.event.sourceEvent.stopPropagation();
	              var KEY = _this.KEY;
	            })
	            .on("drag", function(d, i) {
	              var KEY = _this.KEY;
	              if(!_this.model.ui.chart.labels.dragging) return;
	              if(!this.druging) _this.druging = d[KEY];
	              var cache = _this.cached[d[KEY]];
	              cache.labelFixed = true;
	              
	              var viewWidth = _this._toolContext.width;       
	              var viewHeight = _this._toolContext.height;       
	
	              cache.labelX_ += d3.event.dx / viewWidth;
	              cache.labelY_ += d3.event.dy / viewHeight;
	
	              var resolvedX = _this.xScale(cache.labelX0) + cache.labelX_ * viewWidth;
	              var resolvedY = _this.yScale(cache.labelY0) + cache.labelY_ * viewHeight;
	
	              var resolvedX0 = _this.xScale(cache.labelX0);
	              var resolvedY0 = _this.yScale(cache.labelY0);
	
	              var lineGroup = _this.entityLines.filter(function(f) {
	                return f[KEY] == d[KEY];
	              });
	
	              label._repositionLabels(d, i, this, resolvedX, resolvedY, resolvedX0, resolvedY0, 0, null, lineGroup);
	            })
	            .on("dragend", function(d, i) {
	              var KEY = _this.KEY;
	              if(_this.druging) {
	                var cache = _this.cached[d[KEY]];
	                _this.druging = null;
	                cache.labelOffset[0] = cache.labelX_;
	                cache.labelOffset[1] = cache.labelY_;
	                _this.model.entities.setLabelOffset(d, [cache.labelX_, cache.labelY_]);
	              }
	            });
	          
	          function label(container) {
	            container
	              .call(labelDragger)
	              .each(function(d, index) {
	                var view = d3.select(this);
	
	        // Ola: Clicking bubble label should not zoom to countries boundary #811
	        // It's too easy to accidentally zoom
	        // This feature will be activated later, by making the label into a "context menu" where users can click Split, or zoom,.. hide others etc....
	
	                view.append("rect")
	                  .attr("class","vzb-label-glow")
	                  .attr("filter", "url(" + location.pathname + "#vzb-glow-filter)");
	                view.append("rect")
	                  .attr("class","vzb-label-fill vzb-tooltip-border");
	        //          .on("click", function(d, i) {
	        //            //default prevented is needed to distinguish click from drag
	        //            if(d3.event.defaultPrevented) return;
	        //
	        //            var maxmin = _this.cached[d[KEY]].maxMinValues;
	        //            var radius = utils.areaToRadius(_this.sScale(maxmin.valueSmax));
	        //            _this._panZoom._zoomOnRectangle(_this.element,
	        //              _this.xScale(maxmin.valueXmin) - radius,
	        //              _this.yScale(maxmin.valueYmin) + radius,
	        //              _this.xScale(maxmin.valueXmax) + radius,
	        //              _this.yScale(maxmin.valueYmax) - radius,
	        //              false, 500);
	        //          });
	
	                view.append("text").attr("class", _cssPrefix + "-label-content vzb-label-shadow");
	
	                view.append("text").attr("class", _cssPrefix + "-label-content");
	
	                var cross = view.append("g").attr("class", _cssPrefix + "-label-x vzb-transparent");
	                setIcon(cross, iconClose);
	
	                cross.insert("circle", "svg");
	
	                cross.select("svg")
	                  .attr("class", _cssPrefix + "-label-x-icon")
	                  .attr("width", "0px")
	                  .attr("height", "0px");
	
	                cross.on("click", function() {
	                  _this.model.entities.clearHighlighted();
	                  //default prevented is needed to distinguish click from drag
	                  if(d3.event.defaultPrevented) return;
	                  _this.model.entities.selectEntity(d);
	                });
	
	              })
	              .on("mouseover", function(d) {
	                if(isTouchDevice()) return;
	                _this.model.entities.highlightEntity(d, null, null, true);
	                var KEY = _this.KEY || _this.model.entities.getDimension();
	                // hovered label should be on top of other labels: if "a" is not the hovered element "d", send "a" to the back
	                _this.entityLabels.sort(function (a, b) { return a[KEY] != d[KEY]? -1 : 1; });
	                d3.select(this).selectAll("." + _cssPrefix + "-label-x")
	                  .classed("vzb-transparent", false);
	              })
	              .on("mouseout", function(d) {
	                if(isTouchDevice()) return;
	                _this.model.entities.clearHighlighted();
	                d3.select(this).selectAll("." + _cssPrefix + "-label-x")
	                  .classed("vzb-transparent", true);
	              })
	              .on("click", function(d) {
	                if (!isTouchDevice()) return;
	                var cross = d3.select(this).selectAll("." + _cssPrefix + "-label-x");
	                cross.classed("vzb-transparent", !cross.classed("vzb-transparent"));
	              });
	          
	            return label;  
	          };
	
	          label.line = function(container) {
	            container.append("line").attr("class", _cssPrefix + "-label-line");
	          };
	                  
	
	
	
	          label._repositionLabels = _repositionLabels;
	          function _repositionLabels(d, i, labelContext, _X, _Y, _X0, _Y0, duration, showhide, lineGroup) {
	
	            var cache = _this.cached[d[_this.KEY]];
	
	            var labelGroup = d3.select(labelContext);
	
	            //protect label and line from the broken data
	            var brokenInputs = !_X && _X !==0 || !_Y && _Y !==0 || !_X0 && _X0 !==0 || !_Y0 && _Y0 !==0;
	            if(brokenInputs) {
	                labelGroup.classed("vzb-invisible", brokenInputs);
	                lineGroup.classed("vzb-invisible", brokenInputs);
	                return;
	            }
	            
	            var viewWidth = _this._toolContext.width;       
	            var viewHeight = _this._toolContext.height;       
	            var rectBBox = cache.rectBBox;
	            var width = rectBBox.width;
	            var height = rectBBox.height;
	
	            //apply limits so that the label doesn't stick out of the visible field
	            if(_X - width <= 0) { //check left
	              _X = width;
	              cache.labelX_ = (_X - _this.xScale(cache.labelX0)) / viewWidth;
	            } else if(_X + 5 > viewWidth) { //check right
	              _X = viewWidth - 5; 
	              cache.labelX_ = (_X - _this.xScale(cache.labelX0)) / viewWidth;
	            }
	            if(_Y - height * .75 <= 0) { // check top
	              _Y = height * .75;
	              cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
	            } else if(_Y + height * .35 > viewHeight) { //check bottom
	              _Y = viewHeight - height * .35;
	              cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
	            }
	
	            if(duration == null) duration = _this._toolContext.duration;
	            if(duration) {
	              if(showhide && !d.hidden){
	                  //if need to show label
	                
	                  labelGroup.classed("vzb-invisible", d.hidden);
	                  labelGroup
	                      .attr("transform", "translate(" + _X + "," + _Y + ")")
	                      .style("opacity", 0)
	                      .transition().duration(duration).ease("exp")
	                      .style("opacity", 1)
	                      //i would like to set opactiy to null in the end of transition. 
	                      //but then fade in animation is not working for some reason
	                      .each("interrupt", function(){
	                          labelGroup
	                              .style("opacity", 1)
	                      });
	                  lineGroup.classed("vzb-invisible", d.hidden);
	                  lineGroup
	                      .attr("transform", "translate(" + _X + "," + _Y + ")")
	                      .style("opacity", 0)
	                      .transition().duration(duration).ease("exp")
	                      .style("opacity", 1)
	                      //i would like to set opactiy to null in the end of transition. 
	                      //but then fade in animation is not working for some reason
	                      .each("interrupt", function(){
	                          lineGroup
	                              .style("opacity", 1)
	                      });
	                  
	              } else if(showhide && d.hidden) {
	                  //if need to hide label
	                  
	                  labelGroup
	                      .style("opacity", 1)
	                      .transition().duration(duration).ease("exp")
	                      .style("opacity", 0)
	                      .each("end", function(){
	                          labelGroup
	                              .style("opacity", 1) //i would like to set it to null. but then fade in animation is not working for some reason
	                              .classed("vzb-invisible", d.hidden);
	                      })
	                  lineGroup
	                      .style("opacity", 1)
	                      .transition().duration(duration).ease("exp")
	                      .style("opacity", 0)
	                      .each("end", function(){
	                          lineGroup
	                              .style("opacity", 1) //i would like to set it to null. but then fade in animation is not working for some reason
	                              .classed("vzb-invisible", d.hidden);
	                      })      
	                  
	              } else {
	                  // just update the position
	                  
	                  labelGroup
	                      .transition().duration(duration).ease("linear")
	                      .attr("transform", "translate(" + _X + "," + _Y + ")");
	                  lineGroup
	                      .transition().duration(duration).ease("linear")
	                      .attr("transform", "translate(" + _X + "," + _Y + ")");
	              }
	                
	            } else {
	              labelGroup
	                  .interrupt()
	                  .attr("transform", "translate(" + _X + "," + _Y + ")");
	              lineGroup
	                  .interrupt()
	                  .attr("transform", "translate(" + _X + "," + _Y + ")");
	              if(showhide) labelGroup.classed("vzb-invisible", d.hidden);
	              if(showhide) lineGroup.classed("vzb-invisible", d.hidden);
	            }
	
	            var diffX1 = _X0 - _X;
	            var diffY1 = _Y0 - _Y;
	            var textBBox = labelGroup.select('text').node().getBBox();
	            var diffX2 = -textBBox.width * .5;
	            var diffY2 = -height * .2;
	            var labels = _this.model.ui.chart.labels;
	
	            var bBox = labels.removeLabelBox ? textBBox : rectBBox;
	            
	            var FAR_COEFF = _this.activeProfile.labelLeashCoeff||0;
	
	            var lineHidden = circleRectIntersects({x: diffX1, y: diffY1, r: cache.scaledS0},
	              {x: diffX2, y: diffY2, width: (bBox.height * 2 * FAR_COEFF + bBox.width), height: (bBox.height * (2 * FAR_COEFF + 1))});
	            lineGroup.select('line').classed("vzb-invisible", lineHidden);
	            if(lineHidden) return;
	
	            if(labels.removeLabelBox) {
	              var angle = Math.atan2(diffX1 - diffX2, diffY1 - diffY2) * 180 / Math.PI;
	              var deltaDiffX2 = (angle >= 0 && angle <= 180) ? (bBox.width * .5) : (-bBox.width * .5);
	              var deltaDiffY2 = (Math.abs(angle) <= 90) ? (bBox.height * .55) : (-bBox.height * .45);
	              diffX2 += Math.abs(diffX1 - diffX2) > textBBox.width * .5 ? deltaDiffX2 : 0;
	              diffY2 += Math.abs(diffY1 - diffY2) > textBBox.height * .5 ? deltaDiffY2 : (textBBox.height * .05);
	            }
	
	            var longerSideCoeff = Math.abs(diffX1) > Math.abs(diffY1) ? Math.abs(diffX1) / viewWidth : Math.abs(diffY1) / viewHeight;
	            lineGroup.select("line").style("stroke-dasharray", "0 " + (cache.scaledS0) + " " + ~~(longerSideCoeff + 2) + "00%");
	
	            lineGroup.selectAll("line")
	              .attr("x1", diffX1)
	              .attr("y1", diffY1)
	              .attr("x2", diffX2)
	              .attr("y2", diffY2);
	
	          }
	        
	          /*
	          * Adapted from 
	          * http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection
	          * 
	          * circle { 
	          *  x: center X 
	          *  y: center Y
	          *  r: radius
	          * }
	          * 
	          * rect {
	          *  x: center X
	          *  y: center Y
	          *  width: width
	          *  height: height
	          * }
	          */
	          function circleRectIntersects(circle, rect) {
	            var circleDistanceX = Math.abs(circle.x - rect.x);
	            var circleDistanceY = Math.abs(circle.y - rect.y);    
	            var halfRectWidth = rect.width * .5;
	            var halfRectHeight = rect.height * .5;
	
	            if (circleDistanceX > (halfRectWidth + circle.r)) { return false; }
	            if (circleDistanceY > (halfRectHeight + circle.r)) { return false; }
	
	            if (circleDistanceX <= halfRectWidth) { return true; } 
	            if (circleDistanceY <= halfRectHeight) { return true; }
	
	            var cornerDistance_sq = Math.pow(circleDistanceX - halfRectWidth, 2) +
	                                Math.pow(circleDistanceY - halfRectHeight, 2);
	
	            return (cornerDistance_sq <= Math.pow(circle.r,2));
	          }
	
	          return label;
	        }();
	      }
	
	      var OPTIONS$1 = {
	        TOOL_CONTEXT: null,
	        LABELS_CONTAINER_CLASS: '',
	        LINES_CONTAINER_CLASS: '',
	        CSS_PREFIX: ''
	      }; 
	
	      var Labels = Component.extend({
	
	        init: function(config, context) {
	          var _this = this;
	
	          this.name = 'gapminder-labels';
	
	          this.model_expects = [{
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "ui",
	            type: "model"
	          }];
	
	          this.context = context;
	
	          this.model_binds = {
	            "change:entities.select": function() {
	              if(!_this._readyOnce) return;
	              //console.log("EVENT change:entities:select");
	              _this.selectDataPoints();
	            }
	          }
	          if(context.model.state.marker.size_label)
	            this.model_binds['change:marker.size_label.extent'] = function(evt, path) {
	              //console.log("EVENT change:marker:size:max");
	              if(!_this._readyOnce) return;
	              _this.updateLabelSizeLimits();
	              if(_this._toolContext.model.time.splash) return;
	              _this.updateLabelsOnlyTextSize();
	            }
	          if(context.model.ui.chart.labels.hasOwnProperty('removeLabelBox'))
	            this.model_binds['change:ui.chart.labels.removeLabelBox'] = function(evt, path) {
	              //console.log("EVENT change:marker:size:max");
	              if(!_this._readyOnce) return;
	              _this.updateLabelsOnlyTextSize();
	            }
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.ui = extend({
	            //...add properties here
	          }, this.ui);
	
	          this.label = label(this);
	          this._xScale = null;
	          this._yScale = null;
	          this._closeCrossHeight = 0;
	          this.labelSizeTextScale = null;
	        },
	
	        ready: function() {
	          this.updateLabelSizeLimits();
	          this.updateIndicators();
	          //this.updateLabelsOnlyTextSize();
	        },
	
	        readyOnce: function() {
	          if(this._readyRace) return;
	
	          var _this = this;
	          
	          this.KEY = this.model.entities.getDimension();
	          
	          this.cached = {};
	
	          this._toolContext = OPTIONS$1.TOOL_CONTEXT;
	          this._cssPrefix = OPTIONS$1.CSS_PREFIX;
	          this.label.setCssPrefix(OPTIONS$1.CSS_PREFIX);
	          
	          this.rootEl = this.root.element instanceof Array? this.root.element : d3.select(this.root.element);
	          this.labelsContainer = this.rootEl.select("." + OPTIONS$1.LABELS_CONTAINER_CLASS);
	          this.linesContainer = this.rootEl.select("." + OPTIONS$1.LINES_CONTAINER_CLASS);
	          this.updateIndicators();
	          this.updateSize();
	          this.selectDataPoints();
	        },
	        
	        config: function(newOptions) {
	          extend(OPTIONS$1, newOptions);
	        },
	
	        updateLabelSizeLimits: function() {
	          var _this = this;
	          if (!this.model.marker.size_label) return;
	          var extent = this.model.marker.size_label.extent || [0,1];
	
	          var minLabelTextSize = this.activeProfile.minLabelTextSize;
	          var maxLabelTextSize = this.activeProfile.maxLabelTextSize;
	          var minMaxDelta = maxLabelTextSize - minLabelTextSize;
	
	          this.minLabelTextSize = Math.max(minLabelTextSize + minMaxDelta * extent[0], minLabelTextSize);
	          this.maxLabelTextSize = Math.max(minLabelTextSize + minMaxDelta * extent[1], minLabelTextSize);
	
	          if(this.model.marker.size_label.use == 'constant') {
	            // if(!this.model.marker.size_label.which) {
	            //   this.maxLabelTextSize = this.activeProfile.defaultLabelTextSize;
	            //   this.model.marker.size_label.set({'domainMax': (this.maxLabelTextSize - minLabelTextSize) / minMaxDelta, 'which': '_default'});
	            //   return; 
	            // }
	            this.minLabelTextSize = this.maxLabelTextSize;
	          } 
	
	          if(this.model.marker.size_label.scaleType !== "ordinal" || this.model.marker.size_label.use == 'constant') {
	            this.labelSizeTextScale.range([_this.minLabelTextSize, _this.maxLabelTextSize]);
	          } else {
	            this.labelSizeTextScale.rangePoints([_this.minLabelTextSize, _this.maxLabelTextSize], 0).range();
	          }
	
	        },
	        
	        updateIndicators: function() {
	          var _this = this;
	
	          //scales
	          if(this.model.marker.size_label) {
	            this.labelSizeTextScale = this.model.marker.size_label.getScale();
	          }
	        },
	        
	        setScales: function(xScale, yScale) {
	          this._xScale = xScale;
	          this._yScale = yScale;
	        },
	        
	        setCloseCrossHeight: function(closeCrossHeight) {
	          this._closeCrossHeight = closeCrossHeight;
	        },
	       
	        xScale: function(x) {
	          return this._xScale ? this._xScale(x) : (x * this._toolContext.width);
	        },
	
	        yScale: function(y) {
	          return this._yScale ? this._yScale(y) : (y * this._toolContext.height);
	        },
	
	        selectDataPoints: function() {
	          var _this = this;
	          var KEY = this.KEY;
	          var _cssPrefix = this._cssPrefix;
	
	          this.entityLabels = this.labelsContainer.selectAll("." + _cssPrefix + "-entity")
	            .data(_this.model.entities.select, function(d) {
	              return(d[KEY]);
	            });
	          this.entityLines = this.linesContainer.selectAll("." + _cssPrefix + "-entity")
	            .data(_this.model.entities.select, function(d) {
	              return(d[KEY]);
	            });
	
	          this.entityLabels.exit()
	            .each(function(d) {
	              if(_this.cached[d[KEY]] != null) {
	                  _this.cached[d[KEY]] = void 0;
	              }
	            })
	            .remove();
	          this.entityLines.exit()
	            .remove();
	          this.entityLines
	            .enter().append('g')
	            .attr("class", function(d, index){return _cssPrefix + "-entity line-" + d[KEY]})
	            .each(function(d, index) {
	              _this.label.line(d3.select(this));
	            });
	
	          this.entityLabels
	            .enter().append("g")
	            .attr("class", function(d, index){return _cssPrefix + "-entity label-" + d[KEY]})
	            .each(function(d, index) {
	              _this.cached[d[KEY]] = {};      
	              _this.label(d3.select(this));
	            });
	        },
	        
	        showCloseCross: function(d, show) {
	          var KEY = this.KEY; 
	          //show the little cross on the selected label
	          this.entityLabels
	              .filter(function(f){return f[KEY] == d[KEY]})
	              .select("." + this._cssPrefix + "-label-x")
	              .classed("vzb-transparent", !show);
	        },
	        
	        highlight: function(d, highlight) {
	          var KEY = this.KEY; 
	          var labels = this.entityLabels; 
	          if(d) {
	            labels = labels.filter(function(f) {
	                return f[KEY] == d[KEY]
	              });
	          }
	          labels.classed("vzb-highlighted", highlight);
	        },
	        
	        updateLabel: function(d, index, cache, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {
	          if(!this._readyOnce) {
	            this.readyOnce(); //run readyOnce if tool component is ready but labels component is not ready
	            this._readyRace = true;
	          }
	        
	          var _this = this;
	          var KEY = this.KEY;
	          if(d[KEY] == _this.druging)
	            return;
	
	          var _cssPrefix = OPTIONS$1.CSS_PREFIX;
	          var _context = OPTIONS$1.TOOL_CONTEXT;
	
	          // only for selected entities
	          if(_this.model.entities.isSelected(d) && _this.entityLabels != null) {
	            if(_this.cached[d[KEY]] == null) this.selectDataPoints();
	            
	            var cached = _this.cached[d[KEY]];
	            if(cache) extend(cached, cache);
	
	
	            if(cached.scaledS0 == null || cached.labelX0 == null || cached.labelY0 == null) { //initialize label once
	              if(valueS || valueS === 0) cached.scaledS0 = areaToRadius(this._toolContext.sScale(valueS));
	              cached.labelX0 = valueX;
	              cached.labelY0 = valueY;
	              cached.valueLST = valueLST;
	              cached.scaledC0 = valueC!=null?this._toolContext.cScale(valueC):this._toolContext.COLOR_WHITEISH;
	            }
	
	            if(cached.labelX_ == null || cached.labelY_ == null)
	            {            
	              var select = find(_this.model.entities.select, function(f) {
	                return f[KEY] == d[KEY]
	              });
	              cached.labelOffset = select.labelOffset || [0,0];
	            }
	
	            var brokenInputs = !cached.labelX0 && cached.labelX0 !==0 || !cached.labelY0 && cached.labelY0 !==0 || !cached.scaledS0 && cached.scaledS0 !==0;
	
	            var lineGroup = _this.entityLines.filter(function(f) {
	              return f[KEY] == d[KEY];
	            });
	            // reposition label
	            _this.entityLabels.filter(function(f) {
	                return f[KEY] == d[KEY]
	              })
	              .each(function(groupData) {
	
	                var labelGroup = d3.select(this);
	
	                if (brokenInputs) {
	                  labelGroup.classed("vzb-invisible", brokenInputs);
	                  lineGroup.classed("vzb-invisible", brokenInputs);
	                  return;
	                }
	
	                var text = labelGroup.selectAll("." + _cssPrefix + "-label-content")
	                  .text(valueL);                       
	                
	                _this._updateLabelSize(d, index, labelGroup, valueLST, text);          
	                
	                _this.positionLabel(d, index, this, duration, showhide, lineGroup);
	              });
	          }
	        },
	        
	        _updateLabelSize: function(d, index, labelGroup, valueLST, text) { 
	          var _this = this;
	          var KEY = this.KEY;
	          var cached = _this.cached[d[KEY]];
	
	          
	          var _cssPrefix = OPTIONS$1.CSS_PREFIX;
	          var _context = OPTIONS$1.TOOL_CONTEXT;
	
	                         
	          var labels = _this.model.ui.chart.labels || {};
	          labelGroup.classed('vzb-label-boxremoved', labels.removeLabelBox);
	          
	          var _text = text || labelGroup.selectAll("." + _cssPrefix + "-label-content"); 
	          
	          if(valueLST != null && _this.labelSizeTextScale) {
	            var range = _this.labelSizeTextScale.range();
	            var fontSize = range[0] + Math.sqrt((_this.labelSizeTextScale(valueLST) - range[0]) * (range[1] - range[0]));
	            _text.attr('font-size', fontSize + 'px');
	          }
	
	          var contentBBox = _text[0][0].getBBox();
	          
	          var rect = labelGroup.selectAll("rect");
	          
	          if(!cached.textWidth || cached.textWidth != contentBBox.width) {
	            cached.textWidth = contentBBox.width;
	
	            var labelCloseHeight = _this._closeCrossHeight || contentBBox.height;//_this.activeProfile.infoElHeight * 1.2;//contentBBox.height;
	
	            var labelCloseGroup = labelGroup.select("." + _cssPrefix + "-label-x")
	              .attr('transform', 'translate(' + 4 + ',' + (-contentBBox.height * .85) + ')');
	              //.attr("x", /*contentBBox.height * .0 + */ 4)
	              //.attr("y", contentBBox.height * -1);
	
	            labelCloseGroup.select("circle")
	              .attr("cx", /*contentBBox.height * .0 + */ 0)
	              .attr("cy", 0)
	              .attr("r", labelCloseHeight * .5);
	
	            labelCloseGroup.select("svg")
	              .attr("x", -labelCloseHeight * .5 )
	              .attr("y", labelCloseHeight * -.5)
	              .attr("width", labelCloseHeight)
	              .attr("height", labelCloseHeight)
	        
	            rect.attr("width", contentBBox.width + 8)
	              .attr("height", contentBBox.height * 1.2)
	              .attr("x", -contentBBox.width - 4)
	              .attr("y", -contentBBox.height * .85)
	              .attr("rx", contentBBox.height * .2)
	              .attr("ry", contentBBox.height * .2);
	
	            //cache label bound rect for reposition
	            cached.rectBBox = rect.node().getBBox();
	            //cached.moveX = 5;
	            //cached.moveY = contentBBox.height * .3;
	          }
	          
	          var glowRect = labelGroup.select(".vzb-label-glow")
	          if(glowRect.attr("stroke") !== cached.scaledC0) {
	            glowRect.attr("stroke", cached.scaledC0);
	          }
	        },
	          
	        updateLabelsOnlyTextSize: function() {
	          var _this = this;
	          var KEY = this.KEY;
	          
	          this.entityLabels.each(function(d, index) {
	            var cached = _this.cached[d[KEY]];
	              _this._updateLabelSize(d, index, d3.select(this), _this._toolContext.frame.size_label[d[KEY]]);
	              var lineGroup = _this.entityLines.filter(function(f) {
	                return f[KEY] == d[KEY];
	              });
	              _this.positionLabel(d, index, this, 0, null, lineGroup);
	            });
	        },
	        
	        updateLabelOnlyPosition: function(d, index, cache) {
	          var _this = this;
	          var KEY = this.KEY;
	          var cached = this.cached[d[KEY]];
	          if(cache) extend(cached, cache);
	
	          var lineGroup = _this.entityLines.filter(function(f) {
	            return f[KEY] == d[KEY];
	          });
	          
	          this.entityLabels.filter(function(f) {
	              return f[KEY] == d[KEY]
	            })
	            .each(function(groupData) {
	              _this.positionLabel(d, index, this, 0, null, lineGroup);
	            });
	        },
	
	        updateLabelOnlyColor: function(d, index, cache) {
	          var _this = this;
	          var KEY = this.KEY;
	          var cached = this.cached[d[KEY]];
	          if(cache) extend(cached, cache);
	
	          var labelGroup = _this.entityLabels.filter(function(f) {
	            return f[KEY] == d[KEY];
	          });
	         
	          _this._updateLabelSize(d, index, labelGroup, null);
	          
	        },
	        
	        positionLabel: function(d, index, context, duration, showhide, lineGroup) {
	          var KEY = this.KEY;
	          var cached = this.cached[d[KEY]];
	
	          var viewWidth = this._toolContext.width;       
	          var viewHeight = this._toolContext.height;       
	
	          var resolvedX0 = this.xScale(cached.labelX0);
	          var resolvedY0 = this.yScale(cached.labelY0);
	          
	          if(!cached.labelOffset) cached.labelOffset = [0,0];
	          cached.labelX_ = cached.labelOffset[0] || (-cached.scaledS0 * .75 - 5) / viewWidth;
	          cached.labelY_ = cached.labelOffset[1] || (-cached.scaledS0 * .75 - 11) / viewHeight;
	          
	          //check default label position and switch to mirror position if position 
	          //does not bind to visible field
	
	          var resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
	          if(cached.labelOffset[0] == 0) {
	            if(resolvedX - cached.rectBBox.width <= 0) { //check left
	              cached.labelX_ = (cached.scaledS0 * .75 + cached.rectBBox.width) / viewWidth;
	              resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
	            } else if(resolvedX + 15 > viewWidth) { //check right
	              cached.labelX_ = (viewWidth - 15 - resolvedX0) / viewWidth;
	              resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
	            }
	          }
	          var resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
	          if(cached.labelOffset[1] == 0) {
	            if(resolvedY - cached.rectBBox.height <= 0) { // check top 
	              cached.labelY_ = (cached.scaledS0 * .75 + cached.rectBBox.height) / viewHeight;
	              resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
	            } else if(resolvedY + 10 > viewHeight) { //check bottom
	              cached.labelY_ = (viewHeight - 10 - resolvedY0) / viewHeight;
	              resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
	            }
	          }
	          this.label._repositionLabels(d, index, context, resolvedX, resolvedY, resolvedX0, resolvedY0, duration, showhide, lineGroup);
	        },
	        
	        updateSize: function() {
	          var profiles = {
	            small: {
	              minLabelTextSize: 7,
	              maxLabelTextSize: 21,
	              defaultLabelTextSize: 12,
	              labelLeashCoeff: 0.4
	            },
	            medium: {
	              minLabelTextSize: 7,
	              maxLabelTextSize: 30,
	              defaultLabelTextSize: 15,
	              labelLeashCoeff: 0.3
	            },
	            large: {
	              minLabelTextSize: 6,
	              maxLabelTextSize: 48,
	              defaultLabelTextSize: 20,
	              labelLeashCoeff: 0.2
	            }
	          };
	
	          var _this = this;
	
	          this.activeProfile = this.getActiveProfile(profiles);
	          
	          this.updateLabelSizeLimits();
	        }
	
	      });
	
	      /*!
	       * VIZABI MIN MAX INPUT FIELDS
	       */
	
	      var DOMAINMIN = "domainMin";
	      var DOMAINMAX = "domainMax";
	      var ZOOMEDMIN = "zoomedMin";
	      var ZOOMEDMAX = "zoomedMax";
	
	      var MinMaxInputs = Component.extend({
	
	          /**
	           * Initializes the Component.
	           * Executed once before any template is rendered.
	           * @param config The options passed to the component
	           * @param context The component's parent
	           */
	          init: function(config, context) {
	
	              this.name = 'gapminder-minmaxinputs';
	              this.template = 'minmaxinputs.html';
	
	              var _this = this;
	
	              this.model_expects = [{
	                  name: "marker",
	                  type: "model"
	              }, {
	                  name: "time",
	                  type: "time"
	              }, {
	                  name: "language",
	                  type: "language"
	              }];
	
	              this.markerID = config.markerID;
	              if(!config.markerID) warn("minmaxinputs.js complains on 'markerID' property: " + config.markerID);
	
	              this.model_binds = {};
	              this.model_binds["change:language.strings"] = function(evt) {
	                  _this.updateView();
	              };
	              this.model_binds["change:marker." + this.markerID] = function(evt) {
	                  _this.updateView();
	              };
	              this.model_binds["ready"] = function(evt) {
	                  _this.updateView();
	              };
	
	              //contructor is the same as any component
	              this._super(config, context);
	
	              this.ui = extend({
	                  selectDomainMinMax: false,
	                  selectZoomedMinMax: false
	              }, this.ui.getPlainObject());
	
	          },
	
	          ready: function() {
	              this.updateView();
	          },
	
	          readyOnce: function() {
	              var _this = this;
	
	              this.element = d3.select(this.element);
	
	              this.el_domain_labelMin = this.element.select('.vzb-mmi-domainmin-label');
	              this.el_domain_labelMax = this.element.select('.vzb-mmi-domainmax-label');
	              this.el_domain_fieldMin = this.element.select('.vzb-mmi-domainmin');
	              this.el_domain_fieldMax = this.element.select('.vzb-mmi-domainmax');
	
	              this.el_break = this.element.select('.vzb-mmi-break');
	              
	              this.el_zoomed_labelMin = this.element.select('.vzb-mmi-zoomedmin-label');
	              this.el_zoomed_labelMax = this.element.select('.vzb-mmi-zoomedmax-label');
	              this.el_zoomed_fieldMin = this.element.select('.vzb-mmi-zoomedmin');
	              this.el_zoomed_fieldMax = this.element.select('.vzb-mmi-zoomedmax');
	
	
	              _this.el_domain_fieldMin.on("change", function() {
	                  _this._setModel(DOMAINMIN, this.value)
	              });
	              _this.el_domain_fieldMax.on("change", function() {
	                  _this._setModel(DOMAINMAX, this.value)
	              });
	
	              _this.el_zoomed_fieldMin.on("change", function() {
	                  _this._setModel(ZOOMEDMIN, this.value)
	              });
	              _this.el_zoomed_fieldMax.on("change", function() {
	                  _this._setModel(ZOOMEDMAX, this.value)
	              });
	              
	              this.element.selectAll("input")
	                  .on("keypress", function(e) {
	                      if(d3.event.which == 13) document.activeElement.blur();
	                  });
	          },
	
	          updateView: function() {
	            var _this = this;
	            this.translator = this.model.language.getTFunction();
	
	            this.el_domain_labelMin.text(this.translator("min") + ":");
	            this.el_domain_labelMax.text(this.translator("max") + ":");
	            this.el_zoomed_labelMin.text(this.translator("min") + ":");
	            this.el_zoomed_labelMax.text(this.translator("max") + ":");
	
	            this.el_domain_labelMin.classed('vzb-hidden', !this.ui.selectDomainMinMax);
	            this.el_domain_labelMax.classed('vzb-hidden', !this.ui.selectDomainMinMax);
	            this.el_domain_fieldMin.classed('vzb-hidden', !this.ui.selectDomainMinMax);
	            this.el_domain_fieldMax.classed('vzb-hidden', !this.ui.selectDomainMinMax);
	
	            this.el_break.classed('vzb-hidden', !(this.ui.selectDomainMinMax && this.ui.selectZoomedMinMax));
	
	            this.el_zoomed_labelMin.classed('vzb-hidden', !this.ui.selectZoomedMinMax);
	            this.el_zoomed_labelMax.classed('vzb-hidden', !this.ui.selectZoomedMinMax);
	            this.el_zoomed_fieldMin.classed('vzb-hidden', !this.ui.selectZoomedMinMax);
	            this.el_zoomed_fieldMax.classed('vzb-hidden', !this.ui.selectZoomedMinMax);
	
	            var formatter = function(n) { 
	              if(!n && n!==0) return n;
	              if(isDate(n)) return _this.model.time.timeFormat(n);
	              return d3.format(".2r")(n);
	            }
	            
	            this.el_domain_fieldMin.property("value", formatter(this.model.marker[this.markerID].getScale().domain()[0]));
	            this.el_domain_fieldMax.property("value", formatter(this.model.marker[this.markerID].getScale().domain()[1]));
	            this.el_zoomed_fieldMin.property("value", formatter(this.model.marker[this.markerID].zoomedMin));
	            this.el_zoomed_fieldMax.property("value", formatter(this.model.marker[this.markerID].zoomedMax));
	          },
	
	          _setModel: function(what, value) {
	              this.model.marker[this.markerID][what] = strToFloat(value);
	          }
	
	      });
	
	      var simplecheckbox = Component.extend({
	
	        init: function(config, context) {
	          this.template =
	            '<span class="vzb-sc-holder vzb-dialog-checkbox"><input type="checkbox"><label></label></span>';
	          var _this = this;
	          this.name = 'gapminder-simplecheckbox';
	
	          this.checkbox = config.checkbox;
	          this.submodel = config.submodel;
	
	          this.model_expects = [{
	            name: "mdl"
	              //TODO: learn how to expect model "axis" or "size" or "color"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	
	          this.model_binds = {
	            "change:mdl": function(evt) {
	              _this.updateView();
	            },
	            "change:language.strings": function(evt) {
	              _this.updateView();
	            }
	          };
	
	          var submodel = (this.submodel) ? this.submodel + ':' : '';
	          this.model_binds["change:mdl." + submodel + this.checkbox] = function() {
	            _this.updateView();
	          };
	
	          //contructor is the same as any component
	          this._super(config, context);
	        },
	
	        ready: function() {
	          this.parentModel = (this.submodel) ? this.model.mdl[this.submodel] : this.model.mdl;
	          this.updateView();
	        },
	
	        readyOnce: function() {
	          var _this = this;
	          this.element = d3.select(this.element);
	          var id = "-check-" + Math.random() * 1000;
	          this.labelEl = this.element.select('label').attr("for", id);
	          this.checkEl = this.element.select('input').attr("id", id)
	            .on("change", function() {
	              _this._setModel(d3.select(this).property("checked"));
	            });
	        },
	
	        updateView: function() {
	          this.translator = this.model.language.getTFunction();
	          this.labelEl.text(this.translator("check/" + this.checkbox));
	          this.checkEl.property("checked", !!this.parentModel[this.checkbox]);
	        },
	
	        _setModel: function(value) {
	          this.parentModel[this.checkbox] = value;
	        }
	
	      });
	
	      /*!
	       * VIZABI GENERIC SLIDER CONTROL
	       * Reusable SLIDER
	       */
	
	      var SimpleSlider = Component.extend({
	
	          init: function (config, context) {
	            this.template = '<div class="vzb-ss-holder"><input type="range" id="vzb-ss-slider" class="vzb-ss-slider" step="1"></div>';
	
	            this.model_expects = [{
	              name: "submodel"
	            }];
	
	            var _this = this;
	            this.name = 'gapminder-simpleSlider';
	
	            this.arg = config.arg;
	            this.thumb_size = config.thumb_size;
	            this.slider_properties = config.properties;
	
	            this.model_binds = {};
	            this.model_binds["change:submodel." + this.arg] = function (evt) {
	              _this.updateView();
	            };
	
	            //contructor is the same as any component
	            this._super(config, context);
	              
	            this._setModel = throttle(this._setModel, 50);
	          },
	
	          /**
	           * Executes after the template is loaded and rendered.
	           * Ideally, it contains HTML instantiations related to template
	           * At this point, this.element and this.placeholder are available as a d3 object
	           */
	          readyOnce: function () {
	
	            //default values
	            var min = 0;
	            var max = 1;
	            var step = 0.1;
	            var value = min;
	
	            //selecting elements
	            var _this = this;
	            this.element = d3.select(this.element);
	            this.slider = this.element.selectAll('#vzb-ss-slider');
	
	            this.elementSize = this.element.node().getBoundingClientRect();
	            this.sliderSize = this.slider.node().getBoundingClientRect();
	            this.slider.style('left', (this.elementSize.left - this.sliderSize.left) + 'px');
	
	            //TODO: replace this with utils.extend
	            if(this.slider_properties){
	              if(this.slider_properties.min != null) min = this.slider_properties.min;
	              if(this.slider_properties.max != null) max = this.slider_properties.max;
	              if(this.slider_properties.step != null) step = this.slider_properties.step;
	
	              if(this.slider_properties.scale){
	                value = this.slider_properties.scale(min);
	              }
	            }
	              
	            //step also defines the rounding of values that willbe sent to model: 0.1 --> 1 digit, 0.01 --> 2, 1 and up --> 0
	            this.roundTo = step > 1 ? 0 : Math.round(Math.abs(Math.log(step)/Math.LN10));
	
	            //check and change the slider's thumb size
	            if(this.thumb_size){
	              this.slider.classed('vzb-ss-slider', false);
	              this.slider.classed('vzb-ss-slider-'+this.thumb_size, true);
	            }
	
	            this.slider
	              .attr('min', min)
	              .attr('max', max)
	              .attr('step', step)
	              .attr('value', value)
	              .on('input', function () {
	                var value = +d3.event.target.value;
	                _this._setModel(value, false, false); // on drag - non-persistent changes while dragging
	              })
	              .on('change', function() {
	                var value = +d3.event.target.value;
	                _this._setModel(value, true); // on drag end - value is probably same as last 'input'-event, so force change
	              });
	
	            this.updateView();
	          },
	
	          updateView: function () {
	            var value = this.model.submodel[this.arg];
	            var slider_properties = this.slider_properties;
	            var scale;
	
	            if(slider_properties){
	              scale = slider_properties.scale;
	            }
	            if (scale){
	              value = scale.invert(value);
	            }
	
	            //this.slider.attr('value', value);
	            this.slider.node().value = value;
	          },
	
	          _setModel: function (value, force, persistent) {
	            // rescale value if scale is supplied in slider_properties 
	            if(this.slider_properties && this.slider_properties.scale) value = this.slider_properties.scale(value);
	            
	            this.model.submodel.getModelObject(this.arg).set(value.toFixed(this.roundTo), force, persistent);
	          }
	
	        });
	
	      /*!
	       * VIZABI BUBBLE SIZE slider
	       * Reusable bubble size slider
	       */
	
	      var OPTIONS$2 = {
	        EXTENT_MIN: 0,
	        EXTENT_MAX: 1,
	        TEXT_PARAMS: { TOP: 18, LEFT: 10, MAX_WIDTH: 42, MAX_HEIGHT: 16 },
	        BAR_WIDTH: 6,
	        THUMB_RADIUS: 10,
	        THUMB_STROKE_WIDTH: 4,
	        INTRO_DURATION: 250,
	        MARGIN: { TOP: 2, LEFT: 5, RIGHT:5}  
	      }
	
	      var profiles$1 = {
	          "small": {
	            minLabelTextSize: 7,
	            maxLabelTextSize: 21,
	            defaultLabelTextSize: 12
	          },
	          "medium": {
	            minLabelTextSize: 7,
	            maxLabelTextSize: 30,
	            defaultLabelTextSize: 15
	          },
	          "large": {
	            minLabelTextSize: 6,
	            maxLabelTextSize: 48,
	            defaultLabelTextSize: 20
	          }
	      };
	
	
	      var SizeSlider = Component.extend({
	
	        /**
	         * Initializes the timeslider.
	         * Executed once before any template is rendered.
	         * @param config The options passed to the component
	         * @param context The component's parent
	         */
	        init: function (config, context) {
	
	          this.name = 'sizeslider';
	
	          this.template = this.template || "sizeslider.html";
	
	          this.propertyName = config.propertyname;
	
	          this.model_expects = [{
	            name: "size",
	            type: "size"
	          },{
	            name: "language",
	            type: "language"
	          }];
	
	          var _this = this;
	          this.model_binds = {
	            'change:size.domainMin': changeMinMaxHandler,
	            'change:size.domainMax': changeMinMaxHandler,
	            'change:size.extent': changeMinMaxHandler,        
	            'ready': readyHandler
	          };
	
	          function changeMinMaxHandler(evt, path) {
	            var size = _this.model.size.extent||[OPTIONS$2.EXTENT_MIN, OPTIONS$2.EXTENT_MAX];
	            //_this._updateArcs(size);
	            _this._updateLabels(size);
	            _this.sliderEl.call(_this.brush.extent(size));
	            if(size[0] == size[1]){
	              _this.sliderEl.selectAll(".resize")
	                .style("display", "block");
	            }
	          }
	          
	          function readyHandler(evt) {
	            _this.modelUse = _this.model.size.use; 
	            var size = _this.model.size.extent||[OPTIONS$2.EXTENT_MIN, OPTIONS$2.EXTENT_MAX];
	            if(_this.modelUse != 'constant') {
	              _this.sizeScaleMinMax = _this.model.size.getScale().domain();
	              _this.sliderEl.selectAll('.w').classed('vzb-hidden', false);
	              _this.sliderEl.select('.extent').classed('vzb-hidden', false);
	              _this.sliderEl.select('.background').classed('vzb-pointerevents-none', false);
	              _this._setLabelsText();
	            } else {
	              _this.sliderEl.selectAll('.w').classed('vzb-hidden', true);
	              _this.sliderEl.select('.extent').classed('vzb-hidden', true);
	              _this.sliderEl.select('.background').classed('vzb-pointerevents-none', true);
	              if(!_this.model.size.which) {
	                var p = _this.propertyActiveProfile;
	                size[1] = (p.default - p.min) / (p.max - p.min);
	                _this.model.size.which = '_default';
	              }      
	            }
	            _this.sliderEl.call(_this.brush.extent([size[0], size[1]]));
	            _this.sliderEl.call(_this.brush.event);      
	          }
	
	          this._setModel = throttle(this._setModel, 50);
	          //contructor is the same as any component
	          this._super(config, context);
	        },
	
	        /**
	         * Executes after the template is loaded and rendered.
	         * Ideally, it contains HTML instantiations related to template
	         * At this point, this.element and this.placeholder are available as a d3 object
	         */
	        readyOnce: function () {
	          var _this = this;
	          var values = _this.model.size.extent||[OPTIONS$2.EXTENT_MIN, OPTIONS$2.EXTENT_MAX];
	          this.element = d3.select(this.element);
	          this.sliderSvg = this.element.select(".vzb-szs-svg");
	          this.sliderWrap = this.sliderSvg.select(".vzb-szs-slider-wrap");
	          this.sliderEl = this.sliderWrap.select(".vzb-szs-slider");
	
	          var
	            textMargin = {v: OPTIONS$2.TEXT_PARAMS.TOP, h: OPTIONS$2.TEXT_PARAMS.LEFT},
	            textMaxWidth = OPTIONS$2.TEXT_PARAMS.MAX_WIDTH,
	            textMaxHeight = OPTIONS$2.TEXT_PARAMS.MAX_HEIGHT,
	            barWidth = OPTIONS$2.BAR_WIDTH,
	            thumbRadius = OPTIONS$2.THUMB_RADIUS,
	            thumbStrokeWidth = OPTIONS$2.THUMB_STROKE_WIDTH,
	            padding = {
	              top: OPTIONS$2.MARGIN.TOP + barWidth * 1.25,
	              left: thumbRadius,
	              right: thumbRadius,
	              bottom: barWidth + textMaxHeight
	            }
	          
	          var componentWidth = this.element.node().offsetWidth; 
	
	          this.padding = padding;
	          
	          this.propertyActiveProfile = this.getPropertyActiveProfile();
	          this.translator = this.model.language.getTFunction();
	
	          this.propertyScale = d3.scale.linear()
	            .domain([OPTIONS$2.EXTENT_MIN, OPTIONS$2.EXTENT_MAX])
	            .range([this.propertyActiveProfile.min, this.propertyActiveProfile.max])
	            .clamp(true)
	
	          this.xScale = d3.scale.linear()
	            .domain([OPTIONS$2.EXTENT_MIN, OPTIONS$2.EXTENT_MAX])
	            .range([0, componentWidth - padding.left - padding.right])
	            .clamp(true)
	
	          this.brush = d3.svg.brush()
	            .x(this.xScale)
	            .extent([OPTIONS$2.EXTENT_MIN, OPTIONS$2.EXTENT_MAX])
	            .on("brush", function () {
	              _this._setFromExtent(true, false, false); // non persistent change
	            })
	            .on("brushend", function () {
	               _this.sliderEl.selectAll(".resize")
	               .style("display", null);
	
	              _this._setFromExtent(true, true); // force a persistent change
	            });
	
	          this.sliderEl
	            .call(_this.brush);
	            
	          this.sliderEl.selectAll('.background').attr('style','');
	
	          //For return to round thumbs
	          //var thumbArc = d3.svg.arc()
	          //  .outerRadius(thumbRadius)
	          //  .startAngle(0)
	          //  .endAngle(2 * Math.PI)
	
	          this.sliderThumbs = this.sliderEl.selectAll(".resize").sort(d3.descending)
	            .classed("vzb-szs-slider-thumb", true)
	
	          this.sliderThumbs.append("g")
	            .attr("class", "vzb-szs-slider-thumb-badge")
	            .append("path")
	            .attr('d', function(d,i) {
	              return "M0 " + (barWidth * .5) + "l" + (-thumbRadius) + " " + (thumbRadius * 1.5) + "h" + (thumbRadius * 2) + "Z";
	            })
	
	      //
	
	          this.sliderThumbs.append("path")
	            .attr("class", "vzb-szs-slider-thumb-arc")
	          this.sliderEl.selectAll("text").data([0,0]).enter()
	            .append("text")
	            .attr("class", function(d, i) {
	              return "vzb-szs-slider-thumb-label " + (i ? 'e' : 'w');})
	            .attr("dy", (-barWidth * 1.25) + 'px')
	            .attr("text-anchor", function(d, i) {
	              return 1 - i ? "start" : "end"})
	
	          this.sliderLabelsEl = this.sliderEl.selectAll("text.vzb-szs-slider-thumb-label");
	
	          this.sliderEl.selectAll("rect")
	            .attr("height", barWidth)
	            .attr("rx", barWidth * 0.25)
	            .attr("ry", barWidth * 0.25)
	            .attr("transform", "translate(0," + (-barWidth * 0.5) + ")")
	          this.sliderEl.select(".extent")
	            .classed("vzb-szs-slider-extent", true)
	
	          this.on("resize", function() {
	            //console.log("EVENT: resize");
	            _this.propertyActiveProfile = _this.getPropertyActiveProfile();
	            _this.propertyScale.range([_this.propertyActiveProfile.min, _this.propertyActiveProfile.max])
	            
	            var componentWidth = _this.element.node().offsetWidth; 
	
	             _this.xScale.range([0, componentWidth - _this.padding.left - _this.padding.right])
	             _this._updateSize();
	
	             _this.sliderEl
	               .call(_this.brush.extent(_this.brush.extent()))
	             _this._setFromExtent(false, false, false); // non persistent change
	
	          });
	
	          this._updateSize();
	          
	          this.sliderEl
	            .call(this.brush.extent(values))
	          _this._setFromExtent(false, false, false); // non persistent change
	
	          _this.sizeScaleMinMax = _this.model.size.getScale().domain();
	
	          if(_this.sizeScaleMinMax) {
	            _this._setLabelsText();
	          }
	        },
	        
	        getPropertyActiveProfile: function() {
	          var profile = profiles$1[this.getLayoutProfile()];
	          return { min: profile['min' + this.propertyName], max: profile['max' + this.propertyName], default: profile['default' + this.propertyName]};
	        },
	
	        /*
	         * RESIZE:
	         * Executed whenever the container is resized
	         */
	        _updateSize: function() {
	          this.sliderSvg
	            .attr("height", this.propertyActiveProfile.max + this.padding.top + this.padding.bottom)
	            .attr("width", '100%')
	          this.sliderWrap
	            .attr("transform", "translate(" + this.padding.left + "," + (this.propertyActiveProfile.max + this.padding.top) + ")")
	        },
	
	      //   _updateArcs: function(s) {
	      //     var _this = this;
	      //     var valueArc = d3.svg.arc()
	      //       .outerRadius(function (d) { return _this.xScale(d) * 0.5 })
	      //       .innerRadius(function (d) { return _this.xScale(d) * 0.5 })
	      //       .startAngle(-Math.PI * 0.5)
	      //       .endAngle(Math.PI * 0.5);
	      // 
	      //     this.sliderThumbs.select('.vzb-szs-slider-thumb-arc').data(s)
	      //       .attr("d", valueArc)
	      //       .attr("transform", function (d) {return "translate(" + (-_this.xScale(d) * 0.25) + ",0)"; })
	      //   },
	      // 
	        _updateLabels: function(s) {
	          var _this = this;
	          var arcLabelTransform = function(d, i) {
	            var dX = _this.xScale(i),
	                dY = 0;//i ? -textMargin.v : 0;
	            return "translate(" + (dX) + "," + (dY) + ")";
	          }
	          this.sliderLabelsEl.data(s)
	            .attr("transform", arcLabelTransform)
	            .attr("font-size", function(d, i) {
	              return _this.propertyScale(d);
	            })
	          if(_this.model.size.use === 'constant')
	            this.sliderLabelsEl.data(s).text(function(d) {
	              return ~~(_this.propertyScale(d)) + (_this.translator(_this.ui.constantUnit)||"");
	            })    
	        },
	
	        _setLabelsText: function() {
	            var _this = this;
	            _this.sliderLabelsEl
	              .data([_this.model.size.getTickFormatter()(_this.sizeScaleMinMax[0]),_this.model.size.getTickFormatter()(_this.sizeScaleMinMax[1])])
	              .text(function (d) { return d; });
	        },
	
	        /**
	         * Prepares setting of the current model with the values from extent.
	         * @param {boolean} set model
	         * @param {boolean} force force firing the change event
	         * @param {boolean} persistent sets the persistency of the change event
	         */
	        _setFromExtent: function(setModel, force, persistent) {
	          var s = this.brush.extent();
	      //    this._updateArcs(s);
	          this._updateLabels(s);
	          if(setModel) this._setModel(s, force, persistent);
	        },
	
	        /**
	         * Sets the current value in model. avoid updating more than once in framerate
	         * @param {number} value
	         * @param {boolean} force force firing the change event
	         * @param {boolean} persistent sets the persistency of the change event
	         */
	        _setModel: function (value, force, persistent) {
	          value = [+value[0].toFixed(2), +value[1].toFixed(2)];
	          this.model.size.set({"extent": value}, force, persistent);
	        }
	
	      });
	
	      var precision = 1;
	
	      //constants
	      var class_playing = "vzb-playing";
	      var class_loading = "vzb-ts-loading";
	      var class_hide_play = "vzb-ts-hide-play-button";
	      var class_dragging = "vzb-ts-dragging";
	      var class_axis_aligned = "vzb-ts-axis-aligned";
	      var class_show_value = "vzb-ts-show-value";
	      var class_show_value_when_drag_play = "vzb-ts-show-value-when-drag-play";
	
	      //margins for slider
	      var profiles$2 = {
	        small: {
	          margin: {
	            top: 7,
	            right: 15,
	            bottom: 10,
	            left: 15
	          },
	          radius: 8,
	          label_spacing: 10
	        },
	        medium: {
	          margin: {
	            top: 16,
	            right: 15,
	            bottom: 10,
	            left: 15
	          },
	          radius: 9,
	          label_spacing: 12
	        },
	        large: {
	          margin: {
	            top: 14,
	            right: 15,
	            bottom: 10,
	            left: 15
	          },
	          radius: 11,
	          label_spacing: 14
	        }
	      };
	
	
	      var presentationProfileChanges = {
	        "medium": {
	          margin: {
	            top: 9
	          }
	        },
	        "large": {
	          margin: {
	          }
	        }
	      }
	
	      var TimeSlider = Component.extend({
	        /**
	         * Initializes the timeslider.
	         * Executed once before any template is rendered.
	         * @param model The model passed to the component
	         * @param context The component's parent
	         */
	        init: function(model, context) {
	
	          this.name = "gapminder-timeslider";
	          this.template = this.template || "timeslider.html";
	          this.prevPosition = null;
	          //define expected models/hooks for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }];
	
	          var _this = this;
	
	          //starts as splash if this is the option
	          this._splash = model.ui.splash;
	
	          //binds methods to this model
	          this.model_binds = {
	            'change:time': function(evt, path) {
	
	              //TODO: readyOnce CANNOT be run twice
	              if(_this._splash !== _this.model.time.splash) {
	                _this._splash = _this.model.time.splash;
	                _this.readyOnce();
	                _this.ready();
	              }
	
	              if(!_this._splash && _this.slide) {
	
	                if((['time.start', 'time.end']).indexOf(path) !== -1) {
	                  if (!_this.xScale) return;  
	                  _this.changeLimits();
	                }
	                _this._optionClasses();
	              }
	            },
	            'change:time.value': function(evt, path) {
	              if(!_this._splash && _this.slide) {
	                //only set handle position if change is external
	                if(!_this.model.time.dragging) _this._setHandle(_this.model.time.playing);
	              }
	            },
	            'change:time.start': function(evt, path) {
	              if(!_this._splash && _this.slide) {
	                //only set handle position if change is external
	                if(!_this.model.time.dragging) _this._setHandle(_this.model.time.playing);
	              }
	            },
	            'change:time.end': function(evt, path) {
	              if(!_this._splash && _this.slide) {
	                //only set handle position if change is external
	                if(!_this.model.time.dragging) _this._setHandle(_this.model.time.playing);
	              }
	            },
	            'change:time.startSelected': function(evt, path) {
	              if(!_this._splash && _this.slide) {
	                _this.updateSelectedStartLimiter();
	              }
	            },
	            'change:time.endSelected': function(evt, path) {
	              if(!_this._splash && _this.slide) {
	                _this.updateSelectedEndLimiter();
	              }
	            },
	            'change:entities.select': function(evt, path) {
	              _this.setSelectedLimits();
	            }
	          };
	
	          this.ui = extend({
	            show_limits: false,
	            show_value: false,
	            show_value_when_drag_play: true,
	            show_button: true,
	            class_axis_aligned: false
	          }, model.ui, this.ui);
	
	          // Same constructor as the superclass
	          this._super(model, context);
	
	          //defaults
	          this.width = 0;
	          this.height = 0;
	
	          this.getValueWidth = memoize(this.getValueWidth);
	          this._setTime = throttle(this._setTime, 50);
	        },
	
	        //template is ready
	        readyOnce: function () {
	
	          if(this._splash) return;
	
	          var _this = this;
	
	          //DOM to d3
	          //TODO: remove this ugly hack
	          this.element = isArray(this.element) ? this.element : d3.select(this.element);
	          this.element.classed(class_loading, false);
	
	          //html elements
	          this.slider_outer = this.element.select(".vzb-ts-slider");
	          this.slider = this.slider_outer.select("g");
	          this.axis = this.element.select(".vzb-ts-slider-axis");
	          this.select = this.element.select(".vzb-ts-slider-select");
	          this.slide = this.element.select(".vzb-ts-slider-slide");
	          this.handle = this.slide.select(".vzb-ts-slider-handle");
	          this.valueText = this.slide.select('.vzb-ts-slider-value');
	          //Scale
	          this.xScale = d3.time.scale.utc()
	            .clamp(true);
	
	          //Axis
	          this.xAxis = d3.svg.axis()
	            .orient("bottom")
	            .tickSize(0);
	          //Value
	          this.valueText.attr("text-anchor", "middle").attr("dy", "-0.7em");
	
	          var brushed = _this._getBrushed(),
	            brushedEnd = _this._getBrushedEnd();
	
	          //Brush for dragging
	          this.brush = d3.svg.brush()
	            .x(this.xScale)
	            .extent([0, 0])
	            .on("brush", function () {
	              brushed.call(this);
	            })
	            .on("brushend", function () {
	              brushedEnd.call(this);
	            });
	
	          //Slide
	          this.slide.call(this.brush);
	
	          this.slider_outer.on("mousewheel", function () {
	              //do nothing and dont pass the event on if we are currently dragging the slider
	              if(_this.model.time.dragging){
	                  d3.event.stopPropagation();
	                  d3.event.preventDefault();
	                  d3.event.returnValue = false;
	                  return false;
	              }
	          });
	
	          this.slide.selectAll(".extent,.resize")
	            .remove();
	
	          this._setSelectedLimitsId = 0; //counter for setSelectedLimits
	          this._needRecalcSelectedLimits = true;
	          
	          forEach(_this.model.marker.getSubhooks(), function(hook) {
	            if(hook._important) hook.on('change:which', function() {
	              _this._needRecalcSelectedLimits = true;
	              _this.model.time.startSelected = _this.model.time.start;
	              _this.model.time.endSelected = _this.model.time.end; 
	            });
	          });
	          
	          this.root.on('ready', function() {     
	            if(_this._needRecalcSelectedLimits) {
	              _this._needRecalcSelectedLimits = false;
	              _this.setSelectedLimits(true);
	            }      
	          });
	
	          if(this.model.time.startSelected > this.model.time.start) {
	            _this.updateSelectedStartLimiter();
	          }
	         
	          if(this.model.time.endSelected < this.model.time.end) {
	            _this.updateSelectedEndLimiter();
	          }
	              
	          this.parent.on('myEvent', function (evt, arg) {
	            var layoutProfile = _this.getLayoutProfile();
	
	            if (arg.profile && arg.profile.margin) {
	              profiles$2[layoutProfile].margin = arg.profile.margin;
	            }
	
	            // set the right margin that depends on longest label width
	            _this.element.select(".vzb-ts-slider-wrapper")
	              .style("right", (arg.mRight - profiles$2[layoutProfile].margin.right) + "px");
	
	            _this.xScale.range([0, arg.rangeMax]);      
	            _this.resize();
	          });
	        },
	
	        //template and model are ready
	        ready: function () {
	          if(this._splash) return;
	
	          var play = this.element.select(".vzb-ts-btn-play");
	          var pause = this.element.select(".vzb-ts-btn-pause");
	          var _this = this;
	          var time = this.model.time;
	
	          play.on('click', function () {
	
	            _this.model.time.play();
	          });
	
	          pause.on('click', function () {
	            _this.model.time.pause("soft");
	          });
	
	          this.changeLimits();
	          this.changeTime();
	          this.resize();
	
	        },
	
	        changeLimits: function() {
	          var minValue = this.model.time.start;
	          var maxValue = this.model.time.end;
	          //scale
	          this.xScale.domain([minValue, maxValue]);
	          //axis
	          this.xAxis.tickValues([minValue, maxValue])
	            .tickFormat(this.model.time.timeFormat);
	        },
	
	        changeTime: function() {
	          this.ui.format = this.model.time.unit;
	          //time slider should always receive a time model
	          var time = this.model.time.value;
	          //special classes
	          this._optionClasses();
	        },
	
	        /**
	         * Executes everytime the container or vizabi is resized
	         * Ideally,it contains only operations related to size
	         */
	        resize: function () {
	
	          this.model.time.pause();
	
	          this.profile = this.getActiveProfile(profiles$2, presentationProfileChanges);
	
	          var slider_w = parseInt(this.slider_outer.style("width"), 10) || 0;
	          var slider_h = parseInt(this.slider_outer.style("height"), 10) || 0;
	          this.width = slider_w - this.profile.margin.left - this.profile.margin.right;
	          this.height = slider_h - this.profile.margin.bottom - this.profile.margin.top;
	          var _this = this;
	
	          //translate according to margins
	          this.slider.attr("transform", "translate(" + this.profile.margin.left + "," + this.profile.margin.top + ")");
	
	          //adjust scale width if it was not set manually before
	          if (this.xScale.range()[1] = 1) this.xScale.range([0, this.width]);
	
	          //adjust axis with scale
	          this.xAxis = this.xAxis.scale(this.xScale)
	            .tickPadding(this.profile.label_spacing);
	
	          this.axis.attr("transform", "translate(0," + this.height / 2 + ")")
	            .call(this.xAxis);
	
	          this.select.attr("transform", "translate(0," + this.height / 2 + ")");
	
	          this.slide.select(".background")
	            .attr("height", this.height);
	
	          //size of handle
	          this.handle.attr("transform", "translate(0," + this.height / 2 + ")")
	            .attr("r", this.profile.radius);
	
	          this.sliderWidth = _this.slider.node().getBoundingClientRect().width;
	
	          this.resizeSelectedLimiters();
	          
	          this._setHandle();
	
	        },
	        
	        setSelectedLimits: function(force) {
	          var _this = this;
	          this._setSelectedLimitsId++;
	          var _setSelectedLimitsId = this._setSelectedLimitsId;
	
	          var select = _this.model.entities.select;
	          if(select.length == 0) 
	          {
	            _this.model.time.startSelected = new Date(_this.model.time.start);
	            _this.model.time.endSelected = new Date(_this.model.time.end);
	            return;
	          }
	
	          var KEY = _this.model.entities.getDimension();
	          var timePoints = _this.model.time.getAllSteps();
	          var selectedEdgeTimes = [];
	          var hooks = [];
	          forEach(_this.model.marker.getSubhooks(), function(hook) {
	            if(hook.use == "constant") return;
	            if(hook._important) hooks.push(hook._name);
	          });
	          
	          var findEntityWithCompleteHooks = function(values) {
	            for(var k = 0, l = select.length; k < l; k++) {
	              var complete = 0;
	              for(var i = 0, j = hooks.length; i < j; i++) {
	                if(values[hooks[i]][select[k][KEY]] || values[hooks[i]][select[k][KEY]]===0) complete++;        
	              }
	              if(complete == hooks.length) return true;
	            }
	            return false;
	          }
	          
	          var findSelectedTime = function(iterator, findCB) {
	            var point = iterator();
	            if(point == null) return;
	            _this.model.marker.getFrame(timePoints[point], function(values) {
	              if(findEntityWithCompleteHooks(values)) {
	                findCB(point);
	              } else {
	                findSelectedTime(iterator, findCB);
	              }
	            });
	          }
	          
	          var promises = [];
	          
	          promises.push(new Promise());
	
	          //find startSelected time 
	          findSelectedTime(function(){
	            var max = timePoints.length;
	            var i = 0;
	            return function() {
	              return i < max ? i++ : null;
	            };
	          }(), function(point){
	            selectedEdgeTimes[0] = timePoints[point];
	            promises[0].resolve();
	          });
	          
	          promises.push(new Promise());
	          
	          //find endSelected time
	          findSelectedTime(function(){
	            var min = 0;
	            var i = timePoints.length - 1;
	            return function() {
	              return i >= 0 ? i-- : null;
	            };
	          }(), function(point){
	            selectedEdgeTimes[1] = timePoints[point];
	            promises[1].resolve();
	          });
	          
	          Promise.all(promises).then(function() {
	            //if another setSelectedLimits was started after this 
	            //then return without setup values
	            if(_setSelectedLimitsId != _this._setSelectedLimitsId) return;
	            _this.model.time.set(
	              {"startSelected": selectedEdgeTimes[0],"endSelected": selectedEdgeTimes[1]}, force);
	          });
	
	        },
	
	        updateSelectedStartLimiter: function() {
	          this.select.select('#clip-start').remove();
	          this.select.select(".selected-start").remove();
	          if(this.model.time.startSelected > this.model.time.start) {
	            this.select.append("clipPath")
	              .attr("id", "clip-start")
	              .append('rect')
	            this.select.append('path')
	              .attr("clip-path", "url(" + location.pathname + "#clip-start)")
	              .classed('selected-start', true);
	            this.resizeSelectedLimiters();
	          }    
	        },
	
	        updateSelectedEndLimiter: function() {
	          this.select.select('#clip-end').remove();
	          this.select.select(".selected-end").remove();
	          if(this.model.time.endSelected < this.model.time.end) {
	            this.select.append("clipPath")
	              .attr("id", "clip-end")
	              .append('rect')
	            this.select.append('path')
	              .attr("clip-path", "url(" + location.pathname + "#clip-end)")
	              .classed('selected-end', true);
	            this.resizeSelectedLimiters();
	          }              
	        },
	
	        resizeSelectedLimiters: function() {
	          this.select.select('.selected-start')              
	            .attr('d', "M0,0H" + this.xScale(this.model.time.startSelected));
	          this.select.select("#clip-start").select('rect')
	            .attr("x", -this.height / 2)
	            .attr("y", -this.height / 2)
	            .attr("height", this.height)
	            .attr("width", this.xScale(this.model.time.startSelected) + this.height / 2);
	          this.select.select('.selected-end')              
	            .attr('d', "M" + this.xScale(this.model.time.endSelected) + ",0H" + this.xScale(this.model.time.end));
	          this.select.select("#clip-end").select('rect')
	            .attr("x", this.xScale(this.model.time.endSelected))
	            .attr("y", -this.height / 2)
	            .attr("height", this.height)
	            .attr("width", this.xScale(this.model.time.end) - this.xScale(this.model.time.endSelected) + this.height / 2);
	        },
	        
	
	        /**
	         * Returns width of slider text value.
	         * Parameters in this function needed for memoize function, so they are not redundant.
	         */
	        getValueWidth: function(layout, value) {
	          return this.valueText.node().getBoundingClientRect().width;
	        },
	
	        /**
	         * Gets brushed function to be executed when dragging
	         * @returns {Function} brushed function
	         */
	        _getBrushed: function() {
	          var _this = this;
	          return function() {
	
	            if (_this.model.time.playing)
	              _this.model.time.pause();
	
	            _this._optionClasses();
	            _this.element.classed(class_dragging, true);
	
	            var value = _this.brush.extent()[0];
	
	            //set brushed properties
	
	            if(d3.event.sourceEvent) {
	              // Prevent window scrolling on cursor drag in Chrome/Chromium.
	              d3.event.sourceEvent.preventDefault();
	
	              _this.model.time.dragStart();
	              var posX = roundStep(Math.round(d3.mouse(this)[0]), precision);
	              value = _this.xScale.invert(posX);
	              var maxPosX = _this.width;
	
	              if(posX > maxPosX) {
	                posX = maxPosX;
	              } else if(posX < 0) {
	                posX = 0;
	              }
	
	              //set handle position
	              _this.handle.attr("cx", posX);
	              _this.valueText.attr("transform", "translate(" + posX + "," + (_this.height / 2) + ")");
	              _this.valueText.text(_this.model.time.timeFormat(value));
	            }
	
	            //set time according to dragged position
	            if(value - _this.model.time.value !== 0) {
	              _this._setTime(value);
	            }
	          };
	        },
	
	        /**
	         * Gets brushedEnd function to be executed when dragging ends
	         * @returns {Function} brushedEnd function
	         */
	        _getBrushedEnd: function() {
	          var _this = this;
	          return function() {
	            _this._setTime.recallLast();
	            _this.element.classed(class_dragging, false);
	            _this.model.time.dragStop();
	            _this.model.time.snap();
	          };
	        },
	
	        /**
	         * Sets the handle to the correct position
	         * @param {Boolean} transition whether to use transition or not
	         */
	        _setHandle: function(transition) {
	          var _this = this;
	          var value = this.model.time.value;
	          this.slide.call(this.brush.extent([value, value]));
	            
	          this.element.classed("vzb-ts-disabled", this.model.time.end <= this.model.time.start);
	      //    this.valueText.text(this.model.time.timeFormat(value));
	
	      //    var old_pos = this.handle.attr("cx");
	          var new_pos = this.xScale(value);
	          if(_this.prevPosition == null) _this.prevPosition = new_pos;
	          var delayAnimations = new_pos > _this.prevPosition ? this.model.time.delayAnimations : 0;
	          if(transition) {
	            this.handle.attr("cx", _this.prevPosition)
	              .transition()
	              .duration(delayAnimations)
	              .ease("linear")
	              .attr("cx", new_pos);
	
	            this.valueText.attr("transform", "translate(" + _this.prevPosition + "," + (this.height / 2) + ")")
	              .transition('text')
	              .delay(delayAnimations)
	              .text(this.model.time.timeFormat(value));
	            this.valueText
	              .transition()
	              .duration(delayAnimations)
	              .ease("linear")
	              .attr("transform", "translate(" + new_pos + "," + (this.height / 2) + ")");
	          } else {
	            this.handle
	              //cancel active transition
	              .interrupt()
	              .attr("cx", new_pos);
	
	            this.valueText
	              //cancel active transition
	              .interrupt()
	              .interrupt('text')
	              .transition('text');
	            this.valueText
	              .attr("transform", "translate(" + new_pos + "," + (this.height / 2) + ")")
	              .text(this.model.time.timeFormat(value));
	          }
	          _this.prevPosition = new_pos;
	
	        },
	
	        /**
	         * Sets the current time model to time
	         * @param {number} time The time
	         */
	        _setTime: function(time) {
	          //update state
	          var _this = this;
	          //  frameRate = 50;
	
	          //avoid updating more than once in "frameRate"
	          //var now = new Date();
	          //if (this._updTime != null && now - this._updTime < frameRate) return;
	          //this._updTime = now;
	          var persistent = !this.model.time.dragging && !this.model.time.playing;
	          _this.model.time.getModelObject('value').set(time, false, persistent); // non persistent
	        },
	
	
	        /**
	         * Applies some classes to the element according to options
	         */
	        _optionClasses: function() {
	          //show/hide classes
	
	          var show_limits = this.ui.show_limits;
	          var show_value = this.ui.show_value;
	          var show_value_when_drag_play = this.ui.show_value_when_drag_play;
	          var axis_aligned = this.ui.axis_aligned;
	          var show_play = (this.ui.show_button) && (this.model.time.playable);
	
	          if(!show_limits) {
	            this.xAxis.tickValues([]).ticks(0);
	          }
	
	          this.element.classed(class_hide_play, !show_play);
	          this.element.classed(class_playing, this.model.time.playing);
	          this.element.classed(class_show_value, show_value);
	          this.element.classed(class_show_value_when_drag_play, show_value_when_drag_play);
	          this.element.classed(class_axis_aligned, axis_aligned);
	        }
	      });
	
	      var MENU_HORIZONTAL = 1;
	      var MENU_VERTICAL = 2;
	
	      //css custom classes
	      var css = {
	        wrapper: 'vzb-treemenu-wrap',
	        wrapper_outer: 'vzb-treemenu-wrap-outer',
	        background: 'vzb-treemenu-background',
	        close: 'vzb-treemenu-close',
	        search: 'vzb-treemenu-search',
	        list: 'vzb-treemenu-list',
	        list_outer: 'vzb-treemenu-list-outer',
	        list_item: 'vzb-treemenu-list-item',
	        list_item_leaf: 'vzb-treemenu-list-item-leaf',
	        leaf: 'vzb-treemenu-leaf',
	        leaf_content: 'vzb-treemenu-leaf-content',
	        leaf_content_item: 'vzb-treemenu-leaf-content-item',
	        leaf_content_item_title: 'vzb-treemenu-leaf-content-item-title',
	        leaf_content_item_descr: 'vzb-treemenu-leaf-content-item-descr',
	        hasChild: 'vzb-treemenu-list-item-children',
	        list_item_label: 'vzb-treemenu-list-item-label',
	        list_top_level: 'vzb-treemenu-list-top',
	        search_wrap: 'vzb-treemenu-search-wrap',
	        isSpecial: 'vzb-treemenu-list-item-special',
	        hidden: 'vzb-hidden',
	        title: 'vzb-treemenu-title',
	        scaletypes: 'vzb-treemenu-scaletypes',
	        scaletypesDisabled: 'vzb-treemenu-scaletypes-disabled',
	        scaletypesActive: 'vzb-treemenu-scaletypes-active',
	        alignYt: 'vzb-align-y-top',
	        alignYb: 'vzb-align-y-bottom',
	        alignXl: 'vzb-align-x-left',
	        alignXr: 'vzb-align-x-right',
	        alignXc: 'vzb-align-x-center',
	        menuHorizontal: 'vzb-treemenu-horizontal',
	        menuVertical: 'vzb-treemenu-vertical',
	        absPosVert: 'vzb-treemenu-abs-pos-vert',
	        absPosHoriz: 'vzb-treemenu-abs-pos-horiz',
	        menuOpenLeftSide: 'vzb-treemenu-open-left-side',
	        noTransition: 'notransition'
	      };
	
	      //options and globals
	      var OPTIONS$3 = {
	        MOUSE_LOCS: [], //contains last locations of mouse
	        MOUSE_LOCS_TRACKED: 3, //max number of locations of mouse
	        DELAY: 200, //amazons multilevel delay
	        TOLERANCE: 150, //this parameter is used for controlling the angle of multilevel dropdown
	        LAST_DELAY_LOC: null, //this is cached location of mouse, when was a delay
	        TIMEOUT: null, //timeout id
	        SEARCH_PROPERTY: 'id', //property in input data we we'll search by
	        SUBMENUS: 'children', //property for submenus (used by search)
	        SEARCH_MIN_STR: 1, //minimal length of query string to start searching
	        RESIZE_TIMEOUT: null, //container resize timeout
	        MOBILE_BREAKPOINT: 400, //mobile breakpoint
	        CURRENT_PATH: [], //current active path
	        MIN_COL_WIDTH: 60, //minimal column size
	        MENU_DIRECTION: MENU_HORIZONTAL,
	        MAX_MENU_WIDTH: 320,
	        MENU_OPEN_LEFTSIDE: false
	      };
	
	      var Menu = Class.extend({
	        init: function (parent, menu) {
	          var _this = this;
	          this.parent = parent;
	          this.entity = menu;
	          this.width = OPTIONS$3.MIN_COL_WIDTH;
	          this.direction = OPTIONS$3.MENU_DIRECTION;
	          this._setDirectionClass();
	          this.menuItems = [];
	          var menuItemsHolder;
	          
	          if(this.entity.empty()) return this;
	
	          this.entity.each(function() {
	            menuItemsHolder = d3.selectAll(this.childNodes).filter(function() {
	              return d3.select(this).classed(css.list);
	            });
	          });
	          if(menuItemsHolder.empty()) menuItemsHolder = this.entity;
	          menu.selectAll('.' + css.list_item)
	            .filter(function() {
	              return this.parentNode == menuItemsHolder.node();
	            })
	            .each(function() {
	              _this.addSubmenu(d3.select(this));
	            });
	          return this;
	        },
	        setWidth: function(width, recursive, immediate) {
	          if (this.width != width && this.entity.node()) {
	            this.width = width;
	            if ((this.entity.classed(css.list_top_level) || this.entity.classed('active')) && this.direction == MENU_HORIZONTAL) {
	              if(!immediate) {
	                this.entity.transition()
	                  .delay(0)
	                  .duration(100)
	                  .style('width', this.width + "px")
	              } else {
	                this.entity.style('width', this.width + "px");
	              }
	            }
	            if (this.entity.classed(css.list_top_level)) {
	              this.entity.selectAll('.' + css.leaf).style('width', this.width - 1 + "px");
	            }
	            if (recursive) {
	              for (var i = 0; i < this.menuItems.length; i++) {
	                this.menuItems[i].setWidth(this.width, recursive, immediate);
	              }
	            }
	            return this;
	          }
	        },
	        /**
	         * configure menu type (horizontal or vertical)
	         * @param direction MENU_HORIZONTAL or MENU_VERTICAL
	         * @param recursive change direction over menu sublevels
	         * @returns {Menu}
	         */
	        setDirection: function(direction, recursive) {
	          this.direction = direction;
	          this.entity
	            .style('width', '')
	            .style('height', '');
	          if (recursive) {
	            for (var i = 0; i < this.menuItems.length; i++) {
	              this.menuItems[i].setDirection(this.direction, recursive);
	            }
	          }
	          this._setDirectionClass();
	          return this;
	        },
	        _setDirectionClass: function() {
	          if (this.direction == MENU_HORIZONTAL) {
	            this.entity.classed(css.menuVertical, false);
	            this.entity.classed(css.menuHorizontal, true);
	          } else {
	            this.entity.classed(css.menuHorizontal, false);
	            this.entity.classed(css.menuVertical, true);
	          }
	        },
	        addSubmenu: function(item) {
	          this.menuItems.push(new MenuItem(this, item))
	        },
	        open: function() {
	          var _this = this;
	          if (!this.isActive()) {
	            _this.parent.parentMenu.openSubmenuNow = true;
	            this.closeNeighbors(function() {
	              if (_this.direction == MENU_HORIZONTAL) {
	                _this._openHorizontal();
	                _this.calculateMissingWidth(0);
	              } else {
	                _this._openVertical();
	              }
	            });
	            _this.parent.parentMenu.openSubmenuNow = false;      
	          }
	          return this;
	        },
	        /**
	         * recursively calculate missed width for last menu level
	         * @param width
	         * @param cb
	         */
	        calculateMissingWidth: function(width, cb) {
	          var _this = this;
	          if (this.entity.classed(css.list_top_level)) {
	            if (width > OPTIONS$3.MAX_MENU_WIDTH) {
	              if (typeof cb === "function") cb(width - OPTIONS$3.MAX_MENU_WIDTH);
	            }
	          } else {
	            this.parent.parentMenu.calculateMissingWidth(width + this.width, function(widthToReduce) {
	              if (widthToReduce > 0) {
	                _this.reduceWidth(widthToReduce, function(newWidth) {
	                  if (typeof cb === "function") cb(newWidth); // callback is not defined if it is emitted from this level
	                });
	              } else if (typeof cb === "function") cb(widthToReduce);
	            });
	          }
	        },
	        /**
	         * restore width (if it was reduced before)
	         * @param width
	         * @param isClosedElement (parameter for check if curent element emit this action)
	         * @param cb
	         */
	        restoreWidth: function(width, isClosedElement, cb) {
	          var _this = this;
	          if (isClosedElement) {
	            this.parent.parentMenu.restoreWidth(width, false, cb);
	          } else if (width <= 0) {
	            if (typeof cb === "function") cb();
	          } else if (!this.entity.classed(css.list_top_level)) {
	            var currentElementWidth =  this.entity.node().offsetWidth;
	            var newElementWidth = Math.min(width, _this.width);
	            if (currentElementWidth < newElementWidth) {
	              var duration = 250*(currentElementWidth / newElementWidth);
	              this.entity.transition()
	                .delay(0)
	                .duration(duration)
	                .style('width', newElementWidth + "px")
	                .each('end', function() {
	                });
	              _this.parent.parentMenu.restoreWidth(width - newElementWidth, false, cb);
	            } else {
	              this.parent.parentMenu.restoreWidth(width, false, cb);
	            }
	          } else {
	            if (typeof cb === "function") cb();
	          }
	        },
	        /**
	         * made element narrower to free space for other element
	         * @param width
	         * @param cb
	         */
	        reduceWidth: function(width, cb) {
	          var _this = this;
	          var currWidth = this.entity.node().offsetWidth;
	
	          if (currWidth <= OPTIONS$3.MIN_COL_WIDTH) {
	            cb(width - _this.width + currWidth);
	          } else {
	
	            var newElementWidth = Math.max(OPTIONS$3.MIN_COL_WIDTH, _this.width - width);
	            var duration = 250 / (_this.width / newElementWidth);
	            this.entity.transition()
	              .delay(0)
	              .duration(duration)
	              .style('width', newElementWidth + "px")
	              .each('end', function() {
	                cb(width - _this.width + newElementWidth);
	              });
	          }
	        },
	        _openHorizontal: function() {
	          var _this = this;
	          _this.entity.classed('active', true)
	            .transition()
	            .delay(0)
	            .duration(250)
	            .style('width', _this.width + "px")
	            .each('end', function() {
	              _this.marqueeToggle(true);
	            });
	        },
	        _openVertical: function() {
	          var _this = this;
	          _this.entity.style('height','0px');
	          _this.entity.transition()
	            .delay(0)
	            .duration(250)
	            .style('height', (36 * _this.menuItems.length) + "px")
	            .each('end', function() {
	              _this.entity.style('height', 'auto');
	              _this.marqueeToggle(true);
	              _this.scrollToFitView();
	            });
	          _this.entity.classed('active', true);
	        },
	        closeAllChildren: function(cb) {
	          var callbacks = 0;
	          for (var i = 0; i < this.menuItems.length; i++) {
	            if (this.menuItems[i].isActive()) {
	              ++callbacks;
	              this.menuItems[i].submenu.close(function() {
	                if (--callbacks == 0) {
	                  if (typeof cb === "function") cb();
	                }
	              });
	            }
	          }
	          if (callbacks == 0) {
	            if (typeof cb === "function") cb();
	          }
	        },
	        closeNeighbors: function(cb) {
	          if (this.parent) {
	            this.parent.closeNeighbors(cb);
	          } else {
	            cb();
	          }
	        },
	        close: function(cb) {
	          var _this = this;
	          this.closeAllChildren(function() {
	            if (_this.direction == MENU_HORIZONTAL) {
	              _this._closeHorizontal(cb);
	            } else {
	              _this._closeVertical(cb);
	            }
	          })
	        },
	        _closeHorizontal: function(cb) {
	          var elementWidth = this.entity.node().offsetWidth;
	          var _this = this;
	          var openSubmenuNow = _this.parent.parentMenu.openSubmenuNow;
	          _this.entity.transition()
	            .delay(0)
	            .duration(20)
	            .style('width', 0 + "px")
	            .each('end', function() {
	              _this.marqueeToggle(false);
	              _this.entity.classed('active', false);
	              if(!openSubmenuNow) {
	                _this.restoreWidth(OPTIONS$3.MAX_MENU_WIDTH, true, function() {
	                  if (typeof cb === "function") cb();
	                });
	              } else {
	                if (typeof cb === "function") cb();
	              }
	            });
	        },
	        _closeVertical: function(cb) {
	          var _this = this;
	          _this.entity
	            .transition()
	            .delay(0)
	            .duration(100)
	            .style('height', 0 + "px")
	            .each('end', function() {
	              _this.marqueeToggle(false);
	              _this.entity.classed('active', false);
	              if (typeof cb === "function") cb();
	            });
	        },
	        isActive: function() {
	          return this.entity.classed('active');
	        },
	        marqueeToggle: function(toggle) {
	          for (var i = 0; i < this.menuItems.length; i++) {
	            this.menuItems[i].marqueeToggle(toggle);
	          }
	        },
	        marqueeToggleAll: function(toggle) {
	          for (var i = 0; i < this.menuItems.length; i++) {
	            this.menuItems[i].marqueeToggleAll(toggle);
	          }
	        },
	        findItemByName: function(name) {
	          for (var i = 0; i < this.menuItems.length; i++) {
	            if(this.menuItems[i].entity.select('.' + css.list_item_label).text() == name) {
	              return this.menuItems[i];
	            }
	            if(this.menuItems[i].submenu) {
	              var item = this.menuItems[i].submenu.findItemByName(name);
	              if(item) return item;
	            }
	          }
	          return null;
	        },
	        getTopMenu: function() {
	          if (this.parent) {
	            return this.parent.parentMenu.getTopMenu();
	          } else {
	            return this;
	          }
	        },
	
	        scrollToFitView: function() {
	          var treeMenuNode = this.getTopMenu().entity.node().parentNode;
	          var parentItemNode = this.entity.node().parentNode;
	          var menuRect = treeMenuNode.getBoundingClientRect();
	          var itemRect = parentItemNode.getBoundingClientRect();
	          var viewportItemTop = itemRect.top - menuRect.top;
	          if (viewportItemTop + itemRect.height > menuRect.height) {
	            var newItemTop = (itemRect.height > menuRect.height) ?
	              (menuRect.height - 10) : (itemRect.height + 10);
	
	            var newScrollTop = treeMenuNode.scrollTop + newItemTop - menuRect.height + viewportItemTop;     
	
	            var scrollTopTween = function(scrollTop) {
	              return function() {
	                var i = d3.interpolateNumber(this.scrollTop, scrollTop);
	                return function(t) { this.scrollTop = i(t); };
	              };
	            }
	
	            d3.select(treeMenuNode).transition().duration(20)
	            .tween("scrolltoptween", scrollTopTween(newScrollTop));
	            
	            //treeMenuNode.scrollTop = scrollTop;
	          }
	
	        }
	
	      });
	
	      var MenuItem = Class.extend({
	        init: function (parent, item) {
	          var _this = this;
	          this.parentMenu = parent;
	          this.entity = item;
	          var submenu = item.select('.' + css.list_outer);
	          if (submenu.node()) {
	            this.submenu = new Menu(this, submenu);
	          }
	          var label = this.entity.select('.' + css.list_item_label).on('mouseenter', function() {
	            if(isTouchDevice()) return;
	            if (_this.parentMenu.direction == MENU_HORIZONTAL) {
	              _this.openSubmenu();
	              _this.marqueeToggle(true);
	            }
	          }).on('click.item', function() {
	            if(isTouchDevice()) return;
	            d3.event.stopPropagation();
	            if(_this.parentMenu.direction == MENU_HORIZONTAL) {
	              _this.openSubmenu();
	            } else {
	              var view = d3.select(this);
	              //only for leaf nodes
	              if(!view.attr("children")) return;
	              _this.toggleSubmenu();
	            }
	          }).onTap(function(evt) {
	            d3.event.stopPropagation();
	            if(_this.parentMenu.direction == MENU_VERTICAL) {
	              var view = _this.entity.select('.' + css.list_item_label);
	              //only for leaf nodes
	              if(!view.attr("children")) return;
	            }
	            _this.toggleSubmenu();
	          });
	          return this;
	        },
	        setWidth: function(width, recursive, immediate) {
	          if (this.submenu && recursive) {
	            this.submenu.setWidth(width, recursive, immediate);
	          }
	          return this;
	        },
	        setDirection: function(direction, recursive) {
	          if (this.submenu && recursive) {
	            this.submenu.setDirection(direction, recursive);
	          }
	          return this;
	        },
	        toggleSubmenu: function() {
	          if (this.submenu) {
	            if (this.submenu.isActive()) {
	              this.submenu.close();
	            } else {
	              this.submenu.open();
	            }
	          }
	        },
	        openSubmenu: function() {
	          if (this.submenu) {
	            this.submenu.open();
	          } else {
	            this.closeNeighbors();
	          }
	        },
	        closeNeighbors: function(cb) {
	          this.parentMenu.closeAllChildren(cb);
	        },
	        isActive: function() {
	          return this.submenu && this.submenu.isActive();
	        },
	        marqueeToggleAll: function(toggle) {
	          var _this = this;
	          var labels = this.entity.selectAll('.' + css.list_item_label);
	          labels.each(function() {
	            var label = d3.select(this).select('span');
	            var parent = d3.select(this.parentNode);
	            parent.classed('marquee', false);
	            label.style("left", '');
	            if(toggle) {
	              if(label.node().scrollWidth > label.node().offsetWidth) {
	                label.attr("data-content", label.text());
	                var space = 30;
	                label.style("left", (-space - label.node().scrollWidth) + 'px');
	                parent.classed('marquee', true);
	              }
	            }
	          });
	        },
	        marqueeToggle: function(toggle) {
	          var label = this.entity.select('.' + css.list_item_label).select('span');
	          this.entity.classed('marquee', false);
	          label.style("left", '');
	          if(toggle) {
	            if(label.node().scrollWidth > label.node().offsetWidth) {
	              label.attr("data-content", label.text());
	              var space = 30;
	              label.style("left", (-space - label.node().scrollWidth) + 'px');
	              this.entity.classed('marquee', true);
	            }
	          }
	        }
	      });
	
	      //default callback
	      var callback = function(indicator) {
	        console.log("Indicator selector: stub callback fired. New indicator is ", indicator);
	      };
	
	      var tree;
	      var langStrings;
	      var lang;
	      var markerID;
	      var alignX = "center";
	      var alignY = "center";
	      var top$1;
	      var left$1;
	      var selectedNode;
	
	      var TreeMenu = Component.extend({
	
	        //setters-getters
	        tree: function(input) {
	          if(!arguments.length) return tree;
	          tree = input;
	          return this;
	        },
	        lang: function(input) {
	          if(!arguments.length) return lang;
	          lang = input;
	          return this;
	        },
	        langStrings: function(input) {
	          if(!arguments.length) return langStrings;
	          langStrings = input;
	          return this;
	        },
	        callback: function(input) {
	          if(!arguments.length) return callback;
	          callback = input;
	          return this;
	        },
	        markerID: function(input) {
	          if(!arguments.length) return markerID;
	          markerID = input;
	          return this;
	        },
	        alignX: function(input) {
	          if(!arguments.length) return alignX;
	          alignX = input;
	          return this;
	        },
	        alignY: function(input) {
	          if(!arguments.length) return alignY;
	          alignY = input;
	          return this;
	        },
	        top: function(input) {
	          if(!arguments.length) return top$1;
	          top$1 = input;
	          return this;
	        },
	        left: function(input) {
	          if(!arguments.length) return left$1;
	          left$1 = input;
	          return this;
	        },
	
	        init: function(config, context) {
	
	          var _this = this;
	
	          this.name = 'gapminder-treemenu';
	          this.model_expects = [{
	            name: "marker",
	            type: "model"
	          }, {
	              name: "language",
	              type: "language"
	            }];
	
	          this.context = context;
	          // object for manipulation with menu representation level
	          this.menuEntity = null;
	          this.model_binds = {
	            "change:marker": function(evt, path) {
	              if(path.indexOf(markerID + '.which')==-1 && path.indexOf(markerID + '.scaleType')==-1) return;
	              _this.updateView();
	            },
	            "change:language.strings": function(evt) {
	              _this.updateView();
	            }
	          };
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.ui = extend({
	            //...add properties here
	          }, this.ui);
	
	        },
	
	        ready: function() {
	          this.updateView();
	        },
	
	        readyOnce: function() {
	          //this function is only called once at start, when both DOM and this.model are ready
	          //this.element contains the view where you can append the menu
	          this.element = d3.select(this.placeholder);
	          //menu class private
	          var _this = this;
	
	          this.element.selectAll("div").remove();
	
	          //general markup
	
	          this.element.append("div")
	            .attr("class", css.background)
	            .on("click", function() {
	              d3.event.stopPropagation();
	              _this.toggle()
	            });
	
	          this.wrapperOuter = this.element
	            .append('div')
	            .classed(css.wrapper_outer, true)
	            .classed(css.noTransition, true);
	
	          this.wrapper = this.wrapperOuter
	            .append('div')
	            .classed(css.wrapper, true)
	            .classed(css.noTransition, true)
	            .classed("vzb-dialog-scrollable", true);
	
	          this.wrapper
	            .on("click", function() {
	              d3.event.stopPropagation();
	            })
	
	          this.wrapper.append("div")
	            .attr("class", css.close)
	            .html(iconClose)
	            .on("click", function() {
	              d3.event.stopPropagation();
	              _this.toggle()
	            })
	            .select("svg")
	            .attr("width", "0px")
	            .attr("height", "0px")
	            .attr("class", css.close + '-icon');
	
	          this.wrapper.append('div')
	            .classed(css.scaletypes, true)
	            .append('span');
	          this.wrapper.append('div')
	            .classed(css.title, true)
	            .append('span');
	
	          this.wrapper.append('div')
	            .classed(css.search_wrap, true)
	            .append('input')
	            .classed(css.search, true)
	            .attr('type', 'search')
	            .attr('id', css.search);
	
	
	          //init functions
	          d3.select('body').on('mousemove', _this._mousemoveDocument);
	          this.wrapper.on('mouseleave', function() {
	            //if(_this.menuEntity.direction != MENU_VERTICAL) _this.menuEntity.closeAllChildren();
	          });
	
	          _this._enableSearch();
	
	          _this.resize();
	        },
	
	        //happens on resizing of the container
	        resize: function() {
	          var _this = this;
	
	          this.profiles = {
	            "small": {
	              col_width: 200
	            },
	            "medium": {
	              col_width: 200
	            },
	            "large": {
	              col_width: 200
	            }
	          };
	
	          this.wrapper.classed(css.noTransition, true);
	          this.wrapper.node().scrollTop = 0;
	
	          this.activeProfile = this.profiles[this.getLayoutProfile()];
	          OPTIONS$3.IS_MOBILE = this.getLayoutProfile() === "small";
	
	          if (this.menuEntity) {
	            this.menuEntity.setWidth(this.activeProfile.col_width, true, true);
	
	            if (OPTIONS$3.IS_MOBILE) {
	              if (this.menuEntity.direction != MENU_VERTICAL) {
	                this.menuEntity.setDirection(MENU_VERTICAL, true);
	              }
	            } else {
	              if (this.menuEntity.direction != MENU_HORIZONTAL) {
	                this.menuEntity.setDirection(MENU_HORIZONTAL, true);
	              }
	            }
	          }
	
	          this.width = _this.element.node().offsetWidth;
	          this.height = _this.element.node().offsetHeight;
	          var rect = this.wrapperOuter.node().getBoundingClientRect();
	          var containerWidth = rect.width;
	          var containerHeight = rect.height;
	          if (containerWidth) {
	            if(OPTIONS$3.IS_MOBILE) {
	              this.clearPos();
	            } else {
	              if(top$1 || left$1) {
	                if(this.wrapperOuter.node().offsetTop < 10) {
	                  this.wrapperOuter.style('top', '10px');
	                }
	                if(this.height - _this.wrapperOuter.node().offsetTop - containerHeight < 0) {
	                  if(containerHeight > this.height) {
	                    containerHeight = this.height - 20;
	                  }
	                  this.wrapperOuter.style({'top' : (this.height - containerHeight - 10) + 'px', 'bottom' : 'auto'});
	                }
	                if(top$1) top$1 = _this.wrapperOuter.node().offsetTop;
	              }
	              
	              var maxHeight;
	              if(this.wrapperOuter.classed(css.alignYb)) {
	                maxHeight = this.wrapperOuter.node().offsetTop + this.wrapperOuter.node().offsetHeight;
	              } else {
	                maxHeight = this.height - this.wrapperOuter.node().offsetTop;
	              }
	              this.wrapper.style('max-height', (maxHeight - 10) + 'px');
	            
	              this.wrapperOuter.classed(css.alignXc, alignX === "center");
	              this.wrapperOuter.style("margin-left",alignX === "center"? "-" + containerWidth/2 + "px" : null);
	              if (alignX === "center") {
	                OPTIONS$3.MAX_MENU_WIDTH = this.width/2 - containerWidth * 0.5 - 10;
	              } else {
	                OPTIONS$3.MAX_MENU_WIDTH = this.width - this.wrapperOuter.node().offsetLeft - containerWidth - 10; // 10 - padding around wrapper
	              }
	
	              var minMenuWidth = this.activeProfile.col_width + OPTIONS$3.MIN_COL_WIDTH * 2;
	              var leftPos = this.wrapperOuter.node().offsetLeft;
	              OPTIONS$3.MENU_OPEN_LEFTSIDE = OPTIONS$3.MAX_MENU_WIDTH < minMenuWidth && leftPos > (OPTIONS$3.MAX_MENU_WIDTH + 10);
	              if(OPTIONS$3.MENU_OPEN_LEFTSIDE) {
	                if(leftPos <  (minMenuWidth + 10)) leftPos = (minMenuWidth + 10);
	                OPTIONS$3.MAX_MENU_WIDTH = leftPos - 10; // 10 - padding around wrapper        
	              } else {
	                if (OPTIONS$3.MAX_MENU_WIDTH < minMenuWidth) { 
	                  leftPos = leftPos - (minMenuWidth - OPTIONS$3.MAX_MENU_WIDTH);
	                  OPTIONS$3.MAX_MENU_WIDTH = minMenuWidth;
	                } 
	              }
	             
	              if(left$1) {
	                left$1 = leftPos;
	              } else {
	                if(leftPos != this.wrapperOuter.node().offsetLeft) {
	                  this.wrapperOuter.style({'left': 'auto', 'right': (this.width - leftPos - rect.width) + 'px'}); 
	                }
	              }
	              
	              if(left$1 || top$1) this.setPos();
	              
	              this.wrapperOuter.classed('vzb-treemenu-open-left-side', !OPTIONS$3.IS_MOBILE && OPTIONS$3.MENU_OPEN_LEFTSIDE);        
	            }
	          }
	
	          this.wrapper.node().offsetHeight;
	          this.wrapper.classed(css.noTransition, false);
	
	          return this;
	        },
	
	        toggle: function() {
	          var _this = this;
	          var hidden = !this.element.classed(css.hidden);
	          this.element.classed(css.hidden, hidden);
	
	          if(hidden) {
	            this.clearPos();
	            this.menuEntity.marqueeToggle(false);
	          } else {
	            if(top$1 || left$1) this.setPos();
	            this.resize();
	            this.scrollToSelected();
	          }
	
	          this.wrapper.classed(css.noTransition, hidden);
	
	          this.parent.components.forEach(function(c) {
	            if(c.name == "gapminder-dialogs") {
	              d3.select(c.placeholder.parentNode).classed("vzb-blur", !hidden);
	            } else
	              if(c.element.classed) {
	                c.element.classed("vzb-blur", c != _this && !hidden);
	              } else {
	                d3.select(c.element).classed("vzb-blur", c != _this && !hidden);
	              }
	          });
	
	          this.width = _this.element.node().offsetWidth;
	        },
	
	        scrollToSelected: function() {
	          var _this = this;
	          var scrollToItem = function(listNode, itemNode) {
	            listNode.scrollTop = 0;
	            var rect = listNode.getBoundingClientRect();
	            var itemRect = itemNode.getBoundingClientRect();
	            var scrollTop = itemRect.bottom - rect.top - listNode.offsetHeight + 10;
	            listNode.scrollTop = scrollTop;
	          }
	
	          if (this.menuEntity.direction == MENU_VERTICAL) {
	            scrollToItem(this.wrapper.node(), selectedNode);
	            _this.menuEntity.marqueeToggleAll(true);
	          } else {
	            var selectedItem = this.menuEntity.findItemByName(d3.select(selectedNode).select('span').text());
	            selectedItem.submenu.calculateMissingWidth(0, function() {
	              _this.menuEntity.marqueeToggleAll(true);
	            });
	
	            var parent = selectedNode;
	            var listNode;
	            while(!(hasClass(parent, css.list_top_level))) {
	              if(parent.tagName == 'LI') {
	                listNode = hasClass(parent.parentNode, css.list_top_level) ? parent.parentNode.parentNode : parent.parentNode;
	                scrollToItem(listNode , parent);
	              }
	              parent = parent.parentNode;
	            }
	          }
	        },
	
	        setPos: function() {
	          var rect = this.wrapperOuter.node().getBoundingClientRect();
	
	          if(top$1) {
	            this.wrapperOuter.style({'top': top$1 + 'px', 'bottom': 'auto'});
	            this.wrapperOuter.classed(css.absPosVert, top$1);
	          }
	          if(left$1) {
	            var right = this.element.node().offsetWidth - left$1 - rect.width;
	            right = right < 10 ? 10 : right;
	            this.wrapperOuter.style({'right': right + 'px', 'left': 'auto'});
	            this.wrapperOuter.classed(css.absPosHoriz, right);
	          }
	
	        },
	
	        clearPos: function() {
	          top$1 = '';
	          left$1 = '';
	          this.wrapperOuter.attr("style", "");
	          this.wrapperOuter.classed(css.absPosVert, '');
	          this.wrapperOuter.classed(css.absPosHoriz, '');
	          this.wrapperOuter.classed(css.menuOpenLeftSide, '');
	          this.wrapper.style('max-height', '');
	        },
	        //search listener
	        _enableSearch: function() {
	          var _this = this;
	
	          var input = this.wrapper.select('.' + css.search);
	
	          //it forms the array of possible queries
	          var getMatches = function(value) {
	            var matches = {
	              _id: 'root',
	              children: []
	            };
	
	            //translation integration
	            var translationMatch = function(value, data, i) {
	              var languageId = _this.model.language.id;
	
	              if(_this.langStrings()) {
	                var translate = _this.langStrings()[languageId]['indicator/' + data[i][OPTIONS$3.SEARCH_PROPERTY]] ||
	                  _this.langStrings()[languageId]['indicator' + '/' + _this.model.marker[markerID]._type + '/' + data[i][OPTIONS$3.SEARCH_PROPERTY]];
	                if(translate && translate.toLowerCase().indexOf(value.toLowerCase()) >= 0) return true;
	              };
	              return false;
	            };
	
	            var matching = function(data) {
	              for(var i = 0; i < data.length; i++) {
	                var match = false;
	                match =  translationMatch(value, data, i);
	                if(match) {
	                  matches.children.push(data[i]);
	                }
	                if(!match && data[i][OPTIONS$3.SUBMENUS]) {
	                  matching(data[i][OPTIONS$3.SUBMENUS]);
	                }
	              }
	            };
	            matching(_this.dataFiltered.children);
	            return matches;
	          };
	          
	          var searchValueNonEmpty = false;
	
	          var searchIt = debounce(function() {
	              var value = input.node().value;
	              
	              //Protection from unwanted IE11 input events.
	              //IE11 triggers an 'input' event when 'placeholder' attr is set to input element and
	              //on 'focusin' and on 'focusout', if nothing has been entered into the input.  
	              if(!searchValueNonEmpty && value == "") return;        
	              searchValueNonEmpty = value != "";
	
	              if(value.length >= OPTIONS$3.SEARCH_MIN_STR) {
	                _this.redraw(getMatches(value), true);  
	              } else {
	                _this.redraw();
	              }
	            }, 250);
	
	          input.on('input', searchIt);
	        },
	
	        _selectIndicator: function(value) {
	          callback("which", value, markerID);
	          this.toggle();
	        },
	
	
	        //function is redrawing data and built structure
	        redraw: function(data, useDataFiltered) {
	          var _this = this;
	
	          var dataFiltered;
	          
	          var indicatorsDB = _this.model.marker.getConceptprops();
	
	          var hookType = _this.model.marker[markerID]._type;
	
	          if(useDataFiltered) {
	            dataFiltered = data;
	          } else {
	            if(data == null) data = tree;
	
	            var allowedIDs = keys(indicatorsDB).filter(function(f) {
	              //check if indicator is denied to show with allow->names->!indicator
	              if(_this.model.marker[markerID].allow && _this.model.marker[markerID].allow.names
	                && _this.model.marker[markerID].allow.names.indexOf('!' + f) != -1) return false;
	              //keep indicator if nothing is specified in tool properties
	              if(!_this.model.marker[markerID].allow || !_this.model.marker[markerID].allow.scales) return true;
	              //keep indicator if any scale is allowed in tool properties
	              if(_this.model.marker[markerID].allow.scales[0] == "*") return true;
	
	              // if no scales defined, all are allowed
	              if (!indicatorsDB[f].scales) return true
	
	              //check if there is an intersection between the allowed tool scale types and the ones of indicator
	              for(var i = indicatorsDB[f].scales.length - 1; i >= 0; i--) {
	                if(_this.model.marker[markerID].allow.scales.indexOf(indicatorsDB[f].scales[i]) > -1) return true;
	              }
	
	              return false;
	            })
	
	            dataFiltered = pruneTree(data, function(f) {
	              return allowedIDs.indexOf(f.id) > -1
	            });
	            
	            this.dataFiltered = dataFiltered;
	          }
	
	          this.wrapper.select('ul').remove();
	       
	          this.element.select('.' + css.title).select("span")
	            .text(this.translator("buttons/" + markerID));
	
	          this.element.select('.' + css.search)
	            .attr("placeholder", this.translator("placeholder/search") + "...");
	       
	          var createSubmeny = function(select, data, toplevel) {
	            if(!data.children) return;
	            var _select = toplevel ? select : select.append('div')
	              .classed(css.list_outer, true);
	
	            var li = _select.append('ul')
	              .classed(css.list, !toplevel)
	              .classed(css.list_top_level, toplevel)
	              .classed("vzb-dialog-scrollable", true)
	              .selectAll('li')
	              .data(data.children, function(d) {
	                return d['id'];
	              })
	              .enter()
	              .append('li');
	
	            li.append('span')
	              .classed(css.list_item_label, true)
	              // .attr("info", function(d) {
	              //   return d.id;
	              // })
	              .attr("children", function(d) {
	                return d.children ? "true" : null;
	              })
	              .on('click', function(d) {
	                var view = d3.select(this);
	                //only for leaf nodes
	                if(view.attr("children")) return;
	                d3.event.stopPropagation();
	                _this._selectIndicator(d.id);
	              })
	              .append('span')
	              .text(function(d) {
	                //Let the indicator "_default" in tree menu be translated differnetly for every hook type
	                var translated = _this.translator("indicator" + (d.id==="_default" ? "/" + hookType : "") + "/" + d.id);
	                if(translated.indexOf("indicator/")!==-1)warn("translation missing: " + translated);
	                return translated;
	              });
	            
	            li.classed(css.list_item, true)
	              .classed(css.hasChild, function(d) {
	                return d['children'];
	              })
	              .classed(css.isSpecial, function(d) {
	                return d['special'];
	              })
	              .each(function(d) {
	                var view = d3.select(this);
	
	                //deepLeaf
	                if(!d.children) {
	                  var deepLeaf = view.append('div').attr('class', css.menuHorizontal + ' ' + css.list_outer + ' ' + css.list_item_leaf);
	                  deepLeaf.on('click', function(d) {
	                    _this._selectIndicator(d.id);
	                  });
	                  var deepLeafContent = deepLeaf.append('div').classed(css.leaf + ' ' + css.leaf_content + " vzb-dialog-scrollable", true);
	                  deepLeafContent.append('span').classed(css.leaf_content_item + ' ' + css.leaf_content_item_title, true)
	                    .text(function(d) {
	                      //Let the indicator "_default" in tree menu be translated differnetly for every hook type
	                      var translated = _this.translator("indicator" + (d.id === "_default" ? "/" + hookType : "") + "/" + d.id);
	                      if(translated.indexOf("indicator/") !== -1) warn("translation missing: " + translated);
	                      return translated;
	                    });
	                  var hideUnits;
	                  var units = deepLeafContent.append('span').classed(css.leaf_content_item, true)
	                    .text(function(d) {
	                      //Let the indicator "_default" in tree menu be translated differnetly for every hook type
	                      var translated = _this.translator("unit" + (d.id==="_default" ? "/" + hookType : "") + "/" + d.id);
	                      hideUnits = translated.indexOf("unit/") !== -1 || translated === ''; 
	                      if(translated.indexOf("unit/") !== -1) warn("translation missing: " + translated);
	                      return _this.translator('hints/units') + ': ' + translated;
	                    });
	                  units.classed('vzb-hidden', hideUnits);
	                  var hideDescription;
	                  var description = deepLeafContent.append('span').classed(css.leaf_content_item + ' ' + css.leaf_content_item_descr, true)
	                    .text(function(d) {
	                      //Let the indicator "_default" in tree menu be translated differnetly for every hook type
	                      var translated = _this.translator("description" + (d.id === "_default" ? "/" + hookType : "") + "/" + d.id);
	                      hideDescription = translated.indexOf("description/") !== -1; 
	                      if(hideDescription) warn("translation missing: " + translated);
	                      return (hideUnits && hideDescription) ? _this.translator("hints/nodescr") : translated;
	                    });
	                  description.classed('vzb-hidden', hideDescription && !hideUnits);
	                }
	                
	                if(d.id == _this.model.marker[markerID].which) {
	                  var parent = this.parentNode;
	                  d3.select(this).classed('item-active', true)
	                    .select('.' + css.list_item_leaf).classed('active', true);
	                  while(!(hasClass(parent, css.list_top_level))) {
	                    if(parent.tagName == 'UL') {
	                      d3.select(parent.parentNode)
	                        .classed('active', true);
	                    }
	                    if(parent.tagName == 'LI') {
	                      d3.select(parent).classed('item-active', true);
	                    }
	                    parent = parent.parentNode;
	                  }
	                  selectedNode = this;
	                }
	                createSubmeny(view, d);
	              });
	          };
	          
	          if(OPTIONS$3.IS_MOBILE) {
	            OPTIONS$3.MENU_DIRECTION = MENU_VERTICAL;
	          } else {
	            OPTIONS$3.MENU_DIRECTION = MENU_HORIZONTAL;
	          }
	          createSubmeny(this.wrapper, dataFiltered, true);
	          this.menuEntity = new Menu(null, this.wrapper.selectAll('.' + css.list_top_level));
	          if(this.menuEntity) this.menuEntity.setDirection(OPTIONS$3.MENU_DIRECTION);
	          if(this.menuEntity) this.menuEntity.setWidth(this.activeProfile.col_width, true, true);
	          
	          if(!useDataFiltered) {
	            var pointer = "_default";
	            if(allowedIDs.indexOf(this.model.marker[markerID].which) > -1) pointer = this.model.marker[markerID].which;
	            if(!indicatorsDB[pointer].scales) {
	              this.element.select('.' + css.scaletypes).classed(css.hidden, true);
	              return true;
	            }
	            var scaleTypesData = indicatorsDB[pointer].scales.filter(function(f) {
	              if(!_this.model.marker[markerID].allow || !_this.model.marker[markerID].allow.scales) return true;
	              if(_this.model.marker[markerID].allow.scales[0] == "*") return true;
	              return _this.model.marker[markerID].allow.scales.indexOf(f) > -1;
	            });
	            if(scaleTypesData.length == 0) {
	              this.element.select('.' + css.scaletypes).classed(css.hidden, true);
	            } else {
	
	              var scaleTypes = this.element.select('.' + css.scaletypes).classed(css.hidden, false).selectAll("span")
	                  .data(scaleTypesData, function(d){return d});
	
	              scaleTypes.exit().remove();
	
	              scaleTypes.enter().append("span")
	                .on("click", function(d){
	                  d3.event.stopPropagation();
	                  _this._setModel("scaleType", d, markerID)
	                });
	
	              scaleTypes
	                .classed(css.scaletypesDisabled, scaleTypesData.length < 2)
	                .classed(css.scaletypesActive, function(d){
	                  return d == _this.model.marker[markerID].scaleType && scaleTypesData.length > 1;
	                })
	                .text(function(d){
	                  return _this.translator("scaletype/" + d);
	                });
	            }
	
	          }
	
	          return this;
	        },
	
	
	
	
	
	
	        updateView: function() {
	          var _this = this;
	          var languageID = _this.model.language.id;
	
	          if(!markerID) return;
	
	          this.wrapperOuter.classed(css.absPosVert, top$1);
	          this.wrapperOuter.classed(css.alignYt, alignY === "top");
	          this.wrapperOuter.classed(css.alignYb, alignY === "bottom");
	          this.wrapperOuter.classed(css.absPosHoriz, left$1);
	          this.wrapperOuter.classed(css.alignXl, alignX === "left");
	          this.wrapperOuter.classed(css.alignXr, alignX === "right");
	
	
	          var strings = langStrings ? langStrings : {};
	          strings[languageID] = _this.model.language.strings[languageID];
	
	          this.translator = this.model.language.getTFunction();
	
	          var setModel = this._setModel.bind(this);
	          this.langStrings(strings)
	            .lang(languageID)
	            .callback(setModel)
	            .tree(this.model.marker.getIndicatorsTree())
	            .redraw();
	
	          this.wrapper.select('.' + css.search).node().value = "";
	
	          return this;
	        },
	
	        _setModel: function(what, value, markerID) {
	
	          var indicatorsDB = this.model.marker.getConceptprops();
	
	          var mdl = this.model.marker[markerID];
	
	          var obj = {};
	
	          obj[what] = value;
	
	          if(what == "which") {
	            obj.use = indicatorsDB[value].use;
	
	            if(indicatorsDB[value].scales) {
	              obj.scaleType = indicatorsDB[value].scales[0];
	            }
	          }
	
	          if(mdl.getType() === 'axis' || mdl.getType() === 'size') {
	            obj.domainMin = null;
	            obj.domainMax = null;
	            obj.zoomedMin = null;
	            obj.zoomedMax = null;
	          }
	
	          mdl.set(obj);
	
	        }
	
	
	      });
	
	      /*!
	       * VIZABI OPTIONSBUTTONLIST
	       * Reusable optionsbuttonlist component
	       */
	
	      //default existing buttons
	      var class_active$3 = "vzb-active";
	      // var class_active_locked = "vzb-active-locked";
	      // var class_expand_dialog = "vzb-dialog-side";
	      // var class_hide_btn = "vzb-dialog-side-btn";
	      // var class_unavailable = "vzb-unavailable";
	      // var class_vzb_fullscreen = "vzb-force-fullscreen";
	      // var class_container_fullscreen = "vzb-container-fullscreen";
	
	      var ZoomButtonList = Component.extend({
	
	        /**
	         * Initializes the buttonlist
	         * @param config component configuration
	         * @param context component context (parent)
	         */
	        init: function(config, context) {
	
	          //set properties
	          var _this = this;
	          this.name = 'gapminder-zoombuttonlist';
	
	          this.model_expects = [{
	            name: "state",
	            type: "model"
	          }, {
	            name: "ui",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	          
	          this._available_buttons = {
	            'arrow': {
	              title: "buttons/cursorarrow",
	              icon: "cursorArrow",
	              func: this.toggleCursorMode.bind(this),
	              required: true,
	              statebind: "ui.cursorMode",
	              statebindfunc: this.setCursorMode.bind(this)
	            },
	            'plus': {
	              title: "buttons/cursorplus",
	              icon: "cursorPlus",
	              func: this.toggleCursorMode.bind(this),
	              required: true,
	              statebind: "ui.cursorMode",
	              statebindfunc: this.setCursorMode.bind(this)
	            },
	            'minus': {
	              title: "buttons/cursorminus",
	              icon: "cursorMinus",
	              func: this.toggleCursorMode.bind(this),
	              required: true,
	              statebind: "ui.cursorMode",
	              statebindfunc: this.setCursorMode.bind(this)
	            },
	            'hundredpercent': {
	              title: "buttons/hundredpercent",
	              icon: "hundredPercent",
	              func: this.toggleHundredPercent.bind(this),
	              required: true
	              // ,
	              // statebind: "ui.chart.trails",
	              // statebindfunc: this.setBubbleTrails.bind(this)
	            }
	          }
	          
	          this.model_binds = {};
	          
	          if(config.ui.cursorMode == undefined) {
	            config.ui.set('cursorMode', null, false, false);
	          }
	
	          Object.keys(this._available_buttons).forEach(function(buttonId) {
	            var button = _this._available_buttons[buttonId];
	            if(button && button.statebind) {
	              _this.model_binds['change:' + button.statebind] = function(evt) {
	                button.statebindfunc(buttonId, evt.source.value);
	              }
	            }
	          });
	
	          this._super(config, context);
	          
	        },
	        
	        readyOnce: function() {
	          var _this = this;
	          
	          this.element = d3.select(this.placeholder);
	          this.element.selectAll("div").remove();
	
	          this._addButtons(Object.keys(this._available_buttons), []);
	          this.setCursorMode('arrow');
	
	        },  
	           
	        /*
	         * adds buttons configuration to the components and template_data
	         * @param {Array} button_list list of buttons to be added
	         */
	        _addButtons: function(button_list, button_expand) {
	          var _this = this;
	          this._components_config = [];
	          var details_btns = [];
	          if(!button_list.length) return;
	          //add a component for each button
	          for(var i = 0; i < button_list.length; i++) {
	
	            var btn = button_list[i];
	            var btn_config = this._available_buttons[btn];
	
	            //add template data
	            var d = (btn_config) ? btn : "_default";
	            var details_btn = clone(this._available_buttons[d]);
	
	            details_btn.id = btn;
	            details_btn.icon = iconset[details_btn.icon];
	            details_btns.push(details_btn);
	          };
	
	          var t = this.getTranslationFunction(true);
	
	          this.element.selectAll('button').data(details_btns)
	            .enter().append("button")
	            .attr('class', function (d) {
	              var cls = 'vzb-buttonlist-btn';
	              if (button_expand.length > 0) {
	                if (button_expand.indexOf(d.id) > -1) {
	                  cls += ' vzb-dialog-side-btn';
	                }
	              }
	
	              return cls;
	            })
	            .attr('data-btn', function(d) {
	              return d.id;
	            })
	            .html(function(btn) {
	              return "<span class='vzb-buttonlist-btn-icon fa'>" +
	                btn.icon + "</span><span class='vzb-buttonlist-btn-title'>" +
	                t(btn.title) + "</span>";
	            });
	
	          var buttons = this.element.selectAll(".vzb-buttonlist-btn");
	
	          //clicking the button
	          buttons.on('click', function() {
	
	            d3.event.preventDefault();
	            d3.event.stopPropagation();
	            
	            var id = d3.select(this).attr("data-btn");
	            _this.proceedClick(id);
	          });
	
	        },
	        
	        proceedClick: function(id) {
	          var _this = this;
	          var btn = _this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']"),
	            classes = btn.attr("class"),
	            btn_config = _this._available_buttons[id];
	
	          if(btn_config && btn_config.func) {
	            btn_config.func(id);
	          } else {
	            var btn_active = classes.indexOf(class_active$3) === -1;
	
	            btn.classed(class_active$3, btn_active);
	            var evt = {};
	            evt['id'] = id;
	            evt['active'] = btn_active;
	            _this.trigger('click', evt);
	          }    
	        },
	        
	        setButtonActive: function(id, boolActive) {
	          var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
	
	          btn.classed(class_active$3, boolActive);
	        },
	        
	        toggleCursorMode: function(id) {
	          var value = id;
	          this.model.ui.set('cursorMode', value, false, false);
	        },
	        
	        setCursorMode: function(id) {
	          var value = this.model.ui.cursorMode ? this.model.ui.cursorMode : 'arrow';
	          this.element.selectAll(".vzb-buttonlist-btn")
	            .classed(class_active$3, function(d) {
	              return d.id == value;
	            }); 
	        },
	        
	        toggleHundredPercent: function(id) {
	          this.root.trigger("resetZoom");
	        }
	        
	      });
	
	      var _index$2 = {
	      bubblesize : BubbleSize,
	      buttonlist : ButtonList,
	      colorlegend : ColorLegend,
	      datanotes : DataNotes,
	      datawarning : DataWarning,
	      _dialog : Dialog,
	      dialogs : Dialogs,
	      draggablelist : DraggableList,
	      indicatorpicker : IndPicker,
	      labels : Labels,
	      minmaxinputs : MinMaxInputs,
	      simplecheckbox : simplecheckbox,
	      simpleslider : SimpleSlider,
	      sizeslider : SizeSlider,
	      timeslider : TimeSlider,
	      treemenu : TreeMenu,
	      zoombuttonlist : ZoomButtonList,
	      };
	
	var components = Object.freeze({
	      	bubblesize: BubbleSize,
	      	buttonlist: ButtonList,
	      	colorlegend: ColorLegend,
	      	datanotes: DataNotes,
	      	datawarning: DataWarning,
	      	_dialog: Dialog,
	      	dialogs: Dialogs,
	      	draggablelist: DraggableList,
	      	indicatorpicker: IndPicker,
	      	labels: Labels,
	      	minmaxinputs: MinMaxInputs,
	      	simplecheckbox: simplecheckbox,
	      	simpleslider: SimpleSlider,
	      	sizeslider: SizeSlider,
	      	timeslider: TimeSlider,
	      	treemenu: TreeMenu,
	      	zoombuttonlist: ZoomButtonList,
	      	default: _index$2
	      });
	
	      //  d3.scale.genericLog
	      function genericLog() {
	        return function d3_scale_genericLog(logScale) {
	          var _this = this;
	          var scales = [];
	          var domainParts = [];
	          var eps = 0.1;
	          var delta = 5;
	          var domain = logScale.domain();
	          var range = logScale.range();
	          var interpolator = null;
	          var rangePointingForward, domainPointingForward;
	
	          var abs = function (arg) {
	            if (arg instanceof Array)
	              return arg.map(function (d) {
	                return Math.abs(d);
	              });
	            return Math.abs(arg);
	          };
	
	          var _buildLinearScale = function(fakeDomain, fakeRange) {
	            return {
	              domain: fakeDomain,
	              sign: 1,
	              range: fakeRange,
	              scale: d3.scale.linear().domain(fakeDomain).range(fakeRange)
	            };
	          };
	
	          var _buildLogScale = function(fakeDomain, fakeRange, revertDomain) {
	            var normalizedDomain = fakeDomain;
	            //var normalizedRange = fakeRange.slice(0);
	            if (revertDomain) {
	              normalizedDomain = abs(fakeDomain);
	              //fakeRange.reverse();
	            }
	            return {
	              domain: fakeDomain,
	              sign: revertDomain?-1:1,
	              range: fakeRange,
	              scale: d3.scale.log().domain(normalizedDomain).range(fakeRange)
	            };
	          };
	
	
	          var buildScales = function () {
	            rangePointingForward = range[0] < range[range.length - 1];
	            var rangePointingSign = rangePointingForward ? 1 : -1;
	            scales = [];
	            if (domainParts.length == 1) {
	              if (domainParts[0][0] <= 0 && domainParts[0][1] >= 0) {
	                scales = [_buildLinearScale(domainParts[0], range)];
	              } else {
	                scales = [_buildLogScale(domainParts[0], range, domainParts[0][0] <= 0)];
	              }
	            } else {
	              var maxDomain = d3.max(abs(domain));
	              var rangeLength = abs(d3.max(range) - d3.min(range));
	              var minRangePoint, rangePointKoef = 1;
	              var firstRangePoint = 0, secondRangePoint = 0, firstEps = 0, secondEps = 0;
	              logScale.domain([eps, maxDomain]).range([0, rangeLength]);
	              minRangePoint = delta;//logScale(eps * 2);
	              if (domain[0] != 0 && abs(domain[0]) > eps)
	                firstRangePoint = logScale(abs(domain[0]));
	              if (domain[domain.length - 1] != 0  && abs(domain.length - 1) > eps)
	                secondRangePoint = logScale(abs(domain[domain.length - 1]));
	
	              if (abs(domain[0]) > eps)
	                firstEps = minRangePoint;
	
	              if (abs(domain[domain.length - 1]) > eps)
	                secondEps = minRangePoint;
	
	              rangeLength = rangeLength - firstEps - secondEps;
	              if (secondRangePoint != 0) rangePointKoef = abs((firstRangePoint) / (secondRangePoint));
	
	              var point1, point2;
	              if (domainParts.length == 2) {
	                // example: [-eps..0,eps][eps, val]
	                if (domain[0] == 0 || abs(domain[0]) <= eps) {
	                  point1 = range[0] + firstRangePoint * rangePointKoef * rangePointingSign
	                    + secondEps * rangePointingSign;
	                  scales = [
	                    _buildLinearScale(domainParts[0], [range[0], point1]),
	                    _buildLogScale(domainParts[1], [point1,  range[1]], !domainPointingForward)
	                  ];
	                } else if (domain[domain.length - 1] == 0 || abs(domain[domain.length - 1]) <= eps) {// example: [-val,-eps][-eps, 0..eps]
	                  point1 = range[range.length - 1] - (firstEps + secondEps) * rangePointKoef * rangePointingSign
	                  scales = [
	                    _buildLogScale(domainParts[0], [range[0], point1], domainPointingForward),
	                    _buildLinearScale(domainParts[1], [point1, range[range.length - 1]])
	                  ];
	                }
	              } else {
	                point1 = range[0] + rangeLength / (1/rangePointKoef + 1) * rangePointingSign;
	                point2 = range[0] + (rangeLength / (1/rangePointKoef + 1) + firstEps + secondEps) * rangePointingSign;
	                scales = [
	                  _buildLogScale(domainParts[0], [range[0], point1], domainPointingForward),
	                  _buildLinearScale(domainParts[1], [point1, point2]),
	                  _buildLogScale(domainParts[2], [point2, range[range.length - 1]], !domainPointingForward)
	                ];
	              }
	            }
	          };
	
	          var buildDomain = function () {
	            domainPointingForward = domain[0] < domain[domain.length - 1];
	            domainParts = [];
	            if ((d3.min(domain) > 0 && d3.max(domain) > 0) || (d3.min(domain) < 0 && d3.max(domain) < 0)) {
	              domainParts = [domain];
	            } else {
	              var start, end;
	              if (domainPointingForward) {
	                start = domain[0];
	                end = domain[domain.length - 1];
	              } else {
	                start = domain[domain.length - 1];
	                end = domain[0];
	              }
	              var _addSubdomain = function(first, second) {
	                if (domainPointingForward) {
	                  domainParts.push([first, second]);
	                } else {
	                  domainParts.unshift([second, first]);
	                }
	              };
	              while (start != end) {
	                if (end <= -eps || (start >= -eps && end <= eps) || start >= eps) {
	                  _addSubdomain(start, end);
	                  start = end;
	                } else if (start < -eps && end >= -eps) {
	                  _addSubdomain(start, -eps);
	                  start = -eps;
	                } else if (start >= -eps && end >= eps) {
	                  _addSubdomain(start, eps);
	                  start = eps;
	                } else {
	                  console.warn("Something wrong while build subdomains: " + start + " " + end);
	                  start = end;
	                }
	              }
	            }
	            buildScales();
	          };
	
	          var _getScaleByDomain = function(x) {
	            if (domainPointingForward) {
	              if (x < domain[0]) {
	                return scales[0];
	              } else if (x > domain[domain.length - 1]) {
	                return scales[scales.length - 1];
	              } else {
	                for (var i = 0; i < scales.length; i++) {
	                  if (x >= scales[i].domain[0] && x <= scales[i].domain[scales[i].domain.length - 1]) {
	                    return scales[i];
	                  }
	                }
	              }
	            } else {
	              if (x > domain[0]) {
	                return scales[0];
	              } else if (x < domain[domain.length - 1]) {
	                return scales[scales.length - 1];
	              } else {
	                for (var i = 0; i < scales.length; i++) {
	                  scale = scales[i];
	                  if (x <= scales[i].domain[0] && x >= scales[i].domain[scales[i].domain.length - 1]) {
	                    return scales[i];
	                  }
	                }
	              }
	            }
	          };
	
	          var getScaleByRange = function(x) {
	            if (rangePointingForward) {
	              if (x < range[0]) {
	                return scales[0];
	              } else if (x > range[range.length - 1]) {
	                return scales[scales.length - 1];
	              } else {
	                for (var i = 0; i < scales.length; i++) {
	                  if (x >= scales[i].range[0] && x <= scales[i].range[scales[i].range.length - 1]) {
	                    return scales[i];
	                  }
	                }
	              }
	            } else {
	              if (x > range[0]) {
	                return scales[0];
	              } else if (x < range[range.length - 1]) {
	                return scales[scales.length - 1];
	              } else {
	                for (var i = 0; i < scales.length; i++) {
	                  var scalePart = scales[i];
	                  if (x <= scales[i].range[0] && x >= scales[i].range[1]) {
	                    return scales[i];
	                  }
	                }
	              }
	            }
	          };
	
	          //polyfill for IE11
	          Math.sign = Math.sign || function (x) {
	              x = +x;
	              if (x === 0 || isNaN(x)) {
	                return x;
	              }
	              return x > 0 ? 1 : -1;
	            }
	
	          function scale(x) {
	            var currScale = _getScaleByDomain(x);
	            if (interpolator) {
	              return interpolator(currScale.scale(x * currScale.sign));
	            } else {
	              return currScale.scale(x * currScale.sign);
	            }
	          }
	
	          scale.eps = function(arg) {
	            if(!arguments.length)
	              return eps;
	            eps = arg;
	            scale.domain(domain);
	            return scale;
	          };
	
	          scale.delta = function(arg) {
	            if(!arguments.length)
	              return delta;
	            delta = arg;
	            scale.range(range);
	            return scale;
	          };
	
	          scale.domain = function(arg) {
	            if(!arguments.length)
	              return domain;
	            
	            // this is an internal array, it will be modified. the input _arg should stay intact
	            switch(arg.length) {
	              // if no values are given, reset input to the default domain (do nothing)
	              case 0:
	                arg = domain;
	                break;
	              // use the given value as a center, get the domain /2 and *2 around it
	              case 1:
	                arg = [
	                  arg[0] / 2,
	                  arg[0] * 2
	                ];
	                break;
	            }
	            //if the domain is just a single value
	            if(arg[0] == arg[arg.length - 1]) {
	              arg[0] = arg[0] / 2;
	              arg[arg.length - 1] = arg[arg.length - 1] * 2;
	            }
	            domain = arg;
	            var min = d3.min(abs(domain).filter(function(val){ return !!val}));
	            if (min) eps = Math.min(eps, min / 100);
	            buildDomain();
	            return scale;
	          };
	
	          
	          scale.range = function(arg, force) {
	            if(!arguments.length)
	              return range;
	
	            switch(arg.length) {
	              // reset input to the default range
	              case 0:
	                arg = range;
	                break;
	              // use the only value as a center, get the range ±100 around it
	              case 1:
	                arg = [
	                  arg[0] - 100,
	                  arg[0] + 100
	                ];
	                break;
	              // two is the standard case. do nothing
	            }
	
	            //console.log("LOG and LIN range:", logScale.range(), linScale.range());
	            if (interpolator && !force) {
	              interpolator.range(arg);
	            } else {
	              range = arg;
	              var min = d3.min(abs(range).filter(function(val){ return !!val}));
	
	              if (min) delta = Math.min(delta, min/100);
	              buildScales();
	            }
	            return scale;
	          };
	
	          scale.interpolate = function(arg) {
	            interpolator = d3.scale.linear().domain(domain).range(range).interpolate(arg);
	            scale.range(interpolator.domain(), true);
	            return scale;
	          };
	
	          scale.invert = function(arg) {
	            var currScale = getScaleByRange(arg);
	            return currScale.scale.invert(arg) * currScale.sign;
	          };
	
	          scale.ticks = function(arg) {
	            var ticks = [], partTicks;
	            for (var i = 0; i < scales.length; i++) {
	              if (scales[i].sign == -1) {
	                partTicks = scales[i].scale.ticks().reverse().map(function(val){ return val * -1 });
	              } else {
	                partTicks = scales[i].scale.ticks();
	              }
	              if (ticks.length > 0 && partTicks.length > 0 && ticks[ticks.length - 1] == partTicks[0]) {
	                partTicks.splice(0, 1);
	              }
	              ticks.push.apply(ticks, partTicks);
	            }
	            return ticks;
	          };
	
	          scale.copy = function() {
	            return d3_scale_genericLog(logScale).domain(domain).range(range).delta(delta).eps(eps);
	          };
	
	          return d3.rebind(scale, logScale, 'base', 'rangeRound', 'clamp', 'nice',
	            'tickFormat');
	        }(d3.scale.log().domain([0.1, 200]).range([0, 1000]));
	      };
	
	      function detectTouchEvent(element, onTap, onLongTap) {
	        var start;
	        var coordX;
	        var coordY;
	        var namespace = onTap ? '.onTap' : '.onLongTap';
	        d3.select(element)
	          .on('touchstart' + namespace, function(d, i) {
	            start = d3.event.timeStamp;
	            coordX = d3.event.changedTouches[0].screenX;
	            coordY = d3.event.changedTouches[0].screenY;
	          })
	          .on('touchend' + namespace, function(d, i) {
	            coordX = Math.abs(coordX - d3.event.changedTouches[0].screenX);
	            coordY = Math.abs(coordY - d3.event.changedTouches[0].screenY);
	            if(coordX < 5 && coordY < 5) {
	              if(d3.event.timeStamp - start < 500)
	                return onTap ? onTap(d, i) : undefined;
	              return onLongTap ? onLongTap(d, i) : undefined;
	            } else return undefined;
	          });
	      }
	
	      //d3.selection.prototype.onTap
	      var onTap = function(callback) {
	        return this.each(function() {
	          detectTouchEvent(this, callback);
	        })
	      };
	
	      //d3.selection.prototype.onLongTap
	      var onLongTap = function(callback) {
	        return this.each(function() {
	          detectTouchEvent(this, null, callback);
	        })
	      };
	
	      var Vzb = function(name, placeholder, external_model) {
	        var tool = Tool.get(name);
	        if(tool) {
	          var t = new tool(placeholder, external_model);
	          Vzb._instances[t._id] = t;
	          return t;
	        } else {
	          error$1('Tool "' + name + '" was not found.');
	        }
	      };
	
	      //stores reference to each tool on the page
	      Vzb._instances = {};
	      //stores global variables accessible by any tool or component
	      Vzb._globals = globals;
	
	      //TODO: clear all objects and intervals as well
	      //garbage collection
	      Vzb.clearInstances = function(id) {
	        if(id) {
	          Vzb._instances[id] = void 0;
	        } else {
	          for(var i in Vzb._instances) {
	            Vzb._instances[i].clear();
	          }
	          Vzb._instances = {};
	        }
	      };
	
	      //register available readers
	      forEach(readers, function(reader, name) {
	        Reader.register(name, reader);
	      });
	
	      //register available components
	      forEach(components, function(component, name) {
	        Component.register(name, component);
	      });
	
	
	      d3.scale.genericLog = genericLog;
	      d3.selection.prototype.onTap = onTap;
	      d3.selection.prototype.onLongTap = onLongTap;
	
	      //makes all objects accessible
	      Vzb.Tool = Tool;
	      Vzb.Component = Component;
	      Vzb.Model = Model;
	      Vzb.Reader = Reader;
	      Vzb.Events = EventSource;
	      Vzb.utils = utils;
	
	      var Trail = Class.extend({
	
	        init: function(context) {
	          this.context = context;
	          this._isCreated = null;
	          this.actionsQueue = {};
	          this.entityTrails = {};
	
	        },
	
	        toggle: function(arg) {
	          var _context = this.context;
	
	          if(arg) {
	            _context._trails.create();
	            _context._trails.run(["resize", "recolor", "opacityHandler", "findVisible", "reveal"]);
	          } else {
	            _context._trails.run("remove");
	            _context.model.entities.select.forEach(function(d) {
	              d.trailStartTime = null;
	            });
	          }
	        },
	
	        create: function(selection) {
	          var _context = this.context;
	          var _this = this;
	          var KEY = _context.KEY;
	          this._isCreated = new Promise(function(resolve, reject) {
	
	            //quit if the function is called accidentally
	            if(!_context.model.ui.chart.trails) return;
	
	            var timePoints = _context.model.time.getAllSteps();
	
	            //work with entities.select (all selected entities), if no particular selection is specified
	            var promises = [];
	            selection = selection == null ? _context.model.entities.select : [selection];
	            
	            var _trails = _context.bubbleContainer.selectAll('g.vzb-bc-entity')
	              .data(_context.model.entities.select, function(d) {
	                return(d[KEY]);
	              })
	              
	            _trails.exit().remove();
	        
	            _trails.enter()
	              .insert("g", function(d) { 
	                return this.querySelector(".bubble-" + d[KEY]);
	              })
	              .attr("class", function(d) { 
	                return "vzb-bc-entity trail-" + d[KEY];
	              })
	              .each(function(d, index) {
	                var defer = new Promise();
	                // used for prevent move trail start time forward when we have empty values at end of time range
	                d.firstAvailableSegment = null;
	                promises.push(defer);
	                var trailSegmentData = timePoints.map(function(m) {
	                  return {
	                    t: m,
	                    key: d[KEY]
	                  }
	                });
	                if (_this.entityTrails[d[KEY]]) {
	                   _this._remove(_this.entityTrails[d[KEY]], null, d);  
	                }
	                _this.entityTrails[d[KEY]] = d3.select(this).selectAll("g").data(trailSegmentData);
	                
	                _this.entityTrails[d[KEY]].exit().remove();
	                
	                _this.entityTrails[d[KEY]].enter().append("g")
	                  .attr("class", "vzb-bc-trailsegment")
	                  .on("mouseover", function(segment, index) {
	                    if(isTouchDevice()) return;
	
	                    var pointer = {};
	                    pointer[KEY] = segment.key;
	                    pointer.time = segment.t;
	
	                    _context._axisProjections(pointer);
	                    _context.labels.highlight(d, true);
	                    var text = _context.model.time.timeFormat(segment.t);
	                    var selectedData = find(_context.model.entities.select, function(f) {
	                      return f[KEY] == d[KEY]
	                    });
	                    _context.model.marker.getFrame(pointer.time, function(values) {
	                      var x = _context.xScale(values.axis_x[pointer[KEY]]);
	                      var y = _context.yScale(values.axis_y[pointer[KEY]]);
	                      var s = areaToRadius(_context.sScale(values.size[pointer[KEY]]));
	                      var c = values.color[pointer[KEY]]!=null?_context.cScale(values.color[pointer[KEY]]):_context.COLOR_WHITEISH;
	                      if(text !== selectedData.trailStartTime) {
	                        _context._setTooltip(text, x, y, s + 3, c);
	                      }
	                      _context._setBubbleCrown(x, y, s, c);
	                    });
	                    //change opacity to OPACITY_HIGHLT = 1.0;
	                    d3.select(this).style("opacity", 1.0);
	                  })
	                  .on("mouseout", function(segment, index) {
	                    if(isTouchDevice()) return;
	                    _context._axisProjections();
	                    _context._setTooltip();
	                    _context._setBubbleCrown();
	                    _context.labels.highlight(null, false);
	                    d3.select(this).style("opacity", _context.model.entities.opacityRegular);
	                  })
	                  .each(function(segment, index) {
	                    var view = d3.select(this);
	                    view.append("circle");
	                    view.append("line");
	                  });
	                defer.resolve();
	              });
	            if (promises.length > 0) {
	              Promise.all(promises).then(function (segments) {
	                resolve(true);
	              });
	            } else {
	              resolve(true);
	            }
	          });
	          return this._isCreated;
	        },
	
	        /**
	         * add actions for each selected entities
	         * @param selections
	         * @param actions
	         * @private
	         */
	        _addActions: function(selections, actions) {
	          var _context = this.context;
	          var _this = this;
	          var KEY = _context.KEY;
	
	          selections.forEach(function(d) {
	            if (!_this.actionsQueue[d[KEY]]) _this.actionsQueue[d[KEY]] = [];
	            _this.actionsQueue[d[KEY]] = [].concat(_this.actionsQueue[d[KEY]].filter(function(value) {
	              return actions.indexOf(value) == -1;
	            }), actions);
	          });
	        },
	        _getNextAction: function(key) {
	          return this.actionsQueue[key].shift();
	        },
	        
	        run: function(actions, selection, duration) {
	          var _context = this.context;
	          var _this = this;
	          var KEY = _context.KEY;
	          if (!this._isCreated || _context.model.time.splash) return;
	          this._isCreated.then(function() {
	            //quit if function is called accidentally
	            if((!_context.model.ui.chart.trails || !_context.model.entities.select.length) && actions != "remove") return;
	
	            if(!duration) duration = 0;
	
	            //work with entities.select (all selected entities), if no particular selection is specified
	            selection = selection == null ? _context.model.entities.select : [selection];
	            _this._addActions(selection, actions);
	            selection.forEach(function(d) {
	
	              var trail = _this.entityTrails[d[KEY]];
	              //do all the actions over "trail"
	              var executeSequential = function(index) { // some function can be async, but we should run next when previous completed
	                var action = _this._getNextAction(d[KEY]);
	                if (action) {
	                  var response = _context._trails["_" + action](trail, duration, d);
	                  if (response && response instanceof Promise) {
	                    response.then(function() {
	                      executeSequential(index + 1);
	                    })
	                  } else {
	                    executeSequential(index + 1);
	                  }
	                }
	              };
	              executeSequential(0);
	            });
	          });
	
	        },
	
	
	        _remove: function(trail, duration, d) {
	          this.actionsQueue[d[this.context.KEY]] = []; 
	          if (trail) { // TODO: in some reason run twice 
	            d3.select(this.entityTrails[d[this.context.KEY]].node().parentNode).remove();
	            this.entityTrails[d[this.context.KEY]] = null;
	          }
	        },
	
	        _resize: function(trail, duration, d) {
	          var _context = this.context;
	          if (_context.model.time.splash) {
	            return;
	          }
	      //    this._isCreated.then(function() {
	
	          trail.each(function(segment, index) {
	              
	            if(segment.valueY==null || segment.valueX==null || segment.valueS==null) return;
	
	            var view = d3.select(this);
	            view.select("circle")
	              //.transition().duration(duration).ease("linear")
	              .attr("cy", _context.yScale(segment.valueY))
	              .attr("cx", _context.xScale(segment.valueX))
	              .attr("r", areaToRadius(_context.sScale(segment.valueS)));
	
	            if(!this.nextSibling) return;
	            var next = d3.select(this.nextSibling).datum();
	            if(next == null) return;
	            if(next.valueY==null || next.valueX==null) return;
	              
	            var lineLength = Math.sqrt(
	                Math.pow(_context.xScale(segment.valueX) - _context.xScale(next.valueX),2) +
	                Math.pow(_context.yScale(segment.valueY) - _context.yScale(next.valueY),2)
	            );
	            view.select("line")
	              //.transition().duration(duration).ease("linear")
	              .attr("x1", _context.xScale(next.valueX))
	              .attr("y1", _context.yScale(next.valueY))
	              .attr("x2", _context.xScale(segment.valueX))
	              .attr("y2", _context.yScale(segment.valueY))
	              .style("stroke-dasharray", lineLength)
	              .style("stroke-dashoffset", areaToRadius(_context.sScale(segment.valueS)));
	          });
	        },
	
	        _recolor: function(trail, duration, d) {
	          var _context = this.context;
	
	          trail.each(function(segment, index) {
	
	            var view = d3.select(this);
	
	            var strokeColor = _context.model.marker.color.which == "geo.world_4region"?
	              //use predefined shades for color palette for "geo.world_4region" (hardcoded)
	              _context.model.marker.color.getColorShade({
	                colorID: segment.valueC,
	                shadeID: "shade"
	              })
	              :
	              //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)
	              (segment.valueC!=null?_context.cScale(segment.valueC):_context.COLOR_BLACKISH);
	
	            view.select("circle")
	              //.transition().duration(duration).ease("linear")
	              .style("fill", segment.valueC!=null?_context.cScale(segment.valueC):_context.COLOR_WHITEISH);
	            view.select("line")
	              //.transition().duration(duration).ease("linear")
	              .style("stroke", strokeColor);
	          });
	        },
	
	        _opacityHandler: function(trail, duration, d) {
	          var _context = this.context;
	
	          trail.each(function(segment, index) {
	
	            var view = d3.select(this);
	
	            view
	              //.transition().duration(duration).ease("linear")
	              .style("opacity", d.opacity || _context.model.entities.opacityRegular);
	          });
	        },
	
	
	        _findVisible: function(trail, duration, d) {
	          var _context = this.context;
	          var KEY = _context.KEY;
	
	          var firstVisible = true;
	          var trailStartTime = _context.model.time.timeFormat.parse("" + d.trailStartTime);
	
	          if (_context.time - trailStartTime < 0) { // move trail start time with trail label back if need
	            d.trailStartTime = _context.model.time.timeFormat(_context.time);
	            trailStartTime = _context.model.time.timeFormat.parse("" + d.trailStartTime);
	            var cache = _context.labels.cached[d[KEY]];
	            cache.labelX0 = _context.frame.axis_x[d[KEY]];
	            cache.labelY0 = _context.frame.axis_y[d[KEY]];
	            var valueS = _context.frame.size[d[KEY]];
	            cache.scaledS0 = (valueS || valueS===0) ? areaToRadius(_context.sScale(valueS)) : null;
	            var valueC = _context.frame.color[d[KEY]];
	            cache.scaledC0 = valueC != null ? _context.cScale(valueC) : _context.COLOR_WHITEISH;
	            _context._updateLabel(d, 0, _context.frame.axis_x[d[KEY]], _context.frame.axis_y[d[KEY]], _context.frame.size[d[KEY]], _context.frame.color[d[KEY]], _context.frame.label[d[KEY]], _context.frame.size_label[d[KEY]], 0, true);
	          }
	          trail.each(function(segment, index) {
	            // segment is transparent if it is after current time or before trail StartTime
	            var segmentVisibility = segment.transparent; 
	            segment.transparent = d.trailStartTime == null || (segment.t - _context.time > 0) || (trailStartTime - segment.t > 0)
	              //no trail segment should be visible if leading bubble is shifted backwards, beyond start time
	              || (d.trailStartTime - _context.model.time.timeFormat(_context.time) >= 0);
	            // always update nearest 2 points
	            if (segmentVisibility != segment.transparent || Math.abs(_context.model.time.timeFormat(segment.t) - _context.model.time.timeFormat(_context.time)) < 2) segment.visibilityChanged = true; // segment changed, so need to update it
	
	          });
	        },
	
	
	        _reveal: function(trail, duration, d) {
	          var _context = this.context;
	          var KEY = _context.KEY;
	          var trailStartTime = _context.model.time.timeFormat.parse("" + d.trailStartTime);
	          var generateTrailSegment = function(trail, index) {
	            return new Promise(function(resolve, reject) {
	              var view = d3.select(trail[0][index]);
	              var segment = view.datum();
	              if(segment.transparent) {
	                view.classed("vzb-invisible", segment.transparent);
	                resolve();
	              } else if (!segment.visibilityChanged) { // pass segment if it is not changed
	                resolve();            
	              } else {
	                _context.model.marker.getFrame(segment.t, function(frame) {
	                  if (!frame) return resolve();
	                  segment.valueY = frame.axis_y[d[KEY]];
	                  segment.valueX = frame.axis_x[d[KEY]];
	                  segment.valueS = frame.size[d[KEY]];
	                  segment.valueC = frame.color[d[KEY]];
	
	                  if(segment.valueY==null || segment.valueX==null || segment.valueS==null) {
	                    if (_context.time - trailStartTime > 0 && (!d.firstAvailableSegment || d.firstAvailableSegment - segment.t > 0)) { // move trail start time forward because previous values are empty
	                      d.trailStartTime = _context.model.time.timeFormat(_context.model.time.incrementTime(trailStartTime));
	                      trailStartTime = _context.model.time.timeFormat.parse("" + d.trailStartTime);
	                    }
	                    resolve();
	                  } else {
	                    if (!d.firstAvailableSegment || d.firstAvailableSegment - segment.t > 0) {
	                      d.firstAvailableSegment = segment.t;
	                    }
	                    // fix label position if it not in correct place
	                    var cache = _context.labels.cached[d[KEY]];
	                    if (trailStartTime && trailStartTime.toString() == segment.t.toString()) {
	                        cache.labelX0 = segment.valueX;
	                        cache.labelY0 = segment.valueY;
	                        var valueS = segment.valueS;
	                        cache.scaledS0 = (valueS || valueS===0) ? areaToRadius(_context.sScale(valueS)) : null;
	                        cache.scaledC0 = segment.valueC!=null?_context.cScale(segment.valueC):_context.COLOR_WHITEISH;
	                        _context._updateLabel(d, index, segment.valueX, segment.valueY, segment.valueS, segment.valueC, frame.label[d[KEY]], frame.size_label[d[KEY]], 0, true);
	                    }
	                    view.select("circle")
	                      //.transition().duration(duration).ease("linear")
	                      .attr("cy", _context.yScale(segment.valueY))
	                      .attr("cx", _context.xScale(segment.valueX))
	                      .attr("r", areaToRadius(_context.sScale(segment.valueS)))
	                      .style("fill", segment.valueC!=null?_context.cScale(segment.valueC):_context.COLOR_WHITEISH);
	
	                    view.select("line")
	                      .attr("x2", _context.xScale(segment.valueX))
	                      .attr("y2", _context.yScale(segment.valueY))
	                      .attr("x1", _context.xScale(segment.valueX))
	                      .attr("y1", _context.yScale(segment.valueY));
	
	                    // last point should have data for line but it is invisible
	                    if (_context.time - segment.t > 0) {
	                      segment.visibilityChanged = false;
	                      view.classed("vzb-invisible", segment.transparent);
	                    } else {
	                      view.classed("vzb-invisible", true);
	                    }
	                    var next = trail[0][index + 1];
	                    if(next == null || _context.time.toString() == segment.t.toString()) {
	                      resolve();
	                    } else {
	                      next = next.__data__; 
	                      var nextTime = next.t;
	                      if (_context.time - next.t < 0) { // time is not equal start of year
	                        segment.visibilityChanged = true; // redraw needed next time because line not have full length
	                        nextTime = _context.time; 
	                      }    
	                      _context.model.marker.getFrame(nextTime, function(nextFrame) {
	
	                        // TODO: find why data in segment sometimes become null
	                        segment.valueY = frame.axis_y[d[KEY]];
	                        segment.valueX = frame.axis_x[d[KEY]];
	                        segment.valueS = frame.size[d[KEY]];
	                        segment.valueC = frame.color[d[KEY]];
	
	                        if(!nextFrame || segment.valueY==null || segment.valueX==null || segment.valueS==null) {
	                          resolve();
	                        } else {
	                          if(nextFrame.axis_x[d[KEY]]==null || nextFrame.axis_y[d[KEY]]==null) {
	                            resolve();
	                          } else {
	                            var strokeColor = _context.model.marker.color.which == "geo.world_4region"?
	                              //use predefined shades for color palette for "geo.world_4region" (hardcoded)
	                              _context.model.marker.color.getColorShade({
	                                colorID: segment.valueC,
	                                shadeID: "shade"
	                              })
	                              :
	                              //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)
	                              (segment.valueC!=null?_context.cScale(segment.valueC):_context.COLOR_BLACKISH);
	
	                            var lineLength = Math.sqrt(
	                              Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextFrame.axis_x[d[KEY]]),2) +
	                              Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextFrame.axis_y[d[KEY]]),2)
	                            );
	                            view.select("line")
	                              .transition().duration(duration).ease("linear")
	                              .attr("x1", _context.xScale(nextFrame.axis_x[d[KEY]]))
	                              .attr("y1", _context.yScale(nextFrame.axis_y[d[KEY]]))
	                              .attr("x2", _context.xScale(segment.valueX))
	                              .attr("y2", _context.yScale(segment.valueY))
	                              .style("stroke-dasharray", lineLength)
	                              .style("stroke-dashoffset", areaToRadius(_context.sScale(segment.valueS)))
	                              .style("stroke", strokeColor);
	                            resolve();
	                          }
	                        }
	                      });
	                    }
	
	                  }
	                });          
	              }
	            });
	          };
	          var defer = new Promise();
	          /**
	           * update for generate next trail segment when previous segment finished
	           * @param trail
	           * @param index
	           */
	          var generateTrails = function(trail, index) {
	            if (index < 0 || index >= trail[0].length) {
	              return defer.resolve();
	            }
	            generateTrailSegment(trail, index).then(function() {
	              generateTrails(trail, index + 1);
	            });
	          };
	          generateTrails(trail, 0);
	          return defer;
	        }
	
	
	      });
	
	      var PanZoom = Class.extend({
	
	          init: function(context) {
	              this.context = context;
	
	              this.dragRectangle = d3.behavior.drag();
	              this.zoomer = d3.behavior.zoom();
	
	              this.dragLock = false;
	
	              this.dragRectangle
	                  .on("dragstart", this.drag().start)
	                  .on("drag", this.drag().go)
	                  .on("dragend", this.drag().stop);
	
	              this.zoomer
	                  .scaleExtent([1, 100])
	                  .on("zoomstart", this.zoom().start)
	                  .on("zoom", this.zoom().go)
	                  .on('zoomend', this.zoom().stop);
	
	              this.zoomer.ratioX = 1;
	              this.zoomer.ratioY = 1;
	
	              context._zoomedXYMinMax = {axis_x:{zoomedMin: null, zoomedMax: null}, axis_y:{zoomedMin: null, zoomedMax: null}};
	          },
	
	          drag: function(){
	              var _this = this.context;
	              var self = this;
	
	              return {
	                  start: function(d, i) {
	                      /*
	                       * Do not drag if the Ctrl key, Meta key, or plus cursor mode is
	                       * not enabled. Also do not drag if zoom-pinching on touchmove
	                       * events.
	                       */
	                      if(!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||
	                           _this.ui.cursorMode === "plus") ||
	                           (d3.event.sourceEvent.type === "touchmove" || d3.event.sourceEvent.type === "touchstart") &&
	                           (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {
	                          return;
	                      }
	
	                      self.dragLock = true;
	                      this.origin = {
	                          x: d3.mouse(this)[0],
	                          y: d3.mouse(this)[1]
	                      };
	                      _this.zoomRect.classed("vzb-invisible", false);
	                  },
	
	                  go: function(d, i) {
	                      /*
	                       * Cancel drag if drag lock is false, or when zoom-pinching via
	                       * touchmove events.
	                       */
	                      if(!self.dragLock || (d3.event.sourceEvent.type === "touchmove" || d3.event.sourceEvent.type === "touchstart") &&
	                          (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {
	                          self.dragLock = false;
	
	                          _this.zoomRect
	                              .attr("width", 0)
	                              .attr("height", 0)
	                              .classed("vzb-invisible", true);
	
	                          return;
	                      }
	
	                      var origin = this.origin;
	                      var mouse = {
	                          x: d3.event.x,
	                          y: d3.event.y
	                      };
	
	                      _this.zoomRect
	                          .attr("x", Math.min(mouse.x, origin.x))
	                          .attr("y", Math.min(mouse.y, origin.y))
	                          .attr("width", Math.abs(mouse.x - origin.x))
	                          .attr("height", Math.abs(mouse.y - origin.y));
	                  },
	
	                  stop: function(e) {
	                      if(!self.dragLock) return;
	                      self.dragLock = false;
	
	                      _this.zoomRect
	                          .attr("width", 0)
	                          .attr("height", 0)
	                          .classed("vzb-invisible", true);
	
	                      this.target = {
	                          x: d3.mouse(this)[0],
	                          y: d3.mouse(this)[1]
	                      };
	
	                      /*
	                       * Only compensate for dragging when the Ctrl key or Meta key
	                       * are pressed, or if the cursorMode is not in plus mode.
	                       */
	                      var compensateDragging = d3.event.sourceEvent.ctrlKey ||
	                          d3.event.sourceEvent.metaKey ||
	                          _this.ui.cursorMode === "plus";
	
	                      self._zoomOnRectangle(
	                          d3.select(this),
	                          this.origin.x,
	                          this.origin.y,
	                          this.target.x,
	                          this.target.y,
	                          compensateDragging, 500
	                      );
	                  }
	              };
	          },
	
	          zoom: function() {
	              var _this = this.context;
	              var zoomer = this.zoomer;
	              var self = this;
	
	              return {
	                  start: function() {
	                      this.savedScale = zoomer.scale();
	                  },
	                  go: function() {
	
	                      var sourceEvent = d3.event.sourceEvent;
	
	                      if(sourceEvent != null && (sourceEvent.ctrlKey || sourceEvent.metaKey)) return;
	
	                      // Cancel drag lock when zoom-pinching via touchmove events.
	                      if (sourceEvent !== null &&
	                          (sourceEvent.type === "touchmove" || sourceEvent.type === "touchstart") &&
	                          (sourceEvent.touches.length > 1 || sourceEvent.targetTouches.length > 1)) {
	                          self.dragLock = false;
	                      }
	
	                      if (self.dragLock) return;
	
	                      //send the event to the page if fully zoomed our or page not scrolled into view
	      //
	      //                    if(d3.event.scale == 1)
	      //
	      //                    if(utils.getViewportPosition(_this.element.node()).y < 0 && d3.event.scale > 1) {
	      //                        _this.scrollableAncestor.scrollTop += d3.event.sourceEvent.deltaY;
	      //                        return;
	      //                    }
	                      /*
	                       * Do not zoom on the chart if the scroll event is a wheel
	                       * scroll. Instead, redirect the scroll event to the scrollable
	                       * ancestor
	                       */
	                      if (sourceEvent != null && (sourceEvent.type === "wheel" || sourceEvent.type === "mousewheel") && 
	                          !_this.ui.zoomOnScrolling) {
	                          if (_this.scrollableAncestor) {
	                              _this.scrollableAncestor.scrollTop += (sourceEvent.deltaY || -sourceEvent.wheelDelta);
	                          }
	                          d3.event.scale = null;
	                          zoomer.scale(this.savedScale);
	                          this.quitZoom = true;
	                          return;
	                      }
	                      this.quitZoom = false;
	
	                      _this.model._data.entities.clearHighlighted();
	                      _this._setTooltip();
	
	                      var zoom = d3.event.scale;
	                      var pan = d3.event.translate;
	                      var ratioY = zoomer.ratioY;
	                      var ratioX = zoomer.ratioX;
	
	                      _this.draggingNow = true;
	
	                      //value protections and fallbacks
	                      if(isNaN(zoom) || zoom == null) zoom = zoomer.scale();
	                      if(isNaN(zoom) || zoom == null) zoom = 1;
	
	                      //TODO: this is a patch to fix #221. A proper code review of zoom and zoomOnRectangle logic is needed
	                      /*
	                       * Mouse wheel and touchmove events set the zoom value
	                       * independently of axis ratios. If the zoom event was triggered
	                       * by a mouse wheel event scrolling down or touchmove event with
	                       * more than 1 contact that sets zoom to 1, then set the axis
	                       * ratios to 1 as well, which will fully zoom out.
	                       */
	                      if(zoom === 1 && sourceEvent !== null &&
	                          ((sourceEvent.type === "wheel" || sourceEvent.type === "mousewheel") && (sourceEvent.deltaY || -sourceEvent.wheelDelta) > 0 ||
	                           sourceEvent.type === "touchmove" && sourceEvent.touches.length > 1)) {
	                          zoomer.ratioX = 1;
	                          ratioX = 1;
	                          zoomer.ratioY = 1;
	                          ratioY = 1
	                      }
	
	                      if(isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = zoomer.translate();
	                      if(isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = [0, 0];
	
	                      // limit the zooming, so that it never goes below 1 for any of the axes
	                      if(zoom * ratioY < 1) {
	                          ratioY = 1 / zoom;
	                          zoomer.ratioY = ratioY
	                      }
	                      if(zoom * ratioX < 1) {
	                          ratioX = 1 / zoom;
	                          zoomer.ratioX = ratioX
	                      }
	
	                      //limit the panning, so that we are never outside the possible range
	                      if(pan[0] > 0) pan[0] = 0;
	                      if(pan[1] > 0) pan[1] = 0;
	                      if(pan[0] < (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;
	                      if(pan[1] < (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;
	
	                      var xPanOffset = _this.width * zoom * ratioX;
	                      var yPanOffset = _this.height * zoom * ratioY;
	
	                      var xRange = [0 * zoom * ratioX + pan[0], xPanOffset + pan[0]];
	                      var yRange = [yPanOffset + pan[1], 0 * zoom * ratioY + pan[1]];
	
	                      var xRangeBumped = _this._rangeBump(xRange);
	                      var yRangeBumped = _this._rangeBump(yRange);
	
	                      /*
	                       * Shift xRange and yRange by the difference between the bumped
	                       * ranges, which is scaled by the zoom factor. This accounts for
	                       * the range bump, which controls a gutter around the
	                       * bubblechart, while correctly zooming.
	                       */
	                      var xRangeMinOffset = (xRangeBumped[0] - xRange[0]) * zoom * ratioX;
	                      var xRangeMaxOffset = (xRangeBumped[1] - xRange[1]) * zoom * ratioX;
	
	                      var yRangeMinOffset = (yRangeBumped[0] - yRange[0]) * zoom * ratioY;
	                      var yRangeMaxOffset = (yRangeBumped[1] - yRange[1]) * zoom * ratioY;
	
	                      xRange[0] = xRange[0] + xRangeMinOffset;
	                      xRange[1] = xRange[1] + xRangeMaxOffset;
	
	                      yRange[0] = yRange[0] + yRangeMinOffset;
	                      yRange[1] = yRange[1] + yRangeMaxOffset;
	
	                      // Calculate the maximum xRange and yRange available.
	                      var xRangeBounds = [0,  _this.width];
	                      var yRangeBounds = [_this.height, 0];
	
	                      var xRangeBoundsBumped = _this._rangeBump(xRangeBounds);
	                      var yRangeBoundsBumped = _this._rangeBump(yRangeBounds);
	
	                      /*
	                       * Set the pan to account for the range bump by subtracting
	                       * offsets and preventing panning past the range bump gutter.
	                       */
	                      if(xRange[0] > xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;
	                      if(xRange[1] < xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;
	                      if(yRange[0] < yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;
	                      if(yRange[1] > yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;
	
	                      zoomer.translate(pan);
	
	                      /*
	                       * Clamp the xRange and yRange by the amount that the bounds
	                       * that are range bumped.
	                       *
	                       * Additionally, take the amount clamped on the end of the range
	                       * and either subtract or add it to the range's other end. This
	                       * prevents visible stretching of the range when only panning.
	                       */
	                      if(xRange[0] > xRangeBoundsBumped[0]) {
	                          xRange[1] = xRange[1] - Math.abs(xRange[0] - xRangeBoundsBumped[0]);
	                          xRange[0] = xRangeBoundsBumped[0];
	                      }
	
	                      if(xRange[1] < xRangeBoundsBumped[1]) {
	                          xRange[0] = xRange[0] + Math.abs(xRange[1] - xRangeBoundsBumped[1]);
	                          xRange[1] = xRangeBoundsBumped[1];
	                      }
	
	                      if(yRange[0] < yRangeBoundsBumped[0]) {
	                          yRange[1] = yRange[1] + Math.abs(yRange[0] - yRangeBoundsBumped[0]);
	                          yRange[0] = yRangeBoundsBumped[0];
	                      }
	
	                      if(yRange[1] > yRangeBoundsBumped[1]) {
	                          yRange[0] = yRange[0] - Math.abs(yRange[1] - yRangeBoundsBumped[1]);
	                          yRange[1] = yRangeBoundsBumped[1];
	                      }
	
	                      if(_this.model.marker.axis_x.scaleType === 'ordinal'){
	                          _this.xScale.rangeBands(xRange);
	                      }else{
	                          _this.xScale.range(xRange);
	                      }
	
	                      if(_this.model.marker.axis_y.scaleType === 'ordinal'){
	                          _this.yScale.rangeBands(yRange);
	                      }else{
	                          _this.yScale.range(yRange);
	                      }
	
	                      var formatter = function(n) { return isDate(n)? n : d3.round(n, 2); };
	
	                      var zoomedXRange = xRangeBoundsBumped;
	                      var zoomedYRange = yRangeBoundsBumped;
	
	                      /*
	                       * Set the zoomed min/max to the correct value depending on if the
	                       * min/max values lie within the range bound regions.
	                       */
	                      zoomedXRange[0] = xRangeBounds[0] > xRange[0] ? xRangeBounds[0] : xRange[0];
	                      zoomedXRange[1] = xRangeBounds[1] < xRange[1] ? xRangeBounds[1] : xRange[1];
	                      zoomedYRange[0] = yRangeBounds[0] < yRange[0] ? yRangeBounds[0] : yRange[0];
	                      zoomedYRange[1] = yRangeBounds[1] > yRange[1] ? yRangeBounds[1] : yRange[1];
	                      
	                      _this._zoomedXYMinMax = {
	                        axis_x: {
	                          zoomedMin: formatter(_this.xScale.invert(zoomedXRange[0])),
	                          zoomedMax: formatter(_this.xScale.invert(zoomedXRange[1]))
	                        },
	                        axis_y: {
	                          zoomedMin: formatter(_this.yScale.invert(zoomedYRange[0])),
	                          zoomedMax: formatter(_this.yScale.invert(zoomedYRange[1]))
	                        }
	                      }
	
	
	                      _this.model.marker.set(_this._zoomedXYMinMax, null, false /*avoid storing it in URL*/);
	
	                      // Keep the min and max size (pixels) constant, when zooming.
	                      //                    _this.sScale.range([utils.radiusToArea(_this.minRadius) * zoom * zoom * ratioY * ratioX,
	                      //                                        utils.radiusToArea(_this.maxRadius) * zoom * zoom * ratioY * ratioX ]);
	
	                      var optionsY = _this.yAxis.labelerOptions();
	                      var optionsX = _this.xAxis.labelerOptions();
	                      optionsY.limitMaxTickNumber = zoom * ratioY < 2 ? 7 : zoom * ratioY * 7;
	                      optionsX.limitMaxTickNumber = zoom * ratioX < 2 ? 7 : zoom * ratioX * 7;
	                      optionsY.transitionDuration = zoomer.duration;
	                      optionsX.transitionDuration = zoomer.duration;
	
	                      _this.xAxisEl.call(_this.xAxis.labelerOptions(optionsX));
	                      _this.yAxisEl.call(_this.yAxis.labelerOptions(optionsY));
	                      _this.redrawDataPoints(zoomer.duration);
	                      _this._trails.run("resize", null, zoomer.duration);
	
	                      zoomer.duration = 0;
	                  },
	
	                  stop: function(){
	                      _this.draggingNow = false;
	
	                      if (this.quitZoom) return;
	
	                      //Force the update of the URL and history, with the same values
	                      _this.model.marker.set(_this._zoomedXYMinMax, true, true);
	                  }
	              };
	          },
	
	          expandCanvas: function(duration) {
	              var _this = this.context;
	              if (!duration) duration = _this.duration;
	
	              //d3 extent returns min and max of the input array as [min, max]
	              var mmX = d3.extent(values(_this.frame.axis_x));
	              var mmY = d3.extent(values(_this.frame.axis_y));
	              var radiusMax = areaToRadius(_this.sScale( d3.extent(values(_this.frame.size))[1] )) || 0;
	
	              //protection agains unreasonable min-max results -- abort function
	              if (!mmX[0] && mmX[0]!==0 || !mmX[1] && mmX[1]!==0 || !mmY[0] && mmY[0]!==0 || !mmY[1] && mmY[1]!==0) {
	                return warn("panZoom.expandCanvas: X or Y min/max are broken. Aborting with no action");
	              }
	              /*
	               * Use a range bumped scale to correctly accommodate the range bump
	               * gutter.
	               */
	              var suggestedFrame = {
	                  x1: _this.xScale(mmX[0]) - radiusMax,
	                  y1: _this.yScale(mmY[0]) + radiusMax,
	                  x2: _this.xScale(mmX[1]) + radiusMax,
	                  y2: _this.yScale(mmY[1]) - radiusMax
	              };
	              var xBounds = [0, _this.width];
	              var yBounds = [_this.height, 0];
	
	              // Get the current zoom frame based on the current dimensions.
	              var frame = {
	                  x1: xBounds[0],
	                  x2: xBounds[1],
	                  y1: yBounds[0],
	                  y2: yBounds[1]
	              };
	
	              var TOLERANCE = .0;
	
	              /*
	               * If there is no current zoom frame, or if any of the suggested frame
	               * points extend outside of the current zoom frame, then expand the
	               * canvas.
	               */
	              if(!_this.isCanvasPreviouslyExpanded ||
	                  suggestedFrame.x1 < frame.x1 * (1 - TOLERANCE) || suggestedFrame.x2 > frame.x2 * (1 + TOLERANCE) ||
	                  suggestedFrame.y2 < frame.y2 * (1 - TOLERANCE) || suggestedFrame.y1 > frame.y1 * (1 + TOLERANCE)) {
	                  /*
	                   * If there is already a zoom frame, then clamp the suggested frame
	                   * points to only zoom out and expand the canvas.
	                   *
	                   * If any of x1, x2, y1, or y2 is within the current frame
	                   * boundaries, then clamp them to the frame boundaries. If any of
	                   * the above values will translate into a data value that is outside
	                   * of the possible data range, then clamp them to the frame
	                   * coordinate that corresponds to the maximum data value that can
	                   * be displayed.
	                   */
	                  if (_this.isCanvasPreviouslyExpanded) {
	                      /*
	                       * Calculate bounds and bumped scale for calculating the data boundaries
	                       * to which the suggested frame points need to be clamped.
	                       */
	                      var xBoundsBumped = _this._rangeBump(xBounds);
	                      var yBoundsBumped = _this._rangeBump(yBounds);
	
	                      var xScaleBoundsBumped = _this.xScale.copy()
	                          .range(xBoundsBumped);
	                      var yScaleBoundsBumped = _this.yScale.copy()
	                          .range(yBoundsBumped);
	
	                      var xDataBounds = [xScaleBoundsBumped.invert(xBounds[0]), xScaleBoundsBumped.invert(xBounds[1])];
	                      var yDataBounds = [yScaleBoundsBumped.invert(yBounds[0]), yScaleBoundsBumped.invert(yBounds[1])];
	
	                      if (suggestedFrame.x1 > 0)
	                          suggestedFrame.x1 = 0;
	                      else if (_this.xScale.invert(suggestedFrame.x1) < xDataBounds[0])
	                          suggestedFrame.x1 = _this.xScale(xDataBounds[0]);
	
	                      if (suggestedFrame.x2 < _this.width)
	                          suggestedFrame.x2 = _this.width;
	                      else if (_this.xScale.invert(suggestedFrame.x2) > xDataBounds[1])
	                          suggestedFrame.x2 = _this.xScale(xDataBounds[1]);
	
	                      if (suggestedFrame.y1 < _this.height)
	                          suggestedFrame.y1 = _this.height;
	                      else if (_this.yScale.invert(suggestedFrame.y1) < yDataBounds[0])
	                          suggestedFrame.y1 = _this.yScale(yDataBounds[0]);
	
	                      if (suggestedFrame.y2 > 0)
	                          suggestedFrame.y2 = 0;
	                      else if (_this.yScale.invert(suggestedFrame.y2) > yDataBounds[1])
	                          suggestedFrame.y2 = _this.yScale(yDataBounds[1]);
	                  }
	
	                  _this.isCanvasPreviouslyExpanded = true;
	                  this._zoomOnRectangle(_this.element, suggestedFrame.x1, suggestedFrame.y1,
	                      suggestedFrame.x2, suggestedFrame.y2, false, duration);
	              } else {
	                  _this.redrawDataPoints(duration);
	              }
	          },
	
	          zoomToMaxMin: function(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, duration){
	              var _this = this.context;
	              var minX = zoomedMinX;
	              var maxX = zoomedMaxX;
	              var minY = zoomedMinY;
	              var maxY = zoomedMaxY;
	
	              var xRangeBounds = [0, _this.width];
	              var yRangeBounds = [_this.height, 0];
	
	              var xDomain = _this.xScale.domain();
	              var yDomain = _this.yScale.domain();
	
	              // Clamp zoomed values to maximum and minimum values.
	              if (minX < xDomain[0]) minX = xDomain[0];
	              if (maxX > xDomain[1]) maxX = xDomain[1];
	              if (minY < yDomain[0]) minY = yDomain[0];
	              if (maxY > yDomain[1]) maxY = yDomain[1];
	
	              /*
	               * Define TOLERANCE value as Number.EPSILON if exists, otherwise use
	               * ES6 standard value.
	               */
	              var TOLERANCE = Number.EPSILON ? Number.EPSILON : 2.220446049250313e-16;
	
	              /*
	               * Check if the range bump region is currently displayed, i.e. for the
	               * minX range bump region, check:
	               * _this.xScale.invert(xRangeBounds[0]) < _this.xScale.domain()[0]
	               *
	               * Also check if the given min/max values equal the domain edges.
	               * If so, then set the min/max values according to their range bumped
	               * values. These values are used to calculate the correct rectangle
	               * points for zooming.
	               */
	              if (_this.xScale.invert(xRangeBounds[0]) < xDomain[0]
	                  && Math.abs(minX - xDomain[0]) < TOLERANCE) {
	                  minX = _this.xScale.invert(xRangeBounds[0]);
	              }
	
	              if (_this.xScale.invert(xRangeBounds[1]) > xDomain[1]
	                  && Math.abs(maxX - xDomain[1]) < TOLERANCE) {
	                  maxX = _this.xScale.invert(xRangeBounds[1]);
	              }
	
	              if (_this.yScale.invert(yRangeBounds[0]) < yDomain[0]
	                  && Math.abs(minY - yDomain[0]) < TOLERANCE) {
	                  minY = _this.yScale.invert(yRangeBounds[0]);
	              }
	
	              if (_this.yScale.invert(yRangeBounds[1]) > yDomain[1]
	                  && Math.abs(maxY - yDomain[1]) < TOLERANCE) {
	                  maxY = _this.yScale.invert(yRangeBounds[1]);
	              }
	
	              var xRange = [_this.xScale(minX), _this.xScale(maxX)];
	              var yRange = [_this.yScale(minY), _this.yScale(maxY)];
	
	              this._zoomOnRectangle(_this.element, xRange[0], yRange[0], xRange[1], yRange[1], false, duration);
	          },
	
	          _zoomOnRectangle: function(element, zoomedX1, zoomedY1, zoomedX2, zoomedY2, compensateDragging, duration) {
	              var _this = this.context;
	              var zoomer = this.zoomer;
	
	              var x1 = zoomedX1;
	              var y1 = zoomedY1;
	              var x2 = zoomedX2;
	              var y2 = zoomedY2;
	
	              /*
	               * When dragging to draw a rectangle, the translate vector has (x2 - x1)
	               * added to zoomer.translate()[0], and (y2 - 1) added to
	               * zoomer.translate()[1].
	               *
	               * We need to compensate for this addition when
	               * zooming with a rectangle, because zooming with a rectangle will
	               * update the translate vector with new values based on the rectangle
	               * dimensions.
	               */
	              if(compensateDragging) {
	                  zoomer.translate([
	                      zoomer.translate()[0] + x1 - x2,
	                      zoomer.translate()[1] + y1 - y2
	                  ]);
	              }
	
	              var xRangeBounds = [0, _this.width];
	              var yRangeBounds = [_this.height, 0];
	
	              var xDomain = _this.xScale.domain();
	              var yDomain = _this.yScale.domain();
	
	              /*
	               * If the min or max of one axis lies in the range bump region, then
	               * changing the opposite end of that axis must correctly scale and
	               * maintain the range bump region.
	               */
	              if (_this.xScale.invert(x1) < xDomain[0]) {
	                  x1 = this._scaleCoordinate(x1, xRangeBounds[1] - x2, _this.xScale.range()[0], xRangeBounds[1]);
	              } else if (_this.xScale.invert(x2) < xDomain[0]) {
	                  x2 = this._scaleCoordinate(x2, xRangeBounds[1] - x1, _this.xScale.range()[0], xRangeBounds[1]);
	              }
	
	              if (_this.xScale.invert(x2) > xDomain[1]) {
	                  x2 = this._scaleCoordinate(x2, x1 - xRangeBounds[0], _this.xScale.range()[1], xRangeBounds[0]);
	              } else if (_this.xScale.invert(x1) > xDomain[1]) {
	                  x1 = this._scaleCoordinate(x1, x2 - xRangeBounds[0], _this.xScale.range()[1], xRangeBounds[0]);
	              }
	
	              if (_this.yScale.invert(y1) < yDomain[0]) {
	                  y1 = this._scaleCoordinate(y1, y2 - yRangeBounds[1], _this.yScale.range()[0], yRangeBounds[1]);
	              } else if (_this.yScale.invert(y2) < yDomain[0]) {
	                  y2 = this._scaleCoordinate(y2, y1 - yRangeBounds[1], _this.yScale.range()[0], yRangeBounds[1]);
	              }
	
	              if (_this.yScale.invert(y2) > yDomain[1]) {
	                  y2 = this._scaleCoordinate(y2, yRangeBounds[0] - y1, _this.yScale.range()[1], yRangeBounds[0]);
	              } else if (_this.yScale.invert(y1) > yDomain[1]) {
	                  y1 = this._scaleCoordinate(y1, yRangeBounds[0] - y2, _this.yScale.range()[1], yRangeBounds[0]);
	              }
	
	              if(Math.abs(x1 - x2) < 10 || Math.abs(y1 - y2) < 10) return;
	
	              var maxZoom = zoomer.scaleExtent()[1];
	
	              if(Math.abs(x1 - x2) > Math.abs(y1 - y2)) {
	                  var zoom = _this.height / Math.abs(y1 - y2) * zoomer.scale();
	
	                  /*
	                   * Clamp the zoom scalar to the maximum zoom allowed before
	                   * calculating the next ratioX and ratioY.
	                   */
	                  if (zoom > maxZoom) zoom = maxZoom;
	
	                  var ratioX = _this.width / Math.abs(x1 - x2) * zoomer.scale() / zoom * zoomer.ratioX;
	                  var ratioY = zoomer.ratioY;
	              } else {
	                  var zoom = _this.width / Math.abs(x1 - x2) * zoomer.scale();
	
	                  /*
	                   * Clamp the zoom scalar to the maximum zoom allowed before
	                   * calculating the next ratioX and ratioY.
	                   */
	                  if (zoom > maxZoom) zoom = maxZoom;
	
	                  var ratioY = _this.height / Math.abs(y1 - y2) * zoomer.scale() / zoom * zoomer.ratioY;
	                  var ratioX = zoomer.ratioX;
	              }
	
	              var pan = [
	                  (zoomer.translate()[0] - Math.min(x1, x2)) / zoomer.scale() / zoomer.ratioX * zoom * ratioX,
	                  (zoomer.translate()[1] - Math.min(y1, y2)) / zoomer.scale() / zoomer.ratioY * zoom * ratioY
	              ];
	
	              zoomer.scale(zoom);
	              zoomer.ratioY = ratioY;
	              zoomer.ratioX = ratioX;
	              zoomer.translate(pan);
	              zoomer.duration = duration ? duration : 0;
	
	              zoomer.event(element);
	          },
	
	          /*
	           * Helper function that returns a scaled coordinate value based on the
	           * distance between the given coordinate and the data boundary.
	           */
	          _scaleCoordinate: function(coordValue, scaleDifference, dataBoundary, viewportBoundary) {
	              var scalar = scaleDifference / Math.abs(dataBoundary - viewportBoundary);
	              return (coordValue - dataBoundary) * (1 - scalar) + dataBoundary;
	          },
	
	          /*
	           * Calculate a proportional reduction of the scalar value. Also,
	           * calculate the reduction of the value by a constant of 1.
	           *
	           * Return the larger of the two calculated values.
	           */
	          _scaleToMin: function(scalar, minScalar, proportion, constant) {
	              var scalarProportionDelta = (scalar - minScalar) * proportion;
	              var scalarDifferenceDelta = Math.max(constant, minScalar - constant);
	              var scalarDelta = Math.max(scalarProportionDelta, scalarDifferenceDelta);
	
	              return scalarDelta;
	          },
	
	          /*
	           * Incrementally zoom in or out and pan the view so that it never looses the point where click happened
	           * this function is a modified d3's own zoom behavior on double click
	           * for the original code see https://github.com/mbostock/d3/blob/master/src/behavior/zoom.js
	           * function dblclicked() and what it refers to 
	           */
	          zoomByIncrement: function(direction, duration) {
	              var _this = this.context;
	              
	              var ratio = this.zoomer.scale();
	              var pan = [this.zoomer.translate()[0], this.zoomer.translate()[1]];
	              
	              var mouse = d3.mouse(_this.element.node());
	              var k = Math.log(ratio) / Math.LN2;
	              
	              //change factor direction based on the input. default is no direction supplied
	              if(direction=="plus" || !direction) k = Math.floor(k) + 1;
	              if(direction=="minus") k = Math.ceil(k) - 1;
	
	              //decode panning
	              var locus = [(mouse[0] - pan[0]) / ratio, (mouse[1] - pan[1]) / ratio];
	
	              //recalculate zoom ratio
	              var scaleExtent = this.zoomer.scaleExtent();
	              ratio = Math.max(scaleExtent[0], Math.min( scaleExtent[1], Math.pow(2, k) ));
	              
	              //recalculate panning
	              locus = [locus[0] * ratio + pan[0], locus[1] * ratio + pan[1]];
	              pan[0] += mouse[0] - locus[0];
	              pan[1] += mouse[1] - locus[1];
	              
	              //save changes to the zoom behavior and run the event
	              this.zoomer.scale(ratio);
	              this.zoomer.translate([pan[0], pan[1]]);
	              this.zoomer.duration = duration||0;
	              this.zoomer.event(_this.element);
	          },    
	          
	
	          /*
	           * Reset zoom values without triggering a zoom event.
	           */
	           resetZoomState: function(element) {
	              this.zoomer.scale(1);
	              this.zoomer.ratioY = 1;
	              this.zoomer.ratioX = 1;
	              this.zoomer.translate([0, 0]);
	          },
	
	          reset: function(element, duration) {
	              var _this = this.context;
	              _this.isCanvasPreviouslyExpanded = false;
	
	              this.zoomer.scale(1);
	              this.zoomer.ratioY = 1;
	              this.zoomer.ratioX = 1;
	              this.zoomer.translate([0, 0]);
	              this.zoomer.duration = duration||0;
	              this.zoomer.event(element || _this.element);
	          },
	
	          rerun: function(element) {
	              var _this = this.context;
	              this.zoomer.event(element || _this.element);
	          }
	      });
	
	      var prefix = "";
	      var deleteClasses = [];
	      var SVGHEADER = '<?xml version="1.0" encoding="utf-8"?>';
	
	      var Exporter = Class.extend({
	
	        init: function(context) {
	          this.context = context;
	          this.shapes = [];
	          this.groups = [];
	          this.counter = 0;
	          this.name = "";
	          this.label = "";
	        },
	
	        reset: function() {
	          this.container.remove();
	          this.context.element.selectAll(".vzb-export-redball").remove();
	          this.context.element.selectAll(".vzb-export-counter").remove();
	          this.counter = 0;
	        },
	
	        prefix: function(arg) {
	          if(!arguments.length) return prefix;
	          prefix = arg;
	          return this;
	        },
	        deleteClasses: function(arg) {
	          if(!arguments.length) return deleteClasses;
	          deleteClasses = arg;
	          return this;
	        },
	
	        open: function(element, name) {
	          var _this = this;
	
	          //reset if some exports exists on opening
	          if(this.svg) this.reset();
	
	          if(!element) element = this.context.element;
	          if(!name) name = this.context.name;
	          this.name = name;
	
	          var width = parseInt(element.style("width"), 10) || 0;
	          var height = parseInt(element.style("height"), 10) || 0;
	
	          this.container = element.append("div").attr("class", "vzb-svg-export");
	          this.svg = this.container.node().appendChild(element.select("svg").node().cloneNode(true));
	          this.svg = d3.select(this.svg);
	          this.svg
	            .attr("viewBox", "0 0 " + width + " " + height)
	            .attr("version", "1.1")
	            .attr("param1", "http://www.w3.org/2000/svg")
	            .attr("param2", "http://www.w3.org/1999/xlink")
	            .attr("x", "0px")
	            .attr("y", "0px")
	            .attr("style", "enable-background:new " + "0 0 " + width + " " + height)
	            .attr("xml:space", "preserve");
	
	          this.redBall = element.append("div")
	            .attr("class", "vzb-export-redball")
	            .style("position", "absolute")
	            .style("top", "20px")
	            .style("right", "20px")
	            .style("width", "20px")
	            .style("height", "20px")
	            .style("background", "red")
	            .style("color", "white")
	            .style("text-align", "center")
	            .style("border-radius", "10px")
	            .style("font-size", "14px")
	            .style("line-height", "20px")
	            .style("opacity", .8)
	            .style("cursor", "pointer")
	            .on("mouseover", function() {
	              d3.select(this).style("opacity", 1).text("▼");
	              _this.counterEl.text("Download");
	            })
	            .on("mouseout", function() {
	              d3.select(this).style("opacity", .8).text("");
	              _this.counterEl.text(_this.label);
	            })
	            .on("click", function() {
	              _this.close()
	            });
	
	          this.counterEl = element.append("div")
	            .attr("class", "vzb-export-counter")
	            .style("position", "absolute")
	            .style("top", "20px")
	            .style("right", "45px")
	            .style("color", "red")
	            .style("opacity", .8)
	            .style("line-height", "20px")
	            .style("font-size", "14px")
	            .style("text-align", "center")
	
	
	
	          this.root = this.svg.select("." + prefix + "graph");
	
	          this.root.selectAll("g, text, svg, line, rect")
	            .filter(function() {
	              var view = d3.select(this);
	              var result = false;
	              deleteClasses.forEach(function(one) {
	                result = result || view.classed(one);
	              })
	              return result;
	            })
	            .remove();
	
	          this.svg.selectAll(".tick line")
	            .attr("fill", "none")
	            .attr("stroke", "#999");
	          this.svg.selectAll("." + prefix + "axis-x path")
	            .attr("fill", "none")
	            .attr("stroke", "#999");
	          this.svg.selectAll("." + prefix + "axis-y path")
	            .attr("fill", "none")
	            .attr("stroke", "#999");
	        },
	
	        write: function(me) {
	          var groupBy = "time";
	
	          if(!this.root) this.open();
	
	          //avoid writing the same thing again
	          if(this.shapes.indexOf(me.id + "_" + me.time) > -1) return;
	
	          this.shapes.push(me.id + "_" + me.time);
	
	
	          // check if need to create a new group and do so
	          if(this.groups.indexOf(me[groupBy]) == -1) {
	            this.root.append("g").attr("id", "g_" + me[groupBy]);
	            this.groups.push(me[groupBy]);
	          }
	
	          // put a marker into the group
	          if(me.opacity == null) me.opacity = .5;
	          if(me.fill == null) me.fill = "#ff80dd";
	
	          var marker = this.root.select("#g_" + me[groupBy])
	            .append(me.type)
	            .attr("id", me.id + "_" + me.time)
	            .style("fill", me.fill)
	            .style("opacity", me.opacity);
	
	          switch(me.type) {
	            case "path":
	              marker
	                .attr("d", me.d);
	              break;
	
	            case "circle":
	              marker
	                .attr("cx", me.cx)
	                .attr("cy", me.cy)
	                .attr("r", me.r);
	              break;
	          }
	
	          this.counter++;
	          this.redBall.style("opacity", this.counter % 10 / 12 + .2);
	          this.label = me.type + " shapes: " + this.counter;
	          this.counterEl.text(this.label);
	        },
	
	        close: function() {
	
	          var result = SVGHEADER + " " + this.container.node().innerHTML
	            .replace("param1", "xmlns")
	            .replace("param2", "xmlns:xlink")
	            //round all numbers in SVG code 
	            .replace(/\d+(\.\d+)/g, function(x) {
	              return Math.round(+x * 100) / 100 + ""
	            });
	
	
	          if(result.length / 1024 / 1024 > 2) {
	
	            alert("The file size is " + Math.round(result.length / 1024) +
	              "kB, which is too large to download. Will try to print it in the console instead...")
	            console.log(result);
	
	          } else {
	
	            var link = document.createElement('a');
	            link.download = this.name + " " + this.counter + " shapes" + ".svg";
	            link.href = 'data:,' + result;
	            link.click();
	          }
	        }
	
	
	
	      });
	
	      var DynamicBackground = Class.extend({
	
	        init: function(context, conditions) {
	          this.context = context;
	          this.width = 0;
	          this.height = 0;
	          this.topOffset = 0;
	          this.leftOffset = 0;
	          this.bottomOffset = 0;
	          this.rightOffset = 0;
	          this.fontSize = 0;
	          this.fontWidth = 0;
	          this.fontHeight = 0;
	          this.xAlign = 'center';
	          this.yAlign = 'center';
	          this.symbols = [];
	          if (conditions) {
	            this.setConditions(conditions);
	          }
	        },
	
	        setConditions: function(conditions) {
	          if (!isNaN(parseFloat(conditions.rightOffset)) && isFinite(conditions.rightOffset)) {
	            this.rifgtOffset = conditions.rightOffset;
	          }
	          if (!isNaN(parseFloat(conditions.leftOffset)) && isFinite(conditions.leftOffset)) {
	            this.leftOffset = conditions.leftOffset;
	          }
	          if (!isNaN(parseFloat(conditions.topOffset)) && isFinite(conditions.topOffset)) {
	            this.topOffset = conditions.topOffset;
	          }
	          if (!isNaN(parseFloat(conditions.bottomOffset)) && isFinite(conditions.bottomOffset)) {
	            this.bottomOffset = conditions.bottomOffset;
	          }
	          if (conditions.xAlign) {
	            this.xAlign = conditions.xAlign;
	          }
	          if (conditions.yAlign) {
	            this.yAlign = conditions.yAlign;
	          }
	          return this;
	        },
	
	        resize: function(width, height, fontSize, topOffset, leftOffset) {
	          this.width = width;
	          this.height = height;
	          this.fontSize = fontSize;
	          if (topOffset) {
	            this.topOffset = topOffset;
	          }
	          if (leftOffset) {
	            this.leftOffset = leftOffset;
	          }
	          if (this.fontSize > this.height) {
	            this.fontSize = this.height;
	          }
	          var sample = this.context.append("text").text("0").style("font-size", this.fontSize + "px");
	          this.fontWidth = sample[0][0].getBBox().width;
	          this.fontHeight = this.fontSize*0.72;
	
	          d3.select(sample[0][0]).remove();
	          this.__resizeText();
	        },
	
	        setText: function(text, resize) {
	          var _this = this;
	          var newSymbols = text.split('');
	          if (newSymbols.length != this.symbols.length) {
	            resize = true;
	          }
	          this.symbols = text.split('');
	
	          this.context.selectAll("text")
	            .data(this.symbols).exit().remove();
	          this.context.selectAll("text")
	            .data(this.symbols)
	            .enter()
	            .append("text")
	            .text(function(d){return d;});
	
	          this.context.selectAll("text").each(function (d, i) {
	              d3.select(this).text(d);
	          });
	          if (resize) {
	            return this.__resizeText();
	          } else {
	            return this;
	          }
	
	        },
	
	        __resizeText: function() {
	          var _this = this;
	          this.context.attr("transform", "translate(" + this.__getLeftOffset() + "," + this.__getTopOffset() + ")");
	          this.context.selectAll("text").each(function(d, i) {
	              d3.select(this)
	                .attr("x", _this.fontWidth * i)
	                .style("font-size", _this.fontSize + 'px')
	                .style("text-anchor", "middle");
	            });
	          return this;
	        },
	        __getLeftOffset: function() {
	          switch (this.xAlign) {
	            case 'right':
	              return this.width - this.fontWidth * this.symbols.length + this.fontWidth/2;
	              break;
	            case 'left':
	              return this.fontWidth/2;
	              break;
	            default :
	              return this.fontWidth/2 + (this.width - this.fontWidth * this.symbols.length)/2;
	          }
	        },
	        __getTopOffset: function() {
	          //console.log(this.topOffset);
	          switch (this.yAlign) {
	            case 'top':
	              return this.fontHeight + this.topOffset;
	              break;
	            case 'bottom':
	              return this.height - this.bottomOffset;
	              break;
	            default :
	              return this.fontHeight + (this.height - this.fontHeight)/2 + this.topOffset;
	          }
	        }
	
	      });
	
	      //BUBBLE CHART COMPONENT
	      var BubbleChartComp = Component.extend({
	
	        /**
	         * Initializes the component (Bubble Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The config passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function(config, context) {
	          var _this = this;
	          this.name = 'bubblechart';
	          this.template = 'bubblechart.html';
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }, {
	            name: "ui",
	            type: "model"
	          }];
	
	          this.model_binds = {
	            'change:time.start': function(evt, original) {
	              if(_this.model.marker.color.scaleType === 'time') {
	                _this.model.marker.color.scale = null;
	              }
	            },
	            "change:time.record": function() {
	              //console.log("change time record");
	              if(_this.model.time.record) {
	                _this._export.open(this.element, this.name);
	              } else {
	                _this._export.reset();
	              }
	            },
	            "change:ui.chart.trails": function(evt) {
	              //console.log("EVENT change:time:trails");
	              _this._trails.toggle(_this.model.ui.chart.trails);
	              _this.redrawDataPoints();
	            },
	            "change:ui.chart.lockNonSelected": function(evt) {
	              //console.log("EVENT change:time:lockNonSelected");
	              _this.redrawDataPoints(500);
	            },
	            "change:marker": function(evt, path) {
	              // bubble size change is processed separately
	              if(!_this._readyOnce) return;
	
	              if(path.indexOf("scaleType") > -1) {
	                _this.ready();
	                return;
	              }
	
	              if(path.indexOf("marker.color") !== -1) return;
	              if(path.indexOf("marker.size") !== -1) return;
	              if(path.indexOf("marker.size_label") !== -1) return;
	
	              if(path.indexOf("domainMin") > -1 || path.indexOf("domainMax") > -1) {
	                if(!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress
	                _this.updateSize();
	                _this.updateMarkerSizeLimits();
	                _this._trails.run("findVisible");
	                _this.redrawDataPoints();
	                _this._trails.run("resize");
	                return;
	              }
	              if(path.indexOf("zoomedMin") > -1 || path.indexOf("zoomedMax") > -1) {
	                if(_this.draggingNow)return;
	
	                //avoid zooming again if values didn't change.
	                //also prevents infinite loop on forced URL update from zoom.stop()
	                if(_this._zoomedXYMinMax.axis_x.zoomedMin == _this.model.marker.axis_x.zoomedMin
	                && _this._zoomedXYMinMax.axis_x.zoomedMax == _this.model.marker.axis_x.zoomedMax
	                && _this._zoomedXYMinMax.axis_y.zoomedMin == _this.model.marker.axis_y.zoomedMin
	                && _this._zoomedXYMinMax.axis_y.zoomedMax == _this.model.marker.axis_y.zoomedMax
	                ) return;
	
	                  _this._panZoom.zoomToMaxMin(
	                    _this.model.marker.axis_x.zoomedMin,
	                    _this.model.marker.axis_x.zoomedMax,
	                    _this.model.marker.axis_y.zoomedMin,
	                    _this.model.marker.axis_y.zoomedMax,
	                    500
	                )
	                return;
	              }
	
	              //console.log("EVENT change:marker", evt);
	            },
	            "change:entities.select": function() {
	              if(!_this._readyOnce || !_this.entityBubbles) return;
	              //console.log("EVENT change:entities:select");
	              _this.selectDataPoints();
	              _this.redrawDataPoints();
	              _this._trails.create();
	              _this._trails.run(["resize", "recolor", "opacityHandler","findVisible", "reveal"]);
	              _this.updateBubbleOpacity();
	              _this._updateDoubtOpacity();
	            },
	            "change:entities.highlight": function() {
	              if(!_this._readyOnce) return;
	              //console.log("EVENT change:entities:highlight");
	              _this.highlightDataPoints();
	            },
	            'change:time.value': function() {
	              if (!_this._readyOnce) return;
	              if (!_this.calculationQueue) { // collect timestamp that we request
	                _this.calculationQueue = [_this.model.time.value.toString()]
	              } else {
	                _this.calculationQueue.push(_this.model.time.value.toString());
	              }
	              (function(time) { // isolate timestamp
	              //_this._bubblesInteract().mouseout();
	                _this.model.marker.getFrame(time, function(frame, time) {
	                  if (!_this._frameIsValid(frame)) return;
	                  var index = _this.calculationQueue.indexOf(time.toString()); //
	                  if (index == -1) { // we was receive more recent frame before so we pass this frame
	                    return;
	                  } else {
	                    _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp
	                  }
	                  _this.frameChanged(frame, time);
	                });
	
	              }(_this.model.time.value));
	            },
	            'change:ui.adaptMinMaxZoom': function() {
	              //console.log("EVENT change:ui:adaptMinMaxZoom");
	              if(_this.model.ui.adaptMinMaxZoom) {
	                _this._panZoom.expandCanvas(500);
	              } else {
	                _this._panZoom.reset();
	              }
	            },
	            'change:marker.size.extent': function(evt, path) {
	              //console.log("EVENT change:marker:size:max");
	              if(!_this._readyOnce) return;
	              _this.updateMarkerSizeLimits();
	              _this._trails.run("findVisible");
	              _this.redrawDataPointsOnlySize();
	              _this._trails.run("resize");
	            },
	            'change:marker.color': function(evt, path) {
	              if(!_this._readyOnce) return;
	              //console.log("EVENT change:marker:color:palette");
	              _this.redrawDataPointsOnlyColors();
	              _this._trails.run("recolor");
	            },
	            // 'change:marker.color.palette': function(evt, path) {
	            //   if(!_this._readyOnce) return;
	            //   //console.log("EVENT change:marker:color:palette");
	            //   _this.redrawDataPointsOnlyColors();
	            //   _this._trails.run("recolor");
	            // },
	            'change:entities.opacitySelectDim': function() {
	              _this.updateBubbleOpacity();
	            },
	            'change:entities.opacityRegular': function() {
	              _this.updateBubbleOpacity();
	              _this._trails.run("opacityHandler");
	            },
	            'change:ui.cursorMode': function() {
	              var svg = _this.element.select("svg");
	              if(_this.model.ui.cursorMode === "plus"){
	                  svg.classed("vzb-zoomin", true);
	                  svg.classed("vzb-zoomout", false);
	              }else if(_this.model.ui.cursorMode === "minus"){
	                  svg.classed("vzb-zoomin", false);
	                  svg.classed("vzb-zoomout", true);
	              }else{
	                  svg.classed("vzb-zoomin", false);
	                  svg.classed("vzb-zoomout", false);
	              }
	            },
	            'ready': function() {
	              // if(_this.model.marker.color.scaleType === 'time') {
	              //   _this.model.marker.color.scale = null;
	              //   utils.defer(function() {
	              //     _this.trigger('ready');
	              //   });
	              // }
	            }
	          };
	            
	          this._super(config, context);
	
	          this.xScale = null;
	          this.yScale = null;
	          this.sScale = null;
	          this.cScale = null;
	
	          this.xAxis = axisSmart();
	          this.yAxis = axisSmart();
	
	          _this.COLOR_BLACKISH = "#333";
	          _this.COLOR_WHITEISH = "#fdfdfd";
	
	          this.isCanvasPreviouslyExpanded = false;
	          this.draggingNow = null;
	
	          this._trails = new Trail(this);
	          this._panZoom = new PanZoom(this);
	          this._export = new Exporter(this);
	          this._export
	            .prefix("vzb-bc-")
	            .deleteClasses(["vzb-bc-bubbles-crop", "vzb-hidden", "vzb-bc-year", "vzb-bc-zoom-rect",
	              "vzb-bc-projection-x", "vzb-bc-projection-y", "vzb-bc-axis-c-title"
	            ]);
	
	        },
	        
	        afterPreload: function() {
	          var _this = this;
	          this.labels = this.parent.findChildByName('gapminder-labels');
	          this.labels.config({
	            CSS_PREFIX: 'vzb-bc',
	            TOOL_CONTEXT: this,
	            LABELS_CONTAINER_CLASS: 'vzb-bc-labels',
	            LINES_CONTAINER_CLASS: 'vzb-bc-lines'
	          });
	        },
	
	        _rangeBump: function(arg, undo) {
	          var bump = this.activeProfile.maxRadius/2;
	          undo = undo?-1:1;
	          if(isArray(arg) && arg.length > 1) {
	            var z1 = arg[0];
	            var z2 = arg[arg.length - 1];
	
	            //the sign of bump depends on the direction of the scale
	            if(z1 < z2) {
	              z1 += bump * undo;
	              z2 -= bump * undo;
	              // if the scale gets inverted because of bump, set it to avg between z1 and z2
	              if(z1 > z2) z1 = z2 = (z1 + z2) / 2;
	            } else if(z1 > z2) {
	              z1 -= bump * undo;
	              z2 += bump * undo;
	              // if the scale gets inverted because of bump, set it to avg between z1 and z2
	              if(z1 < z2) z1 = z2 = (z1 + z2) / 2;
	            } else {
	              warn("rangeBump error: the input scale range has 0 length. that sucks");
	            }
	            return [z1, z2];
	          } else {
	            warn("rangeBump error: input is not an array or empty");
	          }
	        },
	
	      //  _marginUnBump: function(arg) {
	      //    var bump = this.profiles[this.getLayoutProfile()].maxRadius/2;
	      //    if(utils.isObject(arg)) {
	      //      return {
	      //        left: arg.left - bump,
	      //        right: arg.right - bump,
	      //        top: arg.top - bump,
	      //        bottom: arg.bottom - bump
	      //      };
	      //    } else {
	      //      utils.warn("marginUnBump error: input is not an object {left top bottom right}");
	      //    }
	      //  },
	
	
	        /**
	         * Executes right after the template is in place, but the model is not yet ready
	         */
	        readyOnce: function() {
	          var _this = this;
	          this._readyOnce = false;
	          this.scrollableAncestor = findScrollableAncestor(this.element);
	          this.element = d3.select(this.element);
	
	          // reference elements
	          this.graph = this.element.select('.vzb-bc-graph');
	          this.yAxisElContainer = this.graph.select('.vzb-bc-axis-y');
	          this.yAxisEl = this.yAxisElContainer.select('g');
	
	          this.xAxisElContainer = this.graph.select('.vzb-bc-axis-x');
	          this.xAxisEl = this.xAxisElContainer.select('g');
	
	          this.yTitleEl = this.graph.select('.vzb-bc-axis-y-title');
	          this.xTitleEl = this.graph.select('.vzb-bc-axis-x-title');
	          this.sTitleEl = this.graph.select('.vzb-bc-axis-s-title');
	          this.cTitleEl = this.graph.select('.vzb-bc-axis-c-title');
	          this.yearEl = this.graph.select('.vzb-bc-year');
	
	          this.year = new DynamicBackground(this.yearEl);
	
	          this.yInfoEl = this.graph.select('.vzb-bc-axis-y-info');
	          this.xInfoEl = this.graph.select('.vzb-bc-axis-x-info');
	          this.dataWarningEl = this.graph.select('.vzb-data-warning');
	
	          this.projectionX = this.graph.select(".vzb-bc-projection-x");
	          this.projectionY = this.graph.select(".vzb-bc-projection-y");
	
	          this.trailsContainer = this.graph.select('.vzb-bc-trails');
	          this.bubbleContainerCrop = this.graph.select('.vzb-bc-bubbles-crop');
	          this.labelsContainerCrop = this.graph.select('.vzb-bc-labels-crop');
	          this.bubbleContainer = this.graph.select('.vzb-bc-bubbles');
	          this.labelsContainer = this.graph.select('.vzb-bc-labels');
	          this.linesContainer = this.graph.select('.vzb-bc-lines');
	          this.zoomRect = this.element.select('.vzb-bc-zoom-rect');
	          this.eventArea = this.element.select('.vzb-bc-eventarea');
	          
	          this.entityBubbles = null;
	          this.bubbleCrown = this.element.select('.vzb-bc-bubble-crown');
	          //set filter
	          this.bubbleCrown.selectAll(".vzb-crown-glow")
	            .attr("filter","url(" + location.pathname + "#vzb-glow-filter)");
	          this.tooltip = this.element.select('.vzb-bc-tooltip');
	          //set filter 
	          this.tooltip.select(".vzb-tooltip-glow")
	            .attr("filter","url(" + location.pathname + "#vzb-glow-filter)");
	
	          this.tooltipMobile = this.element.select('.vzb-tooltip-mobile');
	          //component events
	          this.on("resize", function() {
	            //console.log("EVENT: resize");
	            //return if updatesize exists with error
	            if(_this.updateSize()) return;
	            _this.updateMarkerSizeLimits();
	            _this.labels.updateSize();
	            _this._trails.run("findVisible");
	            _this._panZoom.rerun(); // includes redraw data points and trail resize
	          });
	
	          //keyboard listeners
	          d3.select("body")
	            .on("keydown", function() {
	              if(_this.model.ui.cursorMode !== 'arrow') return;
	              if(d3.event.metaKey || d3.event.ctrlKey) _this.element.select("svg").classed("vzb-zoomin", true);
	            })
	            .on("keyup", function() {
	              if(_this.model.ui.cursorMode !== 'arrow') return;
	              if(!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select("svg").classed("vzb-zoomin", false);
	            });
	              
	          this.root.on('resetZoom', function(){
	              _this._panZoom.reset(null, 500);
	          });
	
	          this.bubbleContainerCrop
	            .call(this._panZoom.zoomer)
	            .call(this._panZoom.dragRectangle)
	            .on('dblclick.zoom', null)
	            .on("mouseup", function() {
	              _this.draggingNow = false;
	            })
	            .on("click", function() {
	              var cursor = _this.model.ui.cursorMode;
	              if (!d3.event.defaultPrevented && cursor!=="arrow") {
	                _this._panZoom.zoomByIncrement(cursor, 500);
	              }
	            });
	
	          this.KEY = this.model.entities.getDimension();
	          this.TIMEDIM = this.model.time.getDimension();
	
	          this.updateUIStrings();
	
	          this.wScale = d3.scale.linear()
	            .domain(this.parent.datawarning_content.doubtDomain)
	            .range(this.parent.datawarning_content.doubtRange);
	          _this._readyOnce = true;
	        },
	        
	        _frameIsValid: function(frame) {
	          return !(!frame
	          || Object.keys(frame.axis_y).length === 0
	          || Object.keys(frame.axis_x).length === 0
	          || Object.keys(frame.size).length === 0);
	        },
	        
	        ready: function() {
	          var _this = this;
	          this.updateUIStrings();
	          var endTime = this.model.time.end;
	          this.model.marker.getFrame(this.model.time.value, function(frame, time) {
	            // TODO: temporary fix for case when after data loading time changed on validation
	              if (time.toString() != _this.model.time.value.toString()) {  
	                defer(function() {
	                  _this.ready();
	                });
	                return;
	              } 
	              if (!_this._frameIsValid(frame)) return;
	
	            _this.frame = frame;
	            _this.updateTime();
	            _this.updateIndicators();
	            _this.updateSize();
	            _this.updateEntities();
	            _this.redrawDataPoints();
	            _this.selectDataPoints();
	            _this._trails.create();
	            _this.updateMarkerSizeLimits();
	            _this.updateBubbleOpacity();
	            _this.zoomToMarkerMaxMin(); // includes redraw data points and trail resize
	            _this._trails.run(["recolor", "opacityHandler", "findVisible", "reveal"]);
	            if(_this.model.ui.adaptMinMaxZoom) _this._panZoom.expandCanvas();
	          });
	        },
	
	          /*
	           * Zoom to the min and max values given in the URL axes markers.
	           */
	          zoomToMarkerMaxMin: function() {
	              /*
	               * Reset just the zoom values without triggering a zoom event. This ensures
	               * a clean zoom state for the subsequent zoom event.
	               */
	              this._panZoom.resetZoomState()
	
	              var xAxis = this.model.marker.axis_x;
	              var yAxis = this.model.marker.axis_y;
	
	              var xDomain = xAxis.getScale().domain();
	              var yDomain = yAxis.getScale().domain();
	
	              /*
	               * The axes may return null when there is no value given for the zoomed
	               * min and max values. In that case, fall back to the axes' domain values.
	               */
	              var zoomedMinX = xAxis.zoomedMin ? xAxis.zoomedMin : xDomain[0];
	              var zoomedMaxX = xAxis.zoomedMax ? xAxis.zoomedMax : xDomain[1];
	              var zoomedMinY = yAxis.zoomedMin ? yAxis.zoomedMin : yDomain[0];
	              var zoomedMaxY = yAxis.zoomedMax ? yAxis.zoomedMax : yDomain[1];
	
	              this._panZoom.zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY);
	          },
	
	        /*
	         * UPDATE INDICATORS
	         */
	        updateIndicators: function() {
	          var _this = this;
	
	          //scales
	          this.yScale = this.model.marker.axis_y.getScale();
	          this.xScale = this.model.marker.axis_x.getScale();
	          this.sScale = this.model.marker.size.getScale();
	          this.cScale = this.model.marker.color.getScale();
	          this.labels.setScales(this.xScale, this.yScale);
	
	          this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());
	          this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());
	        },
	
	        frameChanged: function(frame, time) {
	      //    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
	          this.frame = frame;
	          this.updateTime();
	          this._updateDoubtOpacity();
	          this._trails.run("findVisible");
	          if(this.model.ui.adaptMinMaxZoom) {
	            this._panZoom.expandCanvas();
	          } else {
	            this.redrawDataPoints();
	          }
	          this._trails.run("reveal", null, this.duration);
	          this.tooltipMobile.classed('vzb-hidden', true);
	        },
	
	        updateUIStrings: function() {
	          var _this = this;
	
	          this.translator = this.model.language.getTFunction();
	
	          this.strings = {
	            title: {
	              Y: this.translator("indicator/" + this.model.marker.axis_y.which),
	              X: this.translator("indicator/" + this.model.marker.axis_x.which),
	              S: this.translator("indicator/" + this.model.marker.size.which),
	              C: this.translator("indicator/" + this.model.marker.color.which)
	            },
	            unit: {
	              Y: this.translator("unit/" + this.model.marker.axis_y.which),
	              X: this.translator("unit/" + this.model.marker.axis_x.which),
	              S: this.translator("unit/" + this.model.marker.size.which),
	              C: this.translator("unit/" + this.model.marker.color.which)
	            }
	          }
	          
	          //suppress unit strings that found no translation (returns same thing as requested)
	          if(this.strings.unit.Y === "unit/" + this.model.marker.axis_y.which) this.strings.unit.Y = "";
	          if(this.strings.unit.X === "unit/" + this.model.marker.axis_x.which) this.strings.unit.X = "";
	          if(this.strings.unit.S === "unit/" + this.model.marker.size.which) this.strings.unit.S = "";
	          if(this.strings.unit.C === "unit/" + this.model.marker.color.which) this.strings.unit.C = "";
	          
	          if(!!this.strings.unit.Y) this.strings.unit.Y = ", " + this.strings.unit.Y;
	          if(!!this.strings.unit.X) this.strings.unit.X = ", " + this.strings.unit.X;
	          if(!!this.strings.unit.S) this.strings.unit.S = ", " + this.strings.unit.S;
	          if(!!this.strings.unit.C) this.strings.unit.C = ", " + this.strings.unit.C;
	
	          var yTitle = this.yTitleEl.selectAll("text").data([0]);
	          yTitle.enter().append("text");
	          yTitle
	            //.attr("y", "-6px")
	            .on("click", function() {
	              _this.parent
	                .findChildByName("gapminder-treemenu")
	                .markerID("axis_y")
	                .alignX("left")
	                .alignY("top")
	                .updateView()
	                .toggle();
	            });
	
	          var xTitle = this.xTitleEl.selectAll("text").data([0]);
	          xTitle.enter().append("text");
	          xTitle
	            .on("click", function() {
	              _this.parent
	                .findChildByName("gapminder-treemenu")
	                .markerID("axis_x")
	                .alignX("left")
	                .alignY("bottom")
	                .updateView()
	                .toggle();
	            });
	
	          var sTitle = this.sTitleEl.selectAll("text").data([0]);
	          sTitle.enter().append("text");
	          sTitle
	            .attr("text-anchor", "end");
	
	          setIcon(this.dataWarningEl, iconWarn).select("svg").attr("width", "0px").attr("height", "0px");
	          this.dataWarningEl.append("text")
	            .attr("text-anchor", "end")
	            .text(this.translator("hints/dataWarning"));
	
	          setIcon(this.yInfoEl, iconQuestion)
	              .select("svg").attr("width", "0px").attr("height", "0px");
	
	          setIcon(this.xInfoEl, iconQuestion)
	            .select("svg").attr("width", "0px").attr("height", "0px");
	
	
	          //TODO: move away from UI strings, maybe to ready or ready once
	          this.yInfoEl.on("click", function() {
	            _this.parent.findChildByName("gapminder-datanotes").pin();
	          })
	          this.yInfoEl.on("mouseover", function() {
	            var rect = this.getBBox();
	            var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	            _this.parent.findChildByName("gapminder-datanotes").setHook('axis_y').show().setPos(coord.x, coord.y);
	          })
	          this.yInfoEl.on("mouseout", function() {
	            _this.parent.findChildByName("gapminder-datanotes").hide();
	          })
	          this.xInfoEl.on("click", function() {
	            _this.parent.findChildByName("gapminder-datanotes").pin();
	          })
	          this.xInfoEl.on("mouseover", function() {
	            if (_this.model.time.dragging) return;
	            var rect = this.getBBox();
	            var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	            _this.parent.findChildByName("gapminder-datanotes").setHook('axis_x').show().setPos(coord.x, coord.y);
	          })
	          this.xInfoEl.on("mouseout", function() {
	             if (_this.model.time.dragging) return;
	            _this.parent.findChildByName("gapminder-datanotes").hide();
	          })
	          this.dataWarningEl
	            .on("click", function() {
	              _this.parent.findChildByName("gapminder-datawarning").toggle();
	            })
	            .on("mouseover", function() {
	              _this._updateDoubtOpacity(1);
	            })
	            .on("mouseout", function() {
	              _this._updateDoubtOpacity();
	            })
	        },
	
	        _updateDoubtOpacity: function(opacity) {
	          if(opacity == null) opacity = this.wScale(+this.model.time.timeFormat(this.time));
	          if(this.someSelected) opacity = 1;
	          this.dataWarningEl.style("opacity", opacity);
	        },
	
	        /*
	         * UPDATE ENTITIES:
	         * Ideally should only update when show parameters change or data changes
	         */
	        updateEntities: function() {
	          var _this = this;
	          var KEY = this.KEY;
	          var TIMEDIM = this.TIMEDIM;
	
	          var getKeys = function(prefix) {
	            prefix = prefix || "";
	            return _this.model.marker.getKeys()
	              .map(function(d) {
	                var pointer = {};
	                pointer[KEY] = d[KEY];
	                pointer[TIMEDIM] = endTime;
	                pointer.sortValue = _this.frame.size[d[KEY]]||0;
	                pointer[KEY] = prefix + d[KEY];
	                return pointer;
	              })
	              .sort(function(a, b) {
	                return b.sortValue - a.sortValue;
	              })
	          };
	
	          // get array of GEOs, sorted by the size hook
	          // that makes larger bubbles go behind the smaller ones
	          var endTime = this.model.time.end;
	          this.model.entities.setVisible(getKeys.call(this));
	            
	          //unselecting bubbles with no data is used for the scenario when
	          //some bubbles are selected and user would switch indicator.
	          //bubbles would disappear but selection would stay
	          if (!this.model.time.splash) {
	            this.unselectBubblesWithNoData();
	          }
	
	          this.entityBubbles = this.bubbleContainer.selectAll('.vzb-bc-entity')
	            .data(this.model.entities.getVisible(), function(d) {return d && !d['trailStartTime'] ? d[KEY] : null}); // trails have not keys
	
	          //exit selection
	          this.entityBubbles.exit().remove();
	
	          //enter selection -- init circles
	          this.entityBubbles.enter().append("circle")
	            .attr("class", function(d) {
	              return "vzb-bc-entity " + "bubble-" + d[KEY];
	            })
	            .on("mouseover", function(d, i) {
	              if(isTouchDevice() || _this.model.ui.cursorMode !== 'arrow') return;
	              _this._bubblesInteract().mouseover(d, i);
	            })
	            .on("mouseout", function(d, i) {
	              if(isTouchDevice() || _this.model.ui.cursorMode !== 'arrow') return;
	
	              _this._bubblesInteract().mouseout(d, i);
	            })
	            .on("click", function(d, i) {
	              if(isTouchDevice() || _this.model.ui.cursorMode !== 'arrow') return;
	
	              _this._bubblesInteract().click(d, i);
	            })
	            .onTap(function(d, i) {
	              d3.event.stopPropagation();
	              _this._bubblesInteract().click(d, i);
	            })
	            .onLongTap(function(d, i) {});
	
	            this.entityBubbles.order();
	        },
	          
	        unselectBubblesWithNoData: function(frame){
	            var _this = this;
	            var KEY = this.KEY;
	            if(!frame) frame = this.frame;
	            
	            if(!frame || !frame.axis_y || !frame.axis_x || !frame.size) return;
	            
	            this.model.entities.select.forEach(function(d){
	              if(!frame.axis_y[d[KEY]] && frame.axis_y[d[KEY]] !== 0
	              || !frame.axis_x[d[KEY]] && frame.axis_x[d[KEY]] !== 0
	              || !frame.size[d[KEY]] && frame.size[d[KEY]] !== 0) 
	                  _this.model.entities.selectEntity(d);
	            })
	        },
	
	        _bubblesInteract: function() {
	          var _this = this;
	          var KEY = this.KEY;
	          var TIMEDIM = this.TIMEDIM;
	
	          return {
	            mouseover: function(d, i) {
	              _this.model.entities.highlightEntity(d);
	
	              _this.labels.showCloseCross(d, true);
	            },
	
	            mouseout: function(d, i) {
	              _this.model.entities.clearHighlighted();
	
	              _this.labels.showCloseCross(d, false);
	            },
	
	            click: function(d, i) {
	              if(_this.draggingNow) return;
	              var isSelected = _this.model.entities.isSelected(d);
	              _this.model.entities.selectEntity(d);
	              //return to highlighted state
	              if(!isTouchDevice()) {
	                  if(isSelected) _this.model.entities.highlightEntity(d);
	                  _this.highlightDataPoints();
	              }
	            }
	          }
	        },
	
	
	
	
	        /*
	         * UPDATE TIME:
	         * Ideally should only update when time or data changes
	         */
	        updateTime: function() {
	          var _this = this;
	
	          this.time_1 = this.time == null ? this.model.time.value : this.time;
	          this.time = this.model.time.value;
	          this.duration = this.model.time.playing && (this.time - this.time_1 > 0) ? this.model.time.delayAnimations : 0;
	          if(this.duration) {
	            var time = _this.time;
	            this.yearDelayId = delay(function() {
	              _this.year.setText(_this.model.time.timeFormat(time));
	            }, this.duration);
	          } else {
	            if(this.yearDelayId) {
	              clearDelay(this.yearDelayId);
	              this.yearDelayId = null;
	            }
	            _this.year.setText(_this.model.time.timeFormat(_this.time));
	          }
	        },
	
	        /*
	         * RESIZE:
	         * Executed whenever the container is resized
	         */
	        updateSize: function() {
	
	
	          var profiles = {
	            small: {
	              margin: { top: 30, right: 10, left: 40, bottom: 35 },
	              padding: 2,
	              minRadius: 0.5,
	              maxRadius: 30,
	              infoElHeight: 16,
	              yAxisTitleBottomMargin: 6,
	              xAxisTitleBottomMargin: 4
	            },
	            medium: {
	              margin: { top: 40, right: 15, left: 60, bottom: 55 },
	              padding: 2,
	              minRadius: 1,
	              maxRadius: 55,
	              infoElHeight: 20,
	              yAxisTitleBottomMargin: 6,
	              xAxisTitleBottomMargin: 5
	            },
	            large: {
	              margin: { top: 50, right: 20, left: 60, bottom: 60 },
	              padding: 2,
	              minRadius: 1,
	              maxRadius: 65,
	              infoElHeight: 22,
	              yAxisTitleBottomMargin: 6,
	              xAxisTitleBottomMargin: 5,
	              hideSTitle: true 
	            }
	          };
	
	          var presentationProfileChanges = {
	            "medium": {
	              margin: { top: 80, bottom: 80, left: 100 },
	              yAxisTitleBottomMargin: 20,
	              xAxisTitleBottomMargin: 20,
	              infoElHeight: 26,
	            },
	            "large": {
	              margin: { top: 80, bottom: 100, left: 100 },
	              yAxisTitleBottomMargin: 20,
	              xAxisTitleBottomMargin: 20,
	              infoElHeight: 32,
	              hideSTitle: true
	            }
	          }
	
	          var _this = this;
	
	          this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);
	          var margin = this.activeProfile.margin;
	          var infoElHeight = this.activeProfile.infoElHeight;
	          
	          //labels
	          _this.labels.setCloseCrossHeight(_this.activeProfile.infoElHeight * 1.2);
	
	          //stage
	          this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	            
	          if(this.height<=0 || this.width<=0) return warn("Bubble chart updateSize() abort: vizabi container is too little or has display:none");
	
	          //graph group is shifted according to margins (while svg element is at 100 by 100%)
	          this.graph
	            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	          this.year.resize(this.width, this.height, Math.min(this.width/2.5, Math.max(this.height / 3, this.width / 3)));
	          this.eventArea
	            .attr("width", this.width)
	            .attr("height", Math.max(0, this.height));
	
	          //update scales to the new range
	          if(this.model.marker.axis_y.scaleType !== "ordinal") {
	            this.yScale.range(this._rangeBump([this.height, 0]));
	          } else {
	            this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();
	          }
	          if(this.model.marker.axis_x.scaleType !== "ordinal") {
	            this.xScale.range(this._rangeBump([0, this.width]));
	          } else {
	            this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();
	          }
	
	          //apply scales to axes and redraw
	          this.yAxis.scale(this.yScale)
	            .orient("left")
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_y.scaleType,
	              toolMargin: margin,
	              limitMaxTickNumber: 6,
	              bump: this.activeProfile.maxRadius/2,
	              constantRakeLength: this.height,
	              formatter: this.model.marker.axis_y.getTickFormatter()
	            });
	
	          this.xAxis.scale(this.xScale)
	            .orient("bottom")
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_x.scaleType,
	              toolMargin: margin,
	              bump: this.activeProfile.maxRadius/2,
	              constantRakeLength: this.width,
	              formatter: this.model.marker.axis_x.getTickFormatter()
	            });
	
	
	          this.bubbleContainerCrop
	            .attr("width", this.width)
	            .attr("height", Math.max(0, this.height));
	
	          this.labelsContainerCrop
	            .attr("width", this.width)
	            .attr("height", Math.max(0, this.height));
	
	          this.xAxisElContainer
	            .attr("width", this.width + 1)
	            .attr("height", this.activeProfile.margin.bottom)
	            .attr("y", this.height - 1)
	            .attr("x", -1);
	          this.xAxisEl
	            .attr("transform", "translate(1,1)");
	
	          this.yAxisElContainer
	            .attr("width", this.activeProfile.margin.left)
	            .attr("height", Math.max(0, this.height))
	            .attr("x", -this.activeProfile.margin.left);
	          this.yAxisEl
	            .attr("transform", "translate(" + (this.activeProfile.margin.left - 1) + "," + 0 + ")");
	
	          this.yAxisEl.call(this.yAxis);
	          this.xAxisEl.call(this.xAxis);
	
	          this.projectionX.attr("y1", _this.yScale.range()[0] + this.activeProfile.maxRadius/2);
	          this.projectionY.attr("x2", _this.xScale.range()[0] - this.activeProfile.maxRadius/2);
	
	
	
	          // reduce font size if the caption doesn't fit
	          this._updateSTitle();
	
	
	          var yaxisWidth = this.yAxisElContainer.select("g").node().getBBox().width;
	          this.yTitleEl
	            .style("font-size", infoElHeight + "px")
	            .attr("transform", "translate(" + (-yaxisWidth) + ", -" + this.activeProfile.yAxisTitleBottomMargin + ")");
	
	          this.xTitleEl
	            .style("font-size", infoElHeight + "px")
	            .attr("transform", "translate(" + (0) + "," + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + ")");
	
	          this.sTitleEl
	            .attr("transform", "translate(" + this.width + "," + 20 + ") rotate(-90)");
	
	
	          var yTitleText = this.yTitleEl.select("text").text(this.strings.title.Y + this.strings.unit.Y);
	          if(yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title.Y);
	
	          var xTitleText = this.xTitleEl.select("text").text(this.strings.title.X + this.strings.unit.X);
	          if(xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title.X);
	
	          if(this.yInfoEl.select('svg').node()) {
	            var titleBBox = this.yTitleEl.node().getBBox();
	            var translate = d3.transform(this.yTitleEl.attr('transform')).translate;
	
	            this.yInfoEl.select('svg')
	              .attr("width", infoElHeight + "px")
	              .attr("height", infoElHeight + "px")
	            this.yInfoEl.attr('transform', 'translate('
	              + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	              + (translate[1] - infoElHeight * 0.8) + ')');
	          }
	
	          if(this.xInfoEl.select('svg').node()) {
	            var titleBBox = this.xTitleEl.node().getBBox();
	            var translate = d3.transform(this.xTitleEl.attr('transform')).translate;
	
	            this.xInfoEl.select('svg')
	              .attr("width", infoElHeight + "px")
	              .attr("height", infoElHeight + "px")
	            this.xInfoEl.attr('transform', 'translate('
	              + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	              + (translate[1] - infoElHeight * 0.8) + ')');
	          }
	
	          this._resizeDataWarning();
	        },
	
	        _resizeDataWarning: function(){
	          this.dataWarningEl
	            .attr("transform", "translate("
	              + (this.width) + ","
	              + (this.height + this.activeProfile.margin.bottom - this.activeProfile.xAxisTitleBottomMargin)
	              + ")");
	
	          // reset font size to remove jumpy measurement
	          var dataWarningText = this.dataWarningEl.select("text").style("font-size", null);
	
	          // reduce font size if the caption doesn't fit
	          var dataWarningWidth = dataWarningText.node().getBBox().width + dataWarningText.node().getBBox().height * 3;
	          var remainingWidth = this.width - this.xTitleEl.node().getBBox().width - this.activeProfile.infoElHeight;
	          var font = parseInt(dataWarningText.style("font-size")) * remainingWidth / dataWarningWidth;
	          dataWarningText.style("font-size", dataWarningWidth > remainingWidth? font + "px" : null);
	
	          // position the warning icon
	          var warnBB = dataWarningText.node().getBBox();
	          this.dataWarningEl.select("svg")
	            .attr("width", warnBB.height * 0.75)
	            .attr("height", warnBB.height * 0.75)
	            .attr("x", -warnBB.width - warnBB.height * 1.2)
	            .attr("y", - warnBB.height * 0.65);
	        },
	
	        updateMarkerSizeLimits: function() {
	          var _this = this;
	          var extent = this.model.marker.size.extent || [0,1];
	            
	          if(!this.activeProfile) return warn("updateMarkerSizeLimits() is called before ready(). This can happen if events get unfrozen and getFrame() still didn't return data");
	            
	          var minRadius = this.activeProfile.minRadius;
	          var maxRadius = this.activeProfile.maxRadius;
	
	          this.minRadius = Math.max(maxRadius * extent[0], minRadius);
	          this.maxRadius = Math.max(maxRadius * extent[1], minRadius);
	
	          if(this.model.marker.size.scaleType !== "ordinal") {
	            this.sScale.range([radiusToArea(_this.minRadius), radiusToArea(_this.maxRadius)]);
	          } else {
	            this.sScale.rangePoints([radiusToArea(_this.minRadius), radiusToArea(_this.maxRadius)], 0).range();
	          }
	
	        },
	
	        redrawDataPointsOnlyColors: function() {
	          var _this = this;
	
	          var valuesNow;
	          var KEY = this.KEY;
	
	
	          var time = this.model.time.value;
	
	          if(this.model.ui.chart.lockNonSelected && this.someSelected) {
	            time = this.model.time.timeFormat.parse("" + this.model.ui.chart.lockNonSelected);
	          }
	          this.model.marker.getFrame(time, function(valuesLocked) {
	            if(!_this._frameIsValid(valuesLocked)) return warn("redrawDataPointsOnlyColor: empty data received from marker.getFrames(). doing nothing");
	
	            valuesNow = _this.frame;
	            _this.entityBubbles.each(function(d, index) {
	
	            var selected = _this.model.entities.isSelected(d);
	
	            var valueC = selected ? valuesNow.color[d[KEY]] : valuesLocked.color[d[KEY]];
	
	            var scaledC = valueC!=null?_this.cScale(valueC):_this.COLOR_WHITEISH;
	
	            d3.select(this).style("fill", scaledC);
	
	            //update lines of labels
	            if(selected) {
	
	              var select = find(_this.model.entities.select, function(f) {
	                return f[KEY] == d[KEY]
	              });
	
	              var trailStartTime = _this.model.time.timeFormat.parse("" + select.trailStartTime);
	
	              _this.model.marker.getFrame(trailStartTime, function(valuesTrailStart) {
	                if(!valuesTrailStart) return warn("redrawDataPointsOnlyColor: empty data received from marker.getFrames(). doing nothing");
	                
	                var cache = {};
	                if(!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {
	                  cache.scaledC0 = scaledC;
	                } else {
	                  var valueC = valuesTrailStart.color[d[KEY]];
	                  cache.scaledC0 = valueC!=null?_this.cScale(valueC):_this.COLOR_WHITEISH;
	                }
	                
	                _this.labels.updateLabelOnlyColor(d, index, cache);
	
	              });
	            }
	          });
	          });
	
	        },
	
	        redrawDataPointsOnlySize: function() {
	          var _this = this;
	
	          var valuesNow;
	          var KEY = this.KEY;
	
	
	          var time = this.model.time.value;
	
	          if(this.model.ui.chart.lockNonSelected && this.someSelected) {
	            time = this.model.time.timeFormat.parse("" + this.model.ui.chart.lockNonSelected);
	          }
	          this.model.marker.getFrame(time, function(valuesLocked) {
	            if(!_this._frameIsValid(valuesLocked)) return warn("redrawDataPointsOnlySize: empty data received from marker.getFrames(). doing nothing");
	
	            valuesNow = _this.frame;
	            _this.entityBubbles.each(function(d, index) {
	
	            var selected = _this.model.entities.isSelected(d);
	
	            var valueS = selected ? valuesNow.size[d[KEY]] : valuesLocked.size[d[KEY]];
	            if(valueS == null) return;
	
	            var scaledS = areaToRadius(_this.sScale(valueS));
	            d3.select(this).attr("r", scaledS);
	
	            //update lines of labels
	            if(selected) {
	
	              var select = find(_this.model.entities.select, function(f) {
	                return f[KEY] == d[KEY]
	              });
	
	              var trailStartTime = _this.model.time.timeFormat.parse("" + select.trailStartTime);
	
	              _this.model.marker.getFrame(trailStartTime, function(valuesTrailStart) {
	                if(!valuesTrailStart) return warn("redrawDataPointsOnlySize: empty data received from marker.getFrames(). doing nothing");
	                
	                var cache = {};
	                if(!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {
	                  cache.scaledS0 = scaledS;
	                } else {
	                  cache.scaledS0 = areaToRadius(_this.sScale(valuesTrailStart.size[d[KEY]]));
	                }
	                
	                _this.labels.updateLabelOnlyPosition(d, index, cache);
	
	              });
	            }
	          });
	          });
	        },
	
	        /*
	         * REDRAW DATA POINTS:
	         * Here plotting happens
	         * debouncing to improve performance: events might trigger it more than 1x
	         */
	        redrawDataPoints: function(duration) {
	          var _this = this;
	          var KEY = this.KEY;
	          if(duration == null) duration = _this.duration;
	
	          if(this.model.ui.chart.lockNonSelected && this.someSelected) {
	              var time = this.model.time.timeFormat.parse("" + this.model.ui.chart.lockNonSelected);
	
	              //get values for locked frames
	              this.model.marker.getFrame(time, function(lockedFrame) {
	                  if(!lockedFrame) return warn("redrawDataPoints: empty data received from marker.getFrames(). doing nothing");
	
	                  // each bubble
	                  _this.entityBubbles.each(function(d, index) {
	                      var frame = _this.model.entities.isSelected(d) ? _this.frame : lockedFrame
	                      _this._updateBubble(d, frame, index, d3.select(this), duration);
	                  });
	              });
	          } else {
	              // each bubble
	              _this.entityBubbles.each(function(d, index) {
	                  _this._updateBubble(d, _this.frame, index, d3.select(this), duration);
	              });
	          }
	        },
	
	        //redraw Data Points
	        _updateBubble: function(d, values, index, view, duration) {
	          var _this = this;
	          var KEY = this.KEY;
	
	          var showhide = false;
	
	          var valueY = values.axis_y[d[KEY]];
	          var valueX = values.axis_x[d[KEY]];
	          var valueS = values.size[d[KEY]];
	          var valueL = values.label[d[KEY]];
	          var valueC = values.color[d[KEY]];
	          var valueLST = values.size_label[d[KEY]];
	
	          // check if fetching data succeeded
	          if(!valueL && valueL!==0 || !valueY && valueY!==0 || !valueX && valueX!==0 || !valueS && valueS!==0) {
	            // if entity is missing data it should hide
	             if(!d.hidden) {
	                 d.hidden = true;
	                 showhide = true;
	             }
	              
	             if(showhide) {
	                 if(duration) {
	                     var opacity = view.style("opacity");
	                     view.transition().duration(duration).ease("exp")
	                      .style("opacity", 0)
	                      .each("end", function() {
	                          //to avoid transition from null state add class with a delay
	                          view.classed("vzb-invisible", d.hidden);
	                          view.style("opacity", opacity);
	                      })
	                 }else{
	                     //immediately hide the bubble
	                     view.classed("vzb-invisible", d.hidden);
	                 }
	             }
	          } else {
	              if(d.hidden || view.classed("vzb-invisible")) {
	                 d.hidden = false;
	                 showhide = true;
	             }
	
	
	            // if entity has all the data we update the visuals
	            var scaledS = areaToRadius(_this.sScale(valueS));
	
	            view.style("fill", valueC!=null?_this.cScale(valueC):_this.COLOR_WHITEISH);
	
	            if(duration) {
	              if(showhide) {
	                  var opacity = view.style("opacity");
	                  view.classed("vzb-invisible", d.hidden);
	                  view.style("opacity", 0)
	                      .attr("cy", _this.yScale(valueY))
	                      .attr("cx", _this.xScale(valueX))
	                      .attr("r", scaledS)
	                      .transition().duration(duration).ease("exp")
	                      .style("opacity", opacity);
	              }else{
	                  view.transition().duration(duration).ease("linear")
	                      .attr("cy", _this.yScale(valueY))
	                      .attr("cx", _this.xScale(valueX))
	                      .attr("r", scaledS);
	              }
	
	            } else {
	
	              //interrupt the ongoing transition and immediately do the visual updates
	              view.interrupt()
	                .attr("cy", _this.yScale(valueY))
	                .attr("cx", _this.xScale(valueX))
	                .attr("r", scaledS);
	
	              //show entity if it was hidden
	              if(showhide) view.classed("vzb-invisible", d.hidden);
	            }
	
	            if(this.model.time.record) _this._export.write({
	              type: "circle",
	              id: d[KEY],
	              time: this.model.time.value.getUTCFullYear(),
	              fill: valueC!=null?_this.cScale(valueC):_this.COLOR_WHITEISH,
	              cx: _this.xScale(valueX),
	              cy: _this.yScale(valueY),
	              r: scaledS
	            });
	
	          } // data exists
	
	          _this._updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide);
	        },
	
	        _updateLabel: function(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {
	          var _this = this;
	          var KEY = this.KEY;
	
	          // only for selected entities
	          if(_this.model.entities.isSelected(d)) {
	            
	            var cache = null;
	
	            var select = find(_this.model.entities.select, function(f) {
	              return f[KEY] == d[KEY]
	            });
	
	            var time = _this.model.time.timeFormat(_this.time);
	            if(!this.model.ui.chart.trails || select.trailStartTime == time || select.trailStartTime == null) {
	              if(this.model.ui.chart.trails && select.trailStartTime == null) select.trailStartTime = time; // need only when trailStartTime == null
	
	              var cache = {};
	              cache.labelX0 = valueX;
	              cache.labelY0 = valueY;
	              cache.scaledC0 = valueC!=null?_this.cScale(valueC):_this.COLOR_WHITEISH,
	              cache.scaledS0 = (valueS || valueS===0) ? areaToRadius(_this.sScale(valueS)) : null;
	            }
	
	            var trailStartTime = _this.model.time.timeFormat.parse("" + select.trailStartTime);
	
	            var labelText = valueL + (_this.model.ui.chart.trails ? " " + select.trailStartTime : "");
	
	            if(showhide && d.hidden && _this.model.ui.chart.trails && trailStartTime && (trailStartTime < _this.time)) showhide = false;
	            if(d.hidden && !_this.model.ui.chart.trails) showhide = true;
	
	            this.labels.updateLabel(d, index, cache, valueX, valueY, valueS, valueC, labelText, valueLST, duration, showhide);
	
	          }
	        },
	
	        _updateSTitle: function(titleS, titleC) {
	
	          // vertical text about size and color
	          if (this.activeProfile.hideSTitle) {
	            this.sTitleEl.classed("vzb-invisible", true);
	            return;
	          }
	          if (this.sTitleEl.classed("vzb-invisible")) {
	            this.sTitleEl.classed("vzb-invisible", false);
	          }
	          var sTitleContentON = this.model.marker.size.use !== "constant";
	          var cTitleContentON = this.model.marker.color.use !== "constant";
	          var sTitleText = this.sTitleEl.select("text")
	            // reset font size to remove jumpy measurement
	            .style("font-size", null)
	            .text(
	            (sTitleContentON ? this.translator("buttons/size") + ": " + (titleS ? titleS : this.strings.title.S) : "") +
	            (sTitleContentON && cTitleContentON ? ", " : "") +
	            (cTitleContentON ? this.translator("buttons/colors") + ": " + (titleC ? titleC : this.strings.title.C) : "")
	          );
	          var sTitleWidth = sTitleText.node().getBBox().width;
	          var remainigHeight = this.height - 30;
	          var font = parseInt(sTitleText.style("font-size")) * remainigHeight / sTitleWidth;
	          sTitleText.style("font-size", sTitleWidth > remainigHeight? font + "px" : null);
	        },
	        
	        selectDataPoints: function() {
	          var _this = this;
	          var KEY = this.KEY;
	
	          //hide tooltip
	          _this._setTooltip();
	          _this._setBubbleCrown();
	
	          _this.someSelected = (_this.model.entities.select.length > 0);
	
	        },
	
	        _setBubbleCrown: function(x, y, r, glow, skipInnerFill) {
	          if(x != null) {
	            this.bubbleCrown.classed("vzb-hidden", false);
	            this.bubbleCrown.select(".vzb-crown")
	              .attr("cx", x)
	              .attr("cy", y)
	              .attr("r", r)
	              .attr("fill", skipInnerFill ? "none" : glow);
	            this.bubbleCrown.selectAll(".vzb-crown-glow")
	              .attr("cx", x)
	              .attr("cy", y)
	              .attr("r", r + 10)
	              .attr("stroke", glow);
	
	          } else {
	            this.bubbleCrown.classed("vzb-hidden", true);
	          }
	
	        },
	        
	        _setTooltip: function(tooltipText, x, y, offset, glow) {
	          if(tooltipText) {
	            var xPos, yPos, xSign = -1,
	              ySign = -1,
	              xOffset = 0,
	              yOffset = 0;
	
	            if(offset) {
	              xOffset = offset * .71; // .71 - sin and cos for 315
	              yOffset = offset * .71;
	            }
	            //position tooltip
	            this.tooltip.classed("vzb-hidden", false)
	              //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
	              .selectAll("text")
	              .text(tooltipText);
	
	            var contentBBox = this.tooltip.select('text')[0][0].getBBox();
	            if(x - xOffset - contentBBox.width < 0) {
	              xSign = 1;
	              x += contentBBox.width + 5; // corrective to the block Radius and text padding
	            } else {
	              x -= 5; // corrective to the block Radius and text padding
	            }
	            if(y - yOffset - contentBBox.height < 0) {
	              ySign = 1;
	              y += contentBBox.height;
	            } else {
	              y -= 11; // corrective to the block Radius and text padding
	            }
	            if(offset) {
	              xPos = x + xOffset * xSign;
	              yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
	            } else {
	              xPos = x + xOffset * xSign; // .71 - sin and cos for 315
	              yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
	            }
	            this.tooltip.attr("transform", "translate(" + xPos + "," + yPos + ")")
	
	            this.tooltip.selectAll("rect")
	              .attr("width", contentBBox.width + 8)
	              .attr("height", contentBBox.height * 1.2)
	              .attr("x", -contentBBox.width - 4)
	              .attr("y", -contentBBox.height * .85)
	              .attr("rx", contentBBox.height * .2)
	              .attr("ry", contentBBox.height * .2);
	
	            this.tooltip.select(".vzb-tooltip-glow")
	              .attr("stroke", glow);
	
	          } else {
	            this.tooltip.classed("vzb-hidden", true);
	          }
	        },
	
	        /*
	         * Shows and hides axis projections
	         */
	        _axisProjections: function(d) {
	          var _this = this;
	          var TIMEDIM = this.TIMEDIM;
	          var KEY = this.KEY;
	
	          if(d != null) {
	
	            this.model.marker.getFrame(d[TIMEDIM], function(values) {
	              var valueY = values.axis_y[d[KEY]];
	              var valueX = values.axis_x[d[KEY]];
	              var valueS = values.size[d[KEY]];
	              var radius = areaToRadius(_this.sScale(valueS));
	
	              if(!valueY && valueY!==0 || !valueX && valueX!==0 || !valueS && valueS!==0) return;
	
	              if(_this.ui.chart.whenHovering.showProjectionLineX
	                && _this.xScale(valueX) > 0 && _this.xScale(valueX) < _this.width
	                && (_this.yScale(valueY) + radius) < _this.height) {
	                _this.projectionX
	                  .style("opacity", 1)
	                  .attr("y2", _this.yScale(valueY) + radius)
	                  .attr("x1", _this.xScale(valueX))
	                  .attr("x2", _this.xScale(valueX));
	              }
	
	              if(_this.ui.chart.whenHovering.showProjectionLineY
	                && _this.yScale(valueY) > 0 && _this.yScale(valueY) < _this.height
	                && (_this.xScale(valueX) - radius) > 0) {
	                _this.projectionY
	                  .style("opacity", 1)
	                  .attr("y1", _this.yScale(valueY))
	                  .attr("y2", _this.yScale(valueY))
	                  .attr("x1", _this.xScale(valueX) - radius);
	              }
	
	              if(_this.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(
	                _this.xAxis.highlightValue(valueX)
	              );
	
	              if(_this.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(
	                _this.yAxis.highlightValue(valueY)
	              );
	            });
	
	          } else {
	
	            this.projectionX.style("opacity", 0);
	            this.projectionY.style("opacity", 0);
	            this.xAxisEl.call(this.xAxis.highlightValue("none"));
	            this.yAxisEl.call(this.yAxis.highlightValue("none"));
	
	          }
	
	        },
	
	        /*
	         * Highlights all hovered bubbles
	         */
	        highlightDataPoints: function() {
	          var _this = this;
	          var TIMEDIM = this.TIMEDIM;
	          var KEY = this.KEY;
	
	          this.someHighlighted = (this.model.entities.highlight.length > 0);
	
	          this.updateBubbleOpacity();
	
	          if(this.model.entities.highlight.length === 1) {
	            var d = clone(this.model.entities.highlight[0]);
	
	            if(_this.model.ui.chart.lockNonSelected && _this.someSelected && !_this.model.entities.isSelected(d)) {
	              d[TIMEDIM] = _this.model.time.timeFormat.parse("" + _this.model.ui.chart.lockNonSelected);
	            } else {
	              d[TIMEDIM] = _this.model.time.timeFormat.parse("" + d.trailStartTime) || _this.time;
	            }
	
	            _this.model.marker.getFrame(d[TIMEDIM], function(values) {
	                var x = _this.xScale(values.axis_x[d[KEY]]);
	                var y = _this.yScale(values.axis_y[d[KEY]]);
	                var s = areaToRadius(_this.sScale(values.size[d[KEY]]));
	                var c = values.color[d[KEY]]!=null?_this.cScale(values.color[d[KEY]]):_this.COLOR_WHITEISH;
	                var entityOutOfView = false;
	
	                var unitY = _this.translator("unit/" + _this.model.marker.size.which);
	                var unitC = _this.translator("unit/" + _this.model.marker.color.which);
	        
	                //suppress unit strings that found no translation (returns same thing as requested)
	                if(unitY === "unit/" + _this.model.marker.size.which) unitY = "";
	                if(unitC === "unit/" + _this.model.marker.color.which) unitC = "";
	              
	                var formatterS = _this.model.marker.size.getTickFormatter();
	                var formatterC = _this.model.marker.color.getTickFormatter();
	                _this._updateSTitle(
	                  formatterS(values.size[d[KEY]])  + " " + unitY,
	                  values.color[d[KEY]] || values.color[d[KEY]]===0 ? formatterC(values.color[d[KEY]]) + " " + unitC : _this.translator("hints/nodata")
	                );
	                if(x + s < 0 || x - s > _this.width || y + s < 0 || y - s > _this.height) {
	                  entityOutOfView = true;
	                }
	                
	                //show tooltip
	                var text = "";
	                var hoverTrail = false;
	                if(_this.model.entities.isSelected(d) && _this.model.ui.chart.trails) {
	                  text = _this.model.time.timeFormat(_this.time);
	                  var selectedData = find(_this.model.entities.select, function(f) {
	                    return f[KEY] == d[KEY]
	                  });
	                  hoverTrail = text !== selectedData.trailStartTime && !d3.select(d3.event.target).classed('bubble-' + d[KEY]);
	                  text = text !== selectedData.trailStartTime && _this.time === d[TIMEDIM] ? text : '';
	                } else {
	                  text = _this.model.entities.isSelected(d) ? '': values.label[d[KEY]];
	                }
	
	                _this.labels.highlight(d, true);
	                if(_this.model.entities.isSelected(d)) {
	                  var skipCrownInnerFill = !d.trailStartTime || d.trailStartTime == _this.model.time.timeFormat(_this.time);
	                  _this._setBubbleCrown(x, y, s, c, skipCrownInnerFill);
	                }
	                
	                if(!entityOutOfView && !hoverTrail) {
	                  _this._axisProjections(d);
	                }
	
	                //set tooltip and show axis projections
	                if(text && !entityOutOfView && !hoverTrail) {
	                  _this._setTooltip(text, x, y, s + 3, c);
	                }
	
	                var selectedData = find(_this.model.entities.select, function(f) {
	                  return f[KEY] == d[KEY];
	                });
	                if(selectedData) {
	                  var clonedSelectedData = clone(selectedData);
	                  //change opacity to OPACITY_HIGHLT = 1.0;
	                  clonedSelectedData.opacity = 1.0;
	                  _this._trails.run(["opacityHandler"], clonedSelectedData);
	                }
	              });
	            } else {
	              this._axisProjections();
	              this._trails.run(["opacityHandler"]);
	              //hide tooltip
	              _this._updateSTitle();  
	              this._setTooltip();
	              this._setBubbleCrown();
	              this.labels.highlight(null, false);
	            }
	
	        },
	
	        updateBubbleOpacity: function(duration) {
	          var _this = this;
	          //if(!duration)duration = 0;
	
	          var OPACITY_HIGHLT = 1.0;
	          var OPACITY_HIGHLT_DIM = this.model.entities.opacityHighlightDim;
	          var OPACITY_SELECT = this.model.entities.opacityRegular;
	          var OPACITY_REGULAR = this.model.entities.opacityRegular;
	          var OPACITY_SELECT_DIM = this.model.entities.opacitySelectDim;
	
	          this.entityBubbles
	            //.transition().duration(duration)
	            .style("opacity", function(d) {
	
	              if(_this.someHighlighted) {
	                //highlight or non-highlight
	                if(_this.model.entities.isHighlighted(d)) return OPACITY_HIGHLT;
	              }
	
	              if(_this.someSelected) {
	                //selected or non-selected
	                return _this.model.entities.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
	              }
	
	              if(_this.someHighlighted) return OPACITY_HIGHLT_DIM;
	
	              return OPACITY_REGULAR;
	            });
	
	
	          var someSelectedAndOpacityZero = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	
	          // when pointer events need update...
	          if(someSelectedAndOpacityZero != this.someSelectedAndOpacityZero_1) {
	            this.entityBubbles.style("pointer-events", function(d) {
	              return(!someSelectedAndOpacityZero || _this.model.entities.isSelected(d)) ?
	                "visible" : "none";
	            });
	          }
	
	          this.someSelectedAndOpacityZero_1 = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	        }
	
	      });
	
	      var BubbleChart = Tool.extend('BubbleChart', {
	
	        /**
	         * Initializes the tool (Bubble Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	
	          this.name = "bubblechart";
	
	          //specifying components
	          this.components = [{
	            component: BubbleChartComp,
	            placeholder: '.vzb-tool-viz',
	            model: ["state.time", "state.entities", "state.marker", "language", "ui"] //pass models to component
	          }, {
	            component: Labels,
	            placeholder: '.vzb-tool-labels',
	            model: ["state.entities", "state.marker", "ui"]
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }, {
	            component: DataWarning,
	            placeholder: '.vzb-tool-datawarning',
	            model: ['language']
	          }, {
	            component: DataNotes,
	            placeholder: '.vzb-tool-datanotes',
	            model: ['state.marker', 'language']
	          }];
	
	          this._super(placeholder, external_model);
	
	        },
	        
	        validate: function(model){
	          model = this.model || model;
	          
	          this._super(model);
	          
	          if(model.ui.chart.lockNonSelected) {
	             var time = model.state.time.timeFormat.parse("" + model.ui.chart.lockNonSelected);
	             if(time < model.state.time.start) model.ui.chart.lockNonSelected = model.state.time.timeFormat(model.state.time.start);
	             if(time > model.state.time.end) model.ui.chart.lockNonSelected = model.state.time.timeFormat(model.state.time.end);       
	          }
	        },
	
	        /**
	         * Determines the default model of this tool
	         */
	        default_model: {
	          state: {
	            time: {
	              round: "ceil"
	            },
	            entities: {
	              dim: "geo",
	              show: {
	                _defs_: {
	                  "geo": ["*"],
	                  "geo.cat": ["country"]
	                }
	              },
	              opacitySelectDim: .3,
	              opacityRegular: 1,
	            },
	            marker: {
	              space: ["entities", "time"],
	              type: "geometry",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              size_label: {
	                  use: "constant"
	              },
	              axis_y: {
	                use: "indicator",
	                which: "lex"
	              },
	              axis_x: {
	                use: "indicator",
	                which: "gdp_pc"
	              },
	              color: {
	                use: "property",
	                which: "geo.world_4region"
	              },
	              size: {
	                use: "indicator",
	                which: "pop"
	              }
	            }
	          },
	          ui: {
	            chart: {
	              whenHovering: {
	                showProjectionLineX: true,
	                showProjectionLineY: true,
	                higlightValueX: true,
	                higlightValueY: true
	              },
	              labels: {
	                dragging: true,
	                removeLabelBox: false
	              },
	              trails: true,
	              lockNonSelected: 0
	            },
	            presentation: true,
	            adaptMinMaxZoom: false
	          }
	        }
	      });
	
	      /*!
	       * VIZABI POP BY AGE Component
	       */
	
	
	      //POP BY AGE CHART COMPONENT
	      var BarRankChart$1 = Component.extend({
	
	        /**
	         * Initializes the component (Bar Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The config passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function(config, context) {
	
	          this.name = 'barrankchart-component';
	          this.template = 'barrank.html';
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }, {
	            name: "ui",
	            type: "model"
	          }];
	
	          var _this = this;
	          this.model_binds = {
	            "change:time.value": function(evt) {
	              if(!_this._readyOnce) return;
	              _this.onTimeChange();
	            },
	            "change:entities.select": function(evt) {
	              if(!_this._readyOnce) return;
	              _this.selectBars();
	            },
	            "change:marker.axis_x.scaleType": function(evt) {
	              if(!_this._readyOnce) return;
	              _this.draw();
	            },
	            'change:marker.color.palette': function() {
	              //console.log("EVENT change:marker:color:palette");
	              //_this.drawColors();
	            },
	          };
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          // set up the scales
	          this.xScale = null;
	          this.cScale = d3.scale.category10();
	
	          // set up the axes
	          this.xAxis = axisSmart();
	        },
	
	        onTimeChange: function() {
	          //this.year.setText(this.model.time.timeFormat(this.model.time.value));
	          var _this = this;
	          this.model.marker.getFrame(this.model.time.value, function(values) {
	            _this.values = values;
	            _this.loadData();
	            _this.draw();
	          });
	        },
	
	        /**
	         * DOM and model are ready
	         */
	        readyOnce: function() {
	          this.element = d3.select(this.element);
	
	          // reference elements
	          //this.graph = this.element.select('.vzb-br-graph');
	          //this.yearEl = this.element.select('.vzb-br-year');
	          //this.year = new DynamicBackground(this.yearEl);
	          this.header = this.element.select('.vzb-br-header');
	          this.barViewport = this.element.select('.barsviewport');
	          this.barSvg = this.element.select('.vzb-br-bars-svg');
	          this.barContainer = this.element.select('.vzb-br-bars');
	
	          // set up formatters
	          this.xAxis.tickFormat(this.model.marker.axis_x.getTickFormatter());
	
	          this.ready();
	
	          this.selectBars();
	
	        },
	
	        readyRuns: 0,
	
	        /*
	         * Both model and DOM are ready
	         */
	        ready: function() {
	          var _this = this;
	          // hack: second run is right after readyOnce (in which ready() is also called)
	          // then it's not necessary to run ready()
	          // (without hack it's impossible to run things in readyOnce áfter ready has ran)
	          if (++this.readyRuns == 2) return;
	          this.model.marker.getFrame(this.model.time.value, function(values) {
	            _this.values =values;
	            _this.loadData();
	            _this.draw();
	          });
	        },
	
	        resize: function() {
	          this.draw();
	        },
	
	        loadData: function() {
	
	          // get data, for the active year. Nest them using the entity of the graph
	
	
	          // sort the data (also sets this.total)
	          this.sortedEntities = this.sortByIndicator(this.values.axis_x);
	
	          // change header titles for new data
	          var translator = this.model.language.getTFunction();
	          this.header.select('.vzb-br-title')
	            .text(translator("indicator/" + this.model.marker.axis_x.which) + ' ' + this.model.time.timeFormat(this.model.time.value))
	          this.header.select('.vzb-br-total')
	            .text('Σ = ' + this.model.marker.axis_x.getTickFormatter()(this.total))
	
	          // new scales and axes
	          this.xScale = this.model.marker.axis_x.getScale(false);
	          this.cScale = this.model.marker.color.getScale();
	
	        },
	
	        draw: function() {
	          //return if drawAxes exists with error
	          if(this.drawAxes()) return;
	          this.drawData();
	        },
	
	        /*
	        * draw the chart/stage
	        */
	        drawAxes: function() {
	
	          // these should go in some style-config
	          this.barHeight = 20; 
	          var margin = {top: 60, bottom: 40, left: 90, right: 20}; // need right margin for scroll bar
	
	          // draw the stage - copied from popbyage, should figure out what it exactly does and what is necessary.
	          this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	            
	          if(this.height<=0 || this.width<=0) return warn("Bar rank chart drawAxes() abort: vizabi container is too little or has display:none");
	
	          this.barContainer.attr('transform', 'translate(' + margin.left + ', 0)');
	          this.barViewport.style('height', this.height + 'px');
	
	          // header
	          this.header
	            .attr('height', margin.top)
	            .select('.vzb-br-title')
	              .attr('dominant-baseline', 'middle')
	              .attr('y', margin.top/2)
	              .attr('x', margin.left);
	          this.header
	            .select('.vzb-br-total')
	              .attr('text-anchor', 'end')
	              .attr('dominant-baseline', 'middle')
	              .attr('y', margin.top/2)
	              .attr('x', this.width + margin.left);
	
	
	          // although axes are not drawn, need the xScale for bar width
	          if(this.model.marker.axis_x.scaleType !== "ordinal") {
	            this.xScale.range([0, this.width]);
	          } else {
	            this.xScale.rangePoints([0, this.width]).range();
	          }
	
	          // redraw the limits
	          var limits = this.model.marker.axis_x.getLimits(this.model.marker.axis_x.which);
	          this.xScale = this.xScale.domain([limits.min, limits.max]);
	
	        },
	
	        drawData: function() {
	
	          var _this = this;
	          var bar_margin = 2; // should go in some config
	          var duration = (this.model.time.playing) ? this.model.time.delayAnimations : 0;
	
	          // apply the current data to the bars (including ordering)
	          var updatedBars = this.barContainer
	            .selectAll('.vzb-br-bar')
	            .data(this.sortedEntities, getDataKey)
	            .order();
	
	          // update the shown bars for new data-set
	          this.createAndDeleteBars(updatedBars);
	
	         
	          this.barContainer
	            .selectAll('.vzb-br-bar') 
	            .data(this.sortedEntities, getDataKey)
	            .order()
	            .each(function (d, i) {
	
	              var bar = d3.select(this);
	              var barWidth = _this.xScale(d.value);
	              var xValue = _this.model.marker.axis_x.getTickFormatter()(d.value);
	              
	              // save the current index in the bar datum
	              d.index = i;
	
	              // set width of the bars
	              bar.selectAll('rect')
	                .transition().duration(duration).ease("linear")
	                .attr("width", (barWidth > 0) ? barWidth : 0)
	
	              // set positions of the bar-values
	              bar.selectAll('.vzb-br-value')
	                .text(xValue)
	
	              // set title (tooltip)
	              bar.selectAll('title')
	                .text(_this.values.label[d.entity] + ' (' + xValue + ')');
	
	            })
	            .transition().duration(duration).ease("linear")
	            .attr("transform", function(d, i) {
	              return 'translate(0, '+ getBarPosition(d,i) + ')'
	            })
	            .call(endAll, function() {
	              // when all the transitions have ended
	
	              // set the height of the svg so it resizes according to its children
	              var height = _this.barContainer.node().getBoundingClientRect().height
	              _this.barSvg.attr('height', height + "px");
	
	              // move along with a selection if playing
	              if (_this.model.time.playing) {
	                var follow = _this.barContainer.select('.vzb-selected');
	                if (!follow.empty()) {
	                  var d = follow.datum();
	                  var yPos = getBarPosition(d, d.index);
	
	                  var currentTop = _this.barViewport.node().scrollTop;
	                  var currentBottom = currentTop + _this.height;
	
	                  var scrollTo = false;
	                  if (yPos < currentTop)
	                    scrollTo = yPos;
	                  if ((yPos + _this.barHeight) > currentBottom)
	                    scrollTo = yPos + _this.barHeight - _this.height;
	
	                  if (scrollTo)
	                    _this.barViewport.transition().duration(duration)
	                      .tween('scrollfor' + d.entity, scrollTopTween(scrollTo));
	
	                }
	
	              }
	
	              function scrollTopTween(scrollTop) {
	                return function() {
	                  var i = d3.interpolateNumber(this.scrollTop, scrollTop);
	                  return function(t) { this.scrollTop = i(t); };
	                };
	              }
	
	            });
	
	
	          // helper functions
	          function getBarPosition(d, i) {
	              return (_this.barHeight+bar_margin)*i;
	          }
	          function getDataKey(d) {          
	            return d.entity;  
	          } 
	          // http://stackoverflow.com/questions/10692100/invoke-a-callback-at-the-end-of-a-transition
	          function endAll(transition, callback) { 
	            if (transition.size() === 0) { callback() }
	            var n = 0; 
	            transition 
	                .each(function() { ++n; }) 
	                .each("end", function() { if (!--n) callback.apply(this, arguments); }); 
	          } 
	
	        },
	
	        createAndDeleteBars: function(updatedBars) {
	
	          var _this = this;
	
	          // remove groups for entities that are gone
	          updatedBars.exit().remove();
	
	          // make the groups for the entities which were not drawn yet (.data.enter() does this)
	          var newGroups = updatedBars.enter().append("g")
	              .attr("class", 'vzb-br-bar')
	              .attr("id", function(d) {
	                return "vzb-br-bar-" + d.entity;
	              })
	              .on("mousemove", function(bar) { _this.setHover(bar, true)  })
	              .on("mouseout",  function(bar) { _this.setHover(bar, false) })
	              .on("click", function(d) {
	
	                forEach(_this.model.marker.space, function(entity) {
	                  if (_this.model[entity].getDimension() !== 'time')
	                    _this.model[entity].selectEntity(d); // this will trigger a change in the model, which the tool listens to
	                });
	
	              });
	
	          // draw new bars per group
	          newGroups.append('rect')
	              .attr("x", 0)
	              .attr("rx", this.barHeight/4)
	              .attr("ry", this.barHeight/4)
	              .attr("stroke", "white")
	              .attr("stroke-opacity", 0)
	              .attr("stroke-width", 2)
	              .attr("height", this.barHeight)
	              .style("fill", function(d) {
	                var color = _this.cScale(_this.values.color[d.entity]);
	                return d3.rgb(color);
	              });
	
	          // draw new labels per group
	          newGroups.append('text')
	              .attr("class", "vzb-br-label") 
	              .attr("x", -5)
	              .attr("y", this.barHeight/2)
	              .attr("text-anchor", "end")
	              .attr("dominant-baseline", "middle")
	              .text(function(d, i) {
	                var label = _this.values.label[d.entity];
	                return label.length < 12 ? label : label.substring(0, 9) + '...';
	              })
	              .style("fill", function(d) {
	                var color = _this.cScale(_this.values.color[d.entity]);
	                return d3.rgb(color).darker(2);
	              })
	              .append('title'); // watch out: might be overwritten if changing the labeltext later on
	
	          // draw new values on each bar
	          newGroups.append('text')
	              .attr("class", "vzb-br-value") 
	              .attr("x", 5)
	              .attr("y", this.barHeight/2)
	              .attr("dominant-baseline", "middle")
	              .style("fill", function(d) {
	                var color = _this.cScale(_this.values.color[d.entity]);
	                return d3.rgb(color).darker(2);
	              });
	        },
	
	        drawColors: function() {
	          var _this = this;
	
	          this.barContainer.selectAll('.vzb-br-bar>rect')
	            .style("fill", getColor);
	          this.barContainer.selectAll('.vzb-br-bar>text')
	            .style("fill", getDarkerColor);
	
	          function getColor(d) {
	            var color = _this.cScale(_this.values.color[d.entity]);
	            return d3.rgb(color);
	          }
	          function getDarkerColor(d) {
	            return getColor(d).darker(2);
	          }
	        },
	
	
	        /**
	        * DATA HELPER FUNCTIONS
	        */  
	
	        sortByIndicator: function(values) {
	
	          var _this = this;
	          var data_array = [];
	          this.total = 0; // setting this.total for efficiency at the same time
	
	          // first put the data in an array (objects aren't sortable)
	          forEach(values, function(indicator_value, entity) {
	            var row = { entity: entity, value: indicator_value };
	            row[_this.model.entities.dim] = entity;
	            data_array.push(row);
	
	            // setting this.total for efficiency at the same time
	            _this.total += indicator_value; 
	          });
	          data_array.sort(function(a, b) {
	            // if a is bigger, a comes first, i.e. descending sort
	            return b.value - a.value;
	          });  
	          return data_array;  
	        },
	
	        /**
	        * UI METHODS
	        */
	
	        /**
	         * setting hover
	         */
	        setHover: function(bar, hover) {
	          this.barContainer.classed('vzb-dimmed', hover);
	          this.barContainer.select("#vzb-br-bar-" + bar.entity).classed('vzb-hovered', hover);
	        },
	
	        /**
	         * Select Entities
	         */
	        selectBars: function() {
	          var _this = this;
	          var entityDim = this.model.entities.dim;
	          var selected = this.model.entities.select;
	
	          // unselect all bars
	          this.barContainer.classed('vzb-dimmed-selected', false);
	          this.barContainer.selectAll('.vzb-br-bar.vzb-selected').classed('vzb-selected', false);
	
	          // select the selected ones
	          if(selected.length) {
	            this.barContainer.classed('vzb-dimmed-selected', true);
	            forEach(selected, function(selectedBar) {
	              _this.barContainer.select("#vzb-br-bar-" + selectedBar[entityDim]).classed('vzb-selected', true);
	            });
	          }
	
	        },
	
	      });
	
	      var BarRankChart = Tool.extend('BarRankChart', {
	
	        //Run when the tool is created
	        init: function(placeholder, external_model) {
	
	          this.name = "barrankchart";
	
	          this.components = [{
	            component: BarRankChart$1, 
	            placeholder: '.vzb-tool-viz', 
	            model: ["state.time", "state.entities", "state.marker", "language", "ui"] 
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        }
	
	      });
	
	      var MCMath = Class.extend({
	
	              init: function (context) {
	                  this.context = context;
	                  
	                  this.xScaleFactor = 1;
	                  this.xScaleShift = 0;
	              },
	                      
	              rescale: function (x) {
	                  return Math.exp(this.xScaleFactor * Math.log(x) + this.xScaleShift);
	              },
	              unscale: function (x) {
	                  return Math.exp((Math.log(x) - this.xScaleShift) / this.xScaleFactor);
	              },
	
	              generateMesh: function (length, scaleType, domain) {
	                  // span a uniform mesh across the entire X scale
	                  // if the scale is log, the mesh would be exponentially distorted to look uniform
	                  
	                  var rangeFrom = scaleType === "linear" ? domain[0] 
	                      : Math.log(this.unscale(domain[0]));
	                  
	                  var rangeTo = scaleType === "linear" ? domain[1] 
	                      : Math.log(this.unscale(domain[1]));
	                  
	                  var rangeStep = (rangeTo - rangeFrom) / length;
	                  
	                  var mesh = d3.range(rangeFrom, rangeTo, rangeStep).concat(rangeTo);
	
	                  if (scaleType !== "linear") {
	                      mesh = mesh.map(function (dX) { return Math.exp(dX); });
	                  } else {
	                      mesh = mesh.filter(function (dX) { return dX > 0; });
	                  }
	
	                  return mesh;
	              },
	              
	              gdpToMu: function(gdp, sigma, xScaleFactor, xScaleShift){
	                  // converting gdp per capita per day into MU for lognormal distribution
	                  // see https://en.wikipedia.org/wiki/Log-normal_distribution
	                  return Math.log(gdp/365) - sigma*sigma/2;
	              },
	              
	              giniToSigma: function (gini) {
	                  // The ginis are turned into std deviation. 
	                  // Mattias uses this formula in Excel: stddev = NORMSINV( ((gini/100)+1)/2 )*2^0.5
	                  return this.normsinv( ( (gini / 100) + 1 ) / 2 ) * Math.pow(2,0.5);
	              },
	                                   
	              // this function returns PDF values for a specified distribution
	              pdf: {
	                  normal: function(x, mu, sigma){
	                      return Math.exp(
	                          - .5 * Math.log(2 * Math.PI)
	                          - Math.log(sigma)
	                          - Math.pow(x - mu, 2) / (2 * sigma * sigma)
	                          );
	                  },
	                  lognormal: function(x, mu, sigma){
	                      return Math.exp(
	                          - .5 * Math.log(2 * Math.PI) //should not be different for the two scales- (scaleType=="linear"?Math.log(x):0)
	                          - Math.log(sigma)
	                          - Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma)
	                      );
	                  }
	              },
	
	              
	              normsinv: function (p) {
	                  //
	                  // Lower tail quantile for standard normal distribution function.
	                  //
	                  // This function returns an approximation of the inverse cumulative
	                  // standard normal distribution function.  I.e., given P, it returns
	                  // an approximation to the X satisfying P = Pr{Z <= X} where Z is a
	                  // random variable from the standard normal distribution.
	                  //
	                  // The algorithm uses a minimax approximation by rational functions
	                  // and the result has a relative error whose absolute value is less
	                  // than 1.15e-9.
	                  //
	                  // Author:      Peter John Acklam
	                  // (Javascript version by Alankar Misra @ Digital Sutras (alankar@digitalsutras.com))
	                  // Time-stamp:  2003-05-05 05:15:14
	                  // E-mail:      pjacklam@online.no
	                  // WWW URL:     http://home.online.no/~pjacklam
	                  
	                  // Taken from http://home.online.no/~pjacklam/notes/invnorm/index.html
	                  // adapted from Java code
	                  
	                  // An algorithm with a relative error less than 1.15*10-9 in the entire region.
	
	                  // Coefficients in rational approximations
	                  var a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
	                  var b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
	                  var c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
	                  var d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
	
	                  // Define break-points.
	                  var plow = .02425;
	                  var phigh = 1 - plow;
	
	                  // Rational approximation for lower region:
	                  if (p < plow) {
	                      var q = Math.sqrt(-2 * Math.log(p));
	                      return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
	                          ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
	                  }
	
	                  // Rational approximation for upper region:
	                  if (phigh < p) {
	                      var q = Math.sqrt(-2 * Math.log(1 - p));
	                      return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
	                          ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
	                  }
	
	                  // Rational approximation for central region:
	                  var q = p - .5;
	                  var r = q * q;
	                  return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
	                      (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
	
	              }
	
	
	
	          });
	
	      var MCSelectList = Class.extend({
	
	        init: function (context) {
	          this.context = context;
	
	        },
	
	        rebuild: function (data) {
	          var _this = this.context;
	
	          var listData = _this.mountainPointers
	            .concat(_this.groupedPointers)
	            .concat(_this.stackedPointers)
	            .filter(function (f) {
	              return _this.model.entities.isSelected(f);
	            }).sort(function (a, b) {
	              if (a.sortValue && b.sortValue) {
	                if(a.sortValue[1] === b.sortValue[1]) {
	                  return d3.descending(a.sortValue[0], b.sortValue[0]);
	                }
	                return d3.descending(a.sortValue[1], b.sortValue[1]);
	              } else {
	                if (a.aggrLevel != b.aggrLevel) {
	                  return d3.descending(a.aggrLevel, b.aggrLevel);
	                } else if (a.aggrLevel && b.aggrLevel) {
	                  return d3.descending(a.yMax, b.yMax);
	                } else {
	                  return 0;
	                }
	              }
	            });
	          _this.selectList = _this.mountainLabelContainer.selectAll("g.vzb-mc-label")
	            .data(unique(listData, function (d) {
	              return d.KEY()
	            }));
	          _this.selectList.exit().remove();
	          _this.selectList.enter().append("g")
	            .attr("class", "vzb-mc-label")
	            .each(function (d, i) {
	              var label = d3.select(this);
	              label.append("circle").attr('class', 'vzb-mc-label-legend');
	              label.append("text").attr("class", "vzb-mc-label-shadow vzb-mc-label-text");
	              label.append("text").attr("class", "vzb-mc-label-text");
	              label.append("g").attr("class", "vzb-mc-label-x vzb-label-shadow vzb-invisible")
	                .on("click", function (d, i) {
	                  if (isTouchDevice()) return;
	                  d3.event.stopPropagation();
	                  _this.model.entities.clearHighlighted();
	                  _this.model.entities.selectEntity(d);
	                  d3.event.stopPropagation();
	                })
	                .onTap(function (d, i) {
	                  d3.select("#" + d.geo + "-label").remove();
	                  _this.model.entities.clearHighlighted();
	                  _this.model.entities.selectEntity(d);
	                });
	              var labelCloseGroup = label.select("g.vzb-mc-label-x")
	              if (!isTouchDevice()){
	                setIcon(labelCloseGroup, iconClose)
	                  .select("svg")
	                  .attr("class", "vzb-mc-label-x-icon")
	                  .attr("width", "0px")
	                  .attr("height", "0px");
	
	                labelCloseGroup.insert("circle", "svg");
	
	              } else {
	                labelCloseGroup.append("rect");
	                labelCloseGroup.append("text")
	                  .attr("class", "vzb-mc-label-x-text")
	                  .text("Deselect");
	              }
	            })
	            .on("mousemove", function (d, i) {
	              if (isTouchDevice()) return;
	              _this.model.entities.highlightEntity(d);
	            })
	            .on("mouseout", function (d, i) {
	              if (isTouchDevice()) return;
	              _this.model.entities.clearHighlighted();
	
	            })
	            .on("click", function (d, i) {
	              if (isTouchDevice()) return;
	              _this.model.entities.clearHighlighted();
	              _this.model.entities.selectEntity(d);
	            });
	        },
	
	        redraw: function () {
	          var _this = this.context;
	          if (!_this.selectList || !_this.someSelected) return;
	
	          var sample = _this.mountainLabelContainer.append("g").attr("class", "vzb-mc-label").append("text").text("0");
	          var fontHeight = sample[0][0].getBBox().height*1.2;
	          var fontSizeToFontHeight = parseFloat(sample.style("font-size")) / fontHeight;
	          d3.select(sample[0][0].parentNode).remove();
	          var formatter = _this.model.marker.axis_y.getTickFormatter();
	
	          var titleHeight = _this.yTitleEl.select("text").node().getBBox().height || 0;
	
	          var maxFontHeight = (_this.height - titleHeight * 3) / (_this.selectList.data().length + 2);
	          if(fontHeight > maxFontHeight) fontHeight = maxFontHeight;
	
	          var currentAggrLevel = "null";
	          var aggrLevelSpacing = 0;
	
	          _this.selectList
	            .attr("transform", function (d, i) {
	              if(d.aggrLevel != currentAggrLevel) aggrLevelSpacing += fontHeight;
	              var spacing = fontHeight * i + titleHeight * 1.5 + aggrLevelSpacing;
	              currentAggrLevel = d.aggrLevel;
	              return "translate(0," + spacing + ")";
	            })
	            .each(function (d, i) {
	
	              var view = d3.select(this).attr("id", d.geo + '-label');
	              var name = d.key ? _this.translator("entity/geo.world_4region/" + d.key) : _this.values.label[d.KEY()];
	              var number = _this.values.axis_y[d.KEY()];
	
	              var string = name + ": " + formatter(number) + (i === 0 ? " "+ _this.translator("mount/people") : "");
	
	              var text = view.selectAll(".vzb-mc-label-text")
	                .attr("x", fontHeight)
	                .attr("y", fontHeight)
	                .text(string)
	                .style("font-size", fontHeight === maxFontHeight ? (fontHeight * fontSizeToFontHeight + "px") : null);
	
	              var contentBBox = text[0][0].getBBox();
	
	              var closeGroup = view.select(".vzb-mc-label-x");
	
	              if (isTouchDevice()) {
	                var closeTextBBox = closeGroup.select("text").node().getBBox();
	                closeGroup
	                  .classed("vzb-revert-color", true)
	                  .select(".vzb-mc-label-x-text")
	                  .classed("vzb-revert-color", true)
	                  .attr("x", contentBBox.width + contentBBox.height * 1.12 + closeTextBBox.width * .5)
	                  .attr("y", contentBBox.height * .55);
	
	                closeGroup.select("rect")
	                  .attr("width", closeTextBBox.width + contentBBox.height * .6)
	                  .attr("height", contentBBox.height)
	                  .attr("x", contentBBox.width + contentBBox.height * .9)
	                  .attr("y", 0)
	                  .attr("rx", contentBBox.height * .25)
	                  .attr("ry", contentBBox.height * .25);
	              } else {
	                closeGroup
	                  .attr("x", contentBBox.width + contentBBox.height * 1.1)
	                  .attr("y", contentBBox.height / 3);
	
	                closeGroup.select("circle")
	                  .attr("r", contentBBox.height * .4)
	                  .attr("cx", contentBBox.width + contentBBox.height * 1.1)
	                  .attr("cy", contentBBox.height / 3);
	
	                closeGroup.select("svg")
	                  .attr("x", contentBBox.width + contentBBox.height * (1.1 - .4))
	                  .attr("y", contentBBox.height * (1 / 3 - .4))
	                  .attr("width", contentBBox.height * .8)
	                  .attr("height", contentBBox.height * .8);
	              }
	
	              view.select(".vzb-mc-label-legend")
	                .attr("r", fontHeight / 3)
	                .attr("cx", fontHeight * .4)
	                .attr("cy", fontHeight / 1.5)
	                .style("fill", _this.cScale(_this.values.color[d.KEY()]));
	
	              view.onTap(function (d, i) {
	                d3.event.stopPropagation();
	                _this.model.entities.highlightEntity(d);
	                setTimeout(function() {
	                  _this.model.entities.unhighlightEntity(d);
	                }, 2000)
	              });
	            });
	        }
	      });
	
	      var MCProbe = Class.extend({
	
	              init: function (context) {
	                  this.context = context;
	                  
	              },
	                      
	              redraw: function (options) {
	                  var _this = this.context;
	                  if (!options) options = {};
	
	                  if (!options.level) options.level = _this.model.ui.chart.probeX;
	
	                  _this.probeEl.classed("vzb-hidden", !options.level);
	                  if (!options.level) return;
	
	                  _this.xAxisEl.call(_this.xAxis.highlightValue(options.full ? options.level : "none"));
	
	                  var sumValue = 0;
	                  var totalArea = 0;
	                  var leftArea = 0;
	
	                  var _computeAreas = function (d) {
	                      sumValue += _this.values.axis_y[d.KEY()];
	                      _this.cached[d.KEY()].forEach(function (d) {
	                          totalArea += d.y;
	                          if (_this._math.rescale(d.x) < options.level) leftArea += d.y;
	                      })
	                  };
	
	                  if (_this.model.marker.stack.which === "all") {
	                      _this.stackedPointers.forEach(_computeAreas);
	                  } else if (_this.model.marker.stack.which === "none") {
	                      _this.mountainPointers.forEach(_computeAreas);
	                  } else {
	                      _this.groupedPointers.forEach(_computeAreas);
	                  }
	
	                  var formatter1 = d3.format(".3r");
	                  var formatter2 = _this.model.marker.axis_y.getTickFormatter();
	                  _this.heightOfLabels = _this.heightOfLabels || (.66 * _this.height);
	
	                  _this.probeTextEl.each(function (d, i) {
	                      if (i !== 8) return;
	                      var view = d3.select(this);
	
	                      if (!options.full && _this.model.ui.chart.probeX == _this.model.marker.axis_x.tailFatX) {
	
	                          view.text(_this.translator("mount/extremepoverty"))
	                              .classed("vzb-hidden", false)
	                              .attr("x", -_this.height)
	                              .attr("y", _this.xScale(options.level))
	                              .attr("dy", "-1em")
	                              .attr("dx", "0.5em")
	                              .attr("transform", "rotate(-90)");
	
	                          _this.heightOfLabels = _this.height - view.node().getBBox().width - view.node().getBBox().height * 1.75;
	                      }else{
	                          view.classed("vzb-hidden", true);
	                      }
	                  });
	
	
	                  _this.probeTextEl.each(function (d, i) {
	                      if (i === 8) return;
	                      var view = d3.select(this);
	
	                      var string;
	                      if (i === 0 || i === 4) string = formatter1(leftArea / totalArea * 100) + "%";
	                      if (i === 1 || i === 5) string = formatter1(100 - leftArea / totalArea * 100) + "%";
	                      if (i === 2 || i === 6) string = formatter2(sumValue * leftArea / totalArea);
	                      if (i === 3 || i === 7) string = formatter2(sumValue * (1 - leftArea / totalArea)) + " " + _this.translator("mount/people");
	
	                      view.text(string)
	                          .classed("vzb-hidden", !options.full && i !== 0 && i !== 4)
	                          .attr("x", _this.xScale(options.level) + ([0, 4, 2, 6].indexOf(i) > -1 ? -5 : +5))
	                          .attr("y", _this.heightOfLabels)
	                          .attr("dy", [0, 1, 4, 5].indexOf(i) > -1 ? 0 : "1.5em");
	                  });
	
	
	                  _this.probeLineEl
	                      .attr("x1", _this.xScale(options.level))
	                      .attr("x2", _this.xScale(options.level))
	                      .attr("y1", _this.height + 6)
	                      .attr("y2", 0);
	
	
	              },
	
	
	
	          });
	
	      var THICKNESS_THRESHOLD = 0.001;
	
	      //MOUNTAIN CHART COMPONENT
	      var MountainChartComponent = Component.extend({
	
	          /**
	           * Initialize the component
	           * Executed once before any template is rendered.
	           * @param {Object} config The config passed to the component
	           * @param {Object} context The component's parent
	           */
	          init: function (config, context) {
	
	              var _this = this;
	              this.name = "mountainchart";
	              this.template = "mountainchart.html";
	
	              //define expected models for this component
	              this.model_expects = [
	                  { name: "time", type: "time" },
	                  { name: "entities", type: "entities" },
	                  { name: "marker", type: "model" },
	                  { name: "language", type: "language" },
	                  { name: "ui", type: "model" }
	              ];
	
	              //attach event listeners to the model items
	              this.model_binds = {
	                  "change:time.value": function (evt) {
	                    if (!_this._readyOnce) return;
	                    _this.year.setText(_this.model.time.value.getUTCFullYear().toString());
	                    _this.model.marker.getFrame(_this.model.time.value, _this.frameChanged.bind(_this));
	                  },
	                  "change:time.playing": function (evt) {
	                      // this listener is a patch for fixing #1228. time.js doesn't produce the last event
	                      // with playing == false when paused softly
	                      if(!_this.model.time.playing){
	                          _this.redrawDataPoints();
	                      }
	                  },
	                  "change:marker.axis_x.xScaleFactor": function () {
	                      _this.ready();
	                  },
	                  "change:marker.axis_x.xScaleShift": function () {
	                      _this.ready();
	                  },
	                  "change:marker.axis_x.tailFatX": function () {
	                      _this.ready();
	                  },
	                  "change:marker.axis_x.tailCutX": function () {
	                      _this.ready();
	                  },
	                  "change:marker.axis_x.tailFade": function () {
	                      _this.ready();
	                  },
	                  "change:ui.chart.probeX": function () {
	                      _this.ready();
	                  },
	                  "change:ui.chart.xPoints": function () {
	                      _this.ready();
	                  },
	                  "change:ui.chart.xLogStops": function () {
	                      _this.updateSize();
	                  },
	                  "change:ui.chart.yMaxMethod": function () {
	                      _this._adjustMaxY({ force: true });
	                      _this.redrawDataPoints();
	                  },
	                  "change:time.record": function (evt) {
	                      if (_this.model.time.record) {
	                          _this._export.open(this.element, this.name);
	                      } else {
	                          _this._export.reset();
	                      }
	                  },
	                  "change:entities.highlight": function (evt) {
	                      if (!_this._readyOnce) return;
	                      _this.highlightEntities();
	                      _this.updateOpacity();
	                  },
	                  "change:entities.select": function (evt) {
	                      if (!_this._readyOnce) return;
	                      _this.selectEntities();
	                      _this._selectlist.redraw();
	                      _this.updateOpacity();
	                      _this.updateDoubtOpacity();
	                      _this.redrawDataPoints();
	                  },
	                  "change:entities.opacitySelectDim": function (evt) {
	                      _this.updateOpacity();
	                  },
	                  "change:entities.opacityRegular": function (evt) {
	                      _this.updateOpacity();
	                  },
	                  "change:marker": function (evt, path) {
	                      if (!_this._readyOnce) return;
	                      if(path.indexOf("scaleType") > -1) {
	                          _this.ready();
	                          return;
	                      }
	                      if (path.indexOf("zoomedMin") > -1 || path.indexOf("zoomedMax") > -1) {
	                          _this.zoomToMaxMin();
	                          _this.redrawDataPoints();
	                          _this._probe.redraw();
	                          return;
	                      }
	                  },
	                  "change:marker.group": function (evt, path) {
	                      if (!_this._readyOnce) return;
	                      if (path.indexOf("group.merge") > -1) return;
	                      _this.ready();
	                  },
	                  "change:marker.group.merge": function (evt) {
	                      if (!_this._readyOnce) return;
	                      _this.updateTime();
	                      _this.redrawDataPoints();
	                  },
	                  "change:marker.stack": function (evt) {
	                      if (!_this._readyOnce) return;
	                      _this.ready();
	                  },
	                  "change:marker.color.palette": function (evt) {
	                      if (!_this._readyOnce) return;
	                      _this.redrawDataPointsOnlyColors();
	                      _this._selectlist.redraw();
	                  },
	              };
	
	              this._super(config, context);
	
	              this._math = new MCMath(this);
	              this._export = new Exporter(this);
	              this._export
	                  .prefix("vzb-mc-")
	                  .deleteClasses(["vzb-mc-mountains-mergestacked", "vzb-mc-mountains-mergegrouped", "vzb-mc-mountains", "vzb-mc-year", "vzb-mc-mountains-labels", "vzb-mc-axis-labels"]);
	              this._probe = new MCProbe(this);
	              this._selectlist = new MCSelectList(this);
	
	              // define path generator
	              this.area = d3.svg.area()
	                  .interpolate("basis")
	                  .x(function (d) {
	                      return _this.xScale(_this._math.rescale(d.x));
	                  })
	                  .y0(function (d) {
	                      return _this.yScale(d.y0);
	                  })
	                  .y1(function (d) {
	                      return _this.yScale(d.y0 + d.y);
	                  });
	
	              //define d3 stack layout
	              this.stack = d3.layout.stack()
	                  .order("reverse")
	                  .values(function (d) {
	                      return _this.cached[d.KEY()];
	                  })
	                  .out(function out(d, y0, y) {
	                      d.y0 = y0;
	                  });
	
	              // init internal variables
	              this.xScale = null;
	              this.yScale = null;
	              this.cScale = null;
	
	              this.xAxis = axisSmart();
	
	
	              this.rangeRatio = 1;
	              this.rangeShift = 0;
	              this.cached = {};
	              this.mesh = [];
	              this.yMax = 0;
	          },
	
	          domReady: function () {
	              var _this = this;
	
	              // reference elements
	              this.element = d3.select(this.element);
	              this.graph = this.element.select(".vzb-mc-graph");
	              this.xAxisEl = this.graph.select(".vzb-mc-axis-x");
	              this.xTitleEl = this.graph.select(".vzb-mc-axis-x-title");
	              this.yTitleEl = this.graph.select(".vzb-mc-axis-y-title");
	              this.infoEl = this.graph.select(".vzb-mc-axis-info");
	              this.dataWarningEl = this.graph.select(".vzb-data-warning");
	
	              this.yearEl = this.graph.select(".vzb-mc-year");
	              this.year = new DynamicBackground(this.yearEl);
	
	              this.mountainMergeStackedContainer = this.graph.select(".vzb-mc-mountains-mergestacked");
	              this.mountainMergeGroupedContainer = this.graph.select(".vzb-mc-mountains-mergegrouped");
	              this.mountainAtomicContainer = this.graph.select(".vzb-mc-mountains");
	              this.mountainLabelContainer = this.graph.select(".vzb-mc-mountains-labels");
	              this.tooltip = this.element.select(".vzb-mc-tooltip");
	              this.eventAreaEl = this.element.select(".vzb-mc-eventarea");
	              this.probeEl = this.element.select(".vzb-mc-probe");
	              this.probeLineEl = this.probeEl.select("line");
	              this.probeTextEl = this.probeEl.selectAll("text");
	
	              this.element
	                  .onTap(function (d, i) {
	                      _this._interact()._mouseout(d, i);
	                  });
	          },
	
	          afterPreload: function () {
	              var _this = this;
	
	              var yearNow = _this.model.time.value.getUTCFullYear();
	              var yearEnd = _this.model.time.end.getUTCFullYear();
	
	              this._math.xScaleFactor = this.model.marker.axis_x.xScaleFactor;
	              this._math.xScaleShift = this.model.marker.axis_x.xScaleShift;
	
	              if (!this.precomputedShapes || !this.precomputedShapes[yearNow] || !this.precomputedShapes[yearEnd]) return;
	
	              var yMax = this.precomputedShapes[this.model.ui.chart.yMaxMethod == "immediate" ? yearNow : yearEnd].yMax;
	              var shape = this.precomputedShapes[yearNow].shape;
	
	              if (!yMax || !shape || shape.length === 0) return;
	
	              this.xScale = d3.scale.log().domain([this.model.marker.axis_x.domainMin, this.model.marker.axis_x.domainMax]);
	              this.yScale = d3.scale.linear().domain([0, Math.round(yMax)]);
	
	              _this.updateSize(shape.length);
	              _this.zoomToMaxMin();
	
	              shape = shape.map(function (m, i) {return {x: _this.mesh[i], y0: 0, y: +m};})
	
	              this.mountainAtomicContainer.selectAll(".vzb-mc-prerender")
	                  .data([0])
	                  .enter().append("path")
	                  .attr("class", "vzb-mc-prerender")
	                  .style("fill", "pink")
	                  .style("opacity", 0)
	                  .attr("d", _this.area(shape))
	                  .transition().duration(1000).ease("linear")
	                  .style("opacity", 1);
	          },
	
	          readyOnce: function () {
	
	              this.eventAreaEl
	                  .on("mousemove", function () {
	                      if (_this.model.time.dragging) return;
	                      _this._probe.redraw({
	                          level: _this.xScale.invert(d3.mouse(this)[0]),
	                          full: true
	                      });
	                  })
	                  .on("mouseout", function () {
	                      if (_this.model.time.dragging) return;
	                      _this._probe.redraw();
	                  });
	
	              var _this = this;
	              this.on("resize", function () {
	                  //console.log("acting on resize");
	                  //return if updatesize exists with error
	                  if(_this.updateSize()) return;
	                  _this.updateTime(); // respawn is needed
	                  _this.redrawDataPoints();
	                  _this._selectlist.redraw();
	                  _this._probe.redraw();
	              });
	
	              this.KEY = this.model.entities.getDimension();
	              this.TIMEDIM = this.model.time.getDimension();
	
	              this.mountainAtomicContainer.select(".vzb-mc-prerender").remove();
	              this.year.setText(this.model.time.value.getUTCFullYear().toString());
	              this.wScale = d3.scale.linear()
	                  .domain(this.parent.datawarning_content.doubtDomain)
	                  .range(this.parent.datawarning_content.doubtRange);
	          },
	
	          ready: function () {
	              //console.log("ready")
	              var _this= this;
	
	              this._math.xScaleFactor = this.model.marker.axis_x.xScaleFactor;
	              this._math.xScaleShift = this.model.marker.axis_x.xScaleShift;
	
	              this.updateUIStrings();
	              this.updateIndicators();
	              this.model.marker.getFrame(this.model.time.value, function(values) {
	                if (!values) return;
	                _this.values = values;
	                _this.updateEntities();
	                _this.updateSize();
	                _this.zoomToMaxMin();
	                _this._spawnMasks();
	                _this.updateTime();
	                _this._adjustMaxY({force: true});
	                _this.redrawDataPoints();
	                _this.redrawDataPointsOnlyColors();
	                _this.highlightEntities();
	                _this.selectEntities();
	                _this._selectlist.redraw();
	                _this.updateOpacity();
	                _this.updateDoubtOpacity();
	                _this._probe.redraw();
	              });
	          },
	
	        frameChanged: function(frame, time) {
	          if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
	          this.values = frame;
	          this.updateTime();
	          this.redrawDataPoints();
	          this._selectlist.redraw();
	          this._probe.redraw();
	          this.updateDoubtOpacity();
	        },
	        
	
	      updateSize: function (meshLength) {
	
	              var margin, infoElHeight;
	              var padding = 2;
	
	              var profiles = {
	                small: {
	                  margin: { top: 10, right: 10, left: 10, bottom: 18 },
	                  infoElHeight: 16
	                },
	                medium: {
	                  margin: { top: 20, right: 20, left: 20, bottom: 30 },
	                  infoElHeight: 20
	                },
	                large: {
	                  margin: { top: 30, right: 30, left: 30, bottom: 35 },
	                  infoElHeight: 22
	                }
	              };
	
	              var presentationProfileChanges = {
	                medium: {
	                  margin: { top: 20, right: 20, left: 20, bottom: 50 },
	                  infoElHeight: 26
	                },
	                large: {
	                  margin: { top: 30, right: 30, left: 30, bottom: 50 },
	                  infoElHeight: 32
	                }
	              };
	
	              this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);
	              margin = this.activeProfile.margin;
	              infoElHeight = this.activeProfile.infoElHeight;
	
	              //mesure width and height
	              this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	              this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	          
	              if(this.height<=0 || this.width<=0) return warn("Mountain chart updateSize() abort: vizabi container is too little or has display:none");
	
	              //graph group is shifted according to margins (while svg element is at 100 by 100%)
	              this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	              var yearLabelOptions = {
	                  topOffset: this.getLayoutProfile()==="large"? margin.top * 2 : 0,
	                  xAlign: this.getLayoutProfile()==="large"? 'right' : 'center',
	                  yAlign: this.getLayoutProfile()==="large"? 'top' : 'center',
	              };
	
	              var yearLabelFontSize = this.getLayoutProfile()==="large"? this.width / 6 : Math.max(this.height / 4, this.width / 4);
	
	              //year is centered and resized
	              this.year
	                  .setConditions(yearLabelOptions)
	                  .resize(this.width, this.height, yearLabelFontSize);
	
	              //update scales to the new range
	              this.yScale.range([this.height, 0]);
	              this.xScale.range([this.rangeShift, this.width * this.rangeRatio + this.rangeShift]);
	
	
	              //need to know scale type of X to move on
	              var scaleType = this._readyOnce ? this.model.marker.axis_x.scaleType : "log";
	
	              //axis is updated
	              this.xAxis.scale(this.xScale)
	                  .orient("bottom")
	                  .tickSize(6, 0)
	                  .tickSizeMinor(3, 0)
	                  .labelerOptions({
	                      scaleType: scaleType,
	                      toolMargin: margin,
	                      pivotingLimit: margin.bottom * 1.5,
	                      method: this.xAxis.METHOD_REPEATING,
	                      stops: this._readyOnce ? this.model.ui.chart.xLogStops : [1],
	                      formatter: this.model.marker.axis_x.getTickFormatter()
	                  });
	
	
	              this.xAxisEl
	                  .attr("transform", "translate(0," + this.height + ")")
	                  .call(this.xAxis);
	
	              this.xTitleEl.select("text")
	                  .attr("transform", "translate(" + this.width + "," + this.height + ")")
	                  .attr("dy", "-0.36em");
	
	              this.yTitleEl
	                .style("font-size", infoElHeight + "px")
	                .attr("transform", "translate(0," + margin.top + ")")
	
	
	              var warnBB = this.dataWarningEl.select("text").node().getBBox();
	              this.dataWarningEl.select("svg")
	                  .attr("width", warnBB.height)
	                  .attr("height", warnBB.height)
	                  .attr("x", warnBB.height * .1)
	                  .attr("y", -warnBB.height * 1.0 + 1)
	
	              this.dataWarningEl
	                  .attr("transform", "translate(" + (0) + "," + (margin.top + warnBB.height * 1.5) + ")")
	                  .select("text")
	                  .attr("dx", warnBB.height * 1.5);
	
	              if(this.infoEl.select('svg').node()) {
	                  var titleBBox = this.yTitleEl.node().getBBox();
	                  var translate = d3.transform(this.yTitleEl.attr('transform')).translate;
	
	                  this.infoEl.select('svg')
	                      .attr("width", infoElHeight + "px")
	                      .attr("height", infoElHeight + "px");
	                  this.infoEl.attr('transform', 'translate('
	                      + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	                      + (translate[1]-infoElHeight * .8) + ')');
	              }
	
	              this.eventAreaEl
	                  .attr("y", this.height)
	                  .attr("width", this.width)
	                  .attr("height", margin.bottom);
	
	              if (!meshLength) meshLength = this.model.ui.chart.xPoints;
	              this.mesh = this._math.generateMesh(meshLength, scaleType, this.xScale.domain());
	          },
	
	
	          zoomToMaxMin: function(){
	              var _this = this;
	
	              if(this.model.marker.axis_x.zoomedMin==null || this.model.marker.axis_x.zoomedMax==null) return;
	
	              var x1 = this.xScale(this.model.marker.axis_x.zoomedMin);
	              var x2 = this.xScale(this.model.marker.axis_x.zoomedMax);
	
	              this.rangeRatio = this.width / (x2 - x1) * this.rangeRatio;
	              this.rangeShift = (this.rangeShift - x1) / (x2 - x1) * this.width;
	
	              this.xScale.range([this.rangeShift, this.width*this.rangeRatio + this.rangeShift]);
	
	              this.xAxisEl.call(this.xAxis);
	          },
	
	
	          updateUIStrings: function () {
	              var _this = this;
	
	              this.translator = this.model.language.getTFunction();
	              var xConceptprops = this.model.marker.axis_x.getConceptprops();
	
	
	              this.xTitleEl.select("text")
	                  .text(this.translator("unit/mountainchart_hardcoded_income_per_day"));
	
	              this.yTitleEl.select("text")
	                  .text(this.translator("mount/title"));
	
	              setIcon(this.dataWarningEl, iconWarn).select("svg").attr("width", "0px").attr("height", "0px");
	              this.dataWarningEl.append("text")
	                  .text(this.translator("hints/dataWarning"));
	
	              setIcon(this.infoEl, iconQuestion).select("svg").attr("width", "0px").attr("height", "0px");
	
	              //TODO: move away from UI strings, maybe to ready or ready once
	              this.infoEl.on("click", function() {
	                _this.parent.findChildByName("gapminder-datanotes").pin();
	              })
	              this.infoEl.on("mouseover", function() {
	                var rect = this.getBBox();
	                var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	                _this.parent.findChildByName("gapminder-datanotes").setHook('axis_y').show().setPos(coord.x, coord.y);
	              })
	              this.infoEl.on("mouseout", function() {
	                _this.parent.findChildByName("gapminder-datanotes").hide();
	              })
	              
	              
	              
	              this.dataWarningEl
	                  .on("click", function () {
	                      _this.parent.findChildByName("gapminder-datawarning").toggle();
	                  })
	                  .on("mouseover", function () {
	                      _this.updateDoubtOpacity(1);
	                  })
	                  .on("mouseout", function () {
	                      _this.updateDoubtOpacity();
	                  })
	          },
	
	          updateDoubtOpacity: function (opacity) {
	              if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
	              if (this.someSelected) opacity = 1;
	              this.dataWarningEl.style("opacity", opacity);
	          },
	
	          updateIndicators: function () {
	              var _this = this;
	
	              //fetch scales, or rebuild scales if there are none, then fetch
	              this.yScale = this.model.marker.axis_y.getScale();
	              this.xScale = this.model.marker.axis_x.getScale();
	              this.cScale = this.model.marker.color.getScale();
	
	              this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());
	          },
	
	          updateEntities: function () {
	              var _this = this;
	
	              // construct pointers
	              this.mountainPointers = this.model.marker.getKeys()
	                  .filter(function(d) { return 1
	                      && _this.values.axis_x[d[_this.KEY]]
	                      && _this.values.axis_y[d[_this.KEY]]
	                      && _this.values.axis_s[d[_this.KEY]];
	                  })
	                  .map(function(d) {
	                      var pointer = {};
	                      pointer[_this.KEY] = d[_this.KEY];
	                      pointer.KEY = function () {
	                          return this[_this.KEY];
	                      };
	                      pointer.sortValue = [_this.values.axis_y[pointer.KEY()]||0, 0];
	                      pointer.aggrLevel = 0;
	                      return pointer;
	                  });
	
	
	              //TODO: optimise this!
	              this.groupedPointers = d3.nest()
	                  .key(function (d) {
	                      return _this.model.marker.stack.use === "property" ? _this.values.stack[d.KEY()] : _this.values.group[d.KEY()];
	                  })
	                  .sortValues(function (a, b) {
	                      return b.sortValue[0] - a.sortValue[0];
	                  })
	                  .entries(this.mountainPointers);
	
	
	              var groupManualSort = this.model.marker.group.manualSorting;
	              this.groupedPointers.forEach(function (group) {
	                  var groupSortValue = d3.sum(group.values.map(function (m) {
	                      return m.sortValue[0];
	                  }));
	
	                  if (groupManualSort && groupManualSort.length > 1) groupSortValue = groupManualSort.length-1 - groupManualSort.indexOf(group.key);
	
	                  group.values.forEach(function (d) {
	                      d.sortValue[1] = groupSortValue;
	                  });
	
	                  group[_this.model.entities.getDimension()] = group.key; // hack to get highlihgt and selection work
	                  group.KEY = function () {
	                      return this.key;
	                  };
	                  group.aggrLevel = 1;
	              });
	
	              var sortGroupKeys = {};
	              _this.groupedPointers.map(function (m) {
	                  sortGroupKeys[m.key] = m.values[0].sortValue[1];
	              });
	
	
	              // update the stacked pointers
	              if (_this.model.marker.stack.which === "none") {
	                  this.stackedPointers = [];
	                  this.mountainPointers.sort(function (a, b) {
	                      return b.sortValue[0] - a.sortValue[0];
	                  });
	
	              } else {
	                  this.stackedPointers = d3.nest()
	                      .key(function (d) {
	                          return _this.values.stack[d.KEY()];
	                      })
	                      .key(function (d) {
	                          return _this.values.group[d.KEY()];
	                      })
	                      .sortKeys(function (a, b) {
	                          return sortGroupKeys[b] - sortGroupKeys[a];
	                      })
	                      .sortValues(function (a, b) {
	                          return b.sortValue[0] - a.sortValue[0];
	                      })
	                      .entries(this.mountainPointers);
	
	                  this.mountainPointers.sort(function (a, b) {
	                      return b.sortValue[1] - a.sortValue[1];
	                  });
	
	
	                  this.stackedPointers.forEach(function (stack) {
	                      stack.KEY = function () {
	                          return this.key;
	                      };
	                      stack[_this.model.entities.getDimension()] = stack.key; // hack to get highlihgt and selection work
	                      stack.aggrLevel = 2;
	                  });
	              }
	
	              //bind the data to DOM elements
	              this.mountainsMergeStacked = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel2")
	                  .data(this.stackedPointers);
	              this.mountainsMergeGrouped = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel1")
	                  .data(this.groupedPointers);
	              this.mountainsAtomic = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel0")
	                  .data(this.mountainPointers);
	
	              //exit selection -- remove shapes
	              this.mountainsMergeStacked.exit().remove();
	              this.mountainsMergeGrouped.exit().remove();
	              this.mountainsAtomic.exit().remove();
	
	              //enter selection -- add shapes
	              this.mountainsMergeStacked.enter().append("path")
	                  .attr("class", "vzb-mc-mountain vzb-mc-aggrlevel2");
	              this.mountainsMergeGrouped.enter().append("path")
	                  .attr("class", "vzb-mc-mountain vzb-mc-aggrlevel1");
	              this.mountainsAtomic.enter().append("path")
	                  .attr("class", "vzb-mc-mountain vzb-mc-aggrlevel0");
	
	              //add interaction
	              this.mountains = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain");
	
	              this.mountains
	                  .on("mousemove", function (d, i) {
	                      if (isTouchDevice()) return;
	                      _this._interact()._mousemove(d, i);
	                  })
	                  .on("mouseout", function (d, i) {
	                      if (isTouchDevice()) return;
	                      _this._interact()._mouseout(d, i);
	                  })
	                  .on("click", function (d, i) {
	                      if (isTouchDevice()) return;
	                      _this._interact()._click(d, i);
	                      _this.highlightEntities();
	                  })
	                  .onTap(function (d, i) {
	                      _this._interact()._click(d, i);
	                      d3.event.stopPropagation();
	                  })
	                  .onLongTap(function (d, i) {
	                  })
	          },
	
	          _interact: function () {
	              var _this = this;
	
	              return {
	                  _mousemove: function (d, i) {
	                      if (_this.model.time.dragging || _this.model.time.playing) return;
	
	                      _this.model.entities.highlightEntity(d);
	
	                      var mouse = d3.mouse(_this.graph.node()).map(function (d) {
	                          return parseInt(d);
	                      });
	
	                      //position tooltip
	                      _this._setTooltip(d.key ? _this.translator("entity/geo.world_4region/" + d.key) : _this.values.label[d.KEY()]);
	
	                  },
	                  _mouseout: function (d, i) {
	                      if (_this.model.time.dragging || _this.model.time.playing) return;
	
	                      _this._setTooltip("");
	                      _this.model.entities.clearHighlighted();
	                  },
	                  _click: function (d, i) {
	                      if (_this.model.time.dragging || _this.model.time.playing) return;
	                      
	                      _this.model.entities.selectEntity(d);
	                  }
	              };
	
	          },
	
	          highlightEntities: function () {
	              var _this = this;
	              this.someHighlighted = (this.model.entities.highlight.length > 0);
	
	              if (!this.selectList || !this.someSelected) return;
	              this.selectList.classed("vzb-highlight", function (d) {
	                  return _this.model.entities.isHighlighted(d);
	              });
	              this.selectList.each(function (d, i) {
	                d3.select(this).selectAll(".vzb-mc-label-x")
	                  .classed("vzb-invisible", function(n) {
	                    return !_this.model.entities.isHighlighted(d);
	                  });
	
	              });
	
	          },
	
	          selectEntities: function () {
	              var _this = this;
	              this.someSelected = (this.model.entities.select.length > 0);
	
	              this._selectlist.rebuild();
	          },
	
	          _sumLeafPointersByMarker: function (branch, marker) {
	              var _this = this;
	              if (!branch.key) return _this.values[marker][branch.KEY()];
	              return d3.sum(branch.values.map(function (m) {
	                  return _this._sumLeafPointersByMarker(m, marker);
	              }));
	          },
	
	          updateOpacity: function () {
	              var _this = this;
	              //if(!duration)duration = 0;
	
	              var OPACITY_HIGHLT = 1.0;
	              var OPACITY_HIGHLT_DIM = .3;
	              var OPACITY_SELECT = this.model.entities.opacityRegular;
	              var OPACITY_REGULAR = this.model.entities.opacityRegular;
	              var OPACITY_SELECT_DIM = this.model.entities.opacitySelectDim;
	
	              this.mountains.style("opacity", function (d) {
	
	                  if (_this.someHighlighted) {
	                      //highlight or non-highlight
	                      if (_this.model.entities.isHighlighted(d)) return OPACITY_HIGHLT;
	                  }
	
	                  if (_this.someSelected) {
	                      //selected or non-selected
	                      return _this.model.entities.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
	                  }
	
	                  if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;
	
	                  return OPACITY_REGULAR;
	
	              });
	
	              this.mountains.classed("vzb-selected", function (d) {
	                  return _this.model.entities.isSelected(d)
	              });
	
	              var someSelectedAndOpacityZero = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	
	              // when pointer events need update...
	              if (someSelectedAndOpacityZero !== this.someSelectedAndOpacityZero_1) {
	                  this.mountainsAtomic.style("pointer-events", function (d) {
	                      return (!someSelectedAndOpacityZero || _this.model.entities.isSelected(d)) ?
	                          "visible" : "none";
	                  });
	              }
	
	              this.someSelectedAndOpacityZero_1 = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	          },
	
	          updateTime: function (time) {
	              var _this = this;
	
	              this.time = this.model.time.value;
	              if (time == null) time = this.time;
	
	              this.yMax = 0;
	
	
	              //spawn the original mountains
	              this.mountainPointers.forEach(function (d, i) {
	                  var vertices = _this._spawn(_this.values, d);
	                  _this.cached[d.KEY()] = vertices;
	                  d.hidden = vertices.length === 0;
	              });
	
	
	              //recalculate stacking
	              if (_this.model.marker.stack.which !== "none") {
	                  this.stackedPointers.forEach(function (group) {
	                      var toStack = [];
	                      group.values.forEach(function (subgroup) {
	                          toStack = toStack.concat(subgroup.values.filter(function (f) {
	                              return !f.hidden;
	                          }));
	                      });
	                      _this.stack(toStack);
	                  });
	              }
	
	              this.mountainPointers.forEach(function (d) {
	                  d.yMax = d3.max(_this.cached[d.KEY()].map(function (m) {
	                      return m.y0 + m.y;
	                  }));
	                  if (_this.yMax < d.yMax) _this.yMax = d.yMax;
	              });
	
	              var mergeGrouped = _this.model.marker.group.merge;
	              var mergeStacked = _this.model.marker.stack.merge;
	              var dragOrPlay = (_this.model.time.dragging || _this.model.time.playing) && this.model.marker.stack.which !== "none";
	
	              //if(mergeStacked){
	              this.stackedPointers.forEach(function (d) {
	                  var firstLast = _this._getFirstLastPointersInStack(d);
	                  _this.cached[d.key] = _this._getVerticesOfaMergedShape(firstLast);
	                  _this.values.color[d.key] = "_default";
	                  _this.values.axis_y[d.key] = _this._sumLeafPointersByMarker(d, "axis_y");
	                  d.yMax = firstLast.first.yMax;
	              });
	              //} else if (mergeGrouped || dragOrPlay){
	              this.groupedPointers.forEach(function (d) {
	                  var firstLast = _this._getFirstLastPointersInStack(d);
	                  _this.cached[d.key] = _this._getVerticesOfaMergedShape(firstLast);
	                  _this.values.color[d.key] = _this.values.color[firstLast.first.KEY()];
	                  _this.values.axis_y[d.key] = _this._sumLeafPointersByMarker(d, "axis_y");
	                  d.yMax = firstLast.first.yMax;
	              });
	              //}
	
	              if (!mergeStacked && !mergeGrouped && this.model.marker.stack.use === "property") {
	                  this.groupedPointers.forEach(function (d) {
	                      var visible = d.values.filter(function (f) {
	                          return !f.hidden;
	                      });
	                      d.yMax = visible[0].yMax;
	                      d.values.forEach(function (e) {
	                          e.yMaxGroup = d.yMax;
	                      });
	                  });
	              }
	
	
	          },
	
	          _getFirstLastPointersInStack: function (group) {
	              var _this = this;
	
	              var visible, visible2;
	
	              if (group.values[0].values) {
	                  visible = group.values[0].values.filter(function (f) {
	                      return !f.hidden;
	                  });
	                  visible2 = group.values[group.values.length - 1].values.filter(function (f) {
	                      return !f.hidden;
	                  });
	                  var first = visible[0];
	                  var last = visible2[visible2.length - 1];
	              } else {
	                  visible = group.values.filter(function (f) {
	                      return !f.hidden;
	                  });
	                  var first = visible[0];
	                  var last = visible[visible.length - 1];
	              }
	              
	              if (!visible.length || (visible2 && !visible2.length)) warn('mountain chart failed to generate shapes. check the incoming data');
	
	              return {
	                  first: first,
	                  last: last
	              };
	          },
	
	          _getVerticesOfaMergedShape: function (arg) {
	              var _this = this;
	
	              var first = arg.first.KEY();
	              var last = arg.last.KEY();
	
	              return _this.mesh.map(function (m, i) {
	                  var y = _this.cached[first][i].y0 + _this.cached[first][i].y - _this.cached[last][i].y0;
	                  var y0 = _this.cached[last][i].y0;
	                  return {
	                      x: m,
	                      y0: y0,
	                      y: y
	                  };
	              });
	          },
	
	          _spawnMasks: function () {
	              var _this = this;
	
	              var tailFatX = this._math.unscale(this.model.marker.axis_x.tailFatX);
	              var tailCutX = this._math.unscale(this.model.marker.axis_x.tailCutX);
	              var tailFade = this.model.marker.axis_x.tailFade;
	              var k = 2 * Math.PI / (Math.log(tailFatX) - Math.log(tailCutX));
	              var m = Math.PI - Math.log(tailFatX) * k;
	
	
	              this.spawnMask = [];
	              this.cosineShape = [];
	              this.cosineArea = 0;
	
	              this.mesh.map(function (dX, i) {
	                  _this.spawnMask[i] = dX < tailCutX ? 1 : (dX > tailFade * 7 ? 0 : Math.exp((tailCutX - dX) / tailFade))
	                  _this.cosineShape[i] = (dX > tailCutX && dX < tailFatX ? (1 + Math.cos(Math.log(dX) * k + m)) : 0);
	                  _this.cosineArea += _this.cosineShape[i];
	              });
	          },
	
	          _spawn: function (values, d) {
	              var _this = this;
	
	              var norm = values.axis_y[d.KEY()];
	              var sigma = _this._math.giniToSigma(values.axis_s[d.KEY()]);
	              var mu = _this._math.gdpToMu(values.axis_x[d.KEY()], sigma);
	
	              if (!norm || !mu || !sigma) return [];
	
	              var distribution = [];
	              var acc = 0;
	
	              this.mesh.map(function (dX, i) {
	                  distribution[i] = _this._math.pdf.lognormal(dX, mu, sigma);
	                  acc += _this.spawnMask[i] * distribution[i];
	              });
	
	              var result = this.mesh.map(function (dX, i) {
	                  return {
	                      x: dX,
	                      y0: 0,
	                      y: norm * (distribution[i] * (1 - _this.spawnMask[i]) + _this.cosineShape[i] / _this.cosineArea * acc)
	                  }
	              });
	
	              return result;
	          },
	
	          _adjustMaxY: function (options) {
	              if (!options) options = {};
	              var _this = this;
	              var method = this.model.ui.chart.yMaxMethod;
	
	              if (method !== "immediate" && !options.force) return;
	              if (method === "latest") {
	                var prevValues = _this.values;
	                _this.model.marker.getFrame(_this.model.time.end, function(values) {
	                  if(!values) return;
	                    
	                  _this.values = values;
	                  _this.updateTime();
	                  _this.values = prevValues;
	                  _this.yScale.domain([0, Math.round(_this.yMax)]);
	                  _this.updateTime();
	                });
	              } else {
	                if (!_this.yMax) warn("Setting yMax to " + _this.yMax + ". You failed again :-/");
	                _this.yScale.domain([0, Math.round(_this.yMax)]);
	              }
	          },
	
	          redrawDataPoints: function () {
	              var _this = this;
	              var mergeGrouped = this.model.marker.group.merge;
	              var mergeStacked = this.model.marker.stack.merge;
	              var stackMode = this.model.marker.stack.which;
	              //it's important to know if the chart is dragging or playing at the moment.
	              //because if that is the case, the mountain chart will merge the stacked entities to save performance
	              var dragOrPlay = (this.model.time.dragging || this.model.time.playing)
	                  //never merge when no entities are stacked
	                  && stackMode !== "none"
	                  //when the time is playing and stops in the end, the time.playing is set to false after the slider is stopped
	                  //so the mountain chat is stuck in the merged state. this line prevents it:
	                  && !(this.model.time.value - this.model.time.end==0 && !this.model.time.loop);
	
	              this._adjustMaxY();
	
	              this.mountainsMergeStacked.each(function (d) {
	                  var view = d3.select(this);
	                  var hidden = !mergeStacked;
	                  _this._renderShape(view, d.KEY(), hidden);
	              })
	
	              this.mountainsMergeGrouped.each(function (d) {
	                  var view = d3.select(this);
	                  var hidden = (!mergeGrouped && !dragOrPlay) || (mergeStacked && !_this.model.entities.isSelected(d));
	                  _this._renderShape(view, d.KEY(), hidden);
	              });
	
	              this.mountainsAtomic.each(function (d, i) {
	                  var view = d3.select(this);
	                  var hidden = d.hidden || ((mergeGrouped || mergeStacked || dragOrPlay) && !_this.model.entities.isSelected(d));
	                  _this._renderShape(view, d.KEY(), hidden);
	              })
	
	              if (stackMode === "none") {
	                  this.mountainsAtomic.sort(function (a, b) {
	                      return b.yMax - a.yMax;
	                  });
	
	              } else if (stackMode === "all") {
	                  // do nothing if everything is stacked
	
	              } else {
	                  if (mergeGrouped || dragOrPlay) {
	                      this.mountainsMergeGrouped.sort(function (a, b) {
	                          return b.yMax - a.yMax;
	                      });
	                  } else {
	                      this.mountainsAtomic.sort(function (a, b) {
	                          return b.yMaxGroup - a.yMaxGroup;
	                      });
	                  }
	              }
	
	
	              // exporting shapes for shape preloader. is needed once in a while
	              // if (!this.shapes) this.shapes = {}
	              // this.shapes[this.model.time.value.getUTCFullYear()] = {
	              //     yMax: d3.format(".2e")(_this.yMax),
	              //     shape: _this.cached["all"].map(function (d) {return d3.format(".2e")(d.y);})
	              // }
	
	          },
	
	          redrawDataPointsOnlyColors: function () {
	              var _this = this;
	              this.mountains.style("fill", function (d) {
	                  return _this.values.color[d.KEY()]?_this.cScale(_this.values.color[d.KEY()]):"transparent";
	              });
	          },
	
	          _renderShape: function (view, key, hidden) {
	              var stack = this.model.marker.stack.which;
	              var _this = this;
	
	              view.classed("vzb-hidden", hidden);
	
	              if (hidden) {
	                  if (stack !== "none") view.style("stroke-opacity", 0);
	                  return;
	              }
	
	              var filter = {};
	              filter[this.KEY] = key;
	              if (this.model.entities.isSelected(filter)) {
	                  view.attr("d", this.area(this.cached[key].filter(function (f) {return f.y > _this.values.axis_y[key] * THICKNESS_THRESHOLD })));
	              } else {
	                  view.attr("d", this.area(this.cached[key]));
	              }
	
	              if (this.model.marker.color.use === "indicator") view
	                  .style("fill", this.values.color[key] ? _this.cScale(this.values.color[key]) : "transparent");
	
	              if (stack !== "none") view
	                  .transition().duration(Math.random() * 900 + 100).ease("circle")
	                  .style("stroke-opacity", .5);
	
	              if (this.model.time.record) this._export.write({
	                  type: "path",
	                  id: key,
	                  time: this.model.time.value.getUTCFullYear(),
	                  fill: this.cScale(this.values.color[key]),
	                  d: this.area(this.cached[key])
	              });
	          },
	
	          _setTooltip: function (tooltipText) {
	              if (tooltipText) {
	                  var mouse = d3.mouse(this.graph.node()).map(function (d) { return parseInt(d); });
	
	                  //position tooltip
	                  this.tooltip.classed("vzb-hidden", false)
	                      .attr("transform", "translate(" + (mouse[0]) + "," + (mouse[1]) + ")")
	                      .selectAll("text")
	                      .attr("text-anchor", "middle")
	                      .attr("alignment-baseline", "middle")
	                      .text(tooltipText)
	
	                  var contentBBox = this.tooltip.select("text")[0][0].getBBox();
	
	                  this.tooltip.select("rect")
	                      .attr("width", contentBBox.width + 8)
	                      .attr("height", contentBBox.height + 8)
	                      .attr("x", -contentBBox.width - 25)
	                      .attr("y", -contentBBox.height - 25)
	                      .attr("rx", contentBBox.height * .2)
	                      .attr("ry", contentBBox.height * .2);
	
	                  this.tooltip.selectAll("text")
	                      .attr("x", -contentBBox.width - 25 + ((contentBBox.width + 8)/2))
	                      .attr("y", -contentBBox.height - 25 + ((contentBBox.height + 11)/2)); // 11 is 8 for margin + 3 for strokes
	                  var translateX = (mouse[0] - contentBBox.width - 25) > 0 ? mouse[0] : (contentBBox.width + 25);
	                  var translateY = (mouse[1] - contentBBox.height - 25) > 0 ? mouse[1] : (contentBBox.height + 25);
	                  this.tooltip
	                      .attr("transform", "translate(" + translateX + "," + translateY + ")");
	
	              } else {
	
	                  this.tooltip.classed("vzb-hidden", true);
	              }
	          }
	
	      });
	
	      //MOUNTAIN CHART TOOL
	      var MountainChart = Tool.extend('MountainChart', {
	
	        /**
	         * Initializes the tool (MountainChart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	
	          this.name = "mountainchart";
	
	          //specifying components
	          this.components = [{
	            component: MountainChartComponent,
	            placeholder: '.vzb-tool-viz',
	            model: ["state.time", "state.entities", "state.marker", "language", "ui"] //pass models to component
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }, {
	            component: DataWarning,
	            placeholder: '.vzb-tool-datawarning',
	            model: ['language']
	          }, {
	            component: DataNotes,
	            placeholder: '.vzb-tool-datanotes',
	            model: ['state.marker', 'language']
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        }
	      });
	
	      //BAR CHART COMPONENT
	      var BarComponent = Component.extend({
	
	        /**
	         * Initializes the component (Bar Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The options passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function(config, context) {
	          this.name = 'barchart';
	          this.template = 'barchart.html';
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	          var _this = this;
	
	          this.model_binds = {
	            "change:time.value": function(evt) {
	              _this.model.marker.getFrame(_this.model.time.value, function(values) {
	              _this.values = values;
	              _this.updateEntities();
	              });
	            },
	            'change:marker': function(evt, path) {
	              if(!_this._readyOnce) return;
	              if(path.indexOf("color.palette") > -1) return;
	              if(path.indexOf("which") > -1 || path.indexOf("use") > -1) return;
	
	              _this.ready();
	            },
	            'change:marker.color.palette': debounce(function(evt) {
	              if(!_this._readyOnce) return;
	              _this.updateEntities();
	            }, 200)
	          };
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.xScale = null;
	          this.yScale = null;
	          this.cScale = d3.scale.category10();
	
	          this.xAxis = axisSmart();
	          this.yAxis = axisSmart();
	        },
	
	        /**
	         * DOM is ready
	         */
	        readyOnce: function() {
	          this.element = d3.select(this.element);
	
	          this.graph = this.element.select('.vzb-bc-graph');
	          this.yAxisEl = this.graph.select('.vzb-bc-axis-y');
	          this.xAxisEl = this.graph.select('.vzb-bc-axis-x');
	          this.yTitleEl = this.graph.select('.vzb-bc-axis-y-title');
	          this.xTitleEl = this.graph.select('.vzb-bc-axis-x-title');
	          this.bars = this.graph.select('.vzb-bc-bars');
	          this.year = this.element.select('.vzb-bc-year');
	
	          var _this = this;
	          this.on("resize", function() {
	              _this.updateEntities();
	          });
	        },
	
	        /*
	         * Both model and DOM are ready
	         */
	        ready: function() {
	          var _this = this;
	          this.model.marker.getFrame(this.model.time.value, function(values) {
	            _this.values = values;
	            _this.updateIndicators();
	            _this.resize();
	            _this.updateEntities();
	          });
	
	        },
	
	        /**
	         * Changes labels for indicators
	         */
	        updateIndicators: function() {
	
	          var _this = this;
	          this.translator = this.model.language.getTFunction();
	          this.duration = this.model.time.delayAnimations;
	
	          var titleStringY = this.translator("indicator/" + this.model.marker.axis_y.which);
	          var titleStringX = this.translator("indicator/" + this.model.marker.axis_x.which);
	
	          var yTitle = this.yTitleEl.selectAll("text").data([0]);
	          yTitle.enter().append("text");
	          yTitle
	            .attr("y", "-6px")
	            .attr("x", "-9px")
	            .attr("dx", "-0.72em")
	            .text(titleStringY)
	            .on("click", function() {
	              //TODO: Optimise updateView
	              _this.parent
	                .findChildByName("gapminder-treemenu")
	                .markerID("axis_y")
	                .alignX("left")
	                .alignY("top")
	                .updateView()
	                .toggle();
	            });
	
	          var xTitle = this.xTitleEl.selectAll("text").data([0]);
	          xTitle.enter().append("text");
	          xTitle
	            .attr("y", "-3px")
	            .attr("dx", "-0.72em")
	            .text(titleStringX)
	            .on("click", function() {
	              //TODO: Optimise updateView
	              _this.parent
	                .findChildByName("gapminder-treemenu")
	                .markerID("axis_x")
	                .alignY("bottom")
	                .alignX("center")
	                .updateView()
	                .toggle();
	            });
	
	          this.yScale = this.model.marker.axis_y.getScale();
	          this.xScale = this.model.marker.axis_x.getScale();
	          this.cScale = this.model.marker.color.getScale();
	
	          var xFormatter = this.model.marker.axis_x.which == "geo.world_4region"?
	              function(x){return _this.translator("entity/geo.world_4region/" + x)}
	              :
	              _this.model.marker.axis_x.getTickFormatter();
	
	          this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());
	          this.xAxis.tickFormat(xFormatter);
	
	        },
	
	        /**
	         * Updates entities
	         */
	        updateEntities: function() {
	
	          var _this = this;
	          var time = this.model.time;
	          var timeDim = time.getDimension();
	          var entityDim = this.model.entities.getDimension();
	          var duration = (time.playing) ? time.delayAnimations : 0;
	          var filter = {};
	          filter[timeDim] = time.value;
	          var items = this.model.marker.getKeys(filter);
	
	          this.entityBars = this.bars.selectAll('.vzb-bc-bar')
	            .data(items);
	
	          //exit selection
	          this.entityBars.exit().remove();
	
	          //enter selection -- init circles
	          this.entityBars.enter().append("rect")
	            .attr("class", "vzb-bc-bar")
	            .on("mousemove", function(d, i) {})
	            .on("mouseout", function(d, i) {})
	            .on("click", function(d, i) {});
	
	          //positioning and sizes of the bars
	
	          var bars = this.bars.selectAll('.vzb-bc-bar');
	          var barWidth = this.xScale.rangeBand();
	
	          this.bars.selectAll('.vzb-bc-bar')
	            .attr("width", barWidth)
	            .attr("fill", function(d) {
	              return _this.cScale(_this.values.color[d[entityDim]]);
	            })
	            .attr("x", function(d) {
	              return _this.xScale(_this.values.axis_x[d[entityDim]]);
	            })
	            .transition().duration(duration).ease("linear")
	            .attr("y", function(d) {
	              return _this.yScale(_this.values.axis_y[d[entityDim]]);
	            })
	            .attr("height", function(d) {
	              return _this.height - _this.yScale(_this.values.axis_y[d[entityDim]]);
	            });
	            this.year.text(this.model.time.timeFormat(this.model.time.value));
	        },
	
	        /**
	         * Executes everytime the container or vizabi is resized
	         * Ideally,it contains only operations related to size
	         */
	        resize: function() {
	
	          var _this = this;
	
	          this.profiles = {
	            "small": {
	              margin: {
	                top: 30,
	                right: 20,
	                left: 40,
	                bottom: 50
	              },
	              padding: 2,
	              minRadius: 2,
	              maxRadius: 40
	            },
	            "medium": {
	              margin: {
	                top: 30,
	                right: 60,
	                left: 60,
	                bottom: 60
	              },
	              padding: 2,
	              minRadius: 3,
	              maxRadius: 60
	            },
	            "large": {
	              margin: {
	                top: 30,
	                right: 60,
	                left: 60,
	                bottom: 80
	              },
	              padding: 2,
	              minRadius: 4,
	              maxRadius: 80
	            }
	          };
	
	          this.activeProfile = this.profiles[this.getLayoutProfile()];
	          var margin = this.activeProfile.margin;
	
	
	          //stage
	          this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	            
	          if(this.height<=0 || this.width<=0) return warn("Bar chart resize() abort: vizabi container is too little or has display:none");
	          
	          this.graph
	            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	          //update scales to the new range
	          if(this.model.marker.axis_y.scaleType !== "ordinal") {
	            this.yScale.range([this.height, 0]);
	          } else {
	            this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();
	          }
	          if(this.model.marker.axis_x.scaleType !== "ordinal") {
	            this.xScale.range([0, this.width]);
	          } else {
	            this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();
	          }
	
	          //apply scales to axes and redraw
	          this.yAxis.scale(this.yScale)
	            .orient("left")
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_y.scaleType,
	              timeFormat: this.model.time.timeFormat,
	              toolMargin: {top: 5, right: margin.right, left: margin.left, bottom: margin.bottom},
	              limitMaxTickNumber: 6
	            });
	
	          this.xAxis.scale(this.xScale)
	            .orient("bottom")
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_x.scaleType,
	              timeFormat: this.model.time.timeFormat,
	              toolMargin: margin,
	              constantRakeLength: this.width
	            });
	
	          this.xAxisEl.attr("transform", "translate(0," + this.height + ")")
	            .call(this.xAxis);
	
	          this.xScale.rangeRoundBands([0, this.width], .1, .2);
	
	          this.yAxisEl.call(this.yAxis);
	          this.xAxisEl.call(this.xAxis);
	
	          var xAxisSize = this.xAxisEl.node().getBoundingClientRect();
	          var xTitleSize = this.xTitleEl.node().getBoundingClientRect();
	          var xTitleXPos = xAxisSize.width / 2 - xTitleSize.width / 2;
	          var xTitleYPos = this.height + xAxisSize.height + xTitleSize.height;
	          this.xTitleEl.attr("transform", "translate(" + xTitleXPos + "," + xTitleYPos + ")");
	          this.year.attr('x', this.width).attr('y', 0);
	        }
	      });
	
	      //BAR CHART TOOL
	      var BarChart = Tool.extend('BarChart', {
	
	        /**
	         * Initializes the tool (Bar Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	
	          this.name = "barchart";
	
	          //specifying components
	          this.components = [{
	            component: BarComponent,
	            placeholder: '.vzb-tool-viz',
	            model: ["state.time", "state.entities", "state.marker", "language"] //pass models to component
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        },
	
	        default_model: {
	          state: {
	            time: {},
	            entities: {
	              dim: "geo",
	              show: {
	                _defs_: {
	                  "geo": ["*"],
	                  "geo.cat": ["region"]
	                }
	              }
	            },
	            marker: {
	              space: ["entities", "time"],
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              axis_y: {
	                use: "indicator",
	                which: "lex"
	              },
	              axis_x: {
	                use: "property",
	                which: "geo.name"
	              },
	              color: {
	                use: "property",
	                which: "geo.world_4region"
	              }
	            }
	          }
	        }
	      });
	
	      // topojson
	      var topojson = (function() {
	        var topojson = {
	          version: "1.6.19",
	          mesh: function(topology) {
	             return object(topology, meshArcs.apply(this, arguments));
	          },
	          meshArcs: meshArcs,
	          merge: function(topology) {
	            return object(topology, mergeArcs.apply(this, arguments));
	          },
	          mergeArcs: mergeArcs,
	          feature: featureOrCollection,
	          neighbors: neighbors,
	          presimplify: presimplify
	        };
	
	        function stitchArcs(topology, arcs) {
	          var stitchedArcs = {},
	            fragmentByStart = {},
	            fragmentByEnd = {},
	            fragments = [],
	            emptyIndex = -1;
	
	          // Stitch empty arcs first, since they may be subsumed by other arcs.
	          arcs.forEach(function(i, j) {
	            var arc = topology.arcs[i < 0 ? ~i : i],
	              t;
	            if(arc.length < 3 && !arc[1][0] && !arc[1][1]) {
	              t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
	            }
	          });
	
	          arcs.forEach(function(i) {
	            var e = ends(i),
	              start = e[0],
	              end = e[1],
	              f, g;
	
	            if(f = fragmentByEnd[start]) {
	              delete fragmentByEnd[f.end];
	              f.push(i);
	              f.end = end;
	              if(g = fragmentByStart[end]) {
	                delete fragmentByStart[g.start];
	                var fg = g === f ? f : f.concat(g);
	                fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
	              } else {
	                fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	              }
	            } else if(f = fragmentByStart[end]) {
	              delete fragmentByStart[f.start];
	              f.unshift(i);
	              f.start = start;
	              if(g = fragmentByEnd[start]) {
	                delete fragmentByEnd[g.end];
	                var gf = g === f ? f : g.concat(f);
	                fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
	              } else {
	                fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	              }
	            } else {
	              f = [i];
	              fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
	            }
	          });
	
	          function ends(i) {
	            var arc = topology.arcs[i < 0 ? ~i : i],
	              p0 = arc[0],
	              p1;
	            if(topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
	              p1[0] += dp[0], p1[1] += dp[1];
	            });
	            else p1 = arc[arc.length - 1];
	            return i < 0 ? [p1, p0] : [p0, p1];
	          }
	
	          function flush(fragmentByEnd, fragmentByStart) {
	            for(var k in fragmentByEnd) {
	              var f = fragmentByEnd[k];
	              delete fragmentByStart[f.start];
	              delete f.start;
	              delete f.end;
	              f.forEach(function(i) {
	                stitchedArcs[i < 0 ? ~i : i] = 1;
	              });
	              fragments.push(f);
	            }
	          }
	
	          flush(fragmentByEnd, fragmentByStart);
	          flush(fragmentByStart, fragmentByEnd);
	          arcs.forEach(function(i) {
	            if(!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
	          });
	
	          return fragments;
	        }
	
	        function meshArcs(topology, o, filter) {
	          var arcs = [];
	
	          function arc(i) {
	            var j = i < 0 ? ~i : i;
	            (geomsByArc[j] || (geomsByArc[j] = [])).push({
	              i: i,
	              g: geom
	            });
	          }
	
	          function line(arcs) {
	            arcs.forEach(arc);
	          }
	
	          function polygon(arcs) {
	            arcs.forEach(line);
	          }
	
	          function geometry(o) {
	            if(o.type === "GeometryCollection") o.geometries.forEach(geometry);
	            else if(o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
	          }
	
	          if(arguments.length > 1) {
	            var geomsByArc = [],
	              geom;
	
	            var geometryType = {
	              LineString: line,
	              MultiLineString: polygon,
	              Polygon: polygon,
	              MultiPolygon: function(arcs) {
	                arcs.forEach(polygon);
	              }
	            };
	
	            geometry(o);
	
	            geomsByArc.forEach(arguments.length < 3 ? function(geoms) {
	              arcs.push(geoms[0].i);
	            } : function(geoms) {
	              if(filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
	            });
	          } else {
	            for(var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
	          }
	
	          return {
	            type: "MultiLineString",
	            arcs: stitchArcs(topology, arcs)
	          };
	        }
	
	        function mergeArcs(topology, objects) {
	          var polygonsByArc = {},
	            polygons = [],
	            components = [];
	
	          objects.forEach(function(o) {
	            if(o.type === "Polygon") register(o.arcs);
	            else if(o.type === "MultiPolygon") o.arcs.forEach(register);
	          });
	
	          function register(polygon) {
	            polygon.forEach(function(ring) {
	              ring.forEach(function(arc) {
	                (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
	              });
	            });
	            polygons.push(polygon);
	          }
	
	          function exterior(ring) {
	            return cartesianRingArea(object(topology, {
	              type: "Polygon",
	              arcs: [ring]
	            }).coordinates[0]) > 0; // TODO allow spherical?
	          }
	
	          polygons.forEach(function(polygon) {
	            if(!polygon._) {
	              var component = [],
	                neighbors = [polygon];
	              polygon._ = 1;
	              components.push(component);
	              while(polygon = neighbors.pop()) {
	                component.push(polygon);
	                polygon.forEach(function(ring) {
	                  ring.forEach(function(arc) {
	                    polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
	                      if(!polygon._) {
	                        polygon._ = 1;
	                        neighbors.push(polygon);
	                      }
	                    });
	                  });
	                });
	              }
	            }
	          });
	
	          polygons.forEach(function(polygon) {
	            delete polygon._;
	          });
	
	          return {
	            type: "MultiPolygon",
	            arcs: components.map(function(polygons) {
	              var arcs = [];
	
	              // Extract the exterior (unique) arcs.
	              polygons.forEach(function(polygon) {
	                polygon.forEach(function(ring) {
	                  ring.forEach(function(arc) {
	                    if(polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
	                      arcs.push(arc);
	                    }
	                  });
	                });
	              });
	
	              // Stitch the arcs into one or more rings.
	              arcs = stitchArcs(topology, arcs);
	
	              // If more than one ring is returned,
	              // at most one of these rings can be the exterior;
	              // this exterior ring has the same winding order
	              // as any exterior ring in the original polygons.
	              if((n = arcs.length) > 1) {
	                var sgn = exterior(polygons[0][0]);
	                for(var i = 0, t; i < n; ++i) {
	                  if(sgn === exterior(arcs[i])) {
	                    t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
	                    break;
	                  }
	                }
	              }
	
	              return arcs;
	            })
	          };
	        }
	
	        function featureOrCollection(topology, o) {
	          return o.type === "GeometryCollection" ? {
	            type: "FeatureCollection",
	            features: o.geometries.map(function(o) {
	              return feature(topology, o);
	            })
	          } : feature(topology, o);
	        }
	
	        function feature(topology, o) {
	          var f = {
	            type: "Feature",
	            id: o.id,
	            properties: o.properties || {},
	            geometry: object(topology, o)
	          };
	          if(o.id == null) delete f.id;
	          return f;
	        }
	
	        function object(topology, o) {
	          var absolute = transformAbsolute(topology.transform),
	            arcs = topology.arcs;
	
	          function arc(i, points) {
	            if(points.length) points.pop();
	            for(var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
	              points.push(p = a[k].slice());
	              absolute(p, k);
	            }
	            if(i < 0) reverse(points, n);
	          }
	
	          function point(p) {
	            p = p.slice();
	            absolute(p, 0);
	            return p;
	          }
	
	          function line(arcs) {
	            var points = [];
	            for(var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
	            if(points.length < 2) points.push(points[0].slice());
	            return points;
	          }
	
	          function ring(arcs) {
	            var points = line(arcs);
	            while(points.length < 4) points.push(points[0].slice());
	            return points;
	          }
	
	          function polygon(arcs) {
	            return arcs.map(ring);
	          }
	
	          function geometry(o) {
	            var t = o.type;
	            return t === "GeometryCollection" ? {
	              type: t,
	              geometries: o.geometries.map(geometry)
	            } : t in geometryType ? {
	              type: t,
	              coordinates: geometryType[t](o)
	            } : null;
	          }
	
	          var geometryType = {
	            Point: function(o) {
	              return point(o.coordinates);
	            },
	            MultiPoint: function(o) {
	              return o.coordinates.map(point);
	            },
	            LineString: function(o) {
	              return line(o.arcs);
	            },
	            MultiLineString: function(o) {
	              return o.arcs.map(line);
	            },
	            Polygon: function(o) {
	              return polygon(o.arcs);
	            },
	            MultiPolygon: function(o) {
	              return o.arcs.map(polygon);
	            }
	          };
	
	          return geometry(o);
	        }
	
	        function reverse(array, n) {
	          var t, j = array.length,
	            i = j - n;
	          while(i < --j) t = array[i], array[i++] = array[j], array[j] = t;
	        }
	
	        function bisect(a, x) {
	          var lo = 0,
	            hi = a.length;
	          while(lo < hi) {
	            var mid = lo + hi >>> 1;
	            if(a[mid] < x) lo = mid + 1;
	            else hi = mid;
	          }
	          return lo;
	        }
	
	        function neighbors(objects) {
	          var indexesByArc = {}, // arc index -> array of object indexes
	            neighbors = objects.map(function() {
	              return [];
	            });
	
	          function line(arcs, i) {
	            arcs.forEach(function(a) {
	              if(a < 0) a = ~a;
	              var o = indexesByArc[a];
	              if(o) o.push(i);
	              else indexesByArc[a] = [i];
	            });
	          }
	
	          function polygon(arcs, i) {
	            arcs.forEach(function(arc) {
	              line(arc, i);
	            });
	          }
	
	          function geometry(o, i) {
	            if(o.type === "GeometryCollection") o.geometries.forEach(function(o) {
	              geometry(o, i);
	            });
	            else if(o.type in geometryType) geometryType[o.type](o.arcs, i);
	          }
	
	          var geometryType = {
	            LineString: line,
	            MultiLineString: polygon,
	            Polygon: polygon,
	            MultiPolygon: function(arcs, i) {
	              arcs.forEach(function(arc) {
	                polygon(arc, i);
	              });
	            }
	          };
	
	          objects.forEach(geometry);
	
	          for(var i in indexesByArc) {
	            for(var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
	              for(var k = j + 1; k < m; ++k) {
	                var ij = indexes[j],
	                  ik = indexes[k],
	                  n;
	                if((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
	                if((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
	              }
	            }
	          }
	
	          return neighbors;
	        }
	
	        function presimplify(topology, triangleArea) {
	          var absolute = transformAbsolute(topology.transform),
	            relative = transformRelative(topology.transform),
	            heap = minAreaHeap();
	
	          if(!triangleArea) triangleArea = cartesianTriangleArea;
	
	          topology.arcs.forEach(function(arc) {
	            var triangles = [],
	              maxArea = 0,
	              triangle;
	
	            // To store each point鈥檚 effective area, we create a new array rather than
	            // extending the passed-in point to workaround a Chrome/V8 bug (getting
	            // stuck in smi mode). For midpoints, the initial effective area of
	            // Infinity will be computed in the next step.
	            for(var i = 0, n = arc.length, p; i < n; ++i) {
	              p = arc[i];
	              absolute(arc[i] = [p[0], p[1], Infinity], i);
	            }
	
	            for(var i = 1, n = arc.length - 1; i < n; ++i) {
	              triangle = arc.slice(i - 1, i + 2);
	              triangle[1][2] = triangleArea(triangle);
	              triangles.push(triangle);
	              heap.push(triangle);
	            }
	
	            for(var i = 0, n = triangles.length; i < n; ++i) {
	              triangle = triangles[i];
	              triangle.previous = triangles[i - 1];
	              triangle.next = triangles[i + 1];
	            }
	
	            while(triangle = heap.pop()) {
	              var previous = triangle.previous,
	                next = triangle.next;
	
	              // If the area of the current point is less than that of the previous point
	              // to be eliminated, use the latter's area instead. This ensures that the
	              // current point cannot be eliminated without eliminating previously-
	              // eliminated points.
	              if(triangle[1][2] < maxArea) triangle[1][2] = maxArea;
	              else maxArea = triangle[1][2];
	
	              if(previous) {
	                previous.next = next;
	                previous[2] = triangle[2];
	                update(previous);
	              }
	
	              if(next) {
	                next.previous = previous;
	                next[0] = triangle[0];
	                update(next);
	              }
	            }
	
	            arc.forEach(relative);
	          });
	
	          function update(triangle) {
	            heap.remove(triangle);
	            triangle[1][2] = triangleArea(triangle);
	            heap.push(triangle);
	          }
	
	          return topology;
	        };
	
	        function cartesianRingArea(ring) {
	          var i = -1,
	            n = ring.length,
	            a,
	            b = ring[n - 1],
	            area = 0;
	
	          while(++i < n) {
	            a = b;
	            b = ring[i];
	            area += a[0] * b[1] - a[1] * b[0];
	          }
	
	          return area * .5;
	        }
	
	        function cartesianTriangleArea(triangle) {
	          var a = triangle[0],
	            b = triangle[1],
	            c = triangle[2];
	          return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
	        }
	
	        function compareArea(a, b) {
	          return a[1][2] - b[1][2];
	        }
	
	        function minAreaHeap() {
	          var heap = {},
	            array = [],
	            size = 0;
	
	          heap.push = function(object) {
	            up(array[object._ = size] = object, size++);
	            return size;
	          };
	
	          heap.pop = function() {
	            if(size <= 0) return;
	            var removed = array[0],
	              object;
	            if(--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
	            return removed;
	          };
	
	          heap.remove = function(removed) {
	            var i = removed._,
	              object;
	            if(array[i] !== removed) return; // invalid request
	            if(i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] =
	              object, i);
	            return i;
	          };
	
	          function up(object, i) {
	            while(i > 0) {
	              var j = ((i + 1) >> 1) - 1,
	                parent = array[j];
	              if(compareArea(object, parent) >= 0) break;
	              array[parent._ = i] = parent;
	              array[object._ = i = j] = object;
	            }
	          }
	
	          function down(object, i) {
	            while(true) {
	              var r = (i + 1) << 1,
	                l = r - 1,
	                j = i,
	                child = array[j];
	              if(l < size && compareArea(array[l], child) < 0) child = array[j = l];
	              if(r < size && compareArea(array[r], child) < 0) child = array[j = r];
	              if(j === i) break;
	              array[child._ = i] = child;
	              array[object._ = i = j] = object;
	            }
	          }
	
	          return heap;
	        }
	
	        function transformAbsolute(transform) {
	          if(!transform) return noop;
	          var x0,
	            y0,
	            kx = transform.scale[0],
	            ky = transform.scale[1],
	            dx = transform.translate[0],
	            dy = transform.translate[1];
	          return function(point, i) {
	            if(!i) x0 = y0 = 0;
	            point[0] = (x0 += point[0]) * kx + dx;
	            point[1] = (y0 += point[1]) * ky + dy;
	          };
	        }
	
	        function transformRelative(transform) {
	          if(!transform) return noop;
	          var x0,
	            y0,
	            kx = transform.scale[0],
	            ky = transform.scale[1],
	            dx = transform.translate[0],
	            dy = transform.translate[1];
	          return function(point, i) {
	            if(!i) x0 = y0 = 0;
	            var x1 = (point[0] - dx) / kx | 0,
	              y1 = (point[1] - dy) / ky | 0;
	            point[0] = x1 - x0;
	            point[1] = y1 - y0;
	            x0 = x1;
	            y0 = y1;
	          };
	        }
	
	        function noop() {}
	
	        return topojson;
	      }());
	
	      (function(exports) {
	
	        /*
	         * d3.cartogram is a d3-friendly implementation of An Algorithm to Construct
	         * Continuous Area Cartograms:
	         *
	         * <http://chrisman.scg.ulaval.ca/G360/dougenik.pdf>
	         *
	         * It requires topojson to decode TopoJSON-encoded topologies:
	         *
	         * <http://github.com/mbostock/topojson/>
	         *
	         * Usage:
	         *
	         * var cartogram = d3.cartogram()
	         *  .projection(d3.geo.albersUsa())
	         *  .value(function(d) {
	         *    return Math.random() * 100;
	         *  });
	         * d3.json("path/to/topology.json", function(topology) {
	         *  var features = cartogram(topology, topology.objects.OBJECTNAME.geometries);
	         *  d3.select("svg").selectAll("path")
	         *    .data(features)
	         *    .enter()
	         *    .append("path")
	         *      .attr("d", cartogram.path);
	         * });
	         */
	        d3.cartogram = function() {
	
	          function carto(topology, geometries, totalValue) {
	
	            var calculateObjectsMeta = function(objects, values, path) {
	              return new Promise(function(resolve, reject) {
	                var areas = objects.map(path.area);
	                var totalArea = d3.sum(areas),
	                  sizeErrorsTot =0,
	                  sizeErrorsNum=0;
	                
	                var calculateMeta = function(index, cb) {
	                  var area = Math.abs(areas[index]), // XXX: why do we have negative areas?
	                    v = + values[index],
	                    desired = totalArea * v / totalValue,
	                    radius = Math.sqrt(area / Math.PI),
	                    mass = Math.sqrt(desired / Math.PI) - radius,
	                    sizeError = Math.max(area, desired) / Math.min(area, desired);
	                  // console.log(o.id, "@", j, "area:", area, "value:", v, "->", desired, radius, mass, sizeError);
	                  cb( {
	                    id:         objects[index].id,
	                    area:       area,
	                    centroid:   path.centroid(objects[index]),
	                    value:      v,
	                    desired:    desired,
	                    radius:     radius,
	                    mass:       mass,
	                    sizeError:  sizeError
	                  });
	                };
	                var calculateMetaSequence = function(index) {
	                  if (index >= objects.length) {
	                    return resolve({meta: meta, sizeError: (sizeErrorsTot/sizeErrorsNum)})
	                  }
	                  calculateMeta(index, function(response) {
	                    meta.push(response);
	                    sizeErrorsTot+=response.sizeError;
	                    sizeErrorsNum++;
	                    if (index % 400 == 0) {
	                      defer(function() {
	                        calculateMetaSequence(++index);
	                      });
	                    } else {
	                      calculateMetaSequence(++index);
	                    }
	                  });
	                };
	                var meta = [];
	                calculateMetaSequence(0);
	              });
	            };
	            // copy it first
	            return new Promise(function(resolve, reject) {
	              topology = copy(topology);
	
	              // objects are projected into screen coordinates
	
	              // project the arcs into screen space
	              var tf = transformer(topology.transform),x,y,len1,i1,out1,len2=topology.arcs.length,i2=0,
	                projectedArcs = new Array(len2);
	              var projectedArcsDefer = new Promise();
	              var generateTopologySegment = function(segmentIndex, segmentLength) {
	                return new Promise(function(resolve, reject) {
	                  i1 = 0;
	                  while(i1<segmentLength){
	                    topology.arcs[segmentIndex][i1][0] = (x += topology.arcs[segmentIndex][i1][0]);
	                    topology.arcs[segmentIndex][i1][1] = (y += topology.arcs[segmentIndex][i1][1]);
	                    out1[i1] = projection === null ? tf(topology.arcs[segmentIndex][i1]) : projection(tf(topology.arcs[segmentIndex][i1]));
	                    i1++;
	                  }
	                  resolve(out1);
	                });
	                
	              };
	              var generateTopologyArcs = function(index, totalLength) {
	                if (index >= totalLength) {
	                  return projectedArcsDefer.resolve(projectedArcs);
	                }
	                x = 0;
	                y = 0;
	                len1 = topology.arcs[index].length;
	                i1 = 0;
	                out1 = new Array(len1);
	
	                generateTopologySegment(index, len1).then(function(segment) {
	                  projectedArcs[index++]=segment;
	                  if (index % 400 == 0) {
	                    defer(function() {
	                      generateTopologyArcs(index, totalLength);
	                    })
	                  } else {
	                    generateTopologyArcs(index, totalLength);
	                  }
	                });
	              };
	              generateTopologyArcs(0, len2);
	
	              projectedArcsDefer.then(function(projectedArcs) {
	                // path with identity projection
	                var path = d3.geo.path()
	                  .projection(null);
	                var objects = object(projectedArcs, {type: "GeometryCollection", geometries: geometries})
	                  .geometries.map(function(geom) {
	                    return {
	                      type: "Feature",
	                      id: geom.id,
	                      properties: properties.call(null, geom, topology),
	                      geometry: geom
	                    };
	                  });
	                var values = objects.map(value);
	                if (!totalValue) {
	                  totalValue = d3.sum(values);
	                }
	                // no iterations; just return the features
	                if (iterations <= 0) {
	                  resolve( {
	                    features: objects,
	                    arcs: projectedArcs
	                  });
	                }
	                var i = 0;
	                var resizeSegments = function(index, iterations) {
	                  if (index >= iterations) {
	                    return iterationsDefer.resolve();
	                  }
	                  calculateObjectsMeta(objects, values, path).then(function(response) {
	                    var forceReductionFactor = 1 / (1 + response.sizeError);
	
	                    // console.log("meta:", meta);
	                    // console.log("  total area:", totalArea);
	                    // console.log("  force reduction factor:", forceReductionFactor, "mean error:", sizeError);
	                    var delta,centroid,mass,radius,rSquared,dx,dy,distSquared,dist,Fij;
	                    var updatePoint = function(i2, len2) {
	                      var len1,i1,delta,len3,i3,centroid,mass,radius,rSquared,dx,dy,distSquared,dist,Fij;
	                      while(i2<len2){
	                        len1=projectedArcs[i2].length;
	                        i1=0;
	                        while(i1<len1){
	                          // create an array of vectors: [x, y]
	                          delta = [0,0];
	                          len3 = response.meta.length;
	                          i3=0;
	                          while(i3<len3) {
	                            centroid =  response.meta[i3].centroid;
	                            mass =      response.meta[i3].mass;
	                            radius =    response.meta[i3].radius;
	                            rSquared = (radius*radius);
	                            dx = projectedArcs[i2][i1][0] - centroid[0];
	                            dy = projectedArcs[i2][i1][1] - centroid[1];
	                            distSquared = dx * dx + dy * dy;
	                            dist=Math.sqrt(distSquared);
	                            Fij = (dist > radius)
	                              ? mass * radius / dist
	                              : mass *
	                            (distSquared / rSquared) *
	                            (4 - 3 * dist / radius);
	                            delta[0]+=(Fij * cosArctan(dy,dx));
	                            delta[1]+=(Fij * sinArctan(dy,dx));
	                            i3++;
	                          }
	                          projectedArcs[i2][i1][0] += (delta[0]*forceReductionFactor);
	                          projectedArcs[i2][i1][1] += (delta[1]*forceReductionFactor);
	                          i1++;
	                        }
	                        i2++;
	                      }              
	                    };
	                    var updatePointSequence = function(start) {
	                      if (start >= projectedArcs.length) {
	                        if (response.sizeError <= 1) {
	                          resizeSegments(iterations, iterations);
	                          return;
	                        }
	                        defer(function() {
	                          resizeSegments(++index, iterations);
	                        })
	                        return;
	                      } 
	                      var end = Math.min(start + 400, projectedArcs.length);
	                      updatePoint(start, end);
	                      defer(function() {
	                        updatePointSequence(end);
	                      });
	                    };
	                    updatePointSequence(0);
	                    // break if we hit the target size error
	                  });
	                };
	                var iterationsDefer = new Promise();
	
	                resizeSegments(0, iterations);
	                iterationsDefer.then(function() {
	                  resolve( {
	                    features: objects,
	                    arcs: projectedArcs
	                  });
	                });
	              });
	
	      /*
	              while(i2<len2){
	                x = 0;
	                y = 0;
	                len1 = topology.arcs[i2].length;
	                i1 = 0;
	                out1 = new Array(len1);
	                while(i1<len1){
	                  topology.arcs[i2][i1][0] = (x += topology.arcs[i2][i1][0]);
	                  topology.arcs[i2][i1][1] = (y += topology.arcs[i2][i1][1]);
	                  out1[i1] = projection === null ? tf(topology.arcs[i2][i1]) : projection(tf(topology.arcs[i2][i1]));
	                  i1++;
	                }
	                projectedArcs[i2++]=out1;
	
	              }
	      */
	            });
	            
	          }
	
	          var iterations = 8,
	              projection = d3.geo.albers(),
	              properties = function(id) {
	                return {};
	              },
	              value = function(d) {
	                return 1;
	              };
	
	          // for convenience
	          carto.path = d3.geo.path()
	            .projection(null);
	
	          carto.iterations = function(i) {
	            if (arguments.length) {
	              iterations = i;
	              return carto;
	            } else {
	              return iterations;
	            }
	          };
	
	          carto.value = function(v) {
	            if (arguments.length) {
	              value = d3.functor(v);
	              return carto;
	            } else {
	              return value;
	            }
	          };
	
	          carto.projection = function(p) {
	            if (arguments.length) {
	              projection = p;
	              return carto;
	            } else {
	              return projection;
	            }
	          };
	
	          carto.feature = function(topology, geom) {
	            return {
	              type: "Feature",
	              id: geom.id,
	              properties: properties.call(null, geom, topology),
	              geometry: {
	                type: geom.type,
	                coordinates: topojson.feature(topology, geom).geometry.coordinates
	              }
	            };
	          };
	          
	          carto.meshArcs = function(topology, o, filter) {
	            var arcs = [];
	
	            function arc(i) {
	              var j = i < 0 ? ~i : i;
	              (geomsByArc[j] || (geomsByArc[j] = [])).push({
	                i: i,
	                g: geom
	              });
	            }
	
	            function line(arcs) {
	              arcs.forEach(arc);
	            }
	
	            function polygon(arcs) {
	              arcs.forEach(line);
	            }
	
	            function geometry(o) {
	              if(o.type === "GeometryCollection") o.geometries.forEach(geometry);
	              else if(o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
	            }
	
	            if(arguments.length > 1) {
	              var geomsByArc = [],
	                geom;
	
	              var geometryType = {
	                LineString: line,
	                MultiLineString: polygon,
	                Polygon: polygon,
	                MultiPolygon: function(arcs) {
	                  arcs.forEach(polygon);
	                }
	              };
	
	              geometry(o);
	
	              geomsByArc.forEach(arguments.length < 3 ? function(geoms) {
	                arcs.push(geoms[0].i);
	              } : function(geoms) {
	                if(filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
	              });
	            } else {
	              for(var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
	            }
	
	            return arcs;
	          };
	
	          carto.stitchArcs = function(topology, arcs) {
	            var stitchedArcs = {},
	              fragmentByStart = {},
	              fragmentByEnd = {},
	              fragments = [],
	              emptyIndex = -1;
	
	            // Stitch empty arcs first, since they may be subsumed by other arcs.
	            arcs.forEach(function(i, j) {
	              var arc = topology.arcs[i < 0 ? ~i : i],
	                t;
	              if(arc.length < 3 && !arc[1][0] && !arc[1][1]) {
	                t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
	              }
	            });
	
	            arcs.forEach(function(i) {
	              var e = ends(i),
	                start = e[0],
	                end = e[1],
	                f, g;
	
	              if(f = fragmentByEnd[start]) {
	                delete fragmentByEnd[f.end];
	                f.push(i);
	                f.end = end;
	                if(g = fragmentByStart[end]) {
	                  delete fragmentByStart[g.start];
	                  var fg = g === f ? f : f.concat(g);
	                  fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
	                } else {
	                  fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	                }
	              } else if(f = fragmentByStart[end]) {
	                delete fragmentByStart[f.start];
	                f.unshift(i);
	                f.start = start;
	                if(g = fragmentByEnd[start]) {
	                  delete fragmentByEnd[g.end];
	                  var gf = g === f ? f : g.concat(f);
	                  fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
	                } else {
	                  fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	                }
	              } else {
	                f = [i];
	                fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
	              }
	            });
	
	            function ends(i) {
	              var arc = topology.arcs[i < 0 ? ~i : i],
	                p0 = arc[0],
	                p1;
	              if(topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
	                p1[0] += dp[0], p1[1] += dp[1];
	              });
	              else p1 = arc[arc.length - 1];
	              return i < 0 ? [p1, p0] : [p0, p1];
	            }
	
	            function flush(fragmentByEnd, fragmentByStart) {
	              for(var k in fragmentByEnd) {
	                var f = fragmentByEnd[k];
	                delete fragmentByStart[f.start];
	                delete f.start;
	                delete f.end;
	                f.forEach(function(i) {
	                  stitchedArcs[i < 0 ? ~i : i] = 1;
	                });
	                fragments.push(f);
	              }
	            }
	
	            flush(fragmentByEnd, fragmentByStart);
	            flush(fragmentByStart, fragmentByEnd);
	            arcs.forEach(function(i) {
	              if(!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
	            });
	
	            return object(topology, {
	              type: "MultiLineString",
	              arcs: fragments
	            })
	          };
	          
	          carto.features = function(topo, geometries) {
	            return geometries.map(function(f) {
	              return carto.feature(topo, f);
	            });
	          };
	
	          carto.properties = function(props) {
	            if (arguments.length) {
	              properties = d3.functor(props);
	              return carto;
	            } else {
	              return properties;
	            }
	          };
	
	          return carto;
	        };
	
	        var transformer = d3.cartogram.transformer = function(tf) {
	          var kx = tf.scale[0],
	              ky = tf.scale[1],
	              dx = tf.translate[0],
	              dy = tf.translate[1];
	
	          function transform(c) {
	            return [c[0] * kx + dx, c[1] * ky + dy];
	          }
	
	          transform.invert = function(c) {
	            return [(c[0] - dx) / kx, (c[1]- dy) / ky];
	          };
	
	          return transform;
	        };
	
	        function angle(a, b) {
	          return Math.atan2(b[1] - a[1], b[0] - a[0]);
	        }
	
	        function distance(a, b) {
	          var dx = b[0] - a[0],
	              dy = b[1] - a[1];
	          return Math.sqrt(dx * dx + dy * dy);
	        }
	
	        function projector(proj) {
	          var types = {
	            Point: proj,
	            LineString: function(coords) {
	              return coords.map(proj);
	            },
	            MultiLineString: function(arcs) {
	              return arcs.map(types.LineString);
	            },
	            Polygon: function(rings) {
	              return rings.map(types.LineString);
	            },
	            MultiPolygon: function(rings) {
	              return rings.map(types.Polygon);
	            }
	          };
	          return function(geom) {
	            return types[geom.type](geom.coordinates);
	          };
	        }
	        function cosArctan(dx,dy){
	          if (dy===0) return 0;
	          var div = dx/dy;
	          return (dy>0)?
	            (1/Math.sqrt(1+(div*div))):
	            (-1/Math.sqrt(1+(div*div)));
	        }
	        function sinArctan(dx,dy){
	          if (dy===0) return 1;
	          var div = dx/dy;
	          return (dy>0)?
	            (div/Math.sqrt(1+(div*div))):
	            (-div/Math.sqrt(1+(div*div)));
	        }
	        function copy(o) {
	          return (o instanceof Array)
	            ? o.map(copy)
	            : (typeof o === "string" || typeof o === "number")
	              ? o
	              : copyObject(o);
	        }
	        
	        function copyObject(o) {
	          var obj = {};
	          for (var k in o) obj[k] = copy(o[k]);
	          return obj;
	        }
	
	        function object(topology, o) {
	          var arcs = topology.arcs ? topology.arcs : topology;
	          function arc(i, points) {
	            if (points.length) points.pop();
	            if (!arcs[i < 0 ? ~i : i]) {
	              console.log("fail");
	            }
	            for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
	              points.push(a[k]);
	            }
	            if (i < 0) reverse(points, n);
	          }
	
	          function line(arcs) {
	            var points = [];
	            for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
	            return points;
	          }
	
	          function polygon(arcs) {
	            return arcs.map(line);
	          }
	
	          function geometry(o) {
	            o = Object.create(o);
	            o.coordinates = geometryType[o.type](o.arcs);
	            return o;
	          }
	          var geometryType = {
	            LineString: line,
	            MultiLineString: polygon,
	            Polygon: polygon,
	            MultiPolygon: function(arcs) { return arcs.map(polygon); }
	          };
	
	          return o.type === "GeometryCollection"
	              ? (o = Object.create(o), o.geometries = o.geometries.map(geometry), o)
	              : geometry(o);
	        }
	
	        function reverse(array, n) {
	          var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
	        }
	
	      })(undefined);
	
	      function d3_geo_projection() {
	        d3.geo.project = function(object, projection) {
	          var stream = projection.stream;
	          if (!stream) throw new Error("not yet supported");
	          return (object && d3_geo_projectObjectType.hasOwnProperty(object.type) ? d3_geo_projectObjectType[object.type] : d3_geo_projectGeometry)(object, stream);
	        };
	        function d3_geo_projectFeature(object, stream) {
	          return {
	            type: "Feature",
	            id: object.id,
	            properties: object.properties,
	            geometry: d3_geo_projectGeometry(object.geometry, stream)
	          };
	        }
	        function d3_geo_projectGeometry(geometry, stream) {
	          if (!geometry) return null;
	          if (geometry.type === "GeometryCollection") return {
	            type: "GeometryCollection",
	            geometries: object.geometries.map(function(geometry) {
	              return d3_geo_projectGeometry(geometry, stream);
	            })
	          };
	          if (!d3_geo_projectGeometryType.hasOwnProperty(geometry.type)) return null;
	          var sink = d3_geo_projectGeometryType[geometry.type];
	          d3.geo.stream(geometry, stream(sink));
	          return sink.result();
	        }
	        var d3_geo_projectObjectType = {
	          Feature: d3_geo_projectFeature,
	          FeatureCollection: function(object, stream) {
	            return {
	              type: "FeatureCollection",
	              features: object.features.map(function(feature) {
	                return d3_geo_projectFeature(feature, stream);
	              })
	            };
	          }
	        };
	        var d3_geo_projectPoints = [], d3_geo_projectLines = [];
	        var d3_geo_projectPoint = {
	          point: function(x, y) {
	            d3_geo_projectPoints.push([ x, y ]);
	          },
	          result: function() {
	            var result = !d3_geo_projectPoints.length ? null : d3_geo_projectPoints.length < 2 ? {
	              type: "Point",
	              coordinates: d3_geo_projectPoints[0]
	            } : {
	              type: "MultiPoint",
	              coordinates: d3_geo_projectPoints
	            };
	            d3_geo_projectPoints = [];
	            return result;
	          }
	        };
	        var d3_geo_projectLine = {
	          lineStart: d3_geo_projectNoop,
	          point: function(x, y) {
	            d3_geo_projectPoints.push([ x, y ]);
	          },
	          lineEnd: function() {
	            if (d3_geo_projectPoints.length) d3_geo_projectLines.push(d3_geo_projectPoints), 
	            d3_geo_projectPoints = [];
	          },
	          result: function() {
	            var result = !d3_geo_projectLines.length ? null : d3_geo_projectLines.length < 2 ? {
	              type: "LineString",
	              coordinates: d3_geo_projectLines[0]
	            } : {
	              type: "MultiLineString",
	              coordinates: d3_geo_projectLines
	            };
	            d3_geo_projectLines = [];
	            return result;
	          }
	        };
	        var d3_geo_projectPolygon = {
	          polygonStart: d3_geo_projectNoop,
	          lineStart: d3_geo_projectNoop,
	          point: function(x, y) {
	            d3_geo_projectPoints.push([ x, y ]);
	          },
	          lineEnd: function() {
	            var n = d3_geo_projectPoints.length;
	            if (n) {
	              do d3_geo_projectPoints.push(d3_geo_projectPoints[0].slice()); while (++n < 4);
	              d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];
	            }
	          },
	          polygonEnd: d3_geo_projectNoop,
	          result: function() {
	            if (!d3_geo_projectLines.length) return null;
	            var polygons = [], holes = [];
	            d3_geo_projectLines.forEach(function(ring) {
	              if (d3_geo_projectClockwise(ring)) polygons.push([ ring ]); else holes.push(ring);
	            });
	            holes.forEach(function(hole) {
	              var point = hole[0];
	              polygons.some(function(polygon) {
	                if (d3_geo_projectContains(polygon[0], point)) {
	                  polygon.push(hole);
	                  return true;
	                }
	              }) || polygons.push([ hole ]);
	            });
	            d3_geo_projectLines = [];
	            return !polygons.length ? null : polygons.length > 1 ? {
	              type: "MultiPolygon",
	              coordinates: polygons
	            } : {
	              type: "Polygon",
	              coordinates: polygons[0]
	            };
	          }
	        };
	        var d3_geo_projectGeometryType = {
	          Point: d3_geo_projectPoint,
	          MultiPoint: d3_geo_projectPoint,
	          LineString: d3_geo_projectLine,
	          MultiLineString: d3_geo_projectLine,
	          Polygon: d3_geo_projectPolygon,
	          MultiPolygon: d3_geo_projectPolygon,
	          Sphere: d3_geo_projectPolygon
	        };
	        function d3_geo_projectNoop() {}
	        function d3_geo_projectClockwise(ring) {
	          if ((n = ring.length) < 4) return false;
	          var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
	          while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
	          return area <= 0;
	        }
	        function d3_geo_projectContains(ring, point) {
	          var x = point[0], y = point[1], contains = false;
	          for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
	            var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
	            if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;
	          }
	          return contains;
	        }
	        var ε = 1e-6, ε2 = ε * ε, π = Math.PI, halfπ = π / 2, sqrtπ = Math.sqrt(π), radians = π / 180, degrees = 180 / π;
	        function sinci(x) {
	          return x ? x / Math.sin(x) : 1;
	        }
	        function sgn(x) {
	          return x > 0 ? 1 : x < 0 ? -1 : 0;
	        }
	        function asin(x) {
	          return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	        }
	        function acos(x) {
	          return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	        }
	        function asqrt(x) {
	          return x > 0 ? Math.sqrt(x) : 0;
	        }
	        var projection = d3.geo.projection, projectionMutator = d3.geo.projectionMutator;
	        d3.geo.interrupt = function(project) {
	          var lobes = [ [ [ [ -π, 0 ], [ 0, halfπ ], [ π, 0 ] ] ], [ [ [ -π, 0 ], [ 0, -halfπ ], [ π, 0 ] ] ] ];
	          var bounds;
	          function forward(λ, φ) {
	            var sign = φ < 0 ? -1 : +1, hemilobes = lobes[+(φ < 0)];
	            for (var i = 0, n = hemilobes.length - 1; i < n && λ > hemilobes[i][2][0]; ++i) ;
	            var coordinates = project(λ - hemilobes[i][1][0], φ);
	            coordinates[0] += project(hemilobes[i][1][0], sign * φ > sign * hemilobes[i][0][1] ? hemilobes[i][0][1] : φ)[0];
	            return coordinates;
	          }
	          function reset() {
	            bounds = lobes.map(function(hemilobes) {
	              return hemilobes.map(function(lobe) {
	                var x0 = project(lobe[0][0], lobe[0][1])[0], x1 = project(lobe[2][0], lobe[2][1])[0], y0 = project(lobe[1][0], lobe[0][1])[1], y1 = project(lobe[1][0], lobe[1][1])[1], t;
	                if (y0 > y1) t = y0, y0 = y1, y1 = t;
	                return [ [ x0, y0 ], [ x1, y1 ] ];
	              });
	            });
	          }
	          if (project.invert) forward.invert = function(x, y) {
	            var hemibounds = bounds[+(y < 0)], hemilobes = lobes[+(y < 0)];
	            for (var i = 0, n = hemibounds.length; i < n; ++i) {
	              var b = hemibounds[i];
	              if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
	                var coordinates = project.invert(x - project(hemilobes[i][1][0], 0)[0], y);
	                coordinates[0] += hemilobes[i][1][0];
	                return pointEqual(forward(coordinates[0], coordinates[1]), [ x, y ]) ? coordinates : null;
	              }
	            }
	          };
	          var projection = d3.geo.projection(forward), stream_ = projection.stream;
	          projection.stream = function(stream) {
	            var rotate = projection.rotate(), rotateStream = stream_(stream), sphereStream = (projection.rotate([ 0, 0 ]), 
	            stream_(stream));
	            projection.rotate(rotate);
	            rotateStream.sphere = function() {
	              d3.geo.stream(sphere(), sphereStream);
	            };
	            return rotateStream;
	          };
	          projection.lobes = function(_) {
	            if (!arguments.length) return lobes.map(function(lobes) {
	              return lobes.map(function(lobe) {
	                return [ [ lobe[0][0] * 180 / π, lobe[0][1] * 180 / π ], [ lobe[1][0] * 180 / π, lobe[1][1] * 180 / π ], [ lobe[2][0] * 180 / π, lobe[2][1] * 180 / π ] ];
	              });
	            });
	            lobes = _.map(function(lobes) {
	              return lobes.map(function(lobe) {
	                return [ [ lobe[0][0] * π / 180, lobe[0][1] * π / 180 ], [ lobe[1][0] * π / 180, lobe[1][1] * π / 180 ], [ lobe[2][0] * π / 180, lobe[2][1] * π / 180 ] ];
	              });
	            });
	            reset();
	            return projection;
	          };
	          function sphere() {
	            var ε = 1e-6, coordinates = [];
	            for (var i = 0, n = lobes[0].length; i < n; ++i) {
	              var lobe = lobes[0][i], λ0 = lobe[0][0] * 180 / π, φ0 = lobe[0][1] * 180 / π, φ1 = lobe[1][1] * 180 / π, λ2 = lobe[2][0] * 180 / π, φ2 = lobe[2][1] * 180 / π;
	              coordinates.push(resample([ [ λ0 + ε, φ0 + ε ], [ λ0 + ε, φ1 - ε ], [ λ2 - ε, φ1 - ε ], [ λ2 - ε, φ2 + ε ] ], 30));
	            }
	            for (var i = lobes[1].length - 1; i >= 0; --i) {
	              var lobe = lobes[1][i], λ0 = lobe[0][0] * 180 / π, φ0 = lobe[0][1] * 180 / π, φ1 = lobe[1][1] * 180 / π, λ2 = lobe[2][0] * 180 / π, φ2 = lobe[2][1] * 180 / π;
	              coordinates.push(resample([ [ λ2 - ε, φ2 - ε ], [ λ2 - ε, φ1 + ε ], [ λ0 + ε, φ1 + ε ], [ λ0 + ε, φ0 - ε ] ], 30));
	            }
	            return {
	              type: "Polygon",
	              coordinates: [ d3.merge(coordinates) ]
	            };
	          }
	          function resample(coordinates, m) {
	            var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];
	            while (++i < n) {
	              p1 = coordinates[i];
	              dx = (p1[0] - p0[0]) / m;
	              dy = (p1[1] - p0[1]) / m;
	              for (var j = 0; j < m; ++j) resampled.push([ p0[0] + j * dx, p0[1] + j * dy ]);
	              p0 = p1;
	            }
	            resampled.push(p1);
	            return resampled;
	          }
	          function pointEqual(a, b) {
	            return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
	          }
	          return projection;
	        };
	        function airy(β) {
	          var tanβ_2 = Math.tan(.5 * β), B = 2 * Math.log(Math.cos(.5 * β)) / (tanβ_2 * tanβ_2);
	          function forward(λ, φ) {
	            var cosλ = Math.cos(λ), cosφ = Math.cos(φ), sinφ = Math.sin(φ), cosz = cosφ * cosλ, K = -((1 - cosz ? Math.log(.5 * (1 + cosz)) / (1 - cosz) : -.5) + B / (1 + cosz));
	            return [ K * cosφ * Math.sin(λ), K * sinφ ];
	          }
	          forward.invert = function(x, y) {
	            var ρ = Math.sqrt(x * x + y * y), z = β * -.5, i = 50, δ;
	            if (!ρ) return [ 0, 0 ];
	            do {
	              var z_2 = .5 * z, cosz_2 = Math.cos(z_2), sinz_2 = Math.sin(z_2), tanz_2 = Math.tan(z_2), lnsecz_2 = Math.log(1 / cosz_2);
	              z -= δ = (2 / tanz_2 * lnsecz_2 - B * tanz_2 - ρ) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - B / (2 * cosz_2 * cosz_2));
	            } while (Math.abs(δ) > ε && --i > 0);
	            var sinz = Math.sin(z);
	            return [ Math.atan2(x * sinz, ρ * Math.cos(z)), asin(y * sinz / ρ) ];
	          };
	          return forward;
	        }
	        function airyProjection() {
	          var β = halfπ, m = projectionMutator(airy), p = m(β);
	          p.radius = function(_) {
	            if (!arguments.length) return β / π * 180;
	            return m(β = _ * π / 180);
	          };
	          return p;
	        }
	        (d3.geo.airy = airyProjection).raw = airy;
	        function aitoff(λ, φ) {
	          var cosφ = Math.cos(φ), sinciα = sinci(acos(cosφ * Math.cos(λ /= 2)));
	          return [ 2 * cosφ * Math.sin(λ) * sinciα, Math.sin(φ) * sinciα ];
	        }
	        aitoff.invert = function(x, y) {
	          if (x * x + 4 * y * y > π * π + ε) return;
	          var λ = x, φ = y, i = 25;
	          do {
	            var sinλ = Math.sin(λ), sinλ_2 = Math.sin(λ / 2), cosλ_2 = Math.cos(λ / 2), sinφ = Math.sin(φ), cosφ = Math.cos(φ), sin_2φ = Math.sin(2 * φ), sin2φ = sinφ * sinφ, cos2φ = cosφ * cosφ, sin2λ_2 = sinλ_2 * sinλ_2, C = 1 - cos2φ * cosλ_2 * cosλ_2, E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = 2 * E * cosφ * sinλ_2 - x, fy = E * sinφ - y, δxδλ = F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ), δxδφ = F * (.5 * sinλ * sin_2φ - E * 2 * sinφ * sinλ_2), δyδλ = F * .25 * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ), δyδφ = F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ), denominator = δxδφ * δyδλ - δyδφ * δxδλ;
	            if (!denominator) break;
	            var δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
	            λ -= δλ, φ -= δφ;
	          } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
	          return [ λ, φ ];
	        };
	        (d3.geo.aitoff = function() {
	          return projection(aitoff);
	        }).raw = aitoff;
	        function armadillo(φ0) {
	          var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sφ0 = φ0 > 0 ? 1 : -1, tanφ0 = Math.tan(sφ0 * φ0), k = (1 + sinφ0 - cosφ0) / 2;
	          function forward(λ, φ) {
	            var cosφ = Math.cos(φ), cosλ = Math.cos(λ /= 2);
	            return [ (1 + cosφ) * Math.sin(λ), (sφ0 * φ > -Math.atan2(cosλ, tanφ0) - .001 ? 0 : -sφ0 * 10) + k + Math.sin(φ) * cosφ0 - (1 + cosφ) * sinφ0 * cosλ ];
	          }
	          forward.invert = function(x, y) {
	            var λ = 0, φ = 0, i = 50;
	            do {
	              var cosλ = Math.cos(λ), sinλ = Math.sin(λ), cosφ = Math.cos(φ), sinφ = Math.sin(φ), A = 1 + cosφ, fx = A * sinλ - x, fy = k + sinφ * cosφ0 - A * sinφ0 * cosλ - y, δxδλ = .5 * A * cosλ, δxδφ = -sinλ * sinφ, δyδλ = .5 * sinφ0 * A * sinλ, δyδφ = cosφ0 * cosφ + sinφ0 * cosλ * sinφ, denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = .5 * (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
	              λ -= δλ, φ -= δφ;
	            } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
	            return sφ0 * φ > -Math.atan2(Math.cos(λ), tanφ0) - .001 ? [ λ * 2, φ ] : null;
	          };
	          return forward;
	        }
	        function armadilloProjection() {
	          var φ0 = π / 9, sφ0 = φ0 > 0 ? 1 : -1, tanφ0 = Math.tan(sφ0 * φ0), m = projectionMutator(armadillo), p = m(φ0), stream_ = p.stream;
	          p.parallel = function(_) {
	            if (!arguments.length) return φ0 / π * 180;
	            tanφ0 = Math.tan((sφ0 = (φ0 = _ * π / 180) > 0 ? 1 : -1) * φ0);
	            return m(φ0);
	          };
	          p.stream = function(stream) {
	            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([ 0, 0 ]), 
	            stream_(stream));
	            p.rotate(rotate);
	            rotateStream.sphere = function() {
	              sphereStream.polygonStart(), sphereStream.lineStart();
	              for (var λ = sφ0 * -180; sφ0 * λ < 180; λ += sφ0 * 90) sphereStream.point(λ, sφ0 * 90);
	              while (sφ0 * (λ -= φ0) >= -180) {
	                sphereStream.point(λ, sφ0 * -Math.atan2(Math.cos(λ * radians / 2), tanφ0) * degrees);
	              }
	              sphereStream.lineEnd(), sphereStream.polygonEnd();
	            };
	            return rotateStream;
	          };
	          return p;
	        }
	        (d3.geo.armadillo = armadilloProjection).raw = armadillo;
	        function tanh(x) {
	          x = Math.exp(2 * x);
	          return (x - 1) / (x + 1);
	        }
	        function sinh(x) {
	          return .5 * (Math.exp(x) - Math.exp(-x));
	        }
	        function cosh(x) {
	          return .5 * (Math.exp(x) + Math.exp(-x));
	        }
	        function arsinh(x) {
	          return Math.log(x + asqrt(x * x + 1));
	        }
	        function arcosh(x) {
	          return Math.log(x + asqrt(x * x - 1));
	        }
	        function august(λ, φ) {
	          var tanφ = Math.tan(φ / 2), k = asqrt(1 - tanφ * tanφ), c = 1 + k * Math.cos(λ /= 2), x = Math.sin(λ) * k / c, y = tanφ / c, x2 = x * x, y2 = y * y;
	          return [ 4 / 3 * x * (3 + x2 - 3 * y2), 4 / 3 * y * (3 + 3 * x2 - y2) ];
	        }
	        august.invert = function(x, y) {
	          x *= 3 / 8, y *= 3 / 8;
	          if (!x && Math.abs(y) > 1) return null;
	          var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3η = Math.sqrt(.5 * (s - Math.sqrt(s * s - 4 * y * y))), η = asin(sin3η) / 3, ξ = sin3η ? arcosh(Math.abs(y / sin3η)) / 3 : arsinh(Math.abs(x)) / 3, cosη = Math.cos(η), coshξ = cosh(ξ), d = coshξ * coshξ - cosη * cosη;
	          return [ sgn(x) * 2 * Math.atan2(sinh(ξ) * cosη, .25 - d), sgn(y) * 2 * Math.atan2(coshξ * Math.sin(η), .25 + d) ];
	        };
	        (d3.geo.august = function() {
	          return projection(august);
	        }).raw = august;
	        var bakerφ = Math.log(1 + Math.SQRT2);
	        function baker(λ, φ) {
	          var φ0 = Math.abs(φ);
	          return φ0 < π / 4 ? [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ] : [ λ * Math.cos(φ0) * (2 * Math.SQRT2 - 1 / Math.sin(φ0)), sgn(φ) * (2 * Math.SQRT2 * (φ0 - π / 4) - Math.log(Math.tan(φ0 / 2))) ];
	        }
	        baker.invert = function(x, y) {
	          if ((y0 = Math.abs(y)) < bakerφ) return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	          var sqrt8 = Math.sqrt(8), φ = π / 4, i = 25, δ, y0;
	          do {
	            var cosφ_2 = Math.cos(φ / 2), tanφ_2 = Math.tan(φ / 2);
	            φ -= δ = (sqrt8 * (φ - π / 4) - Math.log(tanφ_2) - y0) / (sqrt8 - .5 * cosφ_2 * cosφ_2 / tanφ_2);
	          } while (Math.abs(δ) > ε2 && --i > 0);
	          return [ x / (Math.cos(φ) * (sqrt8 - 1 / Math.sin(φ))), sgn(y) * φ ];
	        };
	        (d3.geo.baker = function() {
	          return projection(baker);
	        }).raw = baker;
	        var berghausAzimuthalEquidistant = d3.geo.azimuthalEquidistant.raw;
	        function berghaus(n) {
	          var k = 2 * π / n;
	          function forward(λ, φ) {
	            var p = berghausAzimuthalEquidistant(λ, φ);
	            if (Math.abs(λ) > halfπ) {
	              var θ = Math.atan2(p[1], p[0]), r = Math.sqrt(p[0] * p[0] + p[1] * p[1]), θ0 = k * Math.round((θ - halfπ) / k) + halfπ, α = Math.atan2(Math.sin(θ -= θ0), 2 - Math.cos(θ));
	              θ = θ0 + asin(π / r * Math.sin(α)) - α;
	              p[0] = r * Math.cos(θ);
	              p[1] = r * Math.sin(θ);
	            }
	            return p;
	          }
	          forward.invert = function(x, y) {
	            var r = Math.sqrt(x * x + y * y);
	            if (r > halfπ) {
	              var θ = Math.atan2(y, x), θ0 = k * Math.round((θ - halfπ) / k) + halfπ, s = θ > θ0 ? -1 : 1, A = r * Math.cos(θ0 - θ), cotα = 1 / Math.tan(s * Math.acos((A - π) / Math.sqrt(π * (π - 2 * A) + r * r)));
	              θ = θ0 + 2 * Math.atan((cotα + s * Math.sqrt(cotα * cotα - 3)) / 3);
	              x = r * Math.cos(θ), y = r * Math.sin(θ);
	            }
	            return berghausAzimuthalEquidistant.invert(x, y);
	          };
	          return forward;
	        }
	        function berghausProjection() {
	          var n = 5, m = projectionMutator(berghaus), p = m(n), stream_ = p.stream, ε = .01, cr = -Math.cos(ε * radians), sr = Math.sin(ε * radians);
	          p.lobes = function(_) {
	            if (!arguments.length) return n;
	            return m(n = +_);
	          };
	          p.stream = function(stream) {
	            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([ 0, 0 ]), 
	            stream_(stream));
	            p.rotate(rotate);
	            rotateStream.sphere = function() {
	              sphereStream.polygonStart(), sphereStream.lineStart();
	              for (var i = 0, δ = 360 / n, δ0 = 2 * π / n, φ = 90 - 180 / n, φ0 = halfπ; i < n; ++i, 
	              φ -= δ, φ0 -= δ0) {
	                sphereStream.point(Math.atan2(sr * Math.cos(φ0), cr) * degrees, asin(sr * Math.sin(φ0)) * degrees);
	                if (φ < -90) {
	                  sphereStream.point(-90, -180 - φ - ε);
	                  sphereStream.point(-90, -180 - φ + ε);
	                } else {
	                  sphereStream.point(90, φ + ε);
	                  sphereStream.point(90, φ - ε);
	                }
	              }
	              sphereStream.lineEnd(), sphereStream.polygonEnd();
	            };
	            return rotateStream;
	          };
	          return p;
	        }
	        (d3.geo.berghaus = berghausProjection).raw = berghaus;
	        function mollweideBromleyθ(Cp) {
	          return function(θ) {
	            var Cpsinθ = Cp * Math.sin(θ), i = 30, δ;
	            do θ -= δ = (θ + Math.sin(θ) - Cpsinθ) / (1 + Math.cos(θ)); while (Math.abs(δ) > ε && --i > 0);
	            return θ / 2;
	          };
	        }
	        function mollweideBromley(Cx, Cy, Cp) {
	          var θ = mollweideBromleyθ(Cp);
	          function forward(λ, φ) {
	            return [ Cx * λ * Math.cos(φ = θ(φ)), Cy * Math.sin(φ) ];
	          }
	          forward.invert = function(x, y) {
	            var θ = asin(y / Cy);
	            return [ x / (Cx * Math.cos(θ)), asin((2 * θ + Math.sin(2 * θ)) / Cp) ];
	          };
	          return forward;
	        }
	        var mollweideθ = mollweideBromleyθ(π), mollweide = mollweideBromley(Math.SQRT2 / halfπ, Math.SQRT2, π);
	        (d3.geo.mollweide = function() {
	          return projection(mollweide);
	        }).raw = mollweide;
	        function boggs(λ, φ) {
	          var k = 2.00276, θ = mollweideθ(φ);
	          return [ k * λ / (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)), (φ + Math.SQRT2 * Math.sin(θ)) / k ];
	        }
	        boggs.invert = function(x, y) {
	          var k = 2.00276, ky = k * y, θ = y < 0 ? -π / 4 : π / 4, i = 25, δ, φ;
	          do {
	            φ = ky - Math.SQRT2 * Math.sin(θ);
	            θ -= δ = (Math.sin(2 * θ) + 2 * θ - π * Math.sin(φ)) / (2 * Math.cos(2 * θ) + 2 + π * Math.cos(φ) * Math.SQRT2 * Math.cos(θ));
	          } while (Math.abs(δ) > ε && --i > 0);
	          φ = ky - Math.SQRT2 * Math.sin(θ);
	          return [ x * (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)) / k, φ ];
	        };
	        (d3.geo.boggs = function() {
	          return projection(boggs);
	        }).raw = boggs;
	        function parallel1Projection(projectAt) {
	          var φ0 = 0, m = projectionMutator(projectAt), p = m(φ0);
	          p.parallel = function(_) {
	            if (!arguments.length) return φ0 / π * 180;
	            return m(φ0 = _ * π / 180);
	          };
	          return p;
	        }
	        function sinusoidal(λ, φ) {
	          return [ λ * Math.cos(φ), φ ];
	        }
	        sinusoidal.invert = function(x, y) {
	          return [ x / Math.cos(y), y ];
	        };
	        (d3.geo.sinusoidal = function() {
	          return projection(sinusoidal);
	        }).raw = sinusoidal;
	        function bonne(φ0) {
	          if (!φ0) return sinusoidal;
	          var cotφ0 = 1 / Math.tan(φ0);
	          function forward(λ, φ) {
	            var ρ = cotφ0 + φ0 - φ, E = ρ ? λ * Math.cos(φ) / ρ : ρ;
	            return [ ρ * Math.sin(E), cotφ0 - ρ * Math.cos(E) ];
	          }
	          forward.invert = function(x, y) {
	            var ρ = Math.sqrt(x * x + (y = cotφ0 - y) * y), φ = cotφ0 + φ0 - ρ;
	            return [ ρ / Math.cos(φ) * Math.atan2(x, y), φ ];
	          };
	          return forward;
	        }
	        (d3.geo.bonne = function() {
	          return parallel1Projection(bonne).parallel(45);
	        }).raw = bonne;
	        var bromley = mollweideBromley(1, 4 / π, π);
	        (d3.geo.bromley = function() {
	          return projection(bromley);
	        }).raw = bromley;
	        function chamberlin(points) {
	          points = points.map(function(p) {
	            return [ p[0], p[1], Math.sin(p[1]), Math.cos(p[1]) ];
	          });
	          for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {
	            b = points[i];
	            a.v = chamberlinDistanceAzimuth(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
	            a.point = [ 0, 0 ];
	          }
	          var β0 = chamberlinAngle(points[0].v[0], points[2].v[0], points[1].v[0]), β1 = chamberlinAngle(points[0].v[0], points[1].v[0], points[2].v[0]), β2 = π - β0;
	          points[2].point[1] = 0;
	          points[0].point[0] = -(points[1].point[0] = .5 * points[0].v[0]);
	          var mean = [ points[2].point[0] = points[0].point[0] + points[2].v[0] * Math.cos(β0), 2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * Math.sin(β0)) ];
	          function forward(λ, φ) {
	            var sinφ = Math.sin(φ), cosφ = Math.cos(φ), v = new Array(3);
	            for (var i = 0; i < 3; ++i) {
	              var p = points[i];
	              v[i] = chamberlinDistanceAzimuth(φ - p[1], p[3], p[2], cosφ, sinφ, λ - p[0]);
	              if (!v[i][0]) return p.point;
	              v[i][1] = chamberlinLongitude(v[i][1] - p.v[1]);
	            }
	            var point = mean.slice();
	            for (var i = 0; i < 3; ++i) {
	              var j = i == 2 ? 0 : i + 1;
	              var a = chamberlinAngle(points[i].v[0], v[i][0], v[j][0]);
	              if (v[i][1] < 0) a = -a;
	              if (!i) {
	                point[0] += v[i][0] * Math.cos(a);
	                point[1] -= v[i][0] * Math.sin(a);
	              } else if (i == 1) {
	                a = β1 - a;
	                point[0] -= v[i][0] * Math.cos(a);
	                point[1] -= v[i][0] * Math.sin(a);
	              } else {
	                a = β2 - a;
	                point[0] += v[i][0] * Math.cos(a);
	                point[1] += v[i][0] * Math.sin(a);
	              }
	            }
	            point[0] /= 3, point[1] /= 3;
	            return point;
	          }
	          return forward;
	        }
	        function chamberlinProjection() {
	          var points = [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], m = projectionMutator(chamberlin), p = m(points), rotate = p.rotate;
	          delete p.rotate;
	          p.points = function(_) {
	            if (!arguments.length) return points;
	            points = _;
	            var origin = d3.geo.centroid({
	              type: "MultiPoint",
	              coordinates: points
	            }), r = [ -origin[0], -origin[1] ];
	            rotate.call(p, r);
	            return m(points.map(d3.geo.rotation(r)).map(chamberlinRadians));
	          };
	          return p.points([ [ -150, 55 ], [ -35, 55 ], [ -92.5, 10 ] ]);
	        }
	        function chamberlinDistanceAzimuth(dφ, c1, s1, c2, s2, dλ) {
	          var cosdλ = Math.cos(dλ), r;
	          if (Math.abs(dφ) > 1 || Math.abs(dλ) > 1) {
	            r = acos(s1 * s2 + c1 * c2 * cosdλ);
	          } else {
	            var sindφ = Math.sin(.5 * dφ), sindλ = Math.sin(.5 * dλ);
	            r = 2 * asin(Math.sqrt(sindφ * sindφ + c1 * c2 * sindλ * sindλ));
	          }
	          if (Math.abs(r) > ε) {
	            return [ r, Math.atan2(c2 * Math.sin(dλ), c1 * s2 - s1 * c2 * cosdλ) ];
	          }
	          return [ 0, 0 ];
	        }
	        function chamberlinAngle(b, c, a) {
	          return acos(.5 * (b * b + c * c - a * a) / (b * c));
	        }
	        function chamberlinLongitude(λ) {
	          return λ - 2 * π * Math.floor((λ + π) / (2 * π));
	        }
	        function chamberlinRadians(point) {
	          return [ point[0] * radians, point[1] * radians ];
	        }
	        (d3.geo.chamberlin = chamberlinProjection).raw = chamberlin;
	        function collignon(λ, φ) {
	          var α = asqrt(1 - Math.sin(φ));
	          return [ 2 / sqrtπ * λ * α, sqrtπ * (1 - α) ];
	        }
	        collignon.invert = function(x, y) {
	          var λ = (λ = y / sqrtπ - 1) * λ;
	          return [ λ > 0 ? x * Math.sqrt(π / λ) / 2 : 0, asin(1 - λ) ];
	        };
	        (d3.geo.collignon = function() {
	          return projection(collignon);
	        }).raw = collignon;
	        function craig(φ0) {
	          var tanφ0 = Math.tan(φ0);
	          function forward(λ, φ) {
	            return [ λ, (λ ? λ / Math.sin(λ) : 1) * (Math.sin(φ) * Math.cos(λ) - tanφ0 * Math.cos(φ)) ];
	          }
	          forward.invert = tanφ0 ? function(x, y) {
	            if (x) y *= Math.sin(x) / x;
	            var cosλ = Math.cos(x);
	            return [ x, 2 * Math.atan2(Math.sqrt(cosλ * cosλ + tanφ0 * tanφ0 - y * y) - cosλ, tanφ0 - y) ];
	          } : function(x, y) {
	            return [ x, asin(x ? y * Math.tan(x) / x : y) ];
	          };
	          return forward;
	        }
	        (d3.geo.craig = function() {
	          return parallel1Projection(craig);
	        }).raw = craig;
	        function craster(λ, φ) {
	          var sqrt3 = Math.sqrt(3);
	          return [ sqrt3 * λ * (2 * Math.cos(2 * φ / 3) - 1) / sqrtπ, sqrt3 * sqrtπ * Math.sin(φ / 3) ];
	        }
	        craster.invert = function(x, y) {
	          var sqrt3 = Math.sqrt(3), φ = 3 * asin(y / (sqrt3 * sqrtπ));
	          return [ sqrtπ * x / (sqrt3 * (2 * Math.cos(2 * φ / 3) - 1)), φ ];
	        };
	        (d3.geo.craster = function() {
	          return projection(craster);
	        }).raw = craster;
	        function cylindricalEqualArea(φ0) {
	          var cosφ0 = Math.cos(φ0);
	          function forward(λ, φ) {
	            return [ λ * cosφ0, Math.sin(φ) / cosφ0 ];
	          }
	          forward.invert = function(x, y) {
	            return [ x / cosφ0, asin(y * cosφ0) ];
	          };
	          return forward;
	        }
	        (d3.geo.cylindricalEqualArea = function() {
	          return parallel1Projection(cylindricalEqualArea);
	        }).raw = cylindricalEqualArea;
	        function cylindricalStereographic(φ0) {
	          var cosφ0 = Math.cos(φ0);
	          function forward(λ, φ) {
	            return [ λ * cosφ0, (1 + cosφ0) * Math.tan(φ * .5) ];
	          }
	          forward.invert = function(x, y) {
	            return [ x / cosφ0, Math.atan(y / (1 + cosφ0)) * 2 ];
	          };
	          return forward;
	        }
	        (d3.geo.cylindricalStereographic = function() {
	          return parallel1Projection(cylindricalStereographic);
	        }).raw = cylindricalStereographic;
	        function eckert1(λ, φ) {
	          var α = Math.sqrt(8 / (3 * π));
	          return [ α * λ * (1 - Math.abs(φ) / π), α * φ ];
	        }
	        eckert1.invert = function(x, y) {
	          var α = Math.sqrt(8 / (3 * π)), φ = y / α;
	          return [ x / (α * (1 - Math.abs(φ) / π)), φ ];
	        };
	        (d3.geo.eckert1 = function() {
	          return projection(eckert1);
	        }).raw = eckert1;
	        function eckert2(λ, φ) {
	          var α = Math.sqrt(4 - 3 * Math.sin(Math.abs(φ)));
	          return [ 2 / Math.sqrt(6 * π) * λ * α, sgn(φ) * Math.sqrt(2 * π / 3) * (2 - α) ];
	        }
	        eckert2.invert = function(x, y) {
	          var α = 2 - Math.abs(y) / Math.sqrt(2 * π / 3);
	          return [ x * Math.sqrt(6 * π) / (2 * α), sgn(y) * asin((4 - α * α) / 3) ];
	        };
	        (d3.geo.eckert2 = function() {
	          return projection(eckert2);
	        }).raw = eckert2;
	        function eckert3(λ, φ) {
	          var k = Math.sqrt(π * (4 + π));
	          return [ 2 / k * λ * (1 + Math.sqrt(1 - 4 * φ * φ / (π * π))), 4 / k * φ ];
	        }
	        eckert3.invert = function(x, y) {
	          var k = Math.sqrt(π * (4 + π)) / 2;
	          return [ x * k / (1 + asqrt(1 - y * y * (4 + π) / (4 * π))), y * k / 2 ];
	        };
	        (d3.geo.eckert3 = function() {
	          return projection(eckert3);
	        }).raw = eckert3;
	        function eckert4(λ, φ) {
	          var k = (2 + halfπ) * Math.sin(φ);
	          φ /= 2;
	          for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
	            var cosφ = Math.cos(φ);
	            φ -= δ = (φ + Math.sin(φ) * (cosφ + 2) - k) / (2 * cosφ * (1 + cosφ));
	          }
	          return [ 2 / Math.sqrt(π * (4 + π)) * λ * (1 + Math.cos(φ)), 2 * Math.sqrt(π / (4 + π)) * Math.sin(φ) ];
	        }
	        eckert4.invert = function(x, y) {
	          var A = .5 * y * Math.sqrt((4 + π) / π), k = asin(A), c = Math.cos(k);
	          return [ x / (2 / Math.sqrt(π * (4 + π)) * (1 + c)), asin((k + A * (c + 2)) / (2 + halfπ)) ];
	        };
	        (d3.geo.eckert4 = function() {
	          return projection(eckert4);
	        }).raw = eckert4;
	        function eckert5(λ, φ) {
	          return [ λ * (1 + Math.cos(φ)) / Math.sqrt(2 + π), 2 * φ / Math.sqrt(2 + π) ];
	        }
	        eckert5.invert = function(x, y) {
	          var k = Math.sqrt(2 + π), φ = y * k / 2;
	          return [ k * x / (1 + Math.cos(φ)), φ ];
	        };
	        (d3.geo.eckert5 = function() {
	          return projection(eckert5);
	        }).raw = eckert5;
	        function eckert6(λ, φ) {
	          var k = (1 + halfπ) * Math.sin(φ);
	          for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
	            φ -= δ = (φ + Math.sin(φ) - k) / (1 + Math.cos(φ));
	          }
	          k = Math.sqrt(2 + π);
	          return [ λ * (1 + Math.cos(φ)) / k, 2 * φ / k ];
	        }
	        eckert6.invert = function(x, y) {
	          var j = 1 + halfπ, k = Math.sqrt(j / 2);
	          return [ x * 2 * k / (1 + Math.cos(y *= k)), asin((y + Math.sin(y)) / j) ];
	        };
	        (d3.geo.eckert6 = function() {
	          return projection(eckert6);
	        }).raw = eckert6;
	        function eisenlohr(λ, φ) {
	          var s0 = Math.sin(λ /= 2), c0 = Math.cos(λ), k = Math.sqrt(Math.cos(φ)), c1 = Math.cos(φ /= 2), t = Math.sin(φ) / (c1 + Math.SQRT2 * c0 * k), c = Math.sqrt(2 / (1 + t * t)), v = Math.sqrt((Math.SQRT2 * c1 + (c0 + s0) * k) / (Math.SQRT2 * c1 + (c0 - s0) * k));
	          return [ eisenlohrK * (c * (v - 1 / v) - 2 * Math.log(v)), eisenlohrK * (c * t * (v + 1 / v) - 2 * Math.atan(t)) ];
	        }
	        eisenlohr.invert = function(x, y) {
	          var p = d3.geo.august.raw.invert(x / 1.2, y * 1.065);
	          if (!p) return null;
	          var λ = p[0], φ = p[1], i = 20;
	          x /= eisenlohrK, y /= eisenlohrK;
	          do {
	            var _0 = λ / 2, _1 = φ / 2, s0 = Math.sin(_0), c0 = Math.cos(_0), s1 = Math.sin(_1), c1 = Math.cos(_1), cos1 = Math.cos(φ), k = Math.sqrt(cos1), t = s1 / (c1 + Math.SQRT2 * c0 * k), t2 = t * t, c = Math.sqrt(2 / (1 + t2)), v0 = Math.SQRT2 * c1 + (c0 + s0) * k, v1 = Math.SQRT2 * c1 + (c0 - s0) * k, v2 = v0 / v1, v = Math.sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * Math.log(v) - x, fy = c * t * vp1v - 2 * Math.atan(t) - y, δtδλ = s1 && Math.SQRT1_2 * k * s0 * t2 / s1, δtδφ = (Math.SQRT2 * c0 * c1 + k) / (2 * (c1 + Math.SQRT2 * c0 * k) * (c1 + Math.SQRT2 * c0 * k) * k), δcδt = -.5 * t * c * c * c, δcδλ = δcδt * δtδλ, δcδφ = δcδt * δtδφ, A = (A = 2 * c1 + Math.SQRT2 * k * (c0 - s0)) * A * v, δvδλ = (Math.SQRT2 * c0 * c1 * k + cos1) / A, δvδφ = -(Math.SQRT2 * s0 * s1) / (k * A), δxδλ = vm1v * δcδλ - 2 * δvδλ / v + c * (δvδλ + δvδλ / v2), δxδφ = vm1v * δcδφ - 2 * δvδφ / v + c * (δvδφ + δvδφ / v2), δyδλ = t * vp1v * δcδλ - 2 * δtδλ / (1 + t2) + c * vp1v * δtδλ + c * t * (δvδλ - δvδλ / v2), δyδφ = t * vp1v * δcδφ - 2 * δtδφ / (1 + t2) + c * vp1v * δtδφ + c * t * (δvδφ - δvδφ / v2), denominator = δxδφ * δyδλ - δyδφ * δxδλ;
	            if (!denominator) break;
	            var δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
	            λ -= δλ;
	            φ = Math.max(-halfπ, Math.min(halfπ, φ - δφ));
	          } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
	          return Math.abs(Math.abs(φ) - halfπ) < ε ? [ 0, φ ] : i && [ λ, φ ];
	        };
	        var eisenlohrK = 3 + 2 * Math.SQRT2;
	        (d3.geo.eisenlohr = function() {
	          return projection(eisenlohr);
	        }).raw = eisenlohr;
	        function fahey(λ, φ) {
	          var t = Math.tan(φ / 2);
	          return [ λ * faheyK * asqrt(1 - t * t), (1 + faheyK) * t ];
	        }
	        fahey.invert = function(x, y) {
	          var t = y / (1 + faheyK);
	          return [ x ? x / (faheyK * asqrt(1 - t * t)) : 0, 2 * Math.atan(t) ];
	        };
	        var faheyK = Math.cos(35 * radians);
	        (d3.geo.fahey = function() {
	          return projection(fahey);
	        }).raw = fahey;
	        function foucaut(λ, φ) {
	          var k = φ / 2, cosk = Math.cos(k);
	          return [ 2 * λ / sqrtπ * Math.cos(φ) * cosk * cosk, sqrtπ * Math.tan(k) ];
	        }
	        foucaut.invert = function(x, y) {
	          var k = Math.atan(y / sqrtπ), cosk = Math.cos(k), φ = 2 * k;
	          return [ x * sqrtπ * .5 / (Math.cos(φ) * cosk * cosk), φ ];
	        };
	        (d3.geo.foucaut = function() {
	          return projection(foucaut);
	        }).raw = foucaut;
	        d3.geo.gilbert = function(projection) {
	          var e = d3.geo.equirectangular().scale(degrees).translate([ 0, 0 ]);
	          function gilbert(coordinates) {
	            return projection([ coordinates[0] * .5, asin(Math.tan(coordinates[1] * .5 * radians)) * degrees ]);
	          }
	          if (projection.invert) gilbert.invert = function(coordinates) {
	            coordinates = projection.invert(coordinates);
	            coordinates[0] *= 2;
	            coordinates[1] = 2 * Math.atan(Math.sin(coordinates[1] * radians)) * degrees;
	            return coordinates;
	          };
	          gilbert.stream = function(stream) {
	            stream = projection.stream(stream);
	            var s = e.stream({
	              point: function(λ, φ) {
	                stream.point(λ * .5, asin(Math.tan(-φ * .5 * radians)) * degrees);
	              },
	              lineStart: function() {
	                stream.lineStart();
	              },
	              lineEnd: function() {
	                stream.lineEnd();
	              },
	              polygonStart: function() {
	                stream.polygonStart();
	              },
	              polygonEnd: function() {
	                stream.polygonEnd();
	              }
	            });
	            s.sphere = function() {
	              stream.sphere();
	            };
	            s.valid = false;
	            return s;
	          };
	          return gilbert;
	        };
	        var gingeryAzimuthalEquidistant = d3.geo.azimuthalEquidistant.raw;
	        function gingery(ρ, n) {
	          var k = 2 * π / n, ρ2 = ρ * ρ;
	          function forward(λ, φ) {
	            var p = gingeryAzimuthalEquidistant(λ, φ), x = p[0], y = p[1], r2 = x * x + y * y;
	            if (r2 > ρ2) {
	              var r = Math.sqrt(r2), θ = Math.atan2(y, x), θ0 = k * Math.round(θ / k), α = θ - θ0, ρcosα = ρ * Math.cos(α), k_ = (ρ * Math.sin(α) - α * Math.sin(ρcosα)) / (halfπ - ρcosα), s_ = arcLength_(α, k_), e = (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
	              x = r;
	              var i = 50, δ;
	              do {
	                x -= δ = (ρ + gingeryIntegrate(s_, ρcosα, x) * e - r) / (s_(x) * e);
	              } while (Math.abs(δ) > ε && --i > 0);
	              y = α * Math.sin(x);
	              if (x < halfπ) y -= k_ * (x - halfπ);
	              var s = Math.sin(θ0), c = Math.cos(θ0);
	              p[0] = x * c - y * s;
	              p[1] = x * s + y * c;
	            }
	            return p;
	          }
	          forward.invert = function(x, y) {
	            var r2 = x * x + y * y;
	            if (r2 > ρ2) {
	              var r = Math.sqrt(r2), θ = Math.atan2(y, x), θ0 = k * Math.round(θ / k), dθ = θ - θ0, x = r * Math.cos(dθ);
	              y = r * Math.sin(dθ);
	              var x_halfπ = x - halfπ, sinx = Math.sin(x), α = y / sinx, δ = x < halfπ ? Infinity : 0, i = 10;
	              while (true) {
	                var ρsinα = ρ * Math.sin(α), ρcosα = ρ * Math.cos(α), sinρcosα = Math.sin(ρcosα), halfπ_ρcosα = halfπ - ρcosα, k_ = (ρsinα - α * sinρcosα) / halfπ_ρcosα, s_ = arcLength_(α, k_);
	                if (Math.abs(δ) < ε2 || !--i) break;
	                α -= δ = (α * sinx - k_ * x_halfπ - y) / (sinx - x_halfπ * 2 * (halfπ_ρcosα * (ρcosα + α * ρsinα * Math.cos(ρcosα) - sinρcosα) - ρsinα * (ρsinα - α * sinρcosα)) / (halfπ_ρcosα * halfπ_ρcosα));
	              }
	              r = ρ + gingeryIntegrate(s_, ρcosα, x) * (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
	              θ = θ0 + α;
	              x = r * Math.cos(θ);
	              y = r * Math.sin(θ);
	            }
	            return gingeryAzimuthalEquidistant.invert(x, y);
	          };
	          return forward;
	        }
	        function arcLength_(α, k) {
	          return function(x) {
	            var y_ = α * Math.cos(x);
	            if (x < halfπ) y_ -= k;
	            return Math.sqrt(1 + y_ * y_);
	          };
	        }
	        function gingeryProjection() {
	          var n = 6, ρ = 30 * radians, cρ = Math.cos(ρ), sρ = Math.sin(ρ), m = projectionMutator(gingery), p = m(ρ, n), stream_ = p.stream, ε = .01, cr = -Math.cos(ε * radians), sr = Math.sin(ε * radians);
	          p.radius = function(_) {
	            if (!arguments.length) return ρ * degrees;
	            cρ = Math.cos(ρ = _ * radians);
	            sρ = Math.sin(ρ);
	            return m(ρ, n);
	          };
	          p.lobes = function(_) {
	            if (!arguments.length) return n;
	            return m(ρ, n = +_);
	          };
	          p.stream = function(stream) {
	            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([ 0, 0 ]), 
	            stream_(stream));
	            p.rotate(rotate);
	            rotateStream.sphere = function() {
	              sphereStream.polygonStart(), sphereStream.lineStart();
	              for (var i = 0, δ = 2 * π / n, φ = 0; i < n; ++i, φ -= δ) {
	                sphereStream.point(Math.atan2(sr * Math.cos(φ), cr) * degrees, Math.asin(sr * Math.sin(φ)) * degrees);
	                sphereStream.point(Math.atan2(sρ * Math.cos(φ - δ / 2), cρ) * degrees, Math.asin(sρ * Math.sin(φ - δ / 2)) * degrees);
	              }
	              sphereStream.lineEnd(), sphereStream.polygonEnd();
	            };
	            return rotateStream;
	          };
	          return p;
	        }
	        function gingeryIntegrate(f, a, b) {
	          var n = 50, h = (b - a) / n, s = f(a) + f(b);
	          for (var i = 1, x = a; i < n; ++i) s += 2 * f(x += h);
	          return s * .5 * h;
	        }
	        (d3.geo.gingery = gingeryProjection).raw = gingery;
	        function ginzburgPolyconic(a, b, c, d, e, f, g, h) {
	          if (arguments.length < 8) h = 0;
	          function forward(λ, φ) {
	            if (!φ) return [ a * λ / π, 0 ];
	            var φ2 = φ * φ, xB = a + φ2 * (b + φ2 * (c + φ2 * d)), yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)), m = (xB * xB + yB * yB) / (2 * yB), α = λ * Math.asin(xB / m) / π;
	            return [ m * Math.sin(α), φ * (1 + φ2 * h) + m * (1 - Math.cos(α)) ];
	          }
	          forward.invert = function(x, y) {
	            var λ = π * x / a, φ = y, δλ, δφ, i = 50;
	            do {
	              var φ2 = φ * φ, xB = a + φ2 * (b + φ2 * (c + φ2 * d)), yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dαdλ = Math.asin(xB / m) / π, α = λ * dαdλ;
	              xB2 = xB * xB, dxBdφ = (2 * b + φ2 * (4 * c + φ2 * 6 * d)) * φ, dyBdφ = e + φ2 * (3 * f + φ2 * 5 * g), 
	              dpdφ = 2 * (xB * dxBdφ + yB * (dyBdφ - 1)), dqdφ = 2 * (dyBdφ - 1), dmdφ = (dpdφ * q - p * dqdφ) / (q * q), 
	              cosα = Math.cos(α), sinα = Math.sin(α), mcosα = m * cosα, msinα = m * sinα, dαdφ = λ / π * (1 / asqrt(1 - xB2 / m2)) * (dxBdφ * m - xB * dmdφ) / m2, 
	              fx = msinα - x, fy = φ * (1 + φ2 * h) + m - mcosα - y, δxδφ = dmdφ * sinα + mcosα * dαdφ, 
	              δxδλ = mcosα * dαdλ, δyδφ = 1 + dmdφ - (dmdφ * cosα - msinα * dαdφ), δyδλ = msinα * dαdλ, 
	              denominator = δxδφ * δyδλ - δyδφ * δxδλ;
	              if (!denominator) break;
	              λ -= δλ = (fy * δxδφ - fx * δyδφ) / denominator;
	              φ -= δφ = (fx * δyδλ - fy * δxδλ) / denominator;
	            } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
	            return [ λ, φ ];
	          };
	          return forward;
	        }
	        var ginzburg4 = ginzburgPolyconic(2.8284, -1.6988, .75432, -.18071, 1.76003, -.38914, .042555);
	        (d3.geo.ginzburg4 = function() {
	          return projection(ginzburg4);
	        }).raw = ginzburg4;
	        var ginzburg5 = ginzburgPolyconic(2.583819, -.835827, .170354, -.038094, 1.543313, -.411435, .082742);
	        (d3.geo.ginzburg5 = function() {
	          return projection(ginzburg5);
	        }).raw = ginzburg5;
	        var ginzburg6 = ginzburgPolyconic(5 / 6 * π, -.62636, -.0344, 0, 1.3493, -.05524, 0, .045);
	        (d3.geo.ginzburg6 = function() {
	          return projection(ginzburg6);
	        }).raw = ginzburg6;
	        function ginzburg8(λ, φ) {
	          var λ2 = λ * λ, φ2 = φ * φ;
	          return [ λ * (1 - .162388 * φ2) * (.87 - 952426e-9 * λ2 * λ2), φ * (1 + φ2 / 12) ];
	        }
	        ginzburg8.invert = function(x, y) {
	          var λ = x, φ = y, i = 50, δ;
	          do {
	            var φ2 = φ * φ;
	            φ -= δ = (φ * (1 + φ2 / 12) - y) / (1 + φ2 / 4);
	          } while (Math.abs(δ) > ε && --i > 0);
	          i = 50;
	          x /= 1 - .162388 * φ2;
	          do {
	            var λ4 = (λ4 = λ * λ) * λ4;
	            λ -= δ = (λ * (.87 - 952426e-9 * λ4) - x) / (.87 - .00476213 * λ4);
	          } while (Math.abs(δ) > ε && --i > 0);
	          return [ λ, φ ];
	        };
	        (d3.geo.ginzburg8 = function() {
	          return projection(ginzburg8);
	        }).raw = ginzburg8;
	        var ginzburg9 = ginzburgPolyconic(2.6516, -.76534, .19123, -.047094, 1.36289, -.13965, .031762);
	        (d3.geo.ginzburg9 = function() {
	          return projection(ginzburg9);
	        }).raw = ginzburg9;
	        function quincuncialProjection(projectHemisphere) {
	          var dx = projectHemisphere(halfπ, 0)[0] - projectHemisphere(-halfπ, 0)[0];
	          function projection() {
	            var quincuncial = false, m = projectionMutator(projectAt), p = m(quincuncial);
	            p.quincuncial = function(_) {
	              if (!arguments.length) return quincuncial;
	              return m(quincuncial = !!_);
	            };
	            return p;
	          }
	          function projectAt(quincuncial) {
	            var forward = quincuncial ? function(λ, φ) {
	              var t = Math.abs(λ) < halfπ, p = projectHemisphere(t ? λ : λ > 0 ? λ - π : λ + π, φ);
	              var x = (p[0] - p[1]) * Math.SQRT1_2, y = (p[0] + p[1]) * Math.SQRT1_2;
	              if (t) return [ x, y ];
	              var d = dx * Math.SQRT1_2, s = x > 0 ^ y > 0 ? -1 : 1;
	              return [ s * x - sgn(y) * d, s * y - sgn(x) * d ];
	            } : function(λ, φ) {
	              var s = λ > 0 ? -.5 : .5, point = projectHemisphere(λ + s * π, φ);
	              point[0] -= s * dx;
	              return point;
	            };
	            if (projectHemisphere.invert) forward.invert = quincuncial ? function(x0, y0) {
	              var x = (x0 + y0) * Math.SQRT1_2, y = (y0 - x0) * Math.SQRT1_2, t = Math.abs(x) < .5 * dx && Math.abs(y) < .5 * dx;
	              if (!t) {
	                var d = dx * Math.SQRT1_2, s = x > 0 ^ y > 0 ? -1 : 1, x1 = -s * (x0 + (y > 0 ? 1 : -1) * d), y1 = -s * (y0 + (x > 0 ? 1 : -1) * d);
	                x = (-x1 - y1) * Math.SQRT1_2;
	                y = (x1 - y1) * Math.SQRT1_2;
	              }
	              var p = projectHemisphere.invert(x, y);
	              if (!t) p[0] += x > 0 ? π : -π;
	              return p;
	            } : function(x, y) {
	              var s = x > 0 ? -.5 : .5, location = projectHemisphere.invert(x + s * dx, y), λ = location[0] - s * π;
	              if (λ < -π) λ += 2 * π; else if (λ > π) λ -= 2 * π;
	              location[0] = λ;
	              return location;
	            };
	            return forward;
	          }
	          projection.raw = projectAt;
	          return projection;
	        }
	        function gringorten(λ, φ) {
	          var sλ = sgn(λ), sφ = sgn(φ), cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(sφ * φ);
	          λ = Math.abs(Math.atan2(y, z));
	          φ = asin(x);
	          if (Math.abs(λ - halfπ) > ε) λ %= halfπ;
	          var point = gringortenHexadecant(λ > π / 4 ? halfπ - λ : λ, φ);
	          if (λ > π / 4) z = point[0], point[0] = -point[1], point[1] = -z;
	          return point[0] *= sλ, point[1] *= -sφ, point;
	        }
	        gringorten.invert = function(x, y) {
	          var sx = sgn(x), sy = sgn(y), x0 = -sx * x, y0 = -sy * y, t = y0 / x0 < 1, p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0), λ = p[0], φ = p[1];
	          if (t) λ = -halfπ - λ;
	          var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ);
	          return [ sx * (Math.atan2(y, -z) + π), sy * asin(x) ];
	        };
	        function gringortenHexadecant(λ, φ) {
	          if (φ === halfπ) return [ 0, 0 ];
	          var sinφ = Math.sin(φ), r = sinφ * sinφ, r2 = r * r, j = 1 + r2, k = 1 + 3 * r2, q = 1 - r2, z = asin(1 / Math.sqrt(j)), v = q + r * j * z, p2 = (1 - sinφ) / v, p = Math.sqrt(p2), a2 = p2 * j, a = Math.sqrt(a2), h = p * q;
	          if (λ === 0) return [ 0, -(h + r * a) ];
	          var cosφ = Math.cos(φ), secφ = 1 / cosφ, drdφ = 2 * sinφ * cosφ, dvdφ = (-3 * r + z * k) * drdφ, dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v), dpdφ = .5 * dp2dφ / p, dhdφ = q * dpdφ - 2 * r * p * drdφ, dra2dφ = r * j * dp2dφ + p2 * k * drdφ, μ = -secφ * drdφ, ν = -secφ * dra2dφ, ζ = -2 * secφ * dhdφ, Λ = 4 * λ / π;
	          if (λ > .222 * π || φ < π / 4 && λ > .175 * π) {
	            var x = (h + r * asqrt(a2 * (1 + r2) - h * h)) / (1 + r2);
	            if (λ > π / 4) return [ x, x ];
	            var x1 = x, x0 = .5 * x, i = 50;
	            x = .5 * (x0 + x1);
	            do {
	              var g = Math.sqrt(a2 - x * x), f = x * (ζ + μ * g) + ν * asin(x / a) - Λ;
	              if (!f) break;
	              if (f < 0) x0 = x; else x1 = x;
	              x = .5 * (x0 + x1);
	            } while (Math.abs(x1 - x0) > ε && --i > 0);
	          } else {
	            var x = ε, i = 25, δ;
	            do {
	              var x2 = x * x, g = asqrt(a2 - x2), ζμg = ζ + μ * g, f = x * ζμg + ν * asin(x / a) - Λ, df = ζμg + (ν - μ * x2) / g;
	              x -= δ = g ? f / df : 0;
	            } while (Math.abs(δ) > ε && --i > 0);
	          }
	          return [ x, -h - r * asqrt(a2 - x * x) ];
	        }
	        function gringortenHexadecantInvert(x, y) {
	          var x0 = 0, x1 = 1, r = .5, i = 50;
	          while (true) {
	            var r2 = r * r, sinφ = Math.sqrt(r), z = Math.asin(1 / Math.sqrt(1 + r2)), v = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinφ) / v, p = Math.sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = Math.sqrt(g2), y0 = y + h + r * g;
	            if (Math.abs(x1 - x0) < ε2 || --i === 0 || y0 === 0) break;
	            if (y0 > 0) x0 = r; else x1 = r;
	            r = .5 * (x0 + x1);
	          }
	          if (!i) return null;
	          var φ = Math.asin(sinφ), cosφ = Math.cos(φ), secφ = 1 / cosφ, drdφ = 2 * sinφ * cosφ, dvdφ = (-3 * r + z * (1 + 3 * r2)) * drdφ, dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v), dpdφ = .5 * dp2dφ / p, dhdφ = (1 - r2) * dpdφ - 2 * r * p * drdφ, ζ = -2 * secφ * dhdφ, μ = -secφ * drdφ, ν = -secφ * (r * (1 + r2) * dp2dφ + p2 * (1 + 3 * r2) * drdφ);
	          return [ π / 4 * (x * (ζ + μ * g) + ν * Math.asin(x / Math.sqrt(a2))), φ ];
	        }
	        d3.geo.gringorten = quincuncialProjection(gringorten);
	        function ellipticJi(u, v, m) {
	          if (!u) {
	            var b = ellipticJ(v, 1 - m);
	            return [ [ 0, b[0] / b[1] ], [ 1 / b[1], 0 ], [ b[2] / b[1], 0 ] ];
	          }
	          var a = ellipticJ(u, m);
	          if (!v) return [ [ a[0], 0 ], [ a[1], 0 ], [ a[2], 0 ] ];
	          var b = ellipticJ(v, 1 - m), denominator = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
	          return [ [ a[0] * b[2] / denominator, a[1] * a[2] * b[0] * b[1] / denominator ], [ a[1] * b[1] / denominator, -a[0] * a[2] * b[0] * b[2] / denominator ], [ a[2] * b[1] * b[2] / denominator, -m * a[0] * a[1] * b[0] / denominator ] ];
	        }
	        function ellipticJ(u, m) {
	          var ai, b, φ, t, twon;
	          if (m < ε) {
	            t = Math.sin(u);
	            b = Math.cos(u);
	            ai = .25 * m * (u - t * b);
	            return [ t - ai * b, b + ai * t, 1 - .5 * m * t * t, u - ai ];
	          }
	          if (m >= 1 - ε) {
	            ai = .25 * (1 - m);
	            b = cosh(u);
	            t = tanh(u);
	            φ = 1 / b;
	            twon = b * sinh(u);
	            return [ t + ai * (twon - u) / (b * b), φ - ai * t * φ * (twon - u), φ + ai * t * φ * (twon + u), 2 * Math.atan(Math.exp(u)) - halfπ + ai * (twon - u) / b ];
	          }
	          var a = [ 1, 0, 0, 0, 0, 0, 0, 0, 0 ], c = [ Math.sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0;
	          b = Math.sqrt(1 - m);
	          twon = 1;
	          while (Math.abs(c[i] / a[i]) > ε && i < 8) {
	            ai = a[i++];
	            c[i] = .5 * (ai - b);
	            a[i] = .5 * (ai + b);
	            b = asqrt(ai * b);
	            twon *= 2;
	          }
	          φ = twon * a[i] * u;
	          do {
	            t = c[i] * Math.sin(b = φ) / a[i];
	            φ = .5 * (asin(t) + φ);
	          } while (--i);
	          return [ Math.sin(φ), t = Math.cos(φ), t / Math.cos(φ - b), φ ];
	        }
	        function ellipticFi(φ, ψ, m) {
	          var r = Math.abs(φ), i = Math.abs(ψ), sinhψ = sinh(i);
	          if (r) {
	            var cscφ = 1 / Math.sin(r), cotφ2 = 1 / (Math.tan(r) * Math.tan(r)), b = -(cotφ2 + m * sinhψ * sinhψ * cscφ * cscφ - 1 + m), c = (m - 1) * cotφ2, cotλ2 = .5 * (-b + Math.sqrt(b * b - 4 * c));
	            return [ ellipticF(Math.atan(1 / Math.sqrt(cotλ2)), m) * sgn(φ), ellipticF(Math.atan(asqrt((cotλ2 / cotφ2 - 1) / m)), 1 - m) * sgn(ψ) ];
	          }
	          return [ 0, ellipticF(Math.atan(sinhψ), 1 - m) * sgn(ψ) ];
	        }
	        function ellipticF(φ, m) {
	          if (!m) return φ;
	          if (m === 1) return Math.log(Math.tan(φ / 2 + π / 4));
	          var a = 1, b = Math.sqrt(1 - m), c = Math.sqrt(m);
	          for (var i = 0; Math.abs(c) > ε; i++) {
	            if (φ % π) {
	              var dφ = Math.atan(b * Math.tan(φ) / a);
	              if (dφ < 0) dφ += π;
	              φ += dφ + ~~(φ / π) * π;
	            } else φ += φ;
	            c = (a + b) / 2;
	            b = Math.sqrt(a * b);
	            c = ((a = c) - b) / 2;
	          }
	          return φ / (Math.pow(2, i) * a);
	        }
	        function guyou(λ, φ) {
	          var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1), k = Math.sqrt(1 - k_ * k_), K = ellipticF(halfπ, k * k), f = -1;
	          var ψ = Math.log(Math.tan(π / 4 + Math.abs(φ) / 2)), r = Math.exp(f * ψ) / Math.sqrt(k_), at = guyouComplexAtan(r * Math.cos(f * λ), r * Math.sin(f * λ)), t = ellipticFi(at[0], at[1], k * k);
	          return [ -t[1], (φ >= 0 ? 1 : -1) * (.5 * K - t[0]) ];
	        }
	        function guyouComplexAtan(x, y) {
	          var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;
	          return [ .5 * ((x >= 0 ? halfπ : -halfπ) - Math.atan2(t, 2 * x)), -.25 * Math.log(t * t + 4 * x2) + .5 * Math.log(y_1 * y_1 + x2) ];
	        }
	        function guyouComplexDivide(a, b) {
	          var denominator = b[0] * b[0] + b[1] * b[1];
	          return [ (a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator ];
	        }
	        guyou.invert = function(x, y) {
	          var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1), k = Math.sqrt(1 - k_ * k_), K = ellipticF(halfπ, k * k), f = -1;
	          var j = ellipticJi(.5 * K - y, -x, k * k), tn = guyouComplexDivide(j[0], j[1]), λ = Math.atan2(tn[1], tn[0]) / f;
	          return [ λ, 2 * Math.atan(Math.exp(.5 / f * Math.log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfπ ];
	        };
	        d3.geo.guyou = quincuncialProjection(guyou);
	        function hammerRetroazimuthal(φ0) {
	          var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), rotate = hammerRetroazimuthalRotation(φ0);
	          rotate.invert = hammerRetroazimuthalRotation(-φ0);
	          function forward(λ, φ) {
	            var p = rotate(λ, φ);
	            λ = p[0], φ = p[1];
	            var sinφ = Math.sin(φ), cosφ = Math.cos(φ), cosλ = Math.cos(λ), z = acos(sinφ0 * sinφ + cosφ0 * cosφ * cosλ), sinz = Math.sin(z), K = Math.abs(sinz) > ε ? z / sinz : 1;
	            return [ K * cosφ0 * Math.sin(λ), (Math.abs(λ) > halfπ ? K : -K) * (sinφ0 * cosφ - cosφ0 * sinφ * cosλ) ];
	          }
	          forward.invert = function(x, y) {
	            var ρ = Math.sqrt(x * x + y * y), sinz = -Math.sin(ρ), cosz = Math.cos(ρ), a = ρ * cosz, b = -y * sinz, c = ρ * sinφ0, d = asqrt(a * a + b * b - c * c), φ = Math.atan2(a * c + b * d, b * c - a * d), λ = (ρ > halfπ ? -1 : 1) * Math.atan2(x * sinz, ρ * Math.cos(φ) * cosz + y * Math.sin(φ) * sinz);
	            return rotate.invert(λ, φ);
	          };
	          return forward;
	        }
	        function hammerRetroazimuthalRotation(φ0) {
	          var sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0);
	          return function(λ, φ) {
	            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ);
	            return [ Math.atan2(y, x * cosφ0 - z * sinφ0), asin(z * cosφ0 + x * sinφ0) ];
	          };
	        }
	        function hammerRetroazimuthalProjection() {
	          var φ0 = 0, m = projectionMutator(hammerRetroazimuthal), p = m(φ0), rotate_ = p.rotate, stream_ = p.stream, circle = d3.geo.circle();
	          p.parallel = function(_) {
	            if (!arguments.length) return φ0 / π * 180;
	            var r = p.rotate();
	            return m(φ0 = _ * π / 180).rotate(r);
	          };
	          p.rotate = function(_) {
	            if (!arguments.length) return _ = rotate_.call(p), _[1] += φ0 / π * 180, _;
	            rotate_.call(p, [ _[0], _[1] - φ0 / π * 180 ]);
	            circle.origin([ -_[0], -_[1] ]);
	            return p;
	          };
	          p.stream = function(stream) {
	            stream = stream_(stream);
	            stream.sphere = function() {
	              stream.polygonStart();
	              var ε = .01, ring = circle.angle(90 - ε)().coordinates[0], n = ring.length - 1, i = -1, p;
	              stream.lineStart();
	              while (++i < n) stream.point((p = ring[i])[0], p[1]);
	              stream.lineEnd();
	              ring = circle.angle(90 + ε)().coordinates[0];
	              n = ring.length - 1;
	              stream.lineStart();
	              while (--i >= 0) stream.point((p = ring[i])[0], p[1]);
	              stream.lineEnd();
	              stream.polygonEnd();
	            };
	            return stream;
	          };
	          return p;
	        }
	        (d3.geo.hammerRetroazimuthal = hammerRetroazimuthalProjection).raw = hammerRetroazimuthal;
	        var hammerAzimuthalEqualArea = d3.geo.azimuthalEqualArea.raw;
	        function hammer(A, B) {
	          if (arguments.length < 2) B = A;
	          if (B === 1) return hammerAzimuthalEqualArea;
	          if (B === Infinity) return hammerQuarticAuthalic;
	          function forward(λ, φ) {
	            var coordinates = hammerAzimuthalEqualArea(λ / B, φ);
	            coordinates[0] *= A;
	            return coordinates;
	          }
	          forward.invert = function(x, y) {
	            var coordinates = hammerAzimuthalEqualArea.invert(x / A, y);
	            coordinates[0] *= B;
	            return coordinates;
	          };
	          return forward;
	        }
	        function hammerProjection() {
	          var B = 2, m = projectionMutator(hammer), p = m(B);
	          p.coefficient = function(_) {
	            if (!arguments.length) return B;
	            return m(B = +_);
	          };
	          return p;
	        }
	        function hammerQuarticAuthalic(λ, φ) {
	          return [ λ * Math.cos(φ) / Math.cos(φ /= 2), 2 * Math.sin(φ) ];
	        }
	        hammerQuarticAuthalic.invert = function(x, y) {
	          var φ = 2 * asin(y / 2);
	          return [ x * Math.cos(φ / 2) / Math.cos(φ), φ ];
	        };
	        (d3.geo.hammer = hammerProjection).raw = hammer;
	        function hatano(λ, φ) {
	          var c = Math.sin(φ) * (φ < 0 ? 2.43763 : 2.67595);
	          for (var i = 0, δ; i < 20; i++) {
	            φ -= δ = (φ + Math.sin(φ) - c) / (1 + Math.cos(φ));
	            if (Math.abs(δ) < ε) break;
	          }
	          return [ .85 * λ * Math.cos(φ *= .5), Math.sin(φ) * (φ < 0 ? 1.93052 : 1.75859) ];
	        }
	        hatano.invert = function(x, y) {
	          var θ = Math.abs(θ = y * (y < 0 ? .5179951515653813 : .5686373742600607)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ);
	          return [ 1.1764705882352942 * x / Math.cos(θ), Math.abs(θ = ((θ += θ) + Math.sin(θ)) * (y < 0 ? .4102345310814193 : .3736990601468637)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ) ];
	        };
	        (d3.geo.hatano = function() {
	          return projection(hatano);
	        }).raw = hatano;
	        var healpixParallel = 41 + 48 / 36 + 37 / 3600;
	        function healpix(h) {
	          var lambert = d3.geo.cylindricalEqualArea.raw(0), φ0 = healpixParallel * π / 180, dx0 = 2 * π, dx1 = d3.geo.collignon.raw(π, φ0)[0] - d3.geo.collignon.raw(-π, φ0)[0], y0 = lambert(0, φ0)[1], y1 = d3.geo.collignon.raw(0, φ0)[1], dy1 = d3.geo.collignon.raw(0, halfπ)[1] - y1, k = 2 * π / h;
	          function forward(λ, φ) {
	            var point, φ2 = Math.abs(φ);
	            if (φ2 > φ0) {
	              var i = Math.min(h - 1, Math.max(0, Math.floor((λ + π) / k)));
	              λ += π * (h - 1) / h - i * k;
	              point = d3.geo.collignon.raw(λ, φ2);
	              point[0] = point[0] * dx0 / dx1 - dx0 * (h - 1) / (2 * h) + i * dx0 / h;
	              point[1] = y0 + (point[1] - y1) * 4 * dy1 / dx0;
	              if (φ < 0) point[1] = -point[1];
	            } else {
	              point = lambert(λ, φ);
	            }
	            point[0] /= 2;
	            return point;
	          }
	          forward.invert = function(x, y) {
	            x *= 2;
	            var y2 = Math.abs(y);
	            if (y2 > y0) {
	              var i = Math.min(h - 1, Math.max(0, Math.floor((x + π) / k)));
	              x = (x + π * (h - 1) / h - i * k) * dx1 / dx0;
	              var point = d3.geo.collignon.raw.invert(x, .25 * (y2 - y0) * dx0 / dy1 + y1);
	              point[0] -= π * (h - 1) / h - i * k;
	              if (y < 0) point[1] = -point[1];
	              return point;
	            }
	            return lambert.invert(x, y);
	          };
	          return forward;
	        }
	        function healpixProjection() {
	          var n = 2, m = projectionMutator(healpix), p = m(n), stream_ = p.stream;
	          p.lobes = function(_) {
	            if (!arguments.length) return n;
	            return m(n = +_);
	          };
	          p.stream = function(stream) {
	            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([ 0, 0 ]), 
	            stream_(stream));
	            p.rotate(rotate);
	            rotateStream.sphere = function() {
	              d3.geo.stream(sphere(), sphereStream);
	            };
	            return rotateStream;
	          };
	          function sphere() {
	            var step = 180 / n;
	            return {
	              type: "Polygon",
	              coordinates: [ d3.range(-180, 180 + step / 2, step).map(function(x, i) {
	                return [ x, i & 1 ? 90 - 1e-6 : healpixParallel ];
	              }).concat(d3.range(180, -180 - step / 2, -step).map(function(x, i) {
	                return [ x, i & 1 ? -90 + 1e-6 : -healpixParallel ];
	              })) ]
	            };
	          }
	          return p;
	        }
	        (d3.geo.healpix = healpixProjection).raw = healpix;
	        function hill(K) {
	          var L = 1 + K, sinβ = Math.sin(1 / L), β = asin(sinβ), A = 2 * Math.sqrt(π / (B = π + 4 * β * L)), B, ρ0 = .5 * A * (L + Math.sqrt(K * (2 + K))), K2 = K * K, L2 = L * L;
	          function forward(λ, φ) {
	            var t = 1 - Math.sin(φ), ρ, ω;
	            if (t && t < 2) {
	              var θ = halfπ - φ, i = 25, δ;
	              do {
	                var sinθ = Math.sin(θ), cosθ = Math.cos(θ), β_β1 = β + Math.atan2(sinθ, L - cosθ), C = 1 + L2 - 2 * L * cosθ;
	                θ -= δ = (θ - K2 * β - L * sinθ + C * β_β1 - .5 * t * B) / (2 * L * sinθ * β_β1);
	              } while (Math.abs(δ) > ε2 && --i > 0);
	              ρ = A * Math.sqrt(C);
	              ω = λ * β_β1 / π;
	            } else {
	              ρ = A * (K + t);
	              ω = λ * β / π;
	            }
	            return [ ρ * Math.sin(ω), ρ0 - ρ * Math.cos(ω) ];
	          }
	          forward.invert = function(x, y) {
	            var ρ2 = x * x + (y -= ρ0) * y, cosθ = (1 + L2 - ρ2 / (A * A)) / (2 * L), θ = acos(cosθ), sinθ = Math.sin(θ), β_β1 = β + Math.atan2(sinθ, L - cosθ);
	            return [ asin(x / Math.sqrt(ρ2)) * π / β_β1, asin(1 - 2 * (θ - K2 * β - L * sinθ + (1 + L2 - 2 * L * cosθ) * β_β1) / B) ];
	          };
	          return forward;
	        }
	        function hillProjection() {
	          var K = 1, m = projectionMutator(hill), p = m(K);
	          p.ratio = function(_) {
	            if (!arguments.length) return K;
	            return m(K = +_);
	          };
	          return p;
	        }
	        (d3.geo.hill = hillProjection).raw = hill;
	        var sinuMollweideφ = .7109889596207567, sinuMollweideY = .0528035274542;
	        function sinuMollweide(λ, φ) {
	          return φ > -sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] += sinuMollweideY, λ) : sinusoidal(λ, φ);
	        }
	        sinuMollweide.invert = function(x, y) {
	          return y > -sinuMollweideφ ? mollweide.invert(x, y - sinuMollweideY) : sinusoidal.invert(x, y);
	        };
	        (d3.geo.sinuMollweide = function() {
	          return projection(sinuMollweide).rotate([ -20, -55 ]);
	        }).raw = sinuMollweide;
	        function homolosine(λ, φ) {
	          return Math.abs(φ) > sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] -= φ > 0 ? sinuMollweideY : -sinuMollweideY, 
	          λ) : sinusoidal(λ, φ);
	        }
	        homolosine.invert = function(x, y) {
	          return Math.abs(y) > sinuMollweideφ ? mollweide.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidal.invert(x, y);
	        };
	        (d3.geo.homolosine = function() {
	          return projection(homolosine);
	        }).raw = homolosine;
	        function kavrayskiy7(λ, φ) {
	          return [ 3 * λ / (2 * π) * Math.sqrt(π * π / 3 - φ * φ), φ ];
	        }
	        kavrayskiy7.invert = function(x, y) {
	          return [ 2 / 3 * π * x / Math.sqrt(π * π / 3 - y * y), y ];
	        };
	        (d3.geo.kavrayskiy7 = function() {
	          return projection(kavrayskiy7);
	        }).raw = kavrayskiy7;
	        function lagrange(n) {
	          function forward(λ, φ) {
	            if (Math.abs(Math.abs(φ) - halfπ) < ε) return [ 0, φ < 0 ? -2 : 2 ];
	            var sinφ = Math.sin(φ), v = Math.pow((1 + sinφ) / (1 - sinφ), n / 2), c = .5 * (v + 1 / v) + Math.cos(λ *= n);
	            return [ 2 * Math.sin(λ) / c, (v - 1 / v) / c ];
	          }
	          forward.invert = function(x, y) {
	            var y0 = Math.abs(y);
	            if (Math.abs(y0 - 2) < ε) return x ? null : [ 0, sgn(y) * halfπ ];
	            if (y0 > 2) return null;
	            x /= 2, y /= 2;
	            var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2);
	            t = Math.pow((1 + t) / (1 - t), 1 / n);
	            return [ Math.atan2(2 * x, 1 - x2 - y2) / n, asin((t - 1) / (t + 1)) ];
	          };
	          return forward;
	        }
	        function lagrangeProjection() {
	          var n = .5, m = projectionMutator(lagrange), p = m(n);
	          p.spacing = function(_) {
	            if (!arguments.length) return n;
	            return m(n = +_);
	          };
	          return p;
	        }
	        (d3.geo.lagrange = lagrangeProjection).raw = lagrange;
	        function larrivee(λ, φ) {
	          return [ λ * (1 + Math.sqrt(Math.cos(φ))) / 2, φ / (Math.cos(φ / 2) * Math.cos(λ / 6)) ];
	        }
	        larrivee.invert = function(x, y) {
	          var x0 = Math.abs(x), y0 = Math.abs(y), π_sqrt2 = π / Math.SQRT2, λ = ε, φ = halfπ;
	          if (y0 < π_sqrt2) φ *= y0 / π_sqrt2; else λ += 6 * acos(π_sqrt2 / y0);
	          for (var i = 0; i < 25; i++) {
	            var sinφ = Math.sin(φ), sqrtcosφ = asqrt(Math.cos(φ)), sinφ_2 = Math.sin(φ / 2), cosφ_2 = Math.cos(φ / 2), sinλ_6 = Math.sin(λ / 6), cosλ_6 = Math.cos(λ / 6), f0 = .5 * λ * (1 + sqrtcosφ) - x0, f1 = φ / (cosφ_2 * cosλ_6) - y0, df0dφ = sqrtcosφ ? -.25 * λ * sinφ / sqrtcosφ : 0, df0dλ = .5 * (1 + sqrtcosφ), df1dφ = (1 + .5 * φ * sinφ_2 / cosφ_2) / (cosφ_2 * cosλ_6), df1dλ = φ / cosφ_2 * (sinλ_6 / 6) / (cosλ_6 * cosλ_6), denom = df0dφ * df1dλ - df1dφ * df0dλ, dφ = (f0 * df1dλ - f1 * df0dλ) / denom, dλ = (f1 * df0dφ - f0 * df1dφ) / denom;
	            φ -= dφ;
	            λ -= dλ;
	            if (Math.abs(dφ) < ε && Math.abs(dλ) < ε) break;
	          }
	          return [ x < 0 ? -λ : λ, y < 0 ? -φ : φ ];
	        };
	        (d3.geo.larrivee = function() {
	          return projection(larrivee);
	        }).raw = larrivee;
	        function laskowski(λ, φ) {
	          var λ2 = λ * λ, φ2 = φ * φ;
	          return [ λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)), φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032)) ];
	        }
	        laskowski.invert = function(x, y) {
	          var λ = sgn(x) * π, φ = y / 2, i = 50;
	          do {
	            var λ2 = λ * λ, φ2 = φ * φ, λφ = λ * φ, fx = λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)) - x, fy = φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032)) - y, δxδλ = .975534 - φ2 * (.119161 + 3 * λ2 * .0143059 + φ2 * .0547009), δxδφ = -λφ * (2 * .119161 + 4 * .0547009 * φ2 + 2 * .0143059 * λ2), δyδλ = λφ * (2 * .0802894 + 4 * 199025e-9 * λ2 + 2 * -.02855 * φ2), δyδφ = 1.00384 + λ2 * (.0802894 + 199025e-9 * λ2) + φ2 * (3 * (.0998909 - .02855 * λ2) - 5 * .0491032 * φ2), denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
	            λ -= δλ, φ -= δφ;
	          } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
	          return i && [ λ, φ ];
	        };
	        (d3.geo.laskowski = function() {
	          return projection(laskowski);
	        }).raw = laskowski;
	        function littrow(λ, φ) {
	          return [ Math.sin(λ) / Math.cos(φ), Math.tan(φ) * Math.cos(λ) ];
	        }
	        littrow.invert = function(x, y) {
	          var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, cosφ = x ? Math.SQRT1_2 * Math.sqrt((y2_1 - Math.sqrt(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1) : 1 / Math.sqrt(y2_1);
	          return [ asin(x * cosφ), sgn(y) * acos(cosφ) ];
	        };
	        (d3.geo.littrow = function() {
	          return projection(littrow);
	        }).raw = littrow;
	        function loximuthal(φ0) {
	          var cosφ0 = Math.cos(φ0), tanφ0 = Math.tan(π / 4 + φ0 / 2);
	          function forward(λ, φ) {
	            var y = φ - φ0, x = Math.abs(y) < ε ? λ * cosφ0 : Math.abs(x = π / 4 + φ / 2) < ε || Math.abs(Math.abs(x) - halfπ) < ε ? 0 : λ * y / Math.log(Math.tan(x) / tanφ0);
	            return [ x, y ];
	          }
	          forward.invert = function(x, y) {
	            var λ, φ = y + φ0;
	            return [ Math.abs(y) < ε ? x / cosφ0 : Math.abs(λ = π / 4 + φ / 2) < ε || Math.abs(Math.abs(λ) - halfπ) < ε ? 0 : x * Math.log(Math.tan(λ) / tanφ0) / y, φ ];
	          };
	          return forward;
	        }
	        (d3.geo.loximuthal = function() {
	          return parallel1Projection(loximuthal).parallel(40);
	        }).raw = loximuthal;
	        function miller(λ, φ) {
	          return [ λ, 1.25 * Math.log(Math.tan(π / 4 + .4 * φ)) ];
	        }
	        miller.invert = function(x, y) {
	          return [ x, 2.5 * Math.atan(Math.exp(.8 * y)) - .625 * π ];
	        };
	        (d3.geo.miller = function() {
	          return projection(miller);
	        }).raw = miller;
	        function modifiedStereographic(C) {
	          var m = C.length - 1;
	          function forward(λ, φ) {
	            var cosφ = Math.cos(φ), k = 2 / (1 + cosφ * Math.cos(λ)), zr = k * cosφ * Math.sin(λ), zi = k * Math.sin(φ), i = m, w = C[i], ar = w[0], ai = w[1], t;
	            while (--i >= 0) {
	              w = C[i];
	              ar = w[0] + zr * (t = ar) - zi * ai;
	              ai = w[1] + zr * ai + zi * t;
	            }
	            ar = zr * (t = ar) - zi * ai;
	            ai = zr * ai + zi * t;
	            return [ ar, ai ];
	          }
	          forward.invert = function(x, y) {
	            var i = 20, zr = x, zi = y;
	            do {
	              var j = m, w = C[j], ar = w[0], ai = w[1], br = 0, bi = 0, t;
	              while (--j >= 0) {
	                w = C[j];
	                br = ar + zr * (t = br) - zi * bi;
	                bi = ai + zr * bi + zi * t;
	                ar = w[0] + zr * (t = ar) - zi * ai;
	                ai = w[1] + zr * ai + zi * t;
	              }
	              br = ar + zr * (t = br) - zi * bi;
	              bi = ai + zr * bi + zi * t;
	              ar = zr * (t = ar) - zi * ai - x;
	              ai = zr * ai + zi * t - y;
	              var denominator = br * br + bi * bi, δr, δi;
	              zr -= δr = (ar * br + ai * bi) / denominator;
	              zi -= δi = (ai * br - ar * bi) / denominator;
	            } while (Math.abs(δr) + Math.abs(δi) > ε * ε && --i > 0);
	            if (i) {
	              var ρ = Math.sqrt(zr * zr + zi * zi), c = 2 * Math.atan(ρ * .5), sinc = Math.sin(c);
	              return [ Math.atan2(zr * sinc, ρ * Math.cos(c)), ρ ? asin(zi * sinc / ρ) : 0 ];
	            }
	          };
	          return forward;
	        }
	        var modifiedStereographicCoefficients = {
	          alaska: [ [ .9972523, 0 ], [ .0052513, -.0041175 ], [ .0074606, .0048125 ], [ -.0153783, -.1968253 ], [ .0636871, -.1408027 ], [ .3660976, -.2937382 ] ],
	          gs48: [ [ .98879, 0 ], [ 0, 0 ], [ -.050909, 0 ], [ 0, 0 ], [ .075528, 0 ] ],
	          gs50: [ [ .984299, 0 ], [ .0211642, .0037608 ], [ -.1036018, -.0575102 ], [ -.0329095, -.0320119 ], [ .0499471, .1223335 ], [ .026046, .0899805 ], [ 7388e-7, -.1435792 ], [ .0075848, -.1334108 ], [ -.0216473, .0776645 ], [ -.0225161, .0853673 ] ],
	          miller: [ [ .9245, 0 ], [ 0, 0 ], [ .01943, 0 ] ],
	          lee: [ [ .721316, 0 ], [ 0, 0 ], [ -.00881625, -.00617325 ] ]
	        };
	        function modifiedStereographicProjection() {
	          var coefficients = modifiedStereographicCoefficients.miller, m = projectionMutator(modifiedStereographic), p = m(coefficients);
	          p.coefficients = function(_) {
	            if (!arguments.length) return coefficients;
	            return m(coefficients = typeof _ === "string" ? modifiedStereographicCoefficients[_] : _);
	          };
	          return p;
	        }
	        (d3.geo.modifiedStereographic = modifiedStereographicProjection).raw = modifiedStereographic;
	        function mtFlatPolarParabolic(λ, φ) {
	          var sqrt6 = Math.sqrt(6), sqrt7 = Math.sqrt(7), θ = Math.asin(7 * Math.sin(φ) / (3 * sqrt6));
	          return [ sqrt6 * λ * (2 * Math.cos(2 * θ / 3) - 1) / sqrt7, 9 * Math.sin(θ / 3) / sqrt7 ];
	        }
	        mtFlatPolarParabolic.invert = function(x, y) {
	          var sqrt6 = Math.sqrt(6), sqrt7 = Math.sqrt(7), θ = 3 * asin(y * sqrt7 / 9);
	          return [ x * sqrt7 / (sqrt6 * (2 * Math.cos(2 * θ / 3) - 1)), asin(Math.sin(θ) * 3 * sqrt6 / 7) ];
	        };
	        (d3.geo.mtFlatPolarParabolic = function() {
	          return projection(mtFlatPolarParabolic);
	        }).raw = mtFlatPolarParabolic;
	        function mtFlatPolarQuartic(λ, φ) {
	          var k = (1 + Math.SQRT1_2) * Math.sin(φ), θ = φ;
	          for (var i = 0, δ; i < 25; i++) {
	            θ -= δ = (Math.sin(θ / 2) + Math.sin(θ) - k) / (.5 * Math.cos(θ / 2) + Math.cos(θ));
	            if (Math.abs(δ) < ε) break;
	          }
	          return [ λ * (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)) / (3 * Math.SQRT2), 2 * Math.sqrt(3) * Math.sin(θ / 2) / Math.sqrt(2 + Math.SQRT2) ];
	        }
	        mtFlatPolarQuartic.invert = function(x, y) {
	          var sinθ_2 = y * Math.sqrt(2 + Math.SQRT2) / (2 * Math.sqrt(3)), θ = 2 * asin(sinθ_2);
	          return [ 3 * Math.SQRT2 * x / (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)), asin((sinθ_2 + Math.sin(θ)) / (1 + Math.SQRT1_2)) ];
	        };
	        (d3.geo.mtFlatPolarQuartic = function() {
	          return projection(mtFlatPolarQuartic);
	        }).raw = mtFlatPolarQuartic;
	        function mtFlatPolarSinusoidal(λ, φ) {
	          var A = Math.sqrt(6 / (4 + π)), k = (1 + π / 4) * Math.sin(φ), θ = φ / 2;
	          for (var i = 0, δ; i < 25; i++) {
	            θ -= δ = (θ / 2 + Math.sin(θ) - k) / (.5 + Math.cos(θ));
	            if (Math.abs(δ) < ε) break;
	          }
	          return [ A * (.5 + Math.cos(θ)) * λ / 1.5, A * θ ];
	        }
	        mtFlatPolarSinusoidal.invert = function(x, y) {
	          var A = Math.sqrt(6 / (4 + π)), θ = y / A;
	          if (Math.abs(Math.abs(θ) - halfπ) < ε) θ = θ < 0 ? -halfπ : halfπ;
	          return [ 1.5 * x / (A * (.5 + Math.cos(θ))), asin((θ / 2 + Math.sin(θ)) / (1 + π / 4)) ];
	        };
	        (d3.geo.mtFlatPolarSinusoidal = function() {
	          return projection(mtFlatPolarSinusoidal);
	        }).raw = mtFlatPolarSinusoidal;
	        function naturalEarth(λ, φ) {
	          var φ2 = φ * φ, φ4 = φ2 * φ2;
	          return [ λ * (.8707 - .131979 * φ2 + φ4 * (-.013791 + φ4 * (.003971 * φ2 - .001529 * φ4))), φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4))) ];
	        }
	        naturalEarth.invert = function(x, y) {
	          var φ = y, i = 25, δ;
	          do {
	            var φ2 = φ * φ, φ4 = φ2 * φ2;
	            φ -= δ = (φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4))) - y) / (1.007226 + φ2 * (.015085 * 3 + φ4 * (-.044475 * 7 + .028874 * 9 * φ2 - .005916 * 11 * φ4)));
	          } while (Math.abs(δ) > ε && --i > 0);
	          return [ x / (.8707 + (φ2 = φ * φ) * (-.131979 + φ2 * (-.013791 + φ2 * φ2 * φ2 * (.003971 - .001529 * φ2)))), φ ];
	        };
	        (d3.geo.naturalEarth = function() {
	          return projection(naturalEarth);
	        }).raw = naturalEarth;
	        function nellHammer(λ, φ) {
	          return [ λ * (1 + Math.cos(φ)) / 2, 2 * (φ - Math.tan(φ / 2)) ];
	        }
	        nellHammer.invert = function(x, y) {
	          var p = y / 2;
	          for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
	            var c = Math.cos(y / 2);
	            y -= δ = (y - Math.tan(y / 2) - p) / (1 - .5 / (c * c));
	          }
	          return [ 2 * x / (1 + Math.cos(y)), y ];
	        };
	        (d3.geo.nellHammer = function() {
	          return projection(nellHammer);
	        }).raw = nellHammer;
	        var pattersonK1 = 1.0148, pattersonK2 = .23185, pattersonK3 = -.14499, pattersonK4 = .02406, pattersonC1 = pattersonK1, pattersonC2 = 5 * pattersonK2, pattersonC3 = 7 * pattersonK3, pattersonC4 = 9 * pattersonK4, pattersonYmax = 1.790857183;
	        function patterson(λ, φ) {
	          var φ2 = φ * φ;
	          return [ λ, φ * (pattersonK1 + φ2 * φ2 * (pattersonK2 + φ2 * (pattersonK3 + pattersonK4 * φ2))) ];
	        }
	        patterson.invert = function(x, y) {
	          if (y > pattersonYmax) y = pattersonYmax; else if (y < -pattersonYmax) y = -pattersonYmax;
	          var yc = y, δ;
	          do {
	            var y2 = yc * yc;
	            yc -= δ = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
	          } while (Math.abs(δ) > ε);
	          return [ x, yc ];
	        };
	        (d3.geo.patterson = function() {
	          return projection(patterson);
	        }).raw = patterson;
	        var peirceQuincuncialProjection = quincuncialProjection(guyou);
	        (d3.geo.peirceQuincuncial = function() {
	          return peirceQuincuncialProjection().quincuncial(true).rotate([ -90, -90, 45 ]).clipAngle(180 - 1e-6);
	        }).raw = peirceQuincuncialProjection.raw;
	        function polyconic(λ, φ) {
	          if (Math.abs(φ) < ε) return [ λ, 0 ];
	          var tanφ = Math.tan(φ), k = λ * Math.sin(φ);
	          return [ Math.sin(k) / tanφ, φ + (1 - Math.cos(k)) / tanφ ];
	        }
	        polyconic.invert = function(x, y) {
	          if (Math.abs(y) < ε) return [ x, 0 ];
	          var k = x * x + y * y, φ = y * .5, i = 10, δ;
	          do {
	            var tanφ = Math.tan(φ), secφ = 1 / Math.cos(φ), j = k - 2 * y * φ + φ * φ;
	            φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
	          } while (Math.abs(δ) > ε && --i > 0);
	          tanφ = Math.tan(φ);
	          return [ (Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(x * tanφ) : sgn(x) * (acos(Math.abs(x * tanφ)) + halfπ)) / Math.sin(φ), φ ];
	        };
	        (d3.geo.polyconic = function() {
	          return projection(polyconic);
	        }).raw = polyconic;
	        function rectangularPolyconic(φ0) {
	          var sinφ0 = Math.sin(φ0);
	          function forward(λ, φ) {
	            var A = sinφ0 ? Math.tan(λ * sinφ0 / 2) / sinφ0 : λ / 2;
	            if (!φ) return [ 2 * A, -φ0 ];
	            var E = 2 * Math.atan(A * Math.sin(φ)), cotφ = 1 / Math.tan(φ);
	            return [ Math.sin(E) * cotφ, φ + (1 - Math.cos(E)) * cotφ - φ0 ];
	          }
	          forward.invert = function(x, y) {
	            if (Math.abs(y += φ0) < ε) return [ sinφ0 ? 2 * Math.atan(sinφ0 * x / 2) / sinφ0 : x, 0 ];
	            var k = x * x + y * y, φ = 0, i = 10, δ;
	            do {
	              var tanφ = Math.tan(φ), secφ = 1 / Math.cos(φ), j = k - 2 * y * φ + φ * φ;
	              φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
	            } while (Math.abs(δ) > ε && --i > 0);
	            var E = x * (tanφ = Math.tan(φ)), A = Math.tan(Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(E) * .5 : acos(E) * .5 + π / 4) / Math.sin(φ);
	            return [ sinφ0 ? 2 * Math.atan(sinφ0 * A) / sinφ0 : 2 * A, φ ];
	          };
	          return forward;
	        }
	        (d3.geo.rectangularPolyconic = function() {
	          return parallel1Projection(rectangularPolyconic);
	        }).raw = rectangularPolyconic;
	        var robinsonConstants = [ [ .9986, -.062 ], [ 1, 0 ], [ .9986, .062 ], [ .9954, .124 ], [ .99, .186 ], [ .9822, .248 ], [ .973, .31 ], [ .96, .372 ], [ .9427, .434 ], [ .9216, .4958 ], [ .8962, .5571 ], [ .8679, .6176 ], [ .835, .6769 ], [ .7986, .7346 ], [ .7597, .7903 ], [ .7186, .8435 ], [ .6732, .8936 ], [ .6213, .9394 ], [ .5722, .9761 ], [ .5322, 1 ] ];
	        robinsonConstants.forEach(function(d) {
	          d[1] *= 1.0144;
	        });
	        function robinson(λ, φ) {
	          var i = Math.min(18, Math.abs(φ) * 36 / π), i0 = Math.floor(i), di = i - i0, ax = (k = robinsonConstants[i0])[0], ay = k[1], bx = (k = robinsonConstants[++i0])[0], by = k[1], cx = (k = robinsonConstants[Math.min(19, ++i0)])[0], cy = k[1], k;
	          return [ λ * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (φ > 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) ];
	        }
	        robinson.invert = function(x, y) {
	          var yy = y / halfπ, φ = yy * 90, i = Math.min(18, Math.abs(φ / 5)), i0 = Math.max(0, Math.floor(i));
	          do {
	            var ay = robinsonConstants[i0][1], by = robinsonConstants[i0 + 1][1], cy = robinsonConstants[Math.min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (Math.abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));
	            if (di >= 0 || i0 === 1) {
	              φ = (y >= 0 ? 5 : -5) * (di + i);
	              var j = 50, δ;
	              do {
	                i = Math.min(18, Math.abs(φ) / 5);
	                i0 = Math.floor(i);
	                di = i - i0;
	                ay = robinsonConstants[i0][1];
	                by = robinsonConstants[i0 + 1][1];
	                cy = robinsonConstants[Math.min(19, i0 + 2)][1];
	                φ -= (δ = (y >= 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;
	              } while (Math.abs(δ) > ε2 && --j > 0);
	              break;
	            }
	          } while (--i0 >= 0);
	          var ax = robinsonConstants[i0][0], bx = robinsonConstants[i0 + 1][0], cx = robinsonConstants[Math.min(19, i0 + 2)][0];
	          return [ x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), φ * radians ];
	        };
	        (d3.geo.robinson = function() {
	          return projection(robinson);
	        }).raw = robinson;
	        function satelliteVertical(P) {
	          function forward(λ, φ) {
	            var cosφ = Math.cos(φ), k = (P - 1) / (P - cosφ * Math.cos(λ));
	            return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	          }
	          forward.invert = function(x, y) {
	            var ρ2 = x * x + y * y, ρ = Math.sqrt(ρ2), sinc = (P - Math.sqrt(1 - ρ2 * (P + 1) / (P - 1))) / ((P - 1) / ρ + ρ / (P - 1));
	            return [ Math.atan2(x * sinc, ρ * Math.sqrt(1 - sinc * sinc)), ρ ? asin(y * sinc / ρ) : 0 ];
	          };
	          return forward;
	        }
	        function satellite(P, ω) {
	          var vertical = satelliteVertical(P);
	          if (!ω) return vertical;
	          var cosω = Math.cos(ω), sinω = Math.sin(ω);
	          function forward(λ, φ) {
	            var coordinates = vertical(λ, φ), y = coordinates[1], A = y * sinω / (P - 1) + cosω;
	            return [ coordinates[0] * cosω / A, y / A ];
	          }
	          forward.invert = function(x, y) {
	            var k = (P - 1) / (P - 1 - y * sinω);
	            return vertical.invert(k * x, k * y * cosω);
	          };
	          return forward;
	        }
	        function satelliteProjection() {
	          var P = 1.4, ω = 0, m = projectionMutator(satellite), p = m(P, ω);
	          p.distance = function(_) {
	            if (!arguments.length) return P;
	            return m(P = +_, ω);
	          };
	          p.tilt = function(_) {
	            if (!arguments.length) return ω * 180 / π;
	            return m(P, ω = _ * π / 180);
	          };
	          return p;
	        }
	        (d3.geo.satellite = satelliteProjection).raw = satellite;
	        function times(λ, φ) {
	          var t = Math.tan(φ / 2), s = Math.sin(π / 4 * t);
	          return [ λ * (.74482 - .34588 * s * s), 1.70711 * t ];
	        }
	        times.invert = function(x, y) {
	          var t = y / 1.70711, s = Math.sin(π / 4 * t);
	          return [ x / (.74482 - .34588 * s * s), 2 * Math.atan(t) ];
	        };
	        (d3.geo.times = function() {
	          return projection(times);
	        }).raw = times;
	        function twoPointEquidistant(z0) {
	          if (!z0) return d3.geo.azimuthalEquidistant.raw;
	          var λa = -z0 / 2, λb = -λa, z02 = z0 * z0, tanλ0 = Math.tan(λb), S = .5 / Math.sin(λb);
	          function forward(λ, φ) {
	            var za = acos(Math.cos(φ) * Math.cos(λ - λa)), zb = acos(Math.cos(φ) * Math.cos(λ - λb)), ys = φ < 0 ? -1 : 1;
	            za *= za, zb *= zb;
	            return [ (za - zb) / (2 * z0), ys * asqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0) ];
	          }
	          forward.invert = function(x, y) {
	            var y2 = y * y, cosza = Math.cos(Math.sqrt(y2 + (t = x + λa) * t)), coszb = Math.cos(Math.sqrt(y2 + (t = x + λb) * t)), t, d;
	            return [ Math.atan2(d = cosza - coszb, t = (cosza + coszb) * tanλ0), (y < 0 ? -1 : 1) * acos(Math.sqrt(t * t + d * d) * S) ];
	          };
	          return forward;
	        }
	        function twoPointEquidistantProjection() {
	          var points = [ [ 0, 0 ], [ 0, 0 ] ], m = projectionMutator(twoPointEquidistant), p = m(0), rotate = p.rotate;
	          delete p.rotate;
	          p.points = function(_) {
	            if (!arguments.length) return points;
	            points = _;
	            var interpolate = d3.geo.interpolate(_[0], _[1]), origin = interpolate(.5), p = d3.geo.rotation([ -origin[0], -origin[1] ])(_[0]), b = interpolate.distance * .5, γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
	            if (p[0] > 0) γ = π - γ;
	            rotate.call(p, [ -origin[0], -origin[1], -γ * degrees ]);
	            return m(b * 2);
	          };
	          return p;
	        }
	        (d3.geo.twoPointEquidistant = twoPointEquidistantProjection).raw = twoPointEquidistant;
	        function twoPointAzimuthal(d) {
	          var cosd = Math.cos(d);
	          function forward(λ, φ) {
	            var coordinates = d3.geo.gnomonic.raw(λ, φ);
	            coordinates[0] *= cosd;
	            return coordinates;
	          }
	          forward.invert = function(x, y) {
	            return d3.geo.gnomonic.raw.invert(x / cosd, y);
	          };
	          return forward;
	        }
	        function twoPointAzimuthalProjection() {
	          var points = [ [ 0, 0 ], [ 0, 0 ] ], m = projectionMutator(twoPointAzimuthal), p = m(0), rotate = p.rotate;
	          delete p.rotate;
	          p.points = function(_) {
	            if (!arguments.length) return points;
	            points = _;
	            var interpolate = d3.geo.interpolate(_[0], _[1]), origin = interpolate(.5), p = d3.geo.rotation([ -origin[0], -origin[1] ])(_[0]), b = interpolate.distance * .5, γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
	            if (p[0] > 0) γ = π - γ;
	            rotate.call(p, [ -origin[0], -origin[1], -γ * degrees ]);
	            return m(b);
	          };
	          return p;
	        }
	        (d3.geo.twoPointAzimuthal = twoPointAzimuthalProjection).raw = twoPointAzimuthal;
	        function vanDerGrinten(λ, φ) {
	          if (Math.abs(φ) < ε) return [ λ, 0 ];
	          var sinθ = Math.abs(φ / halfπ), θ = asin(sinθ);
	          if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [ 0, sgn(φ) * π * Math.tan(θ / 2) ];
	          var cosθ = Math.cos(θ), A = Math.abs(π / λ - λ / π) / 2, A2 = A * A, G = cosθ / (sinθ + cosθ - 1), P = G * (2 / sinθ - 1), P2 = P * P, P2_A2 = P2 + A2, G_P2 = G - P2, Q = A2 + G;
	          return [ sgn(λ) * π * (A * G_P2 + Math.sqrt(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2, sgn(φ) * π * (P * Q - A * Math.sqrt((A2 + 1) * P2_A2 - Q * Q)) / P2_A2 ];
	        }
	        vanDerGrinten.invert = function(x, y) {
	          if (Math.abs(y) < ε) return [ x, 0 ];
	          if (Math.abs(x) < ε) return [ 0, halfπ * Math.sin(2 * Math.atan(y / π)) ];
	          var x2 = (x /= π) * x, y2 = (y /= π) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -Math.abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * Math.sqrt(-a1 / 3), θ1 = acos(3 * d / (a1 * m1)) / 3;
	          return [ π * (x2_y2 - 1 + Math.sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x), sgn(y) * π * (-m1 * Math.cos(θ1 + π / 3) - c2 / (3 * c3)) ];
	        };
	        (d3.geo.vanDerGrinten = function() {
	          return projection(vanDerGrinten);
	        }).raw = vanDerGrinten;
	        function vanDerGrinten2(λ, φ) {
	          if (Math.abs(φ) < ε) return [ λ, 0 ];
	          var sinθ = Math.abs(φ / halfπ), θ = asin(sinθ);
	          if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [ 0, sgn(φ) * π * Math.tan(θ / 2) ];
	          var cosθ = Math.cos(θ), A = Math.abs(π / λ - λ / π) / 2, A2 = A * A, x1 = cosθ * (Math.sqrt(1 + A2) - A * cosθ) / (1 + A2 * sinθ * sinθ);
	          return [ sgn(λ) * π * x1, sgn(φ) * π * asqrt(1 - x1 * (2 * A + x1)) ];
	        }
	        vanDerGrinten2.invert = function(x, y) {
	          if (!x) return [ 0, halfπ * Math.sin(2 * Math.atan(y / π)) ];
	          var x1 = Math.abs(x / π), A = (1 - x1 * x1 - (y /= π) * y) / (2 * x1), A2 = A * A, B = Math.sqrt(A2 + 1);
	          return [ sgn(x) * π * (B - A), sgn(y) * halfπ * Math.sin(2 * Math.atan2(Math.sqrt((1 - 2 * A * x1) * (A + B) - x1), Math.sqrt(B + A + x1))) ];
	        };
	        (d3.geo.vanDerGrinten2 = function() {
	          return projection(vanDerGrinten2);
	        }).raw = vanDerGrinten2;
	        function vanDerGrinten3(λ, φ) {
	          if (Math.abs(φ) < ε) return [ λ, 0 ];
	          var sinθ = φ / halfπ, θ = asin(sinθ);
	          if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [ 0, π * Math.tan(θ / 2) ];
	          var A = (π / λ - λ / π) / 2, y1 = sinθ / (1 + Math.cos(θ));
	          return [ π * (sgn(λ) * asqrt(A * A + 1 - y1 * y1) - A), π * y1 ];
	        }
	        vanDerGrinten3.invert = function(x, y) {
	          if (!y) return [ x, 0 ];
	          var y1 = y / π, A = (π * π * (1 - y1 * y1) - x * x) / (2 * π * x);
	          return [ x ? π * (sgn(x) * Math.sqrt(A * A + 1) - A) : 0, halfπ * Math.sin(2 * Math.atan(y1)) ];
	        };
	        (d3.geo.vanDerGrinten3 = function() {
	          return projection(vanDerGrinten3);
	        }).raw = vanDerGrinten3;
	        function vanDerGrinten4(λ, φ) {
	          if (!φ) return [ λ, 0 ];
	          var φ0 = Math.abs(φ);
	          if (!λ || φ0 === halfπ) return [ 0, φ ];
	          var B = φ0 / halfπ, B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C2 = C * C, BC = B * C, B_C2 = B2 + C2 + 2 * BC, B_3C = B + 3 * C, λ0 = λ / halfπ, λ1 = λ0 + 1 / λ0, D = sgn(Math.abs(λ) - halfπ) * Math.sqrt(λ1 * λ1 - 4), D2 = D * D, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x1 = (D * (B_C2 + C2 - 1) + 2 * asqrt(F)) / (4 * B_C2 + D2);
	          return [ sgn(λ) * halfπ * x1, sgn(φ) * halfπ * asqrt(1 + D * Math.abs(x1) - x1 * x1) ];
	        }
	        vanDerGrinten4.invert = function(x, y) {
	          if (!x || !y) return [ x, y ];
	          y /= π;
	          var x1 = sgn(x) * x / halfπ, D = (x1 * x1 - 1 + 4 * y * y) / Math.abs(x1), D2 = D * D, B = 2 * y, i = 50;
	          do {
	            var B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C_ = (3 * B - B2 * B - 10) / (2 * B2 * B), C2 = C * C, BC = B * C, B_C = B + C, B_C2 = B_C * B_C, B_3C = B + 3 * C, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)), sqrtF = Math.sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
	            B -= δ = f / f_;
	          } while (δ > ε && --i > 0);
	          return [ sgn(x) * (Math.sqrt(D * D + 4) + D) * π / 4, halfπ * B ];
	        };
	        (d3.geo.vanDerGrinten4 = function() {
	          return projection(vanDerGrinten4);
	        }).raw = vanDerGrinten4;
	        var wagner4 = function() {
	          var A = 4 * π + 3 * Math.sqrt(3), B = 2 * Math.sqrt(2 * π * Math.sqrt(3) / A);
	          return mollweideBromley(B * Math.sqrt(3) / π, B, A / 6);
	        }();
	        (d3.geo.wagner4 = function() {
	          return projection(wagner4);
	        }).raw = wagner4;
	        function wagner6(λ, φ) {
	          return [ λ * Math.sqrt(1 - 3 * φ * φ / (π * π)), φ ];
	        }
	        wagner6.invert = function(x, y) {
	          return [ x / Math.sqrt(1 - 3 * y * y / (π * π)), y ];
	        };
	        (d3.geo.wagner6 = function() {
	          return projection(wagner6);
	        }).raw = wagner6;
	        function wagner7(λ, φ) {
	          var s = .90631 * Math.sin(φ), c0 = Math.sqrt(1 - s * s), c1 = Math.sqrt(2 / (1 + c0 * Math.cos(λ /= 3)));
	          return [ 2.66723 * c0 * c1 * Math.sin(λ), 1.24104 * s * c1 ];
	        }
	        wagner7.invert = function(x, y) {
	          var t1 = x / 2.66723, t2 = y / 1.24104, p = Math.sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);
	          return [ 3 * Math.atan2(x * Math.tan(c), 2.66723 * p), p && asin(y * Math.sin(c) / (1.24104 * .90631 * p)) ];
	        };
	        (d3.geo.wagner7 = function() {
	          return projection(wagner7);
	        }).raw = wagner7;
	        function wiechel(λ, φ) {
	          var cosφ = Math.cos(φ), sinφ = Math.cos(λ) * cosφ, sin1_φ = 1 - sinφ, cosλ = Math.cos(λ = Math.atan2(Math.sin(λ) * cosφ, -Math.sin(φ))), sinλ = Math.sin(λ);
	          cosφ = asqrt(1 - sinφ * sinφ);
	          return [ sinλ * cosφ - cosλ * sin1_φ, -cosλ * cosφ - sinλ * sin1_φ ];
	        }
	        wiechel.invert = function(x, y) {
	          var w = -.5 * (x * x + y * y), k = Math.sqrt(-w * (2 + w)), b = y * w + x * k, a = x * w - y * k, D = Math.sqrt(a * a + b * b);
	          return [ Math.atan2(k * b, D * (1 + w)), D ? -asin(k * a / D) : 0 ];
	        };
	        (d3.geo.wiechel = function() {
	          return projection(wiechel);
	        }).raw = wiechel;
	        function winkel3(λ, φ) {
	          var coordinates = aitoff(λ, φ);
	          return [ (coordinates[0] + λ / halfπ) / 2, (coordinates[1] + φ) / 2 ];
	        }
	        winkel3.invert = function(x, y) {
	          var λ = x, φ = y, i = 25;
	          do {
	            var cosφ = Math.cos(φ), sinφ = Math.sin(φ), sin_2φ = Math.sin(2 * φ), sin2φ = sinφ * sinφ, cos2φ = cosφ * cosφ, sinλ = Math.sin(λ), cosλ_2 = Math.cos(λ / 2), sinλ_2 = Math.sin(λ / 2), sin2λ_2 = sinλ_2 * sinλ_2, C = 1 - cos2φ * cosλ_2 * cosλ_2, E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = .5 * (2 * E * cosφ * sinλ_2 + λ / halfπ) - x, fy = .5 * (E * sinφ + φ) - y, δxδλ = .5 * F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ) + .5 / halfπ, δxδφ = F * (sinλ * sin_2φ / 4 - E * sinφ * sinλ_2), δyδλ = .125 * F * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ), δyδφ = .5 * F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ) + .5, denominator = δxδφ * δyδλ - δyδφ * δxδλ, δλ = (fy * δxδφ - fx * δyδφ) / denominator, δφ = (fx * δyδλ - fy * δxδλ) / denominator;
	            λ -= δλ, φ -= δφ;
	          } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
	          return [ λ, φ ];
	        };
	        (d3.geo.winkel3 = function() {
	          return projection(winkel3);
	        }).raw = winkel3;
	      };
	
	      //import Selectlist from './bubblemap-selectlist';
	
	      //BUBBLE MAP CHART COMPONENT
	      var BubbleMapComponent = Component.extend({
	        /**
	         * Initializes the component (Bubble Map Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The config passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function (config, context) {
	          this.name = 'bubblemap';
	          this.template = 'bubblemap.html';
	          this.bubblesDrawing = null;
	
	
	          //http://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
	          var mobileAndTabletcheck = function() {
	            var check = false;
	            (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
	            return check;
	          };
	          this.isMobile = mobileAndTabletcheck();
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }, {
	            name: "ui",
	            type: "model"
	          }];
	
	          var _this = this;
	          this.model_binds = {
	            "change:time.value": function (evt) {
	              if (!_this._readyOnce) return;
	              _this.year.setText(_this.model.time.timeFormat(_this.model.time.value));
	              _this.model.marker.getFrame(_this.model.time.value, _this.frameChanged.bind(_this));
	            },
	            "change:entities.highlight": function (evt) {
	              if (!_this._readyOnce) return;
	              _this.highlightEntities();
	              _this.updateOpacity();
	            },
	            "change:marker": function(evt, path) {
	              // bubble size change is processed separately
	              if(!_this._readyOnce) return;
	
	              if(path.indexOf("scaleType") > -1) {
	                _this.redrawDataPoints(null, false);
	                // ready is not needed because new data are not needed, just reposition _this.ready(); 
	              }
	            },
	            'change:marker.size.extent': function(evt, path) {
	              //console.log("EVENT change:marker:size:max");
	              if(!_this._readyOnce || !_this.entityBubbles) return;
	              _this.updateMarkerSizeLimits();
	              _this.redrawDataPoints(null, false);
	            },
	            "change:marker.color.palette": function (evt, path) {
	                if (!_this._readyOnce) return;
	                _this.redrawDataPoints(null, false);
	            },
	            "change:entities.select": function (evt) {
	                if (!_this._readyOnce) return;
	                _this.selectEntities();
	                _this.redrawDataPoints(null, false);
	                _this.updateOpacity();
	                _this.updateDoubtOpacity();
	                
	            },
	            "change:entities.opacitySelectDim": function (evt) {
	                _this.updateOpacity();
	            },
	            "change:entities.opacityRegular": function (evt) {
	                _this.updateOpacity();
	            },
	          };
	
	          //this._selectlist = new Selectlist(this);
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.sScale = null;
	          this.cScale = d3.scale.category10();
	
	          _this.COLOR_WHITEISH = "#fdfdfd";
	            
	          this.defaultWidth = 960;
	          this.defaultHeight = 500;
	          this.boundBox = [[0.02, 0], [1.0, 0.85]]; // two points to set box bound on 960 * 500 image;
	
	          d3_geo_projection();
	        },
	
	
	        afterPreload: function(){
	          if(!this.world) warn("bubble map afterPreload: missing country shapes " + this.world);
	            
	          // http://bl.ocks.org/mbostock/d4021aa4dccfd65edffd patterson
	          // http://bl.ocks.org/mbostock/3710566 robinson
	          // map background
	          var defaultWidth = this.defaultWidth;
	          var defaultHeight = this.defaultHeight;
	          var world = this.world;
	          var projection = this.projection = d3.geo.robinson()
	              .scale(150)
	              .translate([defaultWidth / 2, defaultHeight / 2])
	              .precision(.1);
	
	          var path = this.bgPath = d3.geo.path()
	              .projection(projection);
	
	          var svg = this.mapGraph = d3.select(this.element).select(".vzb-bmc-map-graph")
	              .attr("width", defaultWidth)
	              .attr("height", defaultHeight);
	          svg.html('');
	
	          /* // no latlng line
	          svg.append("defs").append("path")
	              .datum({type: "Sphere"})
	              .attr("id", "sphere")
	              .attr("d", path);
	
	          svg.append("use")
	              .attr("class", "stroke")
	              .attr("xlink:href", "#sphere");
	
	          svg.append("use")
	              .attr("class", "fill")
	              .attr("xlink:href", "#sphere");
	
	          svg.append("path")
	              .datum(graticule)
	              .attr("class", "graticule")
	              .attr("d", path);
	          */
	
	          svg.insert("path", ".graticule")
	              .datum(topojson.feature(world, world.objects.land))
	              .attr("class", "land")
	              .attr("d", path);
	
	          svg.insert("path", ".graticule")
	              .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
	              .attr("class", "boundary")
	              .attr("d", path);
	              
	          this.labels = this.parent.findChildByName('gapminder-labels');
	          this.labels.config({
	            CSS_PREFIX: 'vzb-bmc',
	            TOOL_CONTEXT: this,
	            LABELS_CONTAINER_CLASS: 'vzb-bmc-labels',
	            LINES_CONTAINER_CLASS: 'vzb-bmc-lines'
	          });
	          
	        },
	
	        /**
	         * DOM is ready
	         */
	        readyOnce: function () {
	
	          this.element = d3.select(this.element);
	
	          this.graph = this.element.select('.vzb-bmc-graph');
	          this.mapSvg = this.element.select('.vzb-bmc-map-background');
	
	          this.bubbleContainerCrop = this.graph.select('.vzb-bmc-bubbles-crop');
	          this.bubbleContainer = this.graph.select('.vzb-bmc-bubbles');
	          this.labelListContainer = this.graph.select('.vzb-bmc-bubble-labels');
	          this.dataWarningEl = this.graph.select(".vzb-data-warning");
	
	          this.yTitleEl = this.graph.select(".vzb-bmc-axis-y-title");
	          this.cTitleEl = this.graph.select(".vzb-bmc-axis-c-title");
	          this.yInfoEl = this.graph.select(".vzb-bmc-axis-y-info");
	          this.cInfoEl = this.graph.select(".vzb-bmc-axis-c-info");
	
	          this.entityBubbles = null;
	          this.tooltip = this.element.select('.vzb-bmc-tooltip');
	
	          // year background
	          this.yearEl = this.graph.select('.vzb-bmc-year');
	          this.year = new DynamicBackground(this.yearEl);
	          this.year.setConditions({xAlign: 'left', yAlign: 'bottom', bottomOffset: 5});
	
	          var _this = this;
	          this.on("resize", function () {
	            //return if updatesize exists with error
	            if(_this.updateSize()) return;
	            _this.updateMarkerSizeLimits();
	            _this.labels.updateSize();
	            _this.redrawDataPoints();
	            //_this._selectlist.redraw();
	            
	          });
	
	          this.KEY = this.model.entities.getDimension();
	          this.TIMEDIM = this.model.time.getDimension();
	            
	            
	          this.updateUIStrings();
	
	          this.wScale = d3.scale.linear()
	              .domain(this.parent.datawarning_content.doubtDomain)
	              .range(this.parent.datawarning_content.doubtRange);
	
	        },
	
	        /*
	         * Both model and DOM are ready
	         */
	        ready: function () {
	          var _this = this;
	          this.updateUIStrings();
	          this.updateIndicators();
	          this.updateSize();
	          this.updateMarkerSizeLimits();
	          this.model.marker.getFrame(this.model.time.value, function(values, time) {
	            // TODO: temporary fix for case when after data loading time changed on validation
	            if (time.toString() != _this.model.time.value.toString()) {
	              defer(function() {
	                _this.ready();
	              });
	              return;
	            } // frame is outdated
	            
	            if (!values) return;
	            _this.values = values;
	            _this.updateEntities();
	            _this.updateTime();
	            _this.redrawDataPoints();
	            _this.highlightEntities();
	            _this.selectEntities();
	      //    this._selectlist.redraw();
	            _this.updateDoubtOpacity();
	            _this.updateOpacity();
	            _this.year.setText(_this.model.time.timeFormat(_this.model.time.value));        
	          });
	
	        },
	
	        frameChanged: function(frame, time) {
	          if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
	          if (!frame) return;
	          
	          this.values = frame;
	          this.updateTime();
	          this.updateDoubtOpacity();
	          this.redrawDataPoints(null, false);
	
	        },
	        
	        updateUIStrings: function () {
	            var _this = this;
	
	            this.translator = this.model.language.getTFunction();    
	            var sizeConceptprops = this.model.marker.size.getConceptprops();
	
	            this.strings = {
	                title: {
	                  S: this.translator("indicator/" + _this.model.marker.size.which),
	                  C: this.translator("indicator/" + _this.model.marker.color.which)
	                }
	            };
	
	            this.yTitleEl.select("text")
	                .text(this.translator("buttons/size") + ": " + this.strings.title.S)
	                .on("click", function() {
	                  _this.parent
	                    .findChildByName("gapminder-treemenu")
	                    .markerID("size")
	                    .alignX("left")
	                    .alignY("top")
	                    .updateView()
	                    .toggle();
	                });
	
	            this.cTitleEl.select("text")
	                .text(this.translator("buttons/color") + ": " + this.strings.title.C)
	                .on("click", function() {
	                  _this.parent
	                    .findChildByName("gapminder-treemenu")
	                    .markerID("color")
	                    .alignX("left")
	                    .alignY("top")
	                    .updateView()
	                    .toggle();
	                });
	
	            setIcon(this.dataWarningEl, iconWarn).select("svg").attr("width", "0px").attr("height", "0px");
	            this.dataWarningEl.append("text")
	                .attr("text-anchor", "end")
	                .text(this.translator("hints/dataWarning"));
	
	            this.dataWarningEl
	                .on("click", function () {
	                    _this.parent.findChildByName("gapminder-datawarning").toggle();
	                })
	                .on("mouseover", function () {
	                    _this.updateDoubtOpacity(1);
	                })
	                .on("mouseout", function () {
	                    _this.updateDoubtOpacity();
	                })
	
	            this.yInfoEl
	                .html(iconQuestion)
	                .select("svg").attr("width", "0px").attr("height", "0px");
	
	            //TODO: move away from UI strings, maybe to ready or ready once
	            this.yInfoEl.on("click", function() {
	              _this.parent.findChildByName("gapminder-datanotes").pin();
	            })
	            this.yInfoEl.on("mouseover", function() {
	              var rect = this.getBBox();
	              var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	              _this.parent.findChildByName("gapminder-datanotes").setHook('size').show().setPos(coord.x, coord.y);
	            })
	            this.yInfoEl.on("mouseout", function() {
	              _this.parent.findChildByName("gapminder-datanotes").hide();
	            })
	
	            this.cInfoEl
	                .html(iconQuestion)
	                .select("svg").attr("width", "0px").attr("height", "0px");
	
	            //TODO: move away from UI strings, maybe to ready or ready once
	            this.cInfoEl.on("click", function() {
	              _this.parent.findChildByName("gapminder-datanotes").pin();
	            })
	            this.cInfoEl.on("mouseover", function() {
	              var rect = this.getBBox();
	              var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	              _this.parent.findChildByName("gapminder-datanotes").setHook('color').show().setPos(coord.x, coord.y);
	            })
	            this.cInfoEl.on("mouseout", function() {
	              _this.parent.findChildByName("gapminder-datanotes").hide();
	            })
	        },
	
	        // show size number on title when hovered on a bubble
	        updateTitleNumbers: function(){
	            var _this = this;
	
	            var mobile; // if is mobile device and only one bubble is selected, update the ytitle for the bubble
	            if (_this.isMobile && _this.model.entities.select && _this.model.entities.select.length === 1) {
	              mobile = _this.model.entities.select[0];
	            }
	
	            if(_this.hovered || mobile) {
	              var hovered = _this.hovered || mobile;
	              var formatterS = _this.model.marker.size.getTickFormatter();
	              var formatterC = _this.model.marker.color.getTickFormatter();
	
	              var unitY = _this.translator("unit/" + _this.model.marker.size.which);
	              var unitC = _this.translator("unit/" + _this.model.marker.color.which);
	                
	              //suppress unit strings that found no translation (returns same thing as requested)
	              if(unitY === "unit/" + _this.model.marker.size.which) unitY = "";
	              if(unitC === "unit/" + _this.model.marker.color.which) unitC = "";
	                
	              var valueS = _this.values.size[hovered[_this.KEY]];
	              var valueC = _this.values.color[hovered[_this.KEY]];
	                
	              _this.yTitleEl.select("text")
	                .text(_this.translator("buttons/size") + ": " + formatterS(valueS) + " " + unitY);
	                
	              _this.cTitleEl.select("text")
	                .text(_this.translator("buttons/color") + ": " + 
	                  (valueC || valueC===0 ? formatterC(valueC) + " " + unitC : _this.translator("hints/nodata")));
	
	              this.yInfoEl.classed("vzb-hidden", true);
	              this.cInfoEl.classed("vzb-hidden", true);
	            } else {
	              this.yTitleEl.select("text")
	                  .text(this.translator("buttons/size") + ": " + this.strings.title.S);
	              this.cTitleEl.select("text")
	                  .text(this.translator("buttons/color") + ": " + this.strings.title.C);
	
	              this.yInfoEl.classed("vzb-hidden", false);
	              this.cInfoEl.classed("vzb-hidden", false || this.cTitleEl.classed('vzb-hidden'));
	            }
	        },
	
	        updateDoubtOpacity: function (opacity) {
	            if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
	            if (this.someSelected) opacity = 1;
	            this.dataWarningEl.style("opacity", opacity);
	        },
	
	        updateOpacity: function () {
	            var _this = this;
	            /*
	            this.entityBubbles.classed("vzb-selected", function (d) {
	                return _this.model.entities.isSelected(d);
	            });
	            */
	
	            var OPACITY_HIGHLT = 1.0;
	            var OPACITY_HIGHLT_DIM = .3;
	            var OPACITY_SELECT = this.model.entities.opacityRegular;
	            var OPACITY_REGULAR = this.model.entities.opacityRegular;
	            var OPACITY_SELECT_DIM = this.model.entities.opacitySelectDim;
	
	            this.entityBubbles.style("opacity", function (d) {
	
	                if (_this.someHighlighted) {
	                    //highlight or non-highlight
	                    if (_this.model.entities.isHighlighted(d)) return OPACITY_HIGHLT;
	                }
	
	                if (_this.someSelected) {
	                    //selected or non-selected
	                    return _this.model.entities.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
	                }
	
	                if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;
	
	                return OPACITY_REGULAR;
	
	            });
	
	            this.entityBubbles.classed("vzb-selected", function (d) {
	                return _this.model.entities.isSelected(d)
	            });
	
	            var someSelectedAndOpacityZero = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	
	            // when pointer events need update...
	            if (someSelectedAndOpacityZero !== this.someSelectedAndOpacityZero_1) {
	                this.entityBubbles.style("pointer-events", function (d) {
	                    return (!someSelectedAndOpacityZero || _this.model.entities.isSelected(d)) ?
	                        "visible" : "none";
	                });
	            }
	
	            this.someSelectedAndOpacityZero_1 = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	        },
	
	        /**
	         * Changes labels for indicators
	         */
	        updateIndicators: function () {
	          this.sScale = this.model.marker.size.getScale();
	          this.cScale = this.model.marker.color.getScale();
	        },
	
	        /**
	         * Updates entities
	         */
	        updateEntities: function () {
	
	          var _this = this;
	          var KEY = this.KEY;
	          var TIMEDIM = this.TIMEDIM;
	
	          var getKeys = function(prefix) {
	            prefix = prefix || "";
	            return _this.model.marker.getKeys()
	              .map(function(d) {
	                var pointer = {};
	                pointer[KEY] = d[KEY];
	                pointer[TIMEDIM] = endTime;
	                pointer.sortValue = _this.values.size[d[KEY]]||0;
	                pointer[KEY] = prefix + d[KEY];
	                return pointer;
	              })
	              .sort(function(a, b) {
	                return b.sortValue - a.sortValue;
	              })
	          };
	            
	          // get array of GEOs, sorted by the size hook
	          // that makes larger bubbles go behind the smaller ones
	          var endTime = this.model.time.end;
	          this.model.entities.setVisible(getKeys.call(this));
	
	          //unselecting bubbles with no data is used for the scenario when
	          //some bubbles are selected and user would switch indicator.
	          //bubbles would disappear but selection would stay
	          if (!this.model.time.splash) {
	            this.unselectBubblesWithNoData();
	          }
	
	          // TODO: add to csv
	          //Africa 9.1021° N, 18.2812°E
	          //Europe 53.0000° N, 9.0000° E
	          //Asia 49.8380° N, 105.8203° E
	          //north American 48.1667° N and longitude 100.1667° W
	          /*
	          var pos = {
	            "afr": {lat: 9.1, lng: 18.3},
	            "eur": {lat: 53.0, lng: 9.0},
	            "asi": {lat: 49.8, lng: 105.8},
	            "ame": {lat: 48.2, lng: -100.2},
	          };
	          */
	
	
	          this.entityBubbles = this.bubbleContainer.selectAll('.vzb-bmc-bubble')
	            .data(this.model.entities.getVisible(), function(d) { return d[KEY]; })
	            .order();
	
	          //exit selection
	          this.entityBubbles.exit().remove();
	
	          //enter selection -- init circles
	          this.entityBubbles.enter().append("circle")
	            .attr("class", "vzb-bmc-bubble")
	            .on("mouseover", function (d, i) {
	                if (isTouchDevice()) return;
	                _this._interact()._mouseover(d, i);
	            })
	            .on("mouseout", function (d, i) {
	                if (isTouchDevice()) return;
	                _this._interact()._mouseout(d, i);
	            })
	            .on("click", function (d, i) {
	                if (isTouchDevice()) return;
	                _this._interact()._click(d, i);
	                _this.highlightEntities();
	            })
	            .onTap(function (d, i) {
	                _this._interact()._click(d, i);
	                d3.event.stopPropagation();
	            })
	            .onLongTap(function (d, i) {
	            })
	
	        },
	          
	        unselectBubblesWithNoData: function(frame){
	            var _this = this;
	            var KEY = this.KEY;
	            if(!frame) frame = this.values;
	            
	            if(!frame || !frame.size) return;
	            
	            this.model.entities.select.forEach(function(d){
	              if(!frame.size[d[KEY]] && frame.size[d[KEY]] !== 0) 
	                  _this.model.entities.selectEntity(d);
	            })
	        },    
	          
	        redrawDataPoints: function(duration, reposition){
	          var _this = this;  
	          if(!duration) duration = this.duration;
	          if(!reposition) reposition = true;
	          this.entityBubbles.each(function(d, index){
	            var view = d3.select(this);
	
	            var valueX = _this.values.lng[d[_this.KEY]];
	            var valueY = _this.values.lat[d[_this.KEY]];
	            var valueS = _this.values.size[d[_this.KEY]];
	            var valueC = _this.values.color[d[_this.KEY]];
	            var valueL = _this.values.label[d[_this.KEY]];
	
	            d.hidden_1 = d.hidden;
	            d.hidden = !valueS || valueX==null || valueY==null;
	
	            if(d.hidden !== d.hidden_1) view.classed("vzb-hidden", d.hidden);
	              
	            if(!d.hidden){
	                
	                d.r = areaToRadius(_this.sScale(valueS||0));
	                d.label = valueL;
	                
	                view.classed("vzb-hidden", false)
	                    .attr("fill", valueC!=null?_this.cScale(valueC):_this.COLOR_WHITEISH);
	                
	                if(reposition){
	                    d.cLoc = _this.skew(_this.projection([valueX||0, valueY||0]));
	                    
	                    view.attr("cx", d.cLoc[0])
	                        .attr("cy", d.cLoc[1]);
	                }
	
	                if(duration){
	                    view.transition().duration(duration).ease("linear")
	                        .attr("r", d.r);
	                }else{
	                    view.interrupt()
	                        .attr("r", d.r);
	                }
	
	                _this._updateLabel(d, index, d.cLoc[0], d.cLoc[1], valueS, valueC, d.label, duration);
	              } else {
	                _this._updateLabel(d, index, 0, 0, valueS, valueC, valueL, duration);
	              }
	
	            });
	        },
	
	        /*
	         * UPDATE TIME:
	         * Ideally should only update when time or data changes
	         */
	        updateTime: function() {
	          var _this = this;
	
	          this.time_1 = this.time == null ? this.model.time.value : this.time;
	          this.time = this.model.time.value;
	          this.duration = this.model.time.playing && (this.time - this.time_1 > 0) ? this.model.time.delayAnimations : 0;
	
	          //possibly update the exact value in size title
	          this.updateTitleNumbers();
	        },
	
	          
	        fitSizeOfTitles: function(){
	            
	          //reset font sizes first to make the measurement consistent
	          var yTitleText = this.yTitleEl.select("text")
	            .style("font-size", null);
	          var cTitleText = this.cTitleEl.select("text")
	            .style("font-size", null);    
	
	          var yTitleText = this.yTitleEl.select("text");
	          var cTitleText = this.cTitleEl.select("text");
	
	          var yTitleBB = yTitleText.node().getBBox();
	          var cTitleBB = this.cTitleEl.classed('vzb-hidden') ? yTitleBB : cTitleText.node().getBBox();
	
	          var font = 
	              Math.max(parseInt(yTitleText.style("font-size")), parseInt(cTitleText.style("font-size"))) 
	              * this.width / Math.max(yTitleBB.width, cTitleBB.width);
	            
	          if(Math.max(yTitleBB.width, cTitleBB.width) > this.width) {
	            yTitleText.style("font-size", font + "px");
	            cTitleText.style("font-size", font + "px");
	          } else {
	            
	            // Else - reset the font size to default so it won't get stuck
	            yTitleText.style("font-size", null);
	            cTitleText.style("font-size", null);
	          }
	            
	        },
	          
	          
	        /**
	         * Executes everytime the container or vizabi is resized
	         * Ideally,it contains only operations related to size
	         */
	        updateSize: function () {
	
	          var _this = this;
	          var margin, infoElHeight;
	
	          var profiles = {
	            small: {
	              margin: { top: 10, right: 10, left: 10, bottom: 0 },
	              infoElHeight: 16,
	              minRadius: 0.5,
	              maxRadius: 30
	            },
	            medium: {
	              margin: { top: 20, right: 20, left: 20, bottom: 30 },
	              infoElHeight: 20,
	              minRadius: 1,
	              maxRadius: 55
	            },
	            large: {
	              margin: { top: 30, right: 30, left: 30, bottom: 35 },
	              infoElHeight: 22,
	              minRadius: 1,
	              maxRadius: 65
	            }
	          };
	
	          var presentationProfileChanges = {
	            medium: {
	              infoElHeight: 26
	            },
	            large: {
	              infoElHeight: 32
	            }
	          };
	
	          this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);
	          margin = this.activeProfile.margin;
	          infoElHeight = this.activeProfile.infoElHeight;
	
	          //stage
	          var height = this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          var width = this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;      
	            
	          if(this.height<=0 || this.width<=0) return warn("Bubble map updateSize() abort: vizabi container is too little or has display:none");
	            
	          var boundBox = this.boundBox;
	          var viewBox = [ boundBox[0][0] * this.defaultWidth,
	                          boundBox[0][1] * this.defaultHeight,
	                          Math.abs(boundBox[1][0] - boundBox[0][0]) * this.defaultWidth,
	                          Math.abs(boundBox[1][1] - boundBox[0][1]) * this.defaultHeight];
	
	          this.graph
	            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	          this.year.resize(this.width, this.height,
	            Math.min(this.width/2.5, Math.max(this.height / 4, this.width / 4)) / 2.5);
	
	          this.mapSvg
	            .attr('width', width)
	            .attr('height', height)
	            .attr('viewBox', viewBox.join(' '))
	            .attr('preserveAspectRatio', 'none')
	            .attr('x', margin.left)
	            .attr('y', margin.top)
	            .style("transform", "translate3d(" + margin.left + "px," + margin.top + "px,0)");
	
	          //update scales to the new range
	          //this.updateMarkerSizeLimits();
	          //this.sScale.range([0, this.height / 4]);
	
	          var skew = this.skew = (function () {
	            var vb = viewBox;
	            var w = width;
	            var h = height;
	            var vbCenter = [vb[0] + vb[2] / 2, vb[1] + vb[3] / 2];
	            var vbWidth = vb[2] || 0.001;
	            var vbHeight = vb[3] || 0.001;
	            //input pixel loc after projection, return pixel loc after skew;
	            return function (points) {
	              var x = (points[0] - vbCenter[0]) / vbWidth * width + width / 2;
	              var y = (points[1] - vbCenter[1]) / vbHeight * height + height / 2;
	              return [x, y];
	            }
	          }());
	
	
	          this.yTitleEl
	              .style("font-size", infoElHeight)
	              .attr("transform", "translate(0," + margin.top + ")")
	
	          var yTitleBB = this.yTitleEl.select("text").node().getBBox();
	
	          this.cTitleEl.attr("transform", "translate(" + 0 + "," + (margin.top + yTitleBB.height) + ")")
	              .classed("vzb-hidden", this.model.marker.color.which.indexOf(_this.KEY) != -1 || this.model.marker.color.use == "constant");
	
	          var warnBB = this.dataWarningEl.select("text").node().getBBox();
	          this.dataWarningEl.select("svg")
	              .attr("width", warnBB.height * 0.75)
	              .attr("height", warnBB.height * 0.75)
	              .attr("x", -warnBB.width - warnBB.height * 1.2)
	              .attr("y", -warnBB.height * 0.65)
	
	          this.dataWarningEl
	              .attr("transform", "translate(" + (this.width) + "," + (this.height - warnBB.height * 0.5) + ")")
	              .select("text");
	
	          if(this.yInfoEl.select('svg').node()) {
	              var titleBBox = this.yTitleEl.node().getBBox();
	              var translate = d3.transform(this.yTitleEl.attr('transform')).translate;
	
	              this.yInfoEl.select('svg')
	                  .attr("width", infoElHeight)
	                  .attr("height", infoElHeight)
	              this.yInfoEl.attr('transform', 'translate('
	                  + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	                  + (translate[1] - infoElHeight * 0.8) + ')');
	          }
	          
	          this.cInfoEl.classed("vzb-hidden", this.cTitleEl.classed("vzb-hidden"));
	
	          if(!this.cInfoEl.classed("vzb-hidden") && this.cInfoEl.select('svg').node()) {
	              var titleBBox = this.cTitleEl.node().getBBox();
	              var translate = d3.transform(this.cTitleEl.attr('transform')).translate;
	
	              this.cInfoEl.select('svg')
	                  .attr("width", infoElHeight)
	                  .attr("height", infoElHeight)
	              this.cInfoEl.attr('transform', 'translate('
	                  + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	                  + (translate[1] - infoElHeight * 0.8) + ')');
	          }
	        },
	
	        updateMarkerSizeLimits: function() {
	          var _this = this;
	          var extent = this.model.marker.size.extent || [0,1];
	            
	          var minRadius = this.activeProfile.minRadius;
	          var maxRadius = this.activeProfile.maxRadius;
	
	          this.minRadius = Math.max(maxRadius * extent[0], minRadius);
	          this.maxRadius = Math.max(maxRadius * extent[1], minRadius);
	
	          if(this.model.marker.size.scaleType !== "ordinal") {
	            this.sScale.range([radiusToArea(_this.minRadius), radiusToArea(_this.maxRadius)]);
	          } else {
	            this.sScale.rangePoints([radiusToArea(_this.minRadius), radiusToArea(_this.maxRadius)], 0).range();
	          }
	
	        },
	
	        _interact: function () {
	            var _this = this;
	
	            return {
	                _mouseover: function (d, i) {
	                    if (_this.model.time.dragging) return;
	
	                    _this.model.entities.highlightEntity(d);
	
	                    _this.hovered = d;
	                    //put the exact value in the size title
	                    _this.updateTitleNumbers();
	                    _this.fitSizeOfTitles();
	
	                    if (_this.model.entities.isSelected(d)) { // if selected, not show hover tooltip
	                      _this._setTooltip();
	                    } else {
	                      //position tooltip
	                      _this._setTooltip(d);
	                    }
	                },
	                _mouseout: function (d, i) {
	                    if (_this.model.time.dragging) return;
	                    _this._setTooltip();
	                    _this.hovered = null;
	                    _this.updateTitleNumbers();
	                    _this.fitSizeOfTitles();
	                    _this.model.entities.clearHighlighted();
	                },
	                _click: function (d, i) {
	                    _this.model.entities.selectEntity(d);
	                }
	            };
	
	        },
	
	
	        highlightEntities: function () {
	            var _this = this;
	            this.someHighlighted = (this.model.entities.highlight.length > 0);
	
	
	      //      if (!this.selectList || !this.someSelected) return;
	      //      this.selectList.classed("vzb-highlight", function (d) {
	      //          return _this.model.entities.isHighlighted(d);
	      //      });
	      //      this.selectList.each(function (d, i) {
	      //        d3.select(this).selectAll(".vzb-bmc-label-x")
	      //          .classed("vzb-invisible", function(n) {
	      //            return !_this.model.entities.isHighlighted(d);
	      //          });
	      //
	      //      });
	
	        },
	
	        _updateLabel: function(d, index, valueX, valueY, valueS, valueC, valueL, duration) {
	          var _this = this;
	          var KEY = this.KEY;
	          if(d[KEY] == _this.druging) return;
	          if(duration == null) duration = _this.duration;
	
	          // only for selected entities
	          if(_this.model.entities.isSelected(d)) {
	            
	            var showhide = d.hidden !== d.hidden_1;
	            var valueLST = null;
	            var cache = {};
	            cache.labelX0 = valueX / this.width;
	            cache.labelY0 = valueY / this.height;
	            cache.scaledS0 = valueS ? areaToRadius(_this.sScale(valueS)) : null;
	            cache.scaledC0 = valueC!=null?_this.cScale(valueC):_this.COLOR_WHITEISH;
	                   
	            this.labels.updateLabel(d, index, cache, valueX / this.width, valueY / this.height, valueS, valueC, valueL, valueLST, duration, showhide);
	          }
	        },
	
	        selectEntities: function () {
	            var _this = this;
	            var KEY = this.KEY;
	            this.someSelected = (this.model.entities.select.length > 0);
	
	      //      this._selectlist.rebuild();
	
	            // hide recent hover tooltip
	            if (!_this.hovered || _this.model.entities.isSelected(_this.hovered)) {
	              _this._setTooltip();
	            }
	
	        },
	
	        _setTooltip: function (d) {
	          var _this = this;
	          if (d) {
	            var tooltipText = d.label;
	            var x = d.cLoc[0];
	            var y = d.cLoc[1];
	            var offset = d.r;
	            var mouse = d3.mouse(this.graph.node()).map(function(d) {
	              return parseInt(d)
	            });
	            var xPos, yPos, xSign = -1,
	              ySign = -1,
	              xOffset = 0,
	              yOffset = 0;
	
	            if(offset) {
	              xOffset = offset * .71; // .71 - sin and cos for 315
	              yOffset = offset * .71;
	            }
	            //position tooltip
	            this.tooltip.classed("vzb-hidden", false)
	              //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
	              .selectAll("text")
	              .text(tooltipText);
	
	            var contentBBox = this.tooltip.select('text')[0][0].getBBox();
	            if(x - xOffset - contentBBox.width < 0) {
	              xSign = 1;
	              x += contentBBox.width + 5; // corrective to the block Radius and text padding
	            } else {
	              x -= 5; // corrective to the block Radius and text padding
	            }
	            if(y - yOffset - contentBBox.height < 0) {
	              ySign = 1;
	              y += contentBBox.height;
	            } else {
	              y -= 11; // corrective to the block Radius and text padding
	            }
	            if(offset) {
	              xPos = x + xOffset * xSign;
	              yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
	            } else {
	              xPos = x + xOffset * xSign; // .71 - sin and cos for 315
	              yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
	            }
	            this.tooltip.attr("transform", "translate(" + (xPos ? xPos : mouse[0]) + "," + (yPos ? yPos : mouse[1]) +
	              ")")
	
	            this.tooltip.select('rect').attr("width", contentBBox.width + 8)
	              .attr("height", contentBBox.height * 1.2)
	              .attr("x", -contentBBox.width - 4)
	              .attr("y", -contentBBox.height * .85)
	              .attr("rx", contentBBox.height * .2)
	              .attr("ry", contentBBox.height * .2);
	
	
	          } else {
	
	            this.tooltip.classed("vzb-hidden", true);
	          }
	        }
	
	      });
	
	      //BAR CHART TOOL
	      var BubbleMap = Tool.extend('BubbleMap', {
	
	
	        /**
	         * Initializes the tool (Bar Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	
	          this.name = "bubblemap";
	
	          //specifying components
	          this.components = [{
	            component: BubbleMapComponent,
	            placeholder: '.vzb-tool-viz',
	            model: ["state.time", "state.entities", "state.marker", "language", "ui"] //pass models to component
	          }, {
	            component: Labels,
	            placeholder: '.vzb-tool-labels',
	            model: ["state.entities", "state.marker", "ui"]
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }, {
	            component: DataWarning,
	            placeholder: '.vzb-tool-datawarning',
	            model: ['language']
	          }, {
	            component: DataNotes,
	            placeholder: '.vzb-tool-datanotes',
	            model: ['state.marker', 'language']
	          }
	          ];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        },
	
	        default_model: {
	          state: {
	            time: {},
	            entities: {
	              dim: "geo",
	              show: {
	                _defs_: {
	                  "geo": ["*"],
	                  "geo.cat": ["region"]
	                }
	              }
	            },
	            marker: {
	              space: ["entities", "time"],
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              axis_y: {
	                use: "indicator",
	                which: "lex"
	              },
	              axis_x: {
	                use: "property",
	                which: "geo.name"
	              },
	              color: {
	                use: "property",
	                which: "geo.world_4region"
	              }
	            }
	          },
	          ui: {
	            chart: {
	              labels: {
	                dragging: true
	              }
	            },
	            presentation: true
	          }
	        }
	      });
	
	      //d3.svg.collisionResolver
	
	      function collisionResolver() {
	        return function collision_resolver() {
	          var DURATION = 300;
	          var labelHeight = {};
	          var labelPosition = {};
	          // MAINN FUNCTION. RUN COLLISION RESOLVER ON A GROUP g
	          function resolver(g) {
	            if(data == null) {
	              console.warn(
	                'D3 collision resolver stopped: missing data to work with. Example: data = {asi: {valueY: 45, valueX: 87}, ame: {valueY: 987, valueX: 767}}'
	              );
	              return;
	            }
	            if(selector == null) {
	              console.warn('D3 collision resolver stopped: missing a CSS slector');
	              return;
	            }
	            if(height == null) {
	              console.warn('D3 collision resolver stopped: missing height of the canvas');
	              return;
	            }
	            if(value == null) {
	              console.warn(
	                'D3 collision resolver stopped: missing pointer within data objects. Example: value = \'valueY\' ');
	              return;
	            }
	            if(KEY == null) {
	              console.warn('D3 collision resolver stopped: missing a key for data. Example: key = \'geo\' ');
	              return;
	            }
	            g.each(function(d, index) {
	              labelHeight[d[KEY]] = d3.select(this).select(selector)[0][0].getBBox().height;
	            });
	            labelPosition = resolver.calculatePositions(data, value, height, scale);
	            //actually reposition the labels
	            g.each(function(d, i) {
	              if(data[d[KEY]][fixed])
	                return;
	              var resolvedY = labelPosition[d[KEY]] || scale(data[d[KEY]][value]) || 0;
	              var resolvedX = null;
	              if(handleResult != null) {
	                handleResult(d, i, this, resolvedX, resolvedY);
	                return;
	              }
	              d3.select(this).selectAll(selector).transition().duration(DURATION).attr('transform', 'translate(0,' +
	                resolvedY + ')');
	            });
	          }
	
	          // CALCULATE OPTIMIZED POSITIONS BASED ON LABELS' HEIGHT AND THEIR PROXIMITY (DELTA)
	          resolver.calculatePositions = function(data, value, height, scale) {
	            var result = {};
	            var keys = Object.keys(data).sort(function(a, b) {
	              return data[a][value] - data[b][value];
	            });
	            keys.forEach(function(d, index) {
	              //initial positioning
	              result[d] = scale(data[d][value]);
	              // check the overlapping chain reaction all the way down
	              for(var j = index; j > 0; j--) {
	                // if overlap found shift the overlapped label downwards
	                var delta = result[keys[j - 1]] - result[keys[j]] - labelHeight[keys[j]];
	                if(delta < 0)
	                  result[keys[j - 1]] -= delta;
	                // if the chain reaction stopped because found some gap in the middle, then quit
	                if(delta > 0)
	                  break;
	              }
	            });
	            // check if the lowest label is breaking the boundary...
	            var delta = height - result[keys[0]] - labelHeight[keys[0]];
	            // if it does, then
	            if(delta < 0) {
	              // shift the lowest up
	              result[keys[0]] += delta;
	              // check the overlapping chain reaction all the way up
	              for(var j = 0; j < keys.length - 1; j++) {
	                // if overlap found shift the overlapped label upwards
	                var delta = result[keys[j]] - result[keys[j + 1]] - labelHeight[keys[j + 1]];
	                if(delta < 0)
	                  result[keys[j + 1]] += delta;
	                // if the chain reaction stopped because found some gap in the middle, then quit
	                if(delta > 0)
	                  break;
	              }
	            }
	            return result;
	          };
	          // GETTERS AND SETTERS
	          var data = null;
	          resolver.data = function(arg) {
	            if(!arguments.length)
	              return data;
	            data = arg;
	            return resolver;
	          };
	          var selector = null;
	          resolver.selector = function(arg) {
	            if(!arguments.length)
	              return selector;
	            selector = arg;
	            return resolver;
	          };
	          var height = null;
	          resolver.height = function(arg) {
	            if(!arguments.length)
	              return height;
	            height = arg;
	            return resolver;
	          };
	          var scale = d3.scale.linear().domain([
	            0,
	            1
	          ]).range([
	            0,
	            1
	          ]);
	          resolver.scale = function(arg) {
	            if(!arguments.length)
	              return scale;
	            scale = arg;
	            return resolver;
	          };
	          var value = null;
	          resolver.value = function(arg) {
	            if(!arguments.length)
	              return value;
	            value = arg;
	            return resolver;
	          };
	          var fixed = null;
	          resolver.fixed = function(arg) {
	            if(!arguments.length)
	              return fixed;
	            fixed = arg;
	            return resolver;
	          };
	          var handleResult = null;
	          resolver.handleResult = function(arg) {
	            if(!arguments.length)
	              return handleResult;
	            handleResult = arg;
	            return resolver;
	          };
	          var KEY = null;
	          resolver.KEY = function(arg) {
	            if(!arguments.length)
	              return KEY;
	            KEY = arg;
	            return resolver;
	          };
	          return resolver;
	        }();
	      };
	
	      //LINE CHART COMPONENT
	      var LCComponent = Component.extend({
	
	        init: function(config, context) {
	          var _this = this;
	          this.name = 'linechart';
	          this.template = 'linechart.html';
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	
	          this.model_binds = {
	            'change:time.value': function() {
	              if(!_this._readyOnce) return;
	              _this.updateTime();
	              _this.redrawDataPoints();
	            },
	            'change:time.playing': function() {
	              // hide tooltip on touch devices when playing
	              if (_this.model.time.playing && isTouchDevice() && !_this.tooltip.classed("vzb-hidden")) _this.tooltip.classed("vzb-hidden", true);
	            },
	            'change:time.start': function() {
	              if(!_this._readyOnce) return;
	              _this.updateShow();
	            },
	            'change:time.end': function() {
	              if(!_this._readyOnce) return;
	              _this.updateShow();
	            },
	            'change:marker': function(evt, path) {
	              if(!_this._readyOnce) return;
	              if(path.indexOf("domainMin") > -1 || path.indexOf("domainMax") > -1 || 
	                path.indexOf("zoomedMin") > -1 || path.indexOf("zoomedMax") > -1) {
	                if(!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress
	                _this.zoomToMaxMin();
	                _this.updateShow();
	                _this.updateSize();
	                _this.updateTime();
	                _this.redrawDataPoints();
	                return; 
	              }
	              if(path.indexOf("which") > -1 || path.indexOf("use") > -1) return;
	              _this.ready();
	            },
	            "change:entities.highlight": function() {
	              if(!_this._readyOnce) return;
	              _this.highlightLines();
	            },
	            "change:entities.select": function() {
	              if(!_this._readyOnce) return;
	              _this.highlightLines();
	            },
	            'change:entities.opacitySelectDim': function() {
	              if(!_this._readyOnce) return;
	              _this.highlightLines();
	            },
	            'change:entities.opacityRegular': function() {
	              if(!_this._readyOnce) return;
	              _this.highlightLines();
	            }
	          };
	
	          this._super(config, context);
	
	          this.xScale = null;
	          this.yScale = null;
	
	          this.rangeXRatio = 1;
	          this.rangeXShift = 0;
	
	          this.rangeYRatio = 1;
	          this.rangeYShift = 0;
	
	          this.xAxis = axisSmart().orient("bottom");
	          this.yAxis = axisSmart().orient("left");
	
	          this.isDataPreprocessed = false;
	          this.timeUpdatedOnce = false;
	          this.sizeUpdatedOnce = false;
	
	          this.getNearestKey = memoize(this.getNearestKey);
	        },
	
	        /*
	         * domReady:
	         * Executed after template is loaded
	         * Ideally, it contains instantiations related to template
	         */
	        readyOnce: function() {
	          var _this = this;
	
	          this.element = d3.select(this.element);
	          this.graph = this.element.select('.vzb-lc-graph');
	          
	          this.yAxisElContainer = this.graph.select('.vzb-lc-axis-y');
	          this.yAxisEl = this.yAxisElContainer.select('g');
	
	          this.xAxisElContainer = this.graph.select('.vzb-lc-axis-x');
	          this.xAxisEl = this.xAxisElContainer.select('g');
	
	          this.xTitleEl = this.graph.select('.vzb-lc-axis-x-title');
	          this.yTitleEl = this.graph.select('.vzb-lc-axis-y-title');
	          this.yInfoEl = this.graph.select('.vzb-lc-axis-y-info');
	          this.xValueEl = this.graph.select('.vzb-lc-axis-x-value');
	          this.yValueEl = this.graph.select('.vzb-lc-axis-y-value');
	          this.linesContainerCrop = this.graph.select('.vzb-lc-lines-crop');
	          this.linesContainer = this.graph.select('.vzb-lc-lines');
	          this.labelsContainerCrop = this.graph.select('.vzb-lc-labels-crop');
	          this.labelsContainer = this.graph.select('.vzb-lc-labels');
	          
	          this.verticalNow = this.labelsContainer.select(".vzb-lc-vertical-now");
	          this.tooltip = this.element.select('.vzb-tooltip');
	          //            this.filterDropshadowEl = this.element.select('#vzb-lc-filter-dropshadow');
	          this.projectionX = this.graph.select(".vzb-lc-projection-x");
	          this.projectionY = this.graph.select(".vzb-lc-projection-y");
	
	          this.entityLines = null;
	          this.entityLabels = null;
	          this.totalLength_1 = {};
	
	          this.KEY = this.model.entities.getDimension();
	
	          //component events
	
	          setIcon(this.yInfoEl, iconQuestion)
	            .select("svg").attr("width", "0px").attr("height", "0px");
	
	          this.yInfoEl.on("click", function() {
	            _this.parent.findChildByName("gapminder-datanotes").pin();
	          });
	          this.yInfoEl.on("mouseover", function() {
	            var rect = this.getBBox();
	            var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	            _this.parent.findChildByName("gapminder-datanotes").setHook('axis_y').show().setPos(coord.x, coord.y);
	          });
	          this.yInfoEl.on("mouseout", function() {
	            _this.parent.findChildByName("gapminder-datanotes").hide();
	          });
	
	
	          this.on("resize", function() {
	            //return if updatesize exists with error
	            if(_this.updateSize()) return;
	            _this.updateTime();
	            _this.redrawDataPoints();
	          });
	        },
	
	        ready: function() {
	          this.updateUIStrings();
	          var _this = this;
	            
	          //null means we need to calculate all frames before we get to the callback
	          this.model.marker.getFrame(null, function(allValues) {
	            _this.all_values = allValues;
	            _this.model.marker.getFrame(_this.model.time.value, function(values) {
	              _this.values = values;
	              _this.all_steps = _this.model.time.getAllSteps();
	              _this.updateShow();
	              _this.updateTime();
	              _this.updateSize();
	              _this.zoomToMaxMin();
	              _this.redrawDataPoints();
	              _this.linesContainerCrop
	                .on('mousemove', _this.entityMousemove.bind(_this, null, null, _this))
	                .on('mouseleave', _this.entityMouseout.bind(_this, null, null, _this));
	              
	            });
	          });
	        },
	
	        updateUIStrings: function() {
	          var _this = this;
	          this.translator = this.model.language.getTFunction();
	
	          this.strings = {
	            title: {
	              Y: this.translator("indicator/" + this.model.marker.axis_y.which),
	              X: this.translator("indicator/" + this.model.marker.axis_x.which),
	              C: this.translator("indicator/" + this.model.marker.color.which)
	            },
	            unit: {
	              Y: this.translator("unit/" + this.model.marker.axis_y.which),
	              X: this.translator("unit/" + this.model.marker.axis_x.which),
	              C: this.translator("unit/" + this.model.marker.color.which)
	            }
	          };
	
	          if(this.strings.unit.Y === "unit/" + this.model.marker.axis_y.which) this.strings.unit.Y = "";
	          if(this.strings.unit.X === "unit/" + this.model.marker.axis_x.which) this.strings.unit.X = "";
	          if(this.strings.unit.C === "unit/" + this.model.marker.color.which) this.strings.unit.C = "";
	
	          if(!!this.strings.unit.Y) this.strings.unit.Y = ", " + this.strings.unit.Y;
	          if(!!this.strings.unit.X) this.strings.unit.X = ", " + this.strings.unit.X;
	          if(!!this.strings.unit.C) this.strings.unit.C = ", " + this.strings.unit.C;
	
	          var xTitle = this.xTitleEl.selectAll("text").data([0]);
	          xTitle.enter().append("text");
	
	          var yTitle = this.yTitleEl.selectAll("text").data([0]);
	          yTitle.enter().append("text");
	          yTitle
	            .on("click", function() {
	              _this.parent
	                .findChildByName("gapminder-treemenu")
	                .markerID("axis_y")
	                .alignX("left")
	                .alignY("top")
	                .updateView()
	                .toggle();
	            });
	          
	        },
	
	        /*
	         * UPDATE SHOW:
	         * Ideally should only update when show parameters change or data changes
	         */
	        updateShow: function() {
	          var _this = this;
	          var KEY = this.KEY;
	
	          this.cached = {};
	
	          //scales
	          this.yScale = this.model.marker.axis_y.getScale();
	          this.xScale = this.model.marker.axis_x.getScale();
	          this.cScale = this.model.marker.color.getScale();
	          this.yAxis.tickSize(6, 0)
	            .tickFormat(this.model.marker.axis_y.getTickFormatter());
	          this.xAxis.tickSize(6, 0)
	            .tickFormat(this.model.marker.axis_x.getTickFormatter());
	
	          this.collisionResolver = collisionResolver()
	            .selector(".vzb-lc-label")
	            .value("valueY")
	            .scale(this.yScale)
	            .KEY(KEY);
	
	          //line template
	          this.line = d3.svg.line()
	            //see https://bl.ocks.org/mbostock/4342190
	            //"monotone" can also work. "basis" would skip the points on the sharp turns. "linear" is ugly
	            .interpolate("cardinal") 
	            .x(function(d) {
	              return _this.xScale(d[0]);
	            })
	            .y(function(d) {
	              return _this.yScale(d[1]);
	            });
	        },
	
	
	        /*
	         * UPDATE TIME:
	         * Ideally should only update when time or data changes
	         */
	        updateTime: function() {
	          var _this = this;
	          var KEY = this.KEY;
	          var time_1 = (this.time === null) ? this.model.time.value : this.time;
	          this.time = this.model.time.value;
	          this.duration = this.model.time.playing && (this.time - time_1 > 0) ? this.model.time.delayAnimations : 0;
	
	          var timeDim = this.model.time.getDimension();
	          var filter = {};
	
	          filter[timeDim] = this.time;
	
	          this.data = this.model.marker.getKeys();
	          this.prev_steps = this.all_steps.filter(function(f){return f < _this.time;});
	
	          this.entityLines = this.linesContainer.selectAll('.vzb-lc-entity').data(this.data);
	          this.entityLabels = this.labelsContainer.selectAll('.vzb-lc-entity').data(this.data);
	
	          this.timeUpdatedOnce = true;
	
	        },
	
	
	
	        profiles: {
	          "small": {
	            margin: {
	              top: 30,
	              right: 20,
	              left: 55,
	              bottom: 30
	            },
	            infoElHeight: 16,
	            yAxisTitleBottomMargin: 6,
	            tick_spacing: 60,
	            text_padding: 8,
	            lollipopRadius: 6,
	            limitMaxTickNumberX: 5
	          },
	          "medium": {
	            margin: {
	              top: 40,
	              right: 60,
	              left: 65,
	              bottom: 40
	            },
	            infoElHeight: 20,
	            yAxisTitleBottomMargin: 6,
	            tick_spacing: 80,
	            text_padding: 12,
	            lollipopRadius: 7,
	            limitMaxTickNumberX: 10
	          },
	          "large": {
	            margin: {
	              top: 50,
	              right: 60,
	              left: 70,
	              bottom: 50
	            },
	            infoElHeight: 22,
	            yAxisTitleBottomMargin: 6,
	            tick_spacing: 100,
	            text_padding: 20,
	            lollipopRadius: 9,
	            limitMaxTickNumberX: 0 // unlimited
	          }
	        },
	        presentationProfileChanges: {
	          "medium": {
	            margin: { top: 80, bottom: 80, left: 100 },
	            yAxisTitleBottomMargin: 20,
	            xAxisTitleBottomMargin: 20,
	            infoElHeight: 26,
	          },
	          "large": {
	            margin: { top: 80, bottom: 100, left: 100 },
	            yAxisTitleBottomMargin: 20,
	            xAxisTitleBottomMargin: 20,
	            infoElHeight: 32,
	            hideSTitle: true
	          }
	        },
	
	        timeSliderProfiles: {
	          small: {
	            margin: {
	              top: 9,
	              right: 15,
	              bottom: 10,
	              left: 10
	            }
	          },
	          medium: {
	            margin: {
	              top: 9,
	              right: 15,
	              bottom: 10,
	              left: 20
	            }
	          },
	          large: {
	            margin: {
	              top: 9,
	              right: 15,
	              bottom: 10,
	              left: 25
	            }
	          }
	        },
	
	        /*
	         * RESIZE:
	         * Executed whenever the container is resized
	         * Ideally, it contains only operations related to size
	         */
	        updateSize: function() {
	
	          var _this = this;
	          var values = this.values;
	          var KEY = this.KEY;
	
	          var padding = 2;
	
	          this.activeProfile = this.getActiveProfile(this.profiles, this.presentationProfileChanges);
	          this.margin = this.activeProfile.margin;
	          this.tick_spacing = this.activeProfile.tick_spacing;
	          
	          var infoElHeight = this.activeProfile.infoElHeight;
	
	          //adjust right this.margin according to biggest label
	          var lineLabelsText = this.model.marker.getKeys().map(function(d, i) {
	            return values.label[d[KEY]];
	          });
	
	          var longestLabelWidth = 0;
	          var lineLabelsView = this.linesContainer.selectAll(".samplingView").data(lineLabelsText);
	
	          lineLabelsView
	            .enter().append("text")
	            .attr("class", "samplingView vzb-lc-labelname")
	            .style("opacity", 0)
	            .text(function(d) {
	              return(d.length < 13) ? d : d.substring(0, 10) + '...';
	            })
	            .each(function(d) {
	              if(longestLabelWidth > this.getComputedTextLength()) {
	                return;
	              }
	              longestLabelWidth = this.getComputedTextLength();
	            })
	            .remove();
	
	          this.margin.right = Math.max(this.margin.right, longestLabelWidth + this.activeProfile.text_padding + 20);
	
	
	          //stage
	          this.height = (parseInt(this.element.style("height"), 10) - this.margin.top - this.margin.bottom) || 0;
	          this.width = (parseInt(this.element.style("width"), 10) - this.margin.left - this.margin.right) || 0;
	          this.linesContainerCrop
	            .attr("width", this.width)
	            .attr("height", Math.max(0, this.height));
	
	          this.labelsContainerCrop
	            .attr("width", this.width + this.margin.right)
	            .attr("height", Math.max(0, this.height));
	
	          if(this.height<=0 || this.width<=0) return warn("Line chart updateSize() abort: vizabi container is too little or has display:none");
	
	          this.collisionResolver.height(this.height);
	
	          this.graph
	            .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
	
	
	          if(this.model.marker.axis_y.scaleType !== "ordinal") {
	            this.yScale.range([this.height * this.rangeYRatio + this.rangeYShift, this.rangeYShift]);
	          } else {
	            this.yScale.rangePoints([this.height * this.rangeYRatio + this.rangeYShift, this.rangeYShift], padding).range();
	          }
	          if(this.model.marker.axis_x.scaleType !== "ordinal") {
	            this.xScale.range([this.rangeXShift, this.width * this.rangeXRatio + this.rangeXShift]);
	          } else {
	            this.xScale.rangePoints([[this.rangeXShift, this.width * this.rangeXRatio + this.rangeXShift]], padding).range();
	          }
	
	
	          this.yAxis.scale(this.yScale)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_y.scaleType,
	              timeFormat: this.model.time.timeFormat,
	              toolMargin: {top: 5, bottom: 5, left: this.margin.left, right: this.margin.right},
	              limitMaxTickNumber: 6,
	              formatter: this.model.marker.axis_y.getTickFormatter()
	                //showOuter: true
	            });
	
	          this.xAxis.scale(this.xScale)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_x.scaleType,
	              limitMaxTickNumber: this.activeProfile.limitMaxTickNumberX,
	              toolMargin: {left: 5, right: 5, top: this.margin.top, bottom: this.margin.bottom},
	              formatter: this.model.marker.axis_x.getTickFormatter()
	              //showOuter: true
	            });
	
	          this.xAxisElContainer
	            .attr("width", this.width + 1)
	            .attr("height", this.activeProfile.margin.bottom)
	            .attr("y", this.height - 1)
	            .attr("x", -1);
	          this.xAxisEl
	            .attr("transform", "translate(1,1)");
	
	          this.yAxisElContainer
	            .attr("width", this.activeProfile.margin.left)
	            .attr("height", Math.max(0, this.height))
	            .attr("x", -this.activeProfile.margin.left);
	          this.yAxisEl
	            .attr("transform", "translate(" + (this.activeProfile.margin.left - 1) + "," + 0 + ")");
	          
	          this.yAxisEl.call(this.yAxis);
	          this.xAxisEl.call(this.xAxis);
	
	          this.xValueEl.attr("transform", "translate(0," + this.height + ")")
	            .attr("y", this.xAxis.tickPadding() + this.xAxis.tickSize());
	
	          var yaxisWidth = this.yAxisElContainer.select("g").node().getBBox().width;
	
	          this.yTitleEl
	            .style("font-size", infoElHeight + "px")
	            .attr("transform", "translate(" + (-yaxisWidth) + ", -" + this.activeProfile.yAxisTitleBottomMargin + ")");
	
	          var yTitleText = this.yTitleEl.select("text").text(this.strings.title.Y + this.strings.unit.Y);
	          if(yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title.Y);
	
	          if(this.yInfoEl.select('svg').node()) {
	            var titleBBox = this.yTitleEl.node().getBBox();
	            var translate = d3.transform(this.yTitleEl.attr('transform')).translate;
	
	            this.yInfoEl.select('svg')
	              .attr("width", infoElHeight + "px")
	              .attr("height", infoElHeight + "px")
	            this.yInfoEl.attr('transform', 'translate('
	              + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	              + (translate[1] - infoElHeight * 0.8) + ')');
	          }
	          
	          
	          this.xTitleEl
	            .style("font-size", infoElHeight + "px")
	            .attr("transform", "translate(" + this.width + "," + this.height + ")");
	
	          var xTitleText = this.xTitleEl.select("text").text(this.strings.title.X + this.strings.unit.X);
	          if(xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title.X);
	
	          // adjust the vertical dashed line
	          this.verticalNow.attr("y1", this.yScale.range()[0]).attr("y2", this.yScale.range()[1])
	            .attr("x1", 0).attr("x2", 0);
	          this.projectionX.attr("y1", _this.yScale.range()[0]);
	          this.projectionY.attr("x2", _this.xScale.range()[0]);
	
	          if(isTouchDevice()) {
	            _this.tooltip.classed("vzb-hidden", true);
	            _this.verticalNow.style("opacity", 1);
	            _this.projectionX.style("opacity", 0);
	            _this.projectionY.style("opacity", 0);
	            _this.xAxisEl.call(_this.xAxis.highlightValue(_this.time));
	            _this.yAxisEl.call(_this.yAxis.highlightValue("none"));
	            _this.graph.selectAll(".vzb-lc-entity").each(function() {
	              d3.select(this).classed("vzb-dimmed", false).classed("vzb-hovered", false);
	            });
	
	            _this.hoveringNow = null;
	          }
	
	          var opts = {
	            rangeMax: this.xScale.range()[1],
	            mRight: this.margin.right,
	            profile: this.timeSliderProfiles[this.getLayoutProfile()]
	          };
	          this.parent.trigger('myEvent', opts);
	
	          this.sizeUpdatedOnce = true;
	        },
	
	        /*
	         * REDRAW DATA POINTS:
	         * Here plotting happens
	         */
	        redrawDataPoints: function() {
	          var _this = this;
	          var KEY = this.KEY;
	      //    var values = this.values;
	
	          this.model.marker.getFrame(this.time, function(values, time) {
	
	            if(!_this.timeUpdatedOnce) {
	              _this.updateTime();
	            }
	
	            if(!_this.sizeUpdatedOnce) {
	              _this.updateSize();
	            }    
	            
	            _this.entityLabels.exit().remove();
	            _this.entityLines.exit().remove();
	
	            _this.entityLines.enter().append("g")
	              .attr("class", "vzb-lc-entity")
	              .each(function(d, index) {
	                var entity = d3.select(this);
	
	                entity.append("path")
	                  .attr("class", "vzb-lc-line-shadow")
	                  .attr("transform", "translate(0,2)");
	
	                entity.append("path")
	                  .attr("class", "vzb-lc-line");
	
	              });
	
	            _this.entityLabels.enter().append("g")
	              .attr("class", "vzb-lc-entity")
	              .each(function(d, index) {
	                var entity = d3.select(this);
	                var label = values.label[d[KEY]];
	
	                entity.append("circle")
	                  .attr("class", "vzb-lc-circle")
	                  .attr("cx", 0);
	
	                var labelGroup = entity.append("g").attr("class", "vzb-lc-label");
	
	                labelGroup.append("text")
	                  .attr("class", "vzb-lc-labelname")
	                  .attr("dy", ".35em");
	
	                labelGroup.append("text")
	                  .attr("class", "vzb-lc-label-value")
	                  .attr("dy", "1.6em");
	              });
	                  
	            _this.entityLines
	              .each(function(d, index) {
	                var entity = d3.select(this);
	                var label = values.label[d[KEY]];
	
	                var color = _this.cScale(values.color[d[KEY]]);
	                var colorShadow = _this.model.marker.color.which == "geo.world_4region"?
	                    _this.model.marker.color.getColorShade({
	                      colorID: values.color[d[KEY]],
	                      shadeID: "shade"
	                    })
	                    :
	                    d3.rgb(color).darker(0.5).toString();
	
	                //TODO: optimization is possible if getValues would return both x and time
	                //TODO: optimization is possible if getValues would return a limited number of points, say 1 point per screen pixel
	                var xy = _this.prev_steps.map(function(frame, i) {
	                        return [+frame,  _this.all_values[frame] ? +_this.all_values[frame].axis_y[d[KEY]] : null] ;
	                    })
	                    .filter(function(d) { return d[1] || d[1] === 0; });
	                xy.push([+time, +values.axis_y[d[KEY]]]);
	                _this.cached[d[KEY]] = {
	                  valueY: xy[xy.length - 1][1]
	                };
	
	
	                // the following fixes the ugly line butts sticking out of the axis line
	                //if(x[0]!=null && x[1]!=null) xy.splice(1, 0, [(+x[0]*0.99+x[1]*0.01), y[0]]);
	                var path2 = entity.select(".vzb-lc-line");
	
	                if(_this.model.time.playing && _this.totalLength_1[d[KEY]] === null) {
	                  _this.totalLength_1[d[KEY]] = path2.node().getTotalLength();
	                }
	
	                var path1 = entity.select(".vzb-lc-line-shadow")
	                  .style("stroke", colorShadow)
	                  .attr("d", _this.line(xy));
	                path2
	                  //.style("filter", "none")
	                  .style("stroke", color)
	                  .attr("d", _this.line(xy));
	
	                var totalLength = path2.node().getTotalLength();
	
	                // this section ensures the smooth transition while playing and not needed otherwise
	                if(_this.model.time.playing) {
	
	                  path1
	                    .interrupt()
	                    .attr("stroke-dasharray", totalLength)
	                    .attr("stroke-dashoffset", totalLength - _this.totalLength_1[d[KEY]])
	                    .transition()
	                    .delay(0)
	                    .duration(_this.duration)
	                    .ease("linear")
	                    .attr("stroke-dashoffset", 0);
	                  path2
	                    .interrupt()
	                    .attr("stroke-dasharray", totalLength)
	                    .attr("stroke-dashoffset", totalLength - _this.totalLength_1[d[KEY]])
	                    .transition()
	                    .delay(0)
	                    .duration(_this.duration)
	                    .ease("linear")
	                    .attr("stroke-dashoffset", 0);
	
	                  _this.totalLength_1[d[KEY]] = totalLength;
	                } else {
	                  //reset saved line lengths
	                  _this.totalLength_1[d[KEY]] = null;
	
	                  path1
	                    .attr("stroke-dasharray", "none")
	                    .attr("stroke-dashoffset", "none");
	
	                  path2
	                    .attr("stroke-dasharray", "none")
	                    .attr("stroke-dashoffset", "none");
	                }
	
	              });
	
	            _this.entityLabels
	              .each(function(d, index) {
	                var entity = d3.select(this);
	                var label = values.label[d[KEY]];
	
	                var color = _this.cScale(values.color[d[KEY]]);
	                var colorShadow = _this.model.marker.color.which == "geo.world_4region"?
	                    _this.model.marker.color.getColorShade({
	                      colorID: values.color[d[KEY]],
	                      shadeID: "shade"
	                    })
	                    :
	                    d3.rgb(color).darker(0.5).toString();
	
	
	                entity.select(".vzb-lc-circle")
	                  .style("fill", color)
	                  .transition()
	                  .duration(_this.duration)
	                  .ease("linear")
	                  .attr("r", _this.activeProfile.lollipopRadius)
	                  .attr("cy", _this.yScale(_this.cached[d[KEY]].valueY) + 1);
	
	
	                entity.select(".vzb-lc-label")
	                  .transition()
	                  .duration(_this.duration)
	                  .ease("linear")
	                  .attr("transform", "translate(0," + _this.yScale(_this.cached[d[KEY]].valueY) + ")");
	
	
	                var value = _this.yAxis.tickFormat()(_this.cached[d[KEY]].valueY);
	                var name = label.length < 13 ? label : label.substring(0, 10) + '...';
	                var valueHideLimit = _this.ui.chart.labels.min_number_of_entities_when_values_hide;
	
	                var t = entity.select(".vzb-lc-labelname")
	                  .style("fill", colorShadow)
	                  .attr("dx", _this.activeProfile.text_padding)
	                  .text(name + " " + (_this.data.length < valueHideLimit ? value : ""));
	
	                entity.select(".vzb-lc-label-value")
	                  .style("fill", colorShadow)
	                  .attr("dx", _this.activeProfile.text_padding)
	                  .text("");
	
	                if(_this.data.length < valueHideLimit) {
	
	                  var size = _this.xScale(_this.time) + t[0][0].getComputedTextLength() + _this.activeProfile.text_padding;
	                  var width = _this.width + _this.margin.right;
	
	                  if(size > width) {
	                    entity.select(".vzb-lc-labelname").text(name);
	                    entity.select(".vzb-lc-label-value").text(value);
	                  }
	                }
	              });
	            _this.labelsContainer
	              .transition()
	              .duration(_this.duration)
	              .ease("linear")
	              .attr("transform", "translate(" + _this.xScale(d3.min([_this.model.marker.axis_x.zoomedMax, _this.time])) + ",0)");
	
	
	              
	
	            if(!_this.hoveringNow && _this.time - _this.model.time.start !== 0) {
	              if (!_this.ui.chart.hideXAxisValue) _this.xAxisEl.call(
	                 _this.xAxis.highlightValue(time).highlightTransDuration(_this.duration)
	              );
	              _this.verticalNow.style("opacity", 1);
	            }else{
	              _this.verticalNow.style("opacity", 0);
	            }
	
	            // Call flush() after any zero-duration transitions to synchronously flush the timer queue
	            // and thus make transition instantaneous. See https://github.com/mbostock/d3/issues/1951
	            if(_this.duration == 0) {
	              d3.timer.flush();
	            }
	
	            // cancel previously queued simulation if we just ordered a new one
	            // then order a new collision resolving
	            clearTimeout(_this.collisionTimeout);
	            _this.collisionTimeout = setTimeout(function() {
	              _this.entityLabels.call(_this.collisionResolver.data(_this.cached));
	            }, _this.model.time.delayAnimations * 1.5);
	          
	          });  
	        },
	
	        entityMousemove: function(me, index, context, closestToMouse) {
	          var _this = context;
	          var KEY = _this.KEY;
	          var values = _this.values;
	
	          var mouse = d3.mouse(_this.element.node()).map(function(d) {
	            return parseInt(d);
	          });
	
	          var resolvedTime = _this.xScale.invert(mouse[0] - _this.margin.left);
	          if(_this.time - resolvedTime < 0) {
	            resolvedTime = _this.time;
	          } else if(resolvedTime < this.model.time['start']) {
	            resolvedTime = this.model.time['start'];
	          }
	          var resolvedValue;
	          var timeDim = _this.model.time.getDimension();
	          
	          var mousePos = mouse[1] - _this.margin.bottom;
	
	          if(!isDate(resolvedTime)) resolvedTime = this.model.time.timeFormat.parse(resolvedTime);
	            
	          this.model.marker.getFrame(resolvedTime, function(data) {
	            var nearestKey = _this.getNearestKey(mousePos, data.axis_y, _this.yScale.bind(_this));
	          resolvedValue = data.axis_y[nearestKey];
	          if(!me) me = {};
	          me[KEY] = nearestKey;
	          if (!_this.model.entities.isHighlighted(me)) {
	            _this.model.entities.clearHighlighted();
	            _this.model.entities.highlightEntity(me);
	          }
	          _this.hoveringNow = me;
	
	          if(isNaN$1(resolvedValue)) return;
	
	          var scaledTime = _this.xScale(resolvedTime);
	          var scaledValue = _this.yScale(resolvedValue);
	
	          if(_this.ui.chart.whenHovering.showTooltip) {
	            //position tooltip
	            _this.tooltip
	              //.style("right", (_this.width - scaledTime + _this.margin.right ) + "px")
	              .style("left", (scaledTime + _this.margin.left) + "px")
	              .style("bottom", (_this.height - scaledValue + _this.margin.bottom) + "px")
	              .text(_this.yAxis.tickFormat()(resolvedValue))
	              .classed("vzb-hidden", false);
	          }
	
	          // bring the projection lines to the hovering point
	          if(_this.ui.chart.whenHovering.hideVerticalNow) {
	            _this.verticalNow.style("opacity", 0);
	          }
	
	          if(_this.ui.chart.whenHovering.showProjectionLineX) {
	            _this.projectionX
	              .style("opacity", 1)
	              .attr("y2", scaledValue)
	              .attr("x1", scaledTime)
	              .attr("x2", scaledTime);
	          }
	          if(_this.ui.chart.whenHovering.showProjectionLineY) {
	            _this.projectionY
	              .style("opacity", 1)
	              .attr("y1", scaledValue)
	              .attr("y2", scaledValue)
	              .attr("x1", scaledTime);
	          }
	
	          if(_this.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(
	            _this.xAxis.highlightValue(resolvedTime).highlightTransDuration(0)
	          );
	
	          if(_this.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(
	            _this.yAxis.highlightValue(resolvedValue).highlightTransDuration(0)
	          );
	
	          clearTimeout(_this.unhoverTimeout);
	
	          });
	        },
	
	        entityMouseout: function(me, index, context) {
	          var _this = context;
	          if(d3.event.relatedTarget && d3.select(d3.event.relatedTarget).classed('vzb-tooltip')) return;
	
	          // hide and show things like it was before hovering
	          _this.unhoverTimeout = setTimeout(function() {
	            _this.tooltip.classed("vzb-hidden", true);
	            _this.verticalNow.style("opacity", 1);
	            _this.projectionX.style("opacity", 0);
	            _this.projectionY.style("opacity", 0);
	            _this.xAxisEl.call(_this.xAxis.highlightValue(_this.time));
	            _this.yAxisEl.call(_this.yAxis.highlightValue("none"));
	
	            _this.model.entities.clearHighlighted();
	            
	            _this.hoveringNow = null;
	          }, 300);
	
	        },
	
	        /*
	         * Highlights all hovered lines
	         */
	        highlightLines: function() {
	          var _this = this;
	
	          var OPACITY_HIGHLT = 1.0;
	          var OPACITY_HIGHLT_DIM = .3;
	          var OPACITY_SELECT = this.model.entities.opacityRegular;
	          var OPACITY_REGULAR = this.model.entities.opacityRegular;
	          var OPACITY_SELECT_DIM = this.model.entities.opacitySelectDim;
	
	          var someHighlighted = (this.model.entities.highlight.length > 0);
	          var someSelected = (this.model.entities.select.length > 0); 
	          this.graph.selectAll(".vzb-lc-entity").each(function() {
	            d3.select(this)
	              .style("opacity", function(d) {
	                if (_this.model.entities.isHighlighted(d)) return OPACITY_HIGHLT;
	                if(someSelected) {
	                  return _this.model.entities.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
	                }
	                if(someHighlighted) return OPACITY_HIGHLT_DIM;
	                return OPACITY_REGULAR;            
	              });
	          });
	
	        },
	
	        zoomToMaxMin: function() {
	          var _this = this;
	          // 
	          if(this.model.marker.axis_y.zoomedMin == null ) this.model.marker.axis_y.zoomedMin = this.yScale.domain()[0];
	          if(this.model.marker.axis_y.zoomedMin == null ) this.model.marker.axis_y.zoomedMin = this.yScale.domain()[1];
	
	
	          if(
	            this.model.marker.axis_x.zoomedMin != null && 
	            this.model.marker.axis_x.zoomedMax != null) {
	
	            var x1 = this.xScale(this.model.marker.axis_x.zoomedMin);
	            var x2 = this.xScale(this.model.marker.axis_x.zoomedMax);
	
	            this.rangeXRatio = this.width / (x2 - x1) * this.rangeXRatio;
	            this.rangeXShift = (this.rangeXShift - x1) / (x2 - x1) * this.width;
	
	            this.xScale.range([this.rangeXShift, this.width*this.rangeXRatio + this.rangeXShift]);
	            this.xAxisEl.call(this.xAxis);
	          } 
	          if (
	            this.model.marker.axis_y.zoomedMin != null &&
	            this.model.marker.axis_y.zoomedMax != null) {
	
	            var y1 = this.yScale(this.model.marker.axis_y.zoomedMin);
	            var y2 = this.yScale(this.model.marker.axis_y.zoomedMax);
	
	            this.rangeYRatio = this.height / (y1 - y2) * this.rangeYRatio;
	            this.rangeYShift = (this.height - y1) / (y1 - y2) * this.rangeYShift;
	
	            this.yScale.range([this.height * this.rangeYRatio + this.rangeYShift, this.rangeYShift]);
	            this.yAxisEl.call(this.yAxis);
	          }
	        },
	        
	        
	        /**
	         * Returns key from obj which value has the smallest difference with val
	         */
	        getNearestKey: function(val, obj, fn) {
	          var keys = Object.keys(obj);
	          var resKey = keys[0];
	          for(var i = 1; i < keys.length; i++) {
	            var key = keys[i];
	            if(Math.abs((fn ? fn(obj[key]) : obj[key]) - val) < Math.abs((fn ? fn(obj[resKey]) : obj[resKey]) - val)) {
	              resKey = key;
	            }
	          }
	          return resKey;
	        }
	
	      });
	
	      //LINE CHART TOOL
	      var LineChart = Tool.extend('LineChart', {
	          /**
	           * Initialized the tool
	           * @param {Object} placeholder Placeholder element for the tool
	           * @param {Object} external_model Model as given by the external page
	           */
	          init: function(placeholder, external_model) {
	
	            this.name = 'linechart';
	
	            this.components = [{
	              component: LCComponent,
	              placeholder: '.vzb-tool-viz',
	              model: ["state.time", "state.entities", "state.marker", "language"] //pass models to component
	            }, {
	              component: TimeSlider,
	              placeholder: '.vzb-tool-timeslider',
	              model: ["state.time", "state.entities", "state.marker"],
	              ui: {show_value_when_drag_play: false, axis_aligned: true}
	            }, {
	              component: Dialogs,
	              placeholder: '.vzb-tool-dialogs',
	              model: ['state', 'ui', 'language']
	            }, {
	              component: ButtonList,
	              placeholder: '.vzb-tool-buttonlist',
	              model: ['state', 'ui', 'language']
	            }, {
	              component: TreeMenu,
	              placeholder: '.vzb-tool-treemenu',
	              model: ['state.marker', 'language']
	            }, {
	              component: DataNotes,
	              placeholder: '.vzb-tool-datanotes',
	              model: ['state.marker', 'language']
	            }];
	
	            this._super(placeholder, external_model);
	          },
	
	          default_model: {
	          state: {
	            time: {
	              start: 1990,
	              end: 2012,
	              value: 2012,
	              step: 1
	            },
	            //entities we want to show
	            entities: {
	              dim: "geo",
	              show: {
	                _defs_: {
	                  "geo": ["*"],
	                  "geo.cat": ["region"]
	                }
	              }
	            },
	            //how we show it
	            marker: {
	              space: ["entities", "time"],
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              axis_y: {
	                use: "indicator",
	                which: "gdp_pc",
	                scaleType: "log"
	              },
	              axis_x: {
	                use: "indicator",
	                which: "time",
	                scaleType: "time"
	              },
	              color: {
	                use: "property",
	                which: "geo.world_4region"
	              }
	            }
	          },
	          ui: {
	            'vzb-tool-line-chart': {
	              labels: {
	                min_number_of_entities_when_values_hide: 10 //values hide when showing 10 entities or more
	              },
	              whenHovering: {
	                hideVerticalNow: true,
	                showProjectionLineX: true,
	                showProjectionLineY: true,
	                higlightValueX: true,
	                higlightValueY: true,
	                showTooltip: true
	              }
	            }
	          }
	        }
	
	        });
	
	      /*!
	       * VIZABI POP BY AGE Component
	       */
	
	
	      //POP BY AGE CHART COMPONENT
	      var PopByAge$1 = Component.extend({
	
	        /**
	         * Initializes the component (Bar Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The config passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function(config, context) {
	          this.name = 'popbyage';
	          this.template = 'popbyage.html';
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "age",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }];
	
	          var _this = this;
	          this.model_binds = {
	            "change:time.value": function(evt) {
	              _this._updateEntities();
	            },
	            "change:entities.show": function(evt) {
	              console.log('Trying to change show');
	            },
	            "change:age.select": function(evt) {
	              _this._selectBars();
	            },
	            "change:marker.color.palette": function (evt) {
	              if (!_this._readyOnce) return;
	              _this._updateEntities();
	            },
	            "change:marker.color.scaleType":function (evt) {
	              if (!_this._readyOnce) return;
	              _this._updateEntities();
	            }
	          };
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.xScale = null;
	          this.yScale = null;
	          this.cScale = null;
	
	          this.xAxis = axisSmart();
	          this.yAxis = axisSmart();
	        },
	
	        /**
	         * DOM is ready
	         */
	        readyOnce: function() {
	
	          this.el = (this.el) ? this.el : d3.select(this.element);
	          this.element = this.el;
	
	          this.graph = this.element.select('.vzb-bc-graph');
	          this.yAxisEl = this.graph.select('.vzb-bc-axis-y');
	          this.xAxisEl = this.graph.select('.vzb-bc-axis-x');
	          this.yTitleEl = this.graph.select('.vzb-bc-axis-y-title');
	          this.bars = this.graph.select('.vzb-bc-bars');
	          this.labels = this.graph.select('.vzb-bc-labels');
	
	          this.title = this.element.select('.vzb-bc-title');
	          this.year = this.element.select('.vzb-bc-year');
	
	          //only allow selecting one at a time
	          this.model.age.selectMultiple(true);
	
	          var _this = this;
	          this.on("resize", function() {
	            _this._updateEntities();
	          });
	        },
	
	        /*
	         * Both model and DOM are ready
	         */
	        ready: function() {
	
	          this.AGEDIM = this.model.age.getDimension();
	          this.TIMEDIM = this.model.time.getDimension();
	
	          this.updateUIStrings();
	          this._updateIndicators();
	          this.resize();
	          this._updateEntities();
	          this._updateEntities();
	        },
	
	        updateUIStrings: function() {
	          this.translator = this.model.language.getTFunction();
	
	          var titleStringY = this.translator("indicator/" + this.model.marker.axis_y.which);
	
	          var yTitle = this.yTitleEl.selectAll("text").data([0]);
	          yTitle.enter().append("text");
	          yTitle
	            .attr("y", "-6px")
	            .attr("x", "-9px")
	            .attr("dx", "-0.72em")
	            .text(titleStringY);
	        },
	
	        /**
	         * Changes labels for indicators
	         */
	        _updateIndicators: function() {
	          var _this = this;
	          this.duration = this.model.time.delayAnimations;
	          this.yScale = this.model.marker.axis_y.getScale();
	          this.xScale = this.model.marker.axis_x.getScale(false);
	          this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());
	          this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());
	        },
	
	        /**
	         * Updates entities
	         */
	        _updateEntities: function() {
	
	          var _this = this;
	          var time = this.model.time;
	          var ageDim = this.AGEDIM;
	          var timeDim = this.TIMEDIM;
	          var duration = (time.playing) ? time.delayAnimations : 0;
	
	          var group_by = this.model.age.grouping || 1;
	          //var group_offset = this.model.marker.group_offset ? Math.abs(this.model.marker.group_offset % group_by) : 0;
	
	          var filter = {};
	          filter[timeDim] = time.value;
	          var markers = this.model.marker.getKeys(ageDim);
	          var values$$ = this.model.marker.getValues(filter, [ageDim]);
	          var domain = this.yScale.domain();
	
	          this.cScale = this.model.marker.color.getScale();
	          this.model.age.setVisible(markers);
	
	          this.entityBars = this.bars.selectAll('.vzb-bc-bar')
	            .data(markers);
	
	          this.entityLabels = this.labels.selectAll('.vzb-bc-label')
	            .data(markers);
	
	          //exit selection
	          this.entityBars.exit().remove();
	          this.entityLabels.exit().remove();
	
	          var highlight = this._highlightBar.bind(this);
	          var unhighlight = this._unhighlightBars.bind(this)
	
	          //enter selection -- init bars
	          this.entityBars.enter().append("g")
	            .attr("class", "vzb-bc-bar")
	            .attr("id", function(d) {
	              return "vzb-bc-bar-" + d[ageDim];
	            })
	            .on("mouseover", highlight)
	            .on("mouseout", unhighlight)
	            .on("click", function(d, i) {
	              if(isTouchDevice()) return;
	              _this.model.age.selectEntity(d);
	            })
	            .onTap(function(d) {
	              d3.event.stopPropagation();
	              _this.model.age.selectEntity(d);
	            })    
	            .append('rect');
	
	          this.entityLabels.enter().append("g")
	            .attr("class", "vzb-bc-label")
	            .attr("id", function(d) {
	              return "vzb-bc-label-" + d[ageDim];
	            })
	            .append('text')
	            .attr("class", "vzb-bc-age");
	
	          var one_bar_height = this.height / (domain[1] - domain[0]);
	          var bar_height = one_bar_height * group_by; // height per bar is total domain height divided by the number of possible markers in the domain
	          var first_bar_y_offset = this.height - bar_height;
	
	          this.bars.selectAll('.vzb-bc-bar > rect')
	            .attr("fill", function(d) {
	              return _this._temporaryBarsColorAdapter(values$$, d, ageDim);
	              //    return _this.cScale(values.color[d[ageDim]]);
	            })
	            .attr("shape-rendering", "crispEdges") // this makes sure there are no gaps between the bars, but also disables anti-aliasing
	            .attr("x", 0)
	            .transition().duration(duration).ease("linear")
	            .attr("y", function(d, i) {
	              return first_bar_y_offset - (d[ageDim] - domain[0]) * one_bar_height;
	            })
	            .attr("height", bar_height)
	            .attr("width", function(d) {
	              return _this.xScale(values$$.axis_x[d[ageDim]]);
	            });
	
	          this.labels.selectAll('.vzb-bc-label > .vzb-bc-age')
	            .text(function(d, i) {
	              var formatter = _this.model.marker.axis_x.getTickFormatter();
	              var yearOldsIn = _this.translator("popbyage/yearOldsIn");
	
	              var age = parseInt(d[ageDim], 10);
	
	              if(group_by > 1) {
	                age = age + "-to-" + (age + group_by - 1);
	              }
	
	              return age + yearOldsIn + " " + _this.model.time.timeFormat(time.value) + ": " + formatter(values$$.axis_x[d[ageDim]]);
	            })
	            .attr("x", 7)
	            .attr("y", function(d, i) {
	              return first_bar_y_offset - (d[ageDim] - domain[0]) * one_bar_height - 10;
	            })
	            .style("fill", function(d) {
	              var color = _this.cScale(values$$.color[d[ageDim]]);
	              return d3.rgb(color).darker(2);
	            });
	
	          var label = values(values$$.label_name).reverse()[0]; //get last name
	
	          //TODO: remove hack
	          label = label === "usa" ? "United States" : "Sweden";
	
	          this.title.text(label);
	
	          this.year.text(this.model.time.timeFormat(this.model.time.value));
	
	          //update x axis again
	          //TODO: remove this when grouping is done at data level
	          //var x_domain = this.xScale.domain();
	          //var x_domain_max = Math.max.apply(null, utils.values(values.axis_x));
	          //if(x_domain_max > this.xScale.domain()[1]) this.xScale = this.xScale.domain([x_domain[0], x_domain_max]);
	
	          // should not be here
	          var limits = this.model.marker.axis_x.getLimits(this.model.marker.axis_x.which);
	          if (group_by == 1) {
	            this.xScale = this.xScale.domain([limits.min, limits.max]);
	          } else {
	            var values$$ = values(values$$.axis_x);
	            values$$.push(limits.max);
	            this.xScale = this.xScale.domain([limits.min, Math.max.apply(Math, values$$)]);
	          }
	          this.resize();
	
	        },
	
	        _temporaryBarsColorAdapter: function(values$$, d, ageDim) {
	          return this.cScale(values$$.color[d[ageDim]]);
	        },
	
	        /**
	         * Highlight and unhighlight labels
	         */
	        _unhighlightBars: function() {
	          if(isTouchDevice()) return;
	            
	          this.bars.classed('vzb-dimmed', false);
	          this.bars.selectAll('.vzb-bc-bar.vzb-hovered').classed('vzb-hovered', false);
	          this.labels.selectAll('.vzb-hovered').classed('vzb-hovered', false);
	        },
	
	        _highlightBar: function(d) {
	          if(isTouchDevice()) return;
	            
	          this.bars.classed('vzb-dimmed', true);
	          var curr = this.bars.select("#vzb-bc-bar-" + d[this.AGEDIM]);
	          curr.classed('vzb-hovered', true);
	          var label = this.labels.select("#vzb-bc-label-" + d[this.AGEDIM]);
	          label.classed('vzb-hovered', true);
	        },
	
	        /**
	         * Select Entities
	         */
	        _selectBars: function() {
	          var _this = this;
	          var AGEDIM = this.AGEDIM;
	          var selected = this.model.age.select;
	
	          this._unselectBars();
	
	          if(selected.length) {
	            this.bars.classed('vzb-dimmed-selected', true);
	            forEach(selected, function(s) {
	              _this.bars.select("#vzb-bc-bar-" + s[AGEDIM]).classed('vzb-selected', true);
	              _this.labels.select("#vzb-bc-label-" + s[AGEDIM]).classed('vzb-selected', true);
	            });
	          }
	        },
	
	        _unselectBars: function() {
	          this.bars.classed('vzb-dimmed-selected', false);
	          this.bars.selectAll('.vzb-bc-bar.vzb-selected').classed('vzb-selected', false);
	          this.labels.selectAll('.vzb-selected').classed('vzb-selected', false);
	        },
	
	        /**
	         * Executes everytime the container or vizabi is resized
	         * Ideally,it contains only operations related to size
	         */
	        resize: function() {
	
	          var _this = this;
	
	          this.profiles = {
	            "small": {
	              margin: {
	                top: 70,
	                right: 20,
	                left: 40,
	                bottom: 40
	              },
	              minRadius: 2,
	              maxRadius: 40
	            },
	            "medium": {
	              margin: {
	                top: 80,
	                right: 60,
	                left: 60,
	                bottom: 40
	              },
	              minRadius: 3,
	              maxRadius: 60
	            },
	            "large": {
	              margin: {
	                top: 100,
	                right: 60,
	                left: 60,
	                bottom: 40
	              },
	              minRadius: 4,
	              maxRadius: 80
	            }
	          };
	
	          this.activeProfile = this.profiles[this.getLayoutProfile()];
	          var margin = this.activeProfile.margin;
	
	          //stage
	          this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	            
	          if(this.height<=0 || this.width<=0) return warn("Pop by age resize() abort: vizabi container is too little or has display:none");
	
	          this.graph
	            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	          //update scales to the new range
	          if(this.model.marker.axis_y.scaleType !== "ordinal") {
	            this.yScale.range([this.height, 0]);
	          } else {
	            this.yScale.rangePoints([this.height, 0]).range();
	          }
	          if(this.model.marker.axis_x.scaleType !== "ordinal") {
	            this.xScale.range([0, this.width]);
	          } else {
	            this.xScale.rangePoints([0, this.width]).range();
	          }
	
	          //apply scales to axes and redraw
	          this.yAxis.scale(this.yScale)
	            .orient("left")
	            .tickSize(6, 6)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_y.scaleType,
	              toolMargin: margin,
	              limitMaxTickNumber: 6
	            });
	
	          this.xAxis.scale(this.xScale)
	            .orient("bottom")
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_x.scaleType,
	              toolMargin: margin,
	              limitMaxTickNumber: 6
	            });
	          this.xAxisEl.attr("transform", "translate(0," + this.height + ")")
	            .call(this.xAxis);
	
	          this.yAxisEl.call(this.yAxis);
	          //this.xAxisEl.call(this.xAxis);
	
	          this.title.attr('x', margin.right).attr('y', margin.top / 2);
	
	          this.year.attr('x', this.width + margin.left).attr('y', margin.top / 2);
	
	        }
	      });
	
	      //BAR CHART TOOL
	      var PopByAge = Tool.extend('PopByAge', {
	
	        /**
	         * Initializes the tool (Bar Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	
	          this.name = "popbyage";
	
	          //specifying components
	          this.components = [{
	            component: PopByAge$1,
	            placeholder: '.vzb-tool-viz',
	            model: ["state.time", "state.entities", "state.entities_age", "state.marker", "language"] //pass models to component
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        }
	
	      });
	
	      //DONUT CHART COMPONENT
	      var DonutComponent = Component.extend('donut', {
	
	            init: function(config, context) {
	              var _this = this;
	
	              this.name = 'donutchart';
	              this.template = '<div class="vzb-donutchart"><svg class="vzb-donutchart-svg"></svg></div>';
	
	              //define expected models for this component
	              this.model_expects = [{
	                name: "time",
	                type: "time"
	              }, {
	                name: "marker",
	                type: "model"
	              }];
	
	              //bind the function updateTime() to the change of time value in the model
	              this.model_binds = {
	                "change:time:value": function(evt) {
	                  if(!_this._readyOnce) return;
	                  //fetch the time from the model and update the text on screen
	                  _this.time = _this.model.time.value;
	                  _this.yearEl.text(_this.timeFormatter(_this.time));
	                  _this.redraw();
	                }
	              };
	
	              //call the prototype constructor of the component
	              this._super(config, context);
	
	              //init variables for d3 pie layout
	              this.colorScale = null;
	              this.arc = d3.svg.arc();
	              this.pie = d3.layout.pie()
	                .sort(null)
	                .value(function(d) {
	                  return d.pop;
	                });
	            },
	
	            /**
	             * DOM is ready and the model is ready -- happens once on the load and never again
	             */
	            readyOnce: function() {
	              var _this = this;
	
	              //link DOM elements to the variables
	              this.element = d3.select(this.element)
	              this.svgEl = this.element.select("svg").append("g");
	              this.yearEl = this.svgEl.append("text").attr("class", "year").style({'font-size':'4em'});
	              this.titleEl = this.svgEl.append("text").attr("class", "title").style({'font-size':'2em'});
	
	              //bind the resize() and updateTime() events to container resize
	              this.on("resize", function() {
	                _this.resize();
	                _this.redraw();
	              });
	
	              //run a startup sequence
	              this.resize();
	              this.update();
	              this.redraw();
	            },
	
	            /**
	             * Populate the visuals according to the number of entities
	             */
	            update: function() {
	              this.timeFormatter = d3.time.format("%Y");
	              this.colorScale = this.model.marker.color.getScale();
	
	              this.titleEl.text("Population");
	              this.keys = this.model.marker.getKeys();
	
	              this.entities = this.svgEl.selectAll('.vzb-dc-entity')
	                .data(this.keys);
	
	              //exit selection
	              this.entities.exit().remove();
	
	              //enter selection
	              this.entities
	                .enter().append("g")
	                .attr("class", "vzb-dc-entity")
	                .each(function() {
	                  d3.select(this).append("path");
	                  d3.select(this).append("text").attr("class", "label").style({'font-size':'1.2em'});
	                });
	            },
	
	            /**
	             * Updates the visuals
	             */
	            redraw: function() {
	              var _this = this;
	
	              //request the values for the current time from the model
	              this.values = this.model.marker.getValues({time: _this.time}, ["geo"]);
	
	              //prepare the data
	              var data = this.keys.map(function(d) { return {
	                  geo: d.geo,
	                  pop: _this.values.axis[d.geo],
	                  color: _this.values.color[d.geo],
	                  label: _this.values.label[d.geo]
	              }});
	
	              data = this.pie(data);
	
	              //set the properties of the donuts and text labels
	              this.entities
	                .data(data)
	                .select("path")
	                .attr("d", this.arc)
	                .style("fill", function(d) {
	                  return _this.colorScale(d.data.color)
	                })
	                .style("stroke", "white");
	
	              this.entities
	                .select("text")
	                .style({
	                  'text-transform': 'capitalize'
	                })
	                .attr("transform", function(d) {
	                  return "translate(" + _this.arc.centroid(d) + ")";
	                })
	                .text(function(d) {
	                  return d.data.geo;
	                });
	            },
	
	            /**
	             * Executes every time the container or vizabi is resized
	             */
	            resize: function() {
	
	              var height = parseInt(this.element.style("height"), 10) || 0;
	              var width = parseInt(this.element.style("width"), 10) || 0;
	              var min = Math.min(height, width);
	                
	              if(height<=0 || width<=0) return warn("Donut chart resize() abort: vizabi container is too little or has display:none");
	
	              this.svgEl.attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");
	              this.titleEl.attr("y", "-0.1em");
	              this.yearEl.attr("y", "0.1em");
	
	              this.arc
	                .outerRadius(min / 2 * 0.9)
	                .innerRadius(min / 2 - min * 0.1)
	            }
	
	              
	
	      });
	
	      //BAR CHART TOOL
	      //extend the base Tool class and register it in Vizabi tools under a name 'DunutChart'
	      var DonutChart = Tool.extend('DonutChart', {
	
	        //Run when the tool is created
	        init: function(placeholder, external_model) {
	
	          //Let's give it a name
	          this.name = "donutchart";
	
	          //Now we can specify components that should be included in the tool:
	          this.components = [{
	            //choose which component to use:
	            //at this point you can check Vizabi.Component.getCollection() to see which components are available
	            component: 'donut',
	            //these placeholdes are defined by the Tool prototype class
	            placeholder: '.vzb-tool-viz',
	            //component should have access to the following models:
	            model: ["state.time", "state.marker"]
	          }, {
	            component: 'timeslider',
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }];
	            
	            this._super(placeholder, external_model);
	          },
	
	          //provide the default options
	          default_model: {
	            state: {
	            }
	          }
	      });
	
	      //import Selectlist from './bubblemap-selectlist';
	
	      //BUBBLE MAP CHART COMPONENT
	      var CartogramComponent = Component.extend({
	        /**
	         * Initializes the component (Bubble Map Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The config passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function (config, context) {
	          this.name = 'cartogram';
	          this.template = 'cartogram.html';
	
	
	          //http://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
	          var mobileAndTabletcheck = function() {
	            var check = false;
	            (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
	            return check;
	          };
	          this.isMobile = mobileAndTabletcheck();
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }, {
	            name: "ui",
	            type: "model"
	          }];
	
	          var _this = this;
	          this.model_binds = {
	            "change:time.value": function (evt) {
	              if (!_this._readyOnce) return;
	              _this.year.setText(_this.model.time.timeFormat(_this.model.time.value));
	              if (!_this.calculationQueue) { // collect timestamp that we request
	                _this.calculationQueue = [_this.model.time.value.toString()]
	              } else {
	                _this.calculationQueue.push(_this.model.time.value.toString());
	              }
	              (function(time) { // isolate timestamp
	                _this.model.marker.getFrame(time, function(frame, time) {
	                  var index = _this.calculationQueue.indexOf(time.toString()); //
	                  if (index == -1) { // we was receive more recent frame before so we pass this frame
	                    return;
	                  } else {
	                    _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp
	                  }
	                  _this.frameChanged(frame, time);
	                });
	
	              }(_this.model.time.value));
	            },
	            'change:marker.size.extent': function(evt, path) {
	              //console.log("EVENT change:marker:size:max");
	              if(!_this._readyOnce) return;
	              _this.updateMarkerSizeLimits();
	              _this.updateEntities();
	            },
	            "change:marker.color.scaleType": function(evt, path) {
	              _this.updateIndicators();
	              _this.updateEntitityColor();
	            },
	            
	            'change:marker.size.use': function(evt, path) {
	              _this.model.ui.chart.lockActive = _this.model.marker.size.use != "constant";
	            },
	            "change:marker.color.palette": function(evt, path) {
	              _this.updateEntitityColor();
	            },
	            "change:ui.chart.lockNonSelected": function(evt) {
	              _this.updateEntities(900);
	            },
	            "change:entities.select": function() {
	              if(!_this._readyOnce) return;
	              _this.updateLandOpacity();
	            },
	            "change:entities.highlight": function() {
	              if(!_this._readyOnce) return;
	              //console.log("EVENT change:entities:highlight");
	              _this.updateLandOpacity();
	            },
	            'change:entities.opacitySelectDim': function() {
	              _this.updateLandOpacity();
	            },
	            'change:entities.opacityRegular': function() {
	              _this.updateLandOpacity();
	            },
	          };
	          //this._selectlist = new Selectlist(this);
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	
	          _this.COLOR_LAND_DEFAULT = "#fdfdfd";
	
	          this.lands = null;
	          this.features = null;
	          this.topo_features = null;
	          this.borderArcs = null;
	          this.defaultWidth = 700;
	          this.defaultHeight = 550;
	          this.updateEntitiesQueue = [];
	          this.boundBox = [[0.05, 0.0], [0.95, 1.0]]; // two points to set box bound on 960 * 500 image;
	          d3_geo_projection();
	          this.cached = [];
	          this.projection = d3.geo.mercator()
	            .center([25, -29])
	            .scale(1900)
	            .translate([this.defaultWidth / 2, this.defaultHeight / 2])
	            .precision(.1);
	
	          this.cartogram = d3.cartogram()
	            .projection(this.projection)
	            .properties(function(d) {
	              return d.properties;
	            });
	        },
	
	        afterPreload: function(){
	          var _this = this;
	          if(!this.world) warn("cartogram afterPreload: missing country shapes " + this.world);
	          if(!this.geometries) warn("cartogram afterPreload: missing country shapes " + this.geometries);
	
	          // http://bl.ocks.org/mbostock/d4021aa4dccfd65edffd patterson
	          // http://bl.ocks.org/mbostock/3710566 robinson
	          // map background
	
	          this.borderArcs = _this.cartogram.meshArcs(this.world, this.world.objects.topo, function(a, b) {
	            return a.properties.MN_NAME && a.properties.PR_NAME !== b.properties.PR_NAME;
	          });
	
	          this.labels = this.parent.findChildByName('gapminder-labels');
	          if(this.labels) this.labels.config({
	            CSS_PREFIX: 'vzb-ct',
	            TOOL_CONTEXT: this,
	            LABELS_CONTAINER_CLASS: 'vzb-ct-labels',
	            LINES_CONTAINER_CLASS: 'vzb-ct-lines'
	          });
	
	        },
	        _getKey: function(d) {
	          return d.properties[this.id_lookup]? d.properties[this.id_lookup].toString() : d.id.toString(); 
	        },
	        /**
	         * DOM is ready
	         */
	        readyOnce: function () {
	
	          this.element = d3.select(this.element);
	
	          this.graph = this.element.select('.vzb-ct-graph');
	          this.mapSvg = this.element.select('.vzb-ct-map-background');
	
	          this.labelsContainerCrop = this.graph.select('.vzb-ct-labels-crop');
	          this.labelsContainer = this.graph.select('.vzb-ct-labels');
	
	          this.yTitleEl = this.graph.select(".vzb-ct-axis-y-title");
	          this.sTitleEl = this.graph.select(".vzb-ct-axis-c-title");
	          this.yInfoEl = this.graph.select(".vzb-ct-axis-y-info");
	          this.sInfoEl = this.graph.select(".vzb-ct-axis-c-info");
	          this.dataWarningEl = this.graph.select(".vzb-data-warning");
	          this.entityBubbles = null;
	          this.tooltip = this.element.select('.vzb-ct-tooltip');
	
	          // year background
	          this.yearEl = this.graph.select('.vzb-ct-year');
	          this.year = new DynamicBackground(this.yearEl);
	          this.year.setConditions({xAlign: 'left', yAlign: 'bottom', bottomOffset: 5});
	          this.mapGraph = this.element.select(".vzb-ct-map-graph")
	            .attr("width", this.defaultWidth)
	            .attr("height", this.defaultHeight);
	          this.mapGraph.html('');
	
	
	          this.KEY = this.model.entities.getDimension();
	          this.TIMEDIM = this.model.time.getDimension();
	
	          var _this = this;
	          this.updateUIStrings();
	          this.on("resize", function() {
	            if(_this.updateSize()) return;
	          });
	          this.wScale = d3.scale.linear()
	            .domain(this.parent.datawarning_content.doubtDomain)
	            .range(this.parent.datawarning_content.doubtRange);
	
	          this.cartogram.iterations(0);
	          this.redrawInProgress = true;
	
	          this.cartogram(this.world, this.geometries).then(function(response) {
	            _this.redrawInProgress = false;
	
	            _this.features = _this.topo_features = response.features;
	            _this.lands = _this.mapGraph.selectAll(".land")
	              .data(_this.topo_features)
	              .enter().append("path")
	              .attr("class", function(d) { return "land " + (d.properties[_this.id_lookup]?d.properties[_this.id_lookup]:d.id); })
	              .attr("d", _this.cartogram.path)
	              .on("mouseover", function (d, i) {
	                if (isTouchDevice()) return;
	                _this._interact()._mouseover(d, i);
	              })
	              .on("mouseout", function (d, i) {
	                if (isTouchDevice()) return;
	                _this._interact()._mouseout(d, i);
	              })
	              .on("click", function(d, i) {
	                if(isTouchDevice()) return;
	                _this._interact()._click(d, i);
	              })
	              .each(function(d) {
	                d[_this.KEY] = _this._getKey(d);
	              });
	
	            if (_this.borderArcs) {
	              var data = _this.cartogram.stitchArcs(response, _this.borderArcs);
	              _this.borders = _this.mapGraph.append("path")
	                .datum(data)
	                .attr("class", "boundary")
	                .attr("d", _this.cartogram.path);
	            }
	          });
	        },
	        
	        frameChanged: function(frame, time) {
	          if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
	          if (!frame) return;
	          this.values = frame;
	          this.updateTime();
	          this.updateTitleNumbers();
	          this.updateEntities(this.duration);
	        },
	        
	        /*
	         * Both model and DOM are ready
	         */
	        ready: function () {
	          var _this = this;
	          this.cached = [];
	          this.updateIndicators();
	          this.updateUIStrings();
	          this.updateMarkerSizeLimits();
	          this.updateSize();
	          this.model.marker.getFrame(_this.model.time.value, _this.frameChanged.bind(_this));
	          this.year.setText(_this.model.time.timeFormat(_this.model.time.value));
	        },
	
	        /**
	         * Changes labels for indicators
	         */
	        updateIndicators: function () {
	          this.sScale = this.model.marker.size.getScale();
	          this.cScale = this.model.marker.color.getScale();
	        },
	
	        updateMarkerSizeLimits: function() {
	          var _this = this;
	          var extent = this.model.marker.size.extent || [0,1];
	          this.minRadius = Math.max(100 * extent[0], 0);
	          this.maxRadius = Math.max(100 * extent[1], 0);
	
	          this.sScale.domain([0, this.sScale.domain()[1]]);
	          if(this.model.marker.size.scaleType !== "ordinal") {
	            this.sScale.range([this.minRadius, this.maxRadius]);
	          } else {
	            this.sScale.rangePoints([this.minRadius, this.maxRadius], 0).range();
	          }
	        },
	        
	        _calculateTotalSize: function(year, frame) {
	          if (this.cached[year]) {
	            return this.cached[year];
	          }
	          var _this = this;
	          this.cached[year] = 0;
	          forEach(frame, function(val) {
	            _this.cached[year] += _this.sScale(val);
	          });
	          return this.cached[year];
	        },
	         
	        _redrawEntities: function() {
	          var _this = this;
	          if (this.updateEntitiesQueue.length == 0) return;
	          if (this.redrawInProgress) {
	            setTimeout(function() {
	              _this._redrawEntities();
	            }, 100);
	            return;
	          }
	          this.redrawInProgress = true;
	          var time = this.updateEntitiesQueue[this.updateEntitiesQueue.length - 1].time;
	          var duration = this.updateEntitiesQueue[this.updateEntitiesQueue.length - 1].duration;
	          this.updateEntitiesQueue = [];
	          if(this.model.ui.chart.lockNonSelected) {
	            time = this.model.time.timeFormat.parse("" + this.model.ui.chart.lockNonSelected);
	          }
	          this.model.marker.getFrame(time, function(lockedFrame) {
	            var totValue = null;
	            if (_this.model.marker.size.use == "constant") {
	              _this.cartogram.iterations(0);
	            } else {
	              _this.cartogram.iterations(8);
	              //var areas = _this.topo_features.map(d3.geo.path().projection(null).area);
	              _this.cartogram.value(function(d) {
	                if (_this.model.ui.chart.lockNonSelected) {
	                  var size1 = _this.sScale(lockedFrame.size[_this._getKey(d)])/* * _this._calculateTotalSize(_this.model.time.value, _this.values.size)*/,
	                    size2 = _this.sScale(_this.values.size[_this._getKey(d)])/* * _this._calculateTotalSize(time, lockedFrame.size)*/;
	                  return d3.geo.path().projection(null).area(d) * Math.pow((size2 / size1), 2);  
	                } else {
	                  return _this.sScale(_this.values.size[_this._getKey(d)]);
	                }
	              });
	              /*
	               if (_this.model.ui.chart.lockNonSelected) {
	               totValue = d3.sum(areas);
	               }
	               */
	            }
	            var calcDuration = 0;
	            var start = new Date().getTime();
	            _this.cartogram(_this.world, _this.geometries, totValue).then(function(response) {
	              var end = new Date().getTime();
	              if (duration) { // increale duration for prevent gaps between frames
	                duration = Math.max(duration, end - start);
	              }
	              _this.features = response.features;
	              if (_this.borderArcs) {
	                var data = _this.cartogram.stitchArcs(response, _this.borderArcs);
	                _this.borders.datum(data)
	                  .transition()
	                  .duration(duration)
	                  .ease("linear")
	                  .attr("d", _this.cartogram.path);
	              }
	              _this.lands.data(_this.features)
	                .each(function(d) {
	                  d[_this.KEY] = _this._getKey(d);
	                });
	              if (duration) {
	                _this.lands.interrupt()
	                  .transition()
	                  .duration(duration)
	                  .ease("linear")
	                  .style("fill", function(d) {
	                    return _this.values.color[_this._getKey(d)]!=null?_this.cScale(_this.values.color[_this._getKey(d)]):_this.COLOR_LAND_DEFAULT;
	                  })
	                  .attr("d", _this.cartogram.path);
	                if (_this.borderArcs) {
	                  _this.borders.interrupt()
	                    .transition()
	                    .duration(duration)
	                    .ease("linear")
	                    .attr("d", _this.cartogram.path);
	                }
	
	              } else {
	                _this.borders
	                  .attr("d", _this.cartogram.path);
	
	                _this.lands
	                  .style("fill", function(d) {
	                    return _this.values.color[_this._getKey(d)]!=null?_this.cScale(_this.values.color[_this._getKey(d)]):_this.COLOR_LAND_DEFAULT;
	                  })
	                  .attr("d", _this.cartogram.path);
	
	              }
	              _this.updateLandOpacity();
	              _this.redrawInProgress = false;
	              _this._redrawEntities();
	            });
	          });
	        },
	          
	        updateEntities: function(duration) {
	          var time = this.model.time.value;
	          
	          this.updateEntitiesQueue.push({time:time, duration: duration});
	          this._redrawEntities();
	        },
	
	        updateEntitityColor: function() {
	          var _this = this;
	          this.lands.transition()
	            .duration(_this.duration)
	            .ease("linear")
	            .style("fill", function(d) {
	              return _this.values.color[_this._getKey(d)]!=null?_this.cScale(_this.values.color[_this._getKey(d)]):_this.COLOR_LAND_DEFAULT;
	            })
	          
	        },
	        updateUIStrings: function () {
	          var _this = this;
	
	          this.translator = this.model.language.getTFunction();
	          var sizeConceptprops = this.model.marker.size.getConceptprops();
	          this.strings = {
	            title: {
	              C: (_this.model.marker.size.use !== "constant"? this.translator("buttons/color") + ": " : "") + this.translator("indicator/" + _this.model.marker.color.which),
	              S: this.translator("buttons/size") + ": " + this.translator("indicator/" + _this.model.marker.size.which)
	            }
	          };
	          
	          this.yTitleEl.select("text")
	            //don't show "Color:" when the size is constant and we are only showing color
	            .text(this.strings.title.C)
	            .on("click", function() {
	              _this.parent
	                .findChildByName("gapminder-treemenu")
	                .markerID("color")
	                .alignX("left")
	                .alignY("top")
	                .updateView()
	                .toggle();
	            });
	
	          this.sTitleEl.select("text")
	            .text(this.strings.title.S)
	            .on("click", function() {
	              _this.parent
	                .findChildByName("gapminder-treemenu")
	                .markerID("size")
	                .alignX("left")
	                .alignY("top")
	                .updateView()
	                .toggle();
	            });
	
	          setIcon(this.dataWarningEl, iconWarn).select("svg").attr("width", "0px").attr("height", "0px");
	          this.dataWarningEl.append("text")
	            .attr("text-anchor", "end")
	            .text(this.translator("hints/dataWarning"));
	
	          this.dataWarningEl
	            .on("click", function () {
	              _this.parent.findChildByName("gapminder-datawarning").toggle();
	            })
	            .on("mouseover", function () {
	              _this.updateDoubtOpacity(1);
	            })
	            .on("mouseout", function () {
	              _this.updateDoubtOpacity();
	            })
	
	          this.yInfoEl
	            .html(iconQuestion)
	            .select("svg").attr("width", "0px").attr("height", "0px");
	
	          //TODO: move away from UI strings, maybe to ready or ready once
	          this.yInfoEl.on("click", function() {
	            _this.parent.findChildByName("gapminder-datanotes").pin();
	          })
	          this.yInfoEl.on("mouseover", function() {
	            var rect = this.getBBox();
	            var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	            _this.parent.findChildByName("gapminder-datanotes").setHook('size').show().setPos(coord.x, coord.y);
	          })
	          this.yInfoEl.on("mouseout", function() {
	            _this.parent.findChildByName("gapminder-datanotes").hide();
	          })
	
	          this.sInfoEl
	            .html(iconQuestion)
	            .select("svg").attr("width", "0px").attr("height", "0px");
	
	          //TODO: move away from UI strings, maybe to ready or ready once
	          this.sInfoEl.on("click", function() {
	            _this.parent.findChildByName("gapminder-datanotes").pin();
	          })
	          this.sInfoEl.on("mouseover", function() {
	            var rect = this.getBBox();
	            var coord = makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
	            _this.parent.findChildByName("gapminder-datanotes").setHook('color').show().setPos(coord.x, coord.y);
	          })
	          this.sInfoEl.on("mouseout", function() {
	            _this.parent.findChildByName("gapminder-datanotes").hide();
	          })
	        },
	
	        updateDoubtOpacity: function (opacity) {
	          if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
	          if (this.someSelected) opacity = 1;
	          this.dataWarningEl.style("opacity", opacity);
	        },
	
	        /*
	         * UPDATE TIME:
	         * Ideally should only update when time or data changes
	         */
	        updateTime: function() {
	          var _this = this;
	          this.time_1 = this.time == null ? this.model.time.value : this.time;
	          this.time = this.model.time.value;
	          this.duration = this.model.time.playing && (this.time - this.time_1 > 0) ? this.model.time.delayAnimations : 0;
	
	          //possibly update the exact value in size title
	        },
	
	
	        /**
	         * Executes everytime the container or vizabi is resized
	         * Ideally,it contains only operations related to size
	         */
	        updateSize: function () {
	
	          var _this = this;
	          var margin, infoElHeight;
	
	          var profiles = {
	            small: {
	              margin: { top: 10, right: 10, left: 10, bottom: 0 },
	              infoElHeight: 16,
	            },
	            medium: {
	              margin: { top: 20, right: 20, left: 20, bottom: 30 },
	              infoElHeight: 20,
	            },
	            large: {
	              margin: { top: 30, right: 30, left: 30, bottom: 35 },
	              infoElHeight: 22,
	            }
	          };
	
	          var presentationProfileChanges = {
	            medium: {
	              infoElHeight: 26
	            },
	            large: {
	              infoElHeight: 32
	            }
	          };
	
	          this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);
	          margin = this.activeProfile.margin;
	          infoElHeight = this.activeProfile.infoElHeight;
	
	          //stage
	          var height = this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          var width = this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	
	          if(this.height<=0 || this.width<=0) return warn("Bubble map updateSize() abort: vizabi container is too little or has display:none");
	
	          var boundBox = this.boundBox;
	          var viewBox = [ boundBox[0][0] * this.defaultWidth,
	            boundBox[0][1] * this.defaultHeight,
	            Math.abs(boundBox[1][0] - boundBox[0][0]) * this.defaultWidth,
	            Math.abs(boundBox[1][1] - boundBox[0][1]) * this.defaultHeight];
	
	          this.graph
	            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	          this.year.resize(this.width, this.height,
	            Math.min(this.width/2.5, Math.max(this.height / 4, this.width / 4)) / 2.5);
	
	          this.mapSvg
	            .attr('width', width)
	            .attr('height', height)
	            .attr('viewBox', viewBox.join(' '))
	            .attr('preserveAspectRatio', 'xMidYMid')
	            .attr('x', margin.left)
	            .attr('y', margin.top)
	            .style("transform", "translate3d(" + margin.left + "px," + margin.top + "px,0)");
	
	          this.yTitleEl
	            .style("font-size", infoElHeight)
	            .attr("transform", "translate(0," + margin.top + ")")
	
	          var yTitleBB = this.yTitleEl.select("text").node().getBBox();
	
	          this.sTitleEl.attr("transform", "translate(" + 0 + "," + (margin.top + yTitleBB.height) + ")")
	            .classed("vzb-hidden", this.model.marker.size.use == "constant");
	
	          var warnBB = this.dataWarningEl.select("text").node().getBBox();
	          this.dataWarningEl.select("svg")
	            .attr("width", warnBB.height * 0.75)
	            .attr("height", warnBB.height * 0.75)
	            .attr("x", -warnBB.width - warnBB.height * 1.2)
	            .attr("y", -warnBB.height * 0.65)
	
	          this.dataWarningEl
	            .attr("transform", "translate(" + (this.width) + "," + (this.height - warnBB.height * 0.5) + ")")
	            .select("text");
	
	          if(this.yInfoEl.select('svg').node()) {
	            var titleBBox = this.yTitleEl.node().getBBox();
	            var translate = d3.transform(this.yTitleEl.attr('transform')).translate;
	
	            this.yInfoEl.select('svg')
	              .attr("width", infoElHeight)
	              .attr("height", infoElHeight)
	            this.yInfoEl.attr('transform', 'translate('
	              + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	              + (translate[1] - infoElHeight * 0.8) + ')');
	          }
	
	          this.sInfoEl.classed("vzb-hidden", this.sTitleEl.classed("vzb-hidden"));
	
	          if(!this.sInfoEl.classed("vzb-hidden") && this.sInfoEl.select('svg').node()) {
	            var titleBBox = this.sTitleEl.node().getBBox();
	            var translate = d3.transform(this.sTitleEl.attr('transform')).translate;
	
	            this.sInfoEl.select('svg')
	              .attr("width", infoElHeight)
	              .attr("height", infoElHeight)
	            this.sInfoEl.attr('transform', 'translate('
	              + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * .4) + ','
	              + (translate[1] - infoElHeight * 0.8) + ')');
	          }
	        },
	
	        fitSizeOfTitles: function(){
	
	          //reset font sizes first to make the measurement consistent
	          var yTitleText = this.yTitleEl.select("text")
	            .style("font-size", null);
	          var sTitleText = this.sTitleEl.select("text")
	            .style("font-size", null);
	
	
	          var yTitleBB = yTitleText.node().getBBox();
	          var sTitleBB = this.sTitleEl.classed('vzb-hidden') ? yTitleBB : sTitleText.node().getBBox();
	
	          var font =
	            Math.max(parseInt(yTitleText.style("font-size")), parseInt(sTitleText.style("font-size")))
	            * this.width / Math.max(yTitleBB.width, sTitleBB.width);
	
	          if(Math.max(yTitleBB.width, sTitleBB.width) > this.width) {
	            yTitleText.style("font-size", font + "px");
	            sTitleText.style("font-size", font + "px");
	          } else {
	            // Else - reset the font size to default so it won't get stuck
	            yTitleText.style("font-size", null);
	            sTitleText.style("font-size", null);
	          }
	        },
	        _interact: function () {
	          var _this = this;
	
	          return {
	            _mouseover: function (d, i) {
	              if (_this.model.time.dragging) return;
	
	              _this.model.entities.highlightEntity(d);
	
	              _this.hovered = d;
	              //put the exact value in the size title
	              _this.updateTitleNumbers();
	              _this.fitSizeOfTitles();
	
	              if (_this.model.entities.isSelected(d)) { // if selected, not show hover tooltip
	                _this._setTooltip();
	              } else {
	                //position tooltip
	                _this._setTooltip(d);
	              }
	            },
	            _mouseout: function (d, i) {
	              if (_this.model.time.dragging) return;
	              _this._setTooltip();
	              _this.hovered = null;
	              _this.updateTitleNumbers();
	              _this.fitSizeOfTitles();
	              _this.model.entities.clearHighlighted();
	            },
	            _click: function (d, i) {
	              _this.model.entities.selectEntity(d);
	            }
	          };
	
	        },
	
	        // show size number on title when hovered on a bubble
	        updateTitleNumbers: function(){
	          var _this = this;
	
	          var mobile; // if is mobile device and only one bubble is selected, update the ytitle for the bubble
	          if (_this.isMobile && _this.model.entities.select && _this.model.entities.select.length === 1) {
	            mobile = _this.model.entities.select[0];
	          }
	
	          if(_this.hovered || mobile) {
	            var hovered = _this.hovered || mobile;
	            var formatterC = _this.model.marker.color.getTickFormatter();
	
	            var unitC = _this.translator("unit/" + _this.model.marker.color.which);
	            //suppress unit strings that found no translation (returns same thing as requested)
	            if(unitC === "unit/" + _this.model.marker.color.which) unitC = "";
	            
	            var valueC = _this.values.color[_this._getKey(hovered)];
	            _this.yTitleEl.select("text")
	              .text(this.strings.title.C + ": " +
	              (valueC || valueC===0 ? formatterC(valueC) + " " + unitC : _this.translator("hints/nodata")));
	
	            if (this.model.marker.size.use !== "constant") {
	              var formatterS = _this.model.marker.size.getTickFormatter();
	              
	              var unitS = _this.translator("unit/" + _this.model.marker.size.which);
	              //suppress unit strings that found no translation (returns same thing as requested)
	              if(unitS === "unit/" + _this.model.marker.size.which) unitS = "";
	              
	              var valueS = _this.values.size[_this._getKey(hovered)];
	              _this.sTitleEl.select("text")
	                .text(this.strings.title.S + ": " + formatterS(valueS) + " " + unitS);
	            }
	
	            this.yInfoEl.classed("vzb-hidden", true);
	            this.sInfoEl.classed("vzb-hidden", true);
	          } else {
	            this.yTitleEl.select("text")
	              .text(this.strings.title.C);
	            this.sTitleEl.select("text")
	              .text(this.strings.title.S);
	
	            this.yInfoEl.classed("vzb-hidden", false);
	            this.sInfoEl.classed("vzb-hidden", false);
	          }
	        },
	        
	        _setTooltip: function (d) {
	          var _this = this;
	          if (d) {
	            var tooltipText = this.values.label[this._getKey(d)]?
	              this.values.label[this._getKey(d)]
	              :d.properties.MN_NAME;
	            var offset = 10;
	            var mouse = d3.mouse(this.graph.node()).map(function(d) {
	              return parseInt(d)
	            });
	            var x = mouse[0];
	            var y = mouse[1];
	            var xPos, yPos, xSign = -1,
	              ySign = -1,
	              xOffset = 0,
	              yOffset = 0;
	
	            if(offset) {
	              xOffset = offset * .71; // .71 - sin and cos for 315
	              yOffset = offset * .71;
	            }
	            //position tooltip
	            this.tooltip.classed("vzb-hidden", false)
	              //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
	              .selectAll("text")
	              .text(tooltipText);
	
	            var contentBBox = this.tooltip.select('text')[0][0].getBBox();
	            if(x - xOffset - contentBBox.width < 0) {
	              xSign = 1;
	              x += contentBBox.width + 5; // corrective to the block Radius and text padding
	            } else {
	              x -= 5; // corrective to the block Radius and text padding
	            }
	            if(y - yOffset - contentBBox.height < 0) {
	              ySign = 1;
	              y += contentBBox.height;
	            } else {
	              y -= 11; // corrective to the block Radius and text padding
	            }
	            if(offset) {
	              xPos = x + xOffset * xSign;
	              yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
	            } else {
	              xPos = x + xOffset * xSign; // .71 - sin and cos for 315
	              yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
	            }
	            this.tooltip.attr("transform", "translate(" + (xPos ? xPos : mouse[0]) + "," + (yPos ? yPos : mouse[1]) +
	              ")")
	
	            this.tooltip.select('rect').attr("width", contentBBox.width + 8)
	              .attr("height", contentBBox.height * 1.2)
	              .attr("x", -contentBBox.width - 4)
	              .attr("y", -contentBBox.height * .85)
	              .attr("rx", contentBBox.height * .2)
	              .attr("ry", contentBBox.height * .2);
	
	
	          } else {
	
	            this.tooltip.classed("vzb-hidden", true);
	          }
	        },
	        
	        updateLandOpacity: function() {
	          var _this = this;
	          //if(!duration)duration = 0;
	
	          var OPACITY_HIGHLT = 0.8;
	          var OPACITY_HIGHLT_DIM = .3;
	          var OPACITY_SELECT = this.model.entities.opacityRegular;
	          var OPACITY_REGULAR = this.model.entities.opacityRegular;
	          var OPACITY_SELECT_DIM = this.model.entities.opacitySelectDim;
	          this.someHighlighted = (this.model.entities.highlight.length > 0);
	          this.someSelected = (this.model.entities.select.length > 0);
	          this.lands
	            .style("opacity", function(d) {
	
	              if(_this.someHighlighted) {
	                //highlight or non-highlight
	                if(_this.model.entities.isHighlighted(d)) return OPACITY_HIGHLT;
	              }
	
	              if(_this.someSelected) {
	                //selected or non-selected
	                return _this.model.entities.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
	              }
	
	              if(_this.someHighlighted) return OPACITY_HIGHLT_DIM;
	
	              return OPACITY_REGULAR;
	            });
	
	
	          var someSelectedAndOpacityZero = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	
	          // when pointer events need update...
	          if(someSelectedAndOpacityZero != this.someSelectedAndOpacityZero_1) {
	            this.lands.style("pointer-events", function(d) {
	              return(!someSelectedAndOpacityZero || _this.model.entities.isSelected(d)) ?
	                "visible" : "none";
	            });
	          }
	
	          this.someSelectedAndOpacityZero_1 = _this.someSelected && _this.model.entities.opacitySelectDim < .01;
	        }
	
	
	      });
	
	      //CARTOGRAM TOOL
	      var Cartogram = Tool.extend('Cartogram', {
	
	          /**
	           * Initialized the tool
	           * @param {Object} placeholder Placeholder element for the tool
	           * @param {Object} external_model Model as given by the external page
	           */
	          init: function(placeholder, external_model) {
	
	            this.name = 'cartogram';
	
	            //specifying components
	            this.components = [{
	              component: CartogramComponent,
	              placeholder: '.vzb-tool-viz',
	              model: ["state.time", "state.entities", "state.marker", "language", "ui"] //pass models to component
	            }, {
	              component: TimeSlider,
	              placeholder: '.vzb-tool-timeslider',
	              model: ["state.time", "state.entities", "state.marker"]
	            }, {
	              component: Labels,
	              placeholder: '.vzb-tool-labels',
	              model: ["state.entities", "state.marker", "ui"]
	            }, {
	              component: Dialogs,
	              placeholder: '.vzb-tool-dialogs',
	              model: ['state', 'ui', 'language']
	            }, {
	              component: ButtonList,
	              placeholder: '.vzb-tool-buttonlist',
	              model: ['state', 'ui', 'language']
	            }, {
	              component: TreeMenu,
	              placeholder: '.vzb-tool-treemenu',
	              model: ['state.marker', 'language']
	            }, {
	              component: DataWarning,
	              placeholder: '.vzb-tool-datawarning',
	              model: ['language']
	            }, {
	              component: DataNotes,
	              placeholder: '.vzb-tool-datanotes',
	              model: ['state.marker', 'language']
	            }
	            ];
	
	            //constructor is the same as any tool
	            this._super(placeholder, external_model);
	          },
	
	        default_model: {
	          state: {
	            time: {},
	            marker: {
	              space: ["entities", "time"],
	              color: {
	                use: "property",
	                which: "population"
	              }
	            }
	          },
	          ui: {
	            chart: {
	              labels: {
	                dragging: true
	              },
	              lockNonSelected: 0
	            },
	            presentation: true
	          }
	        }
	
	        });
	
	      //BAR CHART COMPONENT
	      var AxisLabelerComponent = Component.extend({
	
	        /**
	         * Initializes the component (Bar Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The options passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function(config, context) {
	          this.name = 'axislabeler';
	          this.template = 'axislabeler.html';
	
	          //define expected models for this component
	          this.model_expects = [{name: "scales"}, {name: "show"}];
	
	          var _this = this;
	
	          this.model_binds = {
	            "change:scales": function(evt) {
	              _this.initScales();
	              _this.update();
	            },
	            'change:show': function(evt, path) {
	              _this.initScales();
	              _this.update();
	            }
	          };
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.xScale = null;
	          this.yScale = null;
	
	          this.xAxis = axisSmart();
	          this.yAxis = axisSmart();
	        },
	
	        /**
	         * DOM is ready
	         */
	        readyOnce: function() {
	          var _this = this;
	          this.element = d3.select(this.element);
	
	          // reference elements
	          this.graph = this.element.select('.vzb-al-graph');
	          this.xAxisEl = this.graph.select('.vzb-al-axis-x');
	          this.yAxisEl = this.graph.select('.vzb-al-axis-y');
	          
	          //$(".vzb-bc-axis-x, .vzb-bc-axis-y").css('font-size',this.model.show.labelSize);
	          this.xInvert = function(d){return _this.xScale(_this.xScale.invert(_this.xScale(d)));}
	          this.yInvert = function(d){return _this.yScale(_this.yScale.invert(_this.yScale(d)));}
	          
	          this.line = d3.svg.line()
	            .x(function(d) { return _this.xScale(d); })
	            .y(function(d) { return _this.yScale(d); });
	
	          this.lineInvert = d3.svg.line()
	            .x(function(d) { return _this.xInvert(d); })
	            .y(function(d) { return _this.yInvert(d); });
	
	          //component events
	          this.on("resize", function() {
	            _this.update();
	          })
	        },
	
	        /*
	         * Both model and DOM are ready
	         */
	        ready: function() {
	          console.log("Model ready");
	          this.initScales();
	          this.update();
	        },
	        
	        initScales: function() {
	          var _this = this;
	
	          var domain = this.model.scales.domain;
	
	          this.xScale = d3.scale[this.model.scales.xScaleType]();
	          this.yScale = d3.scale[this.model.scales.yScaleType]();
	
	          this.xScale.domain(domain);
	
	          this.yScale.domain(domain);
	
	          this.mockData = d3.range(domain[0], domain[domain.length - 1], (domain[domain.length - 1] - domain[0]) / 10000);
	          this.mockData.push(domain[domain.length - 1]);
	        },
	
	
	
	        update: function() {
	          var _this = this;
	
	          var margin = this.model.show.toolMargin.getPlainObject();
	
	          //stage
	          var height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          var width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	          
	          if(height<=0 || width<=0) return warn("Axis Labeler update() call interrupted for Vizabi container is too little or has display:none");
	
	          //graph group is shifted according to margins (while svg element is at 100 by 100%)
	          this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	          //update scales to the new range
	          var xLength = this.xScale.domain().length;
	          var yLength = this.yScale.domain().length;
	          this.xScale.range(d3.range(xLength).map(function(n) { return width/(xLength-1) * n })) //.nice();
	          this.yScale.range(d3.range(yLength).map(function(n) { return height/(yLength-1) * n }).reverse()) //.nice();
	
	          this.xAxis.scale(this.xScale)
	            .orient("bottom")
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.scales.xScaleType,
	              toolMargin: margin
	            });
	
	          this.yAxis.scale(this.yScale)
	            .orient("left")
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.scales.yScaleType,
	              toolMargin: margin
	            });
	
	
	
	          this.xAxisEl.attr("transform", "translate(0," + height + ")");
	          this.xAxisEl.call(this.xAxis);
	          this.yAxisEl.call(this.yAxis);
	
	          //TODO: remove. make font sizing through plain CSS
	          //this.xAxisEl.selectAll("text").style('font-size',this.model.show.labelSize);
	          //this.yAxisEl.selectAll("text").style('font-size',this.model.show.labelSize);
	
	
	          var path = this.graph.selectAll(".vzb-al-line").data([0]);
	          path.enter().append("path")
	            .attr("class", "vzb-al-line")
	          path.datum(this.mockData).attr("d", this.line);
	          
	          var pathInvert = this.graph.selectAll(".vzb-al-line-invert").data([0]);
	          pathInvert.enter().append("path")
	            .attr("class", "vzb-al-line-invert")
	          pathInvert.datum(this.mockData).attr("d", this.lineInvert);
	          
	          var format = d3.format(".4r");
	
	          var dots = this.graph.selectAll(".vzb-al-dots").data(this.mockData);
	          dots.enter().append("circle")
	            .attr("class", "vzb-al-dots")
	            .attr("r", 5)
	            .on("mouseenter", function(d, i){
	              console.log("Point #" + i + ": " + d + " x=" + format(_this.xScale(d)) + " y=" + format(_this.yScale(d)))
	            });
	          dots.exit().remove();
	          dots.attr("cx", function(d) {
	              return _this.xScale(d)
	            })
	            .attr("cy", function(d) {
	              return _this.yScale(d)
	            });
	          
	          var dotsInvert = this.graph.selectAll(".vzb-al-dots-invert").data(this.mockData);
	          dotsInvert.enter().append("circle")
	            .attr("class", "vzb-al-dots-invert")
	            .attr("r", 5)
	            .on("mouseenter", function(d, i){
	              console.log("Point #" + i + ": " + d + " x=" + format(_this.xScale(d)) + " y=" + format(_this.yScale(d)))
	            });
	          dotsInvert.exit().remove();
	          dotsInvert.attr("cx", function(d) {
	              return _this.xInvert(d)
	            })
	            .attr("cy", function(d) {
	              return _this.yInvert(d)
	            });
	        }
	      });
	
	      var listPointer = 0;
	      var listData = [
	          [-123, 123],
	          [1.00000, 10000.0],
	          [4.00000, 123.000],
	          [0.00060, 123.000],
	          [123.000, 4.00000],
	          [123.000, 0.00060],
	          [-123.00, -4.0000],
	          [-123.00, -0.0006],
	          [-4.0000, -123.00],
	          [-0.0006, -123.00],
	          [-123.00, 1800.00],
	          [1800.00, -123.00],
	          [123.000, -18000.],
	          [-18000., 123.000],
	          [-0.0006, 1800.00],
	          [1800.00, -0.0006],
	          [0.00060, -1800.0],
	          [-1800.0, 0.00060],
	          [-12.000, -2.0000],
	          [-80.000, 40.0000],
	          [5.00000, 8.00000],
	          [42.0000, 42.0000],
	          [0.00000000005, 4554545484715],
	          [-2611968678575, 4554545484715],
	          [-0.0020, 0.00200],
	          [-123, -0.1, 0.002, 1540],
	          [-123, -0.001, 0.5, 1540],
	          [123, 0.1, -0.002, -1540],
	          [123, 0.001, -0.5, -1540]
	      ];
	
	      //AXIS LABELER TOOL
	      var AxisLabeler = Tool.extend('AxisLabeler', {
	
	        /**
	         * Initializes the tool (Bar Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	
	          this.name = "axislabeler";
	
	          //specifying components
	          this.components = [{
	            component: AxisLabelerComponent,
	            placeholder: '.vzb-tool-viz',
	            model: ["state.scales", "state.show"] //pass models to component
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        },
	
	        default_model: {
	          state: {
	            scales:{
	                domain: listData[listPointer],
	                xScaleType: 'linear',
	                yScaleType: 'genericLog'
	            },
	            show:{
	                labelSize: "16px",
	                labelMargin: {LR: "5px", TB: "5px"},
	                toolMargin: {top: 30, right: 20, left: 40, bottom: 40}
	            }
	
	          },
	          data: {noConceptprops: true}
	        }
	      });
	
	      /*!
	       * VIZABI POP BY AGE Component
	       */
	
	
	      //POP BY AGE CHART COMPONENT
	      var AgePyramid$1 = Component.extend({
	
	        /**
	         * Initializes the component (Bar Chart).
	         * Executed once before any template is rendered.
	         * @param {Object} config The config passed to the component
	         * @param {Object} context The component's parent
	         */
	        init: function(config, context) {
	          this.name = 'agepyramid';
	          this.template = 'agepyramid.html';
	
	          //define expected models for this component
	          this.model_expects = [{
	            name: "time",
	            type: "time"
	          }, {
	            name: "entities",
	            type: "entities"
	          }, {
	            name: "side",
	            type: "entities"
	          }, {
	            name: "stack",
	            type: "entities"
	          }, {
	            name: "age",
	            type: "entities"
	          }, {
	            name: "marker",
	            type: "model"
	          }, {
	            name: "marker_side",
	            type: "model"
	          }, {
	            name: "language",
	            type: "language"
	          }, {
	            name: "ui",
	            type: "model"
	          }];
	
	          var _this = this;
	          this.model_binds = {
	            "change:time.value": function(evt) {
	              if (!_this._readyOnce) return;
	              if(_this.model.time.step != 1 && !_this.snapped && !_this.model.time.playing && !_this.model.time.dragging) {
	                var next = d3.bisectLeft(_this.timeSteps, _this.model.time.value);
	                if(next != 0 && (_this.timeSteps[next] - _this.model.time.value)) {
	                  _this.snapped = true;
	                  var time = _this.model.time.value;
	                  var prev = _this.timeSteps[next - 1];
	                  var next = _this.timeSteps[next];
	                  var snapTime = (time - prev) < (next - time) ? prev : next;
	                  _this.model.time.value = new Date(snapTime); 
	                }
	              }
	              if(!_this.snapped) _this._updateEntities();
	              _this.snapped = false;
	            },
	            "change:entities.show": function(evt) {
	              console.log('Trying to change show');
	            },
	            "change:stack.select": function(evt) {
	              _this._selectBars();
	            },
	            "change:marker.color.palette": function (evt) {
	              if (!_this._readyOnce) return;
	              _this._updateEntities();
	            },
	            "change:marker.color.scaleType":function (evt) {
	              if (!_this._readyOnce) return;
	              _this._updateEntities();
	            },
	            "change:ui.chart.inpercent":function (evt) {
	              if (!_this._readyOnce) return;
	              _this._updateLimits();
	              _this.resize();
	              _this._updateEntities();
	            }
	          };
	
	          //contructor is the same as any component
	          this._super(config, context);
	
	          this.xScale = null;
	          this.yScale = null;
	          this.cScale = null;
	
	          this.xAxis = axisSmart();
	          this.xAxisLeft = axisSmart();
	          this.yAxis = axisSmart();
	          this.xScales = [];
	          
	          this.totalFieldName = "Total";
	        },
	
	        // afterPreload: function() {
	        //   var obj = {};
	        //   obj["which"] = this.model.marker.axis_x.which;
	        //   obj["use"] = this.model.marker.axis_x.use;
	        //   this.model.marker_side.hook_total.set(obj);
	        // },
	        
	        /**
	         * DOM is ready
	         */
	        readyOnce: function() {
	
	          this.el = (this.el) ? this.el : d3.select(this.element);
	          this.element = this.el;
	          
	          this.interaction = this._interaction();
	
	          this.graph = this.element.select('.vzb-bc-graph');
	          this.yAxisEl = this.graph.select('.vzb-bc-axis-y');
	          this.xAxisEl = this.graph.select('.vzb-bc-axis-x');
	          this.xAxisLeftEl = this.graph.select('.vzb-bc-axis-x-left');
	          this.yTitleEl = this.graph.select('.vzb-bc-axis-y-title');
	          this.barsCrop = this.graph.select('.vzb-bc-bars-crop');
	          this.bars = this.graph.select('.vzb-bc-bars');
	          this.labels = this.graph.select('.vzb-bc-labels');
	
	          this.title = this.element.select('.vzb-bc-title');
	          this.titleRight = this.element.select('.vzb-bc-title-right');
	          this.year = this.element.select('.vzb-bc-year');
	
	          //only allow selecting one at a time
	          this.model.age.selectMultiple(true);
	
	          var _this = this;
	          this.on("resize", function() {
	            _this._updateEntities();
	          });
	        },
	
	        /*
	         * Both model and DOM are ready
	         */
	        ready: function() {
	
	          this.timeSteps = this.model.time.getAllSteps();
	
	          this.shiftScale = d3.scale.linear()
	            .domain([this.timeSteps[0], this.timeSteps[this.timeSteps.length - 1]])
	            .range([0, this.timeSteps.length - 1]);
	
	          this.SIDEDIM = this.model.marker.side.which;//this.model.side.getDimension();
	          //this.STACKDIM = this.model.marker.color.which;
	          this.STACKDIM = this.model.stack.getDimension() || this.model.marker.color.which;
	          this.AGEDIM = this.model.age.getDimension();
	          this.TIMEDIM = this.model.time.getDimension();
	
	          this.updateUIStrings();
	          this._updateIndicators();
	          this._updateLimits();
	          this._createStepData(this.model.marker.axis_x);
	
	          this.resize();
	          this._updateEntities();
	          this._selectBars();
	        },
	
	        updateUIStrings: function() {
	          this.translator = this.model.language.getTFunction();
	
	          var titleStringY = this.translator("indicator/" + this.model.marker.axis_y.which);
	
	          var yTitle = this.yTitleEl.selectAll("text").data([0]);
	          yTitle.enter().append("text");
	          yTitle
	            .attr("y", "-6px")
	            .attr("x", "-9px")
	            .attr("dx", "-0.72em")
	            .text(titleStringY);
	        },
	
	        /**
	         * Changes labels for indicators
	         */
	        _updateIndicators: function() {
	          var _this = this;
	          this.duration = this.model.time.delayAnimations;
	          this.yScale = this.model.marker.axis_y.getScale();
	          this.xScale = this.model.marker.axis_x.getScale(false);
	          this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());
	          this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());
	          this.xAxisLeft.tickFormat(_this.model.marker.axis_x.getTickFormatter());
	          
	          var sideDim = this.SIDEDIM;
	          var stackDim = this.STACKDIM;
	          var ageDim = this.AGEDIM;
	          var group_by = this.model.age.grouping || 1;
	
	          var ages = this.model.marker.getKeys(ageDim);
	          var ageKeys = [];
	          ageKeys = ages.map(function(m) {
	              return m[ageDim];
	            });
	          this.ageKeys = ageKeys;
	
	          this.shiftedAgeKeys = this.timeSteps.map(function(m, i) {return -i * group_by;}).slice(1).reverse().concat(ageKeys);
	
	          var sides = this.model.marker.getKeys(sideDim);
	          var sideKeys = [];
	          sideKeys = sides.map(function(m) {
	              return m[sideDim];
	            });
	            
	          var sideFilter = this.model.side.getFilter;
	          if(sideFilter[sideDim] && sideFilter[sideDim][0] != "*") {
	            sideKeys = sideKeys.filter(function(m) {
	              var f = {};
	              f[sideDim] = m;
	              return _this.model.side.isShown(f);
	            });
	          }
	
	          if(sideKeys.length > 1) {
	            var sortFunc = this.ui.chart.flipSides ? d3.ascending : d3.descending; 
	            sideKeys.sort(sortFunc);
	          }
	          if(sideKeys.length > 2) sideKeys.length = 2;
	
	          this.sideKeys = sideKeys;
	
	          var stacks = this.model.marker.getKeys(stackDim);
	          var stackKeys = [];
	          var stackKeys = without(stacks.map(function(m) {
	            if(m[stackDim] == _this.totalFieldName) _this.dataWithTotal = true;
	            return m[stackDim];
	          }), this.totalFieldName);
	
	          var sortedStackKeys = keys(this.model.marker.color.getPalette()).reduce(function(arr, val) {
	            if(stackKeys.indexOf(val) != -1) arr.push(val);
	            return arr;
	          }, []);
	
	          if(sortedStackKeys.length != stackKeys.length) {
	            sortedStackKeys = stackKeys.reduce(function(arr, val) {
	              if(arr.indexOf(val) == -1) arr.push(val);
	              return arr;
	            }, sortedStackKeys);
	          }
	          this.stackKeys = sortedStackKeys;
	
	          this.stacked = this.ui.chart.stacked && this.model.marker.color.use != "constant" && this.model.stack.getDimension();
	          
	          this.twoSided = this.sideKeys.length > 1; 
	          if(this.twoSided) {
	            this.xScaleLeft = this.xScale.copy();
	            this.title.text(this.sideKeys[1]);    
	            this.titleRight.text(this.sideKeys[0]);
	          } else {
	            var title = this.translator("indicator/" + this.model.marker.axis_x.which);
	            this.title.text(title);
	          }
	
	          this.cScale = this.model.marker.color.getScale();
	
	        },
	
	        _updateLimits: function() {
	          var _this = this; 
	          var limits, domain;
	          var axisX = this.model.marker.axis_x;
	          if(this.ui.chart.inpercent) {
	            limits = axisX.getLimitsByDimensions([this.SIDEDIM, this.TIMEDIM, this.AGEDIM, this.STACKDIM]);      
	            var totalLimits = this.model.marker_side.hook_total.getLimitsByDimensions([this.SIDEDIM, this.TIMEDIM]);
	            var totalCoeff = this.dataWithTotal ? .5 : 1;
	            var timeKeys = axisX.getUnique();
	            var maxLimits = []; 
	            forEach(_this.sideKeys, function(key) {
	              forEach(timeKeys, function(time) {
	                forEach(_this.ageKeys, function(age) {
	                  var stackSum = 0;
	                  forEach(_this.stackKeys, function(stack) {
	                    if (limits[key][time][age][stack])
	                      stackSum += limits[key][time][age][stack].max;
	                  });
	                  maxLimits.push(stackSum / (totalLimits[key][time].max * totalCoeff));
	                });          
	              });
	            });
	            domain = [0, Math.max.apply(Math, maxLimits)];
	          } else {
	            limits = axisX.getLimitsByDimensions([this.SIDEDIM, this.TIMEDIM, this.AGEDIM, this.STACKDIM]);
	            var timeKeys = axisX.getUnique();
	            var maxLimits = []; 
	            forEach(_this.sideKeys, function(key) {
	              forEach(timeKeys, function(time) {
	                forEach(_this.ageKeys, function(age) {
	                  var stackSum = 0;
	                  forEach(_this.stackKeys, function(stack) {
	                    if (limits[key][time][age][stack])
	                      stackSum += limits[key][time][age][stack].max;
	                  });
	                  maxLimits.push(stackSum);
	                });          
	              });
	            });
	                  
	            domain = (axisX.domainMin!=null && axisX.domainMax!=null) ? [+axisX.domainMin, +axisX.domainMax] : [0, Math.max.apply(Math, maxLimits)];
	          }
	          this.xScale.domain(domain);
	          if(this.xScaleLeft) this.xScaleLeft.domain(this.xScale.domain());
	        },
	
	        getShiftedValues: function(hook, time) {
	
	          var iterateGroupKeys = function(data, deep, result, cb) {
	              deep--;
	              forEach(data, function(d, id) {
	                if(deep) {
	                  result[id] = {};
	                  iterateGroupKeys(d, deep, result[id], cb);
	                } else {
	                  cb(d, result, id);
	                }
	              });
	            }
	
	          var which = hook.which;
	          var use = hook.use;
	          var dimTime = this.TIMEDIM;
	          var response = {};
	          var method = hook.getConceptprops ? hook.getConceptprops().interpolation : null;
	
	          iterateGroupKeys(this.stepData, this.stepDataDeep, response, function(arr, result, id) {
	            var next = d3.bisectLeft(arr.map(function(m){return m[dimTime]}), time);
	                
	            var value = interpolatePoint(arr, use, which, next, dimTime, time, method);
	            result[id] = hook.mapValue(value);
	          });
	
	          return response;
	        },
	
	        _createStepData: function(hook) {
	          var _this = this;
	          var timeDim = this.TIMEDIM;
	          var sideDim = this.SIDEDIM;
	          var stackDim = this.STACKDIM;
	          var ageDim = this.AGEDIM;
	
	          this.stepData = {};
	
	          var ageShift = 0;
	          var group_by = this.model.age.grouping || 1;
	
	          var groupArray = [ageDim, sideDim, stackDim];
	          this.stepDataDeep = groupArray.length; 
	
	          forEach(this.timeSteps, function(time, i) {
	            var filter = {};
	            filter[timeDim] = time;
	            var values = _this.model.marker.getValues(filter, groupArray).axis_x;
	            var stepData = _this.stepData[time] = {};
	            forEach(_this.shiftedAgeKeys, function(key) {
	              var shiftedKey = +key + ageShift;
	              var value = values[shiftedKey];
	              if(!value) {
	                if(shiftedKey < 0) {
	                  value = values[0];
	                } else {
	                  stepData["null"] = values[0];
	                }
	              }
	              stepData[key] = value;
	            });
	            ageShift += group_by;
	          });
	
	          var stepData = this.stepData;
	          var stepDataMoved = {};          
	          var which = hook.which;
	          var use = hook.use;
	          forEach(stepData, function(time, timeKey) {
	            forEach(time, function(age, ageKey) {
	              var allToNull = false;
	              if(ageKey == "null") return;
	              if(!age && age != 0) {
	                age = stepData[timeKey]["null"];
	                allToNull = true;
	              }
	              forEach(age, function(side, sideKey) {
	                forEach(side, function(value, stackKey) {
	                  var age = stepDataMoved[ageKey] || {};
	                  var side = age[sideKey] || {};
	                  var stack = side[stackKey] || [];
	                  var point = {};
	                  point[timeDim] = new Date(timeKey);
	                  point[which] = allToNull ? 0 : value;
	                  stack.push(point);
	                  side[stackKey] = stack;
	                  age[sideKey] = side;
	                  stepDataMoved[ageKey] = age;
	                })
	              })
	            })
	          });
	
	          this.stepData = stepDataMoved;
	        },
	
	        /**
	         * Updates entities
	         */
	        _updateEntities: function() {
	
	          var _this = this;
	          var time = this.model.time;
	          var sideDim = this.SIDEDIM;
	          var ageDim = this.AGEDIM;
	          var stackDim = this.STACKDIM;
	          var timeDim = this.TIMEDIM;
	          var duration = (time.playing) ? time.delayAnimations : 0;
	
	          var shiftedValues = this.getShiftedValues(this.model.marker.axis_x, time.value);
	
	          var group_by = this.model.age.grouping || 1;
	          //var group_offset = this.model.marker.group_offset ? Math.abs(this.model.marker.group_offset % group_by) : 0;
	
	          if(this.ui.chart.inpercent) {
	            var filter = {};
	            filter[timeDim] = time.value;
	            
	            this.totalValues = this.model.marker_side.getValues(filter,[this.SIDEDIM]).hook_total;
	            if(this.dataWithTotal) {
	              forEach(this.sideKeys, function(key) {
	                _this.totalValues[key] *= .5;
	              });
	            }
	          } 
	
	          // var filter = {};
	          // filter[timeDim] = time.value;
	          var markers = this.model.marker.getKeys(ageDim);
	
	          //_this.values1 = this.model.marker.getValues(filter,[ ageDim, sideDim, stackDim]);
	          //var values = this.model.marker.getValues(filter,[this.AGEDIM]);
	          var domain = this.yScale.domain();
	               
	          this.model.age.setVisible(markers);
	
	          var nextStep = d3.bisectLeft(this.timeSteps, time.value);
	
	          var shiftedAgeDim = "s_age"; 
	
	          // var ageBars = this.shiftedAgeKeys.map(function(shiftedKey) {
	          //   var data = {};
	          //   data[shiftedAgeDim] = shiftedKey;
	          //   data[ageDim] = data[shiftedAgeDim] + nextStep * group_by;
	          // });
	
	          var ageBars = markers.map(function(data) {
	            data[shiftedAgeDim] = +data[ageDim];
	            data[ageDim] = data[shiftedAgeDim] - nextStep * group_by;
	            return data;
	          })
	
	          //var ageBars = [{}].concat(ageBars);
	          //ageBars[0][shiftedAgeDim] = ageBars[1][shiftedAgeDim] - group_by;
	          //ageBars[0][ageDim] = ageBars[1][ageDim];
	
	          var outAge = {};
	          outAge[shiftedAgeDim] = markers.length * group_by;
	          outAge[ageDim] = outAge[shiftedAgeDim] - nextStep * group_by;
	
	          if (nextStep) ageBars.push(outAge);
	
	          this.entityBars = this.bars.selectAll('.vzb-bc-bar')
	            .data(ageBars, function(d) {return d[ageDim]});
	
	          this.entityLabels = this.labels.selectAll('.vzb-bc-label')
	            .data(markers);
	
	          //exit selection
	          this.entityBars.exit().remove();
	          this.entityLabels.exit().remove();
	
	          //var highlight = this._highlightBar.bind(this);
	          //var unhighlight = this._unhighlightBars.bind(this)
	
	          var one_bar_height = this.height / (domain[1] - domain[0]);
	          var bar_height = one_bar_height * group_by; // height per bar is total domain height divided by the number of possible markers in the domain
	          var first_bar_y_offset = this.height - bar_height;
	
	          //enter selection -- init bars
	          this.entityBars.enter().append("g")
	            .attr("class", function(d) {
	              return "vzb-bc-bar " + "vzb-bc-bar-" + d[ageDim];
	            })
	            // .on("mouseover", highlight)
	            // .on("mouseout", unhighlight)
	            // .on("click", function(d, i) {
	            //   if(utils.isTouchDevice()) return;
	            //   _this.model.age.selectEntity(d);
	            // })
	            // .onTap(function(d) {
	            //   d3.event.stopPropagation();
	            //   _this.model.age.selectEntity(d);
	            // })
	
	          this.entityBars.attr("class", function(d) {
	              return "vzb-bc-bar " + "vzb-bc-bar-" + d[ageDim];
	            })
	
	
	          this.sideBars = this.entityBars.selectAll('.vzb-bc-side').data(function(d) {
	            return _this.sideKeys.map(function(m) {
	                var r = {};    
	                r[ageDim] = d[ageDim];
	                r[shiftedAgeDim] = d[shiftedAgeDim];
	                r[sideDim] = m;
	                return r;
	              });
	            })
	          
	          this.sideBars.exit().remove();  
	          this.sideBars.enter().append("g")
	              .attr("class", function(d, i) {
	                return "vzb-bc-side " + "vzb-bc-side-" + (!i != !_this.twoSided ? "right": "left");
	              })
	              
	          var stackBars = this.sideBars.selectAll('.vzb-bc-stack').data(function(d,i) {
	                var stacks = _this.stacked ? _this.stackKeys : [_this.totalFieldName];
	                return stacks.map(function(m) {
	                  var r = {};
	                  r[ageDim] = d[ageDim];
	                  r[shiftedAgeDim] = d[shiftedAgeDim];
	                  r[sideDim] = d[sideDim];
	                  r[stackDim] = m;
	                  return r;  
	                });
	              })
	              
	          stackBars.exit().remove();    
	          stackBars.enter().append("rect")
	                .attr("class", function(d, i) {
	                  return "vzb-bc-stack " + "vzb-bc-stack-" + i + (_this.highlighted ? " vzb-dimmed" : "");
	                })
	                .attr("y", 0)
	                .on("mouseover", _this.interaction.highlightBar)
	                .on("mouseout", _this.interaction.unhighlightBars)
	                .on("click", function(d, i) {
	                  if(isTouchDevice()) return;
	                  _this.model.stack.selectEntityMD(d);
	                })
	                .onTap(function(d) {
	                  d3.event.stopPropagation();
	                  _this.model.stack.selectEntityMD(d);
	                });
	              
	          this.stackBars = this.bars.selectAll('.vzb-bc-bar')
	            .selectAll('.vzb-bc-side')
	              .attr("transform", function(d, i) {
	                return i ? ("scale(-1,1) translate(" + _this.activeProfile.centerWidth + ",0)") : "";
	              })
	            .selectAll('.vzb-bc-stack')
	              .attr("height", bar_height)
	              .attr("fill", function(d) {
	                //return _this._temporaryBarsColorAdapter(values, d, ageDim);
	                //return _this.cScale(values.color[d[ageDim]]);
	                return _this.cScale(d[stackDim]);
	              })
	              //.attr("shape-rendering", "crispEdges") // this makes sure there are no gaps between the bars, but also disables anti-aliasing
	              .each(function(d, i) {
	                var total = _this.ui.chart.inpercent ? _this.totalValues[d[sideDim]] : 1;
	                var sum = 0;
	                if(_this.stacked) {
	                  sum = shiftedValues[d[ageDim]][d[sideDim]][d[stackDim]];
	                } else {
	                  var stacksData = shiftedValues[d[ageDim]][d[sideDim]];
	                  forEach(stacksData, function(val) {
	                    sum += val; 
	                  });
	                }
	                //var prevWidth = +this.getAttribute("width");
	                d["width_"] = _this.xScale(sum / total);
	                //d3.select(this).classed("vzb-hidden", d["width_"] < 1 && prevWidth < 1);
	
	                var prevSbl = this.previousSibling;
	                if(prevSbl) {
	                  var prevSblDatum = d3.select(prevSbl).datum();
	                  d["x_"] = prevSblDatum.x_ + prevSblDatum.width_;          
	                } else {
	                  d["x_"] = 0;
	                }
	              });
	
	          var stepShift = (ageBars[0][shiftedAgeDim] - ageBars[0][ageDim]) - this.shiftScale(time.value) * group_by; 
	
	          this.bars.selectAll('.vzb-bc-bar')
	            .attr("transform", function(d, i) {
	              var _d = d[shiftedAgeDim] < 0 ? 0 : d[ageDim] - group_by;
	              return "translate(0," + (first_bar_y_offset - (d[shiftedAgeDim] - group_by - domain[0]) * one_bar_height) + ")";
	            })
	            .transition('age')
	            .duration(duration)
	            .ease("linear")
	            .attr("transform", function(d, i) {
	              return "translate(0," + (first_bar_y_offset - (d[shiftedAgeDim] - domain[0] - stepShift) * one_bar_height) + ")";
	            })
	
	          this.stackBars.interrupt().transition().duration(duration*.95).ease("linear")
	              .attr("width", function(d, i) {
	                return d.width_;
	              })    
	              .attr("x", function(d, i){
	                return d.x_;
	              });
	
	          // this.sideBars.selectAll(":not(.vzb-hidden)").interrupt().transition().duration(duration*.95).ease("linear")
	          //   .attr("width", function(d, i) {
	          //     return d.width_;
	          //   })    
	          //   .attr("x", function(d, i){
	          //     return d.x_;
	          //   });
	
	          // this.sideBars.selectAll(".vzb-hidden").interrupt()
	          //   .attr("width", function(d, i) {
	          //     return d.width_;
	          //   })    
	          //   .attr("x", function(d, i){
	          //     return d.x_;
	          //   });
	
	       
	          this.entityLabels.enter().append("g")
	            .attr("class", "vzb-bc-label")
	            .attr("id", function(d) {
	              return "vzb-bc-label-" + d[shiftedAgeDim];
	            })
	            .append('text')
	            .attr("class", "vzb-bc-age");
	
	          this.labels.selectAll('.vzb-bc-label > .vzb-bc-age')
	            .each(function(d, i) {
	              var yearOlds = _this.translator("agepyramid/yearOlds");
	
	              var age = parseInt(d[ageDim], 10);
	
	              if(group_by > 1) {
	                age = age + "-to-" + (age + group_by - 1);
	              }
	
	              d["text"] = age + yearOlds;
	            })
	            .attr("y", function(d, i) {
	              return first_bar_y_offset - (d[shiftedAgeDim] - domain[0]) * one_bar_height - 10;
	            });
	            // .style("fill", function(d) {
	            //   var color = _this.cScale(values.color[d[ageDim]]);
	            //   return d3.rgb(color).darker(2);
	            // });
	          
	          if(duration) {
	            this.year.transition().duration(duration).ease("linear")
	              .each("end", this._setYear(time.value));
	          } else {
	            this.year.interrupt().text(time.timeFormat(time.value));
	          }
	            
	
	          //update x axis again
	          //TODO: remove this when grouping is done at data level
	          //var x_domain = this.xScale.domain();
	          //var x_domain_max = Math.max.apply(null, utils.values(values.axis_x));
	          //if(x_domain_max > this.xScale.domain()[1]) this.xScale = this.xScale.domain([x_domain[0], x_domain_max]);
	          this._selectBars();
	        },
	
	        _setYear: function(timeValue) {
	            var year = this.model.time.timeFormat(timeValue);
	            return function() { d3.select(this).text(year);};
	        },
	        // _temporaryBarsColorAdapter: function(values, d, ageDim) {
	        //   return this.cScale(values.color[d[ageDim]]);
	        // },
	
	        
	        _interaction: function() {
	          var _this = this; 
	        /**
	         * Highlight and unhighlight labels
	         */
	          return {
	            unhighlightBars: function() {
	              if(isTouchDevice()) return;
	
	              _this.highlighted = false;
	                
	              _this.stackBars.classed('vzb-dimmed', false).classed('vzb-hovered', false);
	              _this.labels.selectAll('.vzb-hovered').classed('vzb-hovered', false);
	
	            },
	
	            highlightBar: function(d) {
	              if(isTouchDevice()) return;
	
	              _this.highlighted = true;
	                
	              var formatter = _this.ui.chart.inpercent ? d3.format(".1%") : _this.model.marker.axis_x.getTickFormatter();
	              var sideDim = _this.SIDEDIM;
	              var ageDim = _this.AGEDIM;
	              var stackDim = _this.STACKDIM;
	              var shiftedAgeDim = "s_age"; 
	            
	              _this.stackBars.classed('vzb-dimmed', true);
	              var curr = d3.select(this); 
	              //_this.bars.select("#vzb-bc-bar-" + d[this.AGEDIM]);
	              curr.classed('vzb-hovered', true);
	              var left = _this.sideKeys.indexOf(d[sideDim]);
	              var label = _this.labels.select("#vzb-bc-label-" + d[shiftedAgeDim]);
	              label.selectAll('.vzb-bc-age')
	                .text(function(textData) { 
	                  //var total = _this.ui.chart.inpercent ? _this.totalValues[d[sideDim]] : 1;
	                  var text = _this.stackKeys.length > 1 ? d[stackDim]: textData.text;
	                  text = _this.twoSided ? text : textData.text + " " + d[stackDim];
	                  var value = _this.xScale.invert(d["width_"]); 
	                  //var value = (_this.dataWithTotal || _this.stacked) ? _this.values1.axis_x[d[shiftedAgeDim]][d[sideDim]][d[stackDim]] / total : _this.xScale.invert(d["width_"]); 
	                  return text + ": " + formatter(value);
	                })
	                .attr("x", (left?-1:1) * (_this.activeProfile.centerWidth * .5 + 7))
	                .classed("vzb-text-left", left);
	              
	              label.classed('vzb-hovered', true);
	            }
	          }
	        },
	
	        /**
	         * Select Entities
	         */
	        _selectBars: function() {
	          var _this = this;
	          var stackDim = this.STACKDIM;
	          var ageDim = this.AGEDIM;
	          var sideDim = this.SIDEDIM;
	          var selected = this.model.stack.select;
	
	          this._unselectBars();
	
	          if(selected.length) {
	            this.stackBars.classed('vzb-dimmed-selected', true);
	            forEach(selected, function(d) {
	              var indexSide = _this.stacked ? _this.sideKeys.indexOf(d[sideDim]) : 0;
	              var indexStack = _this.stacked ? _this.stackKeys.indexOf(d[stackDim]) : 0;
	              var side = _this.twoSided != !indexSide ? "left": "right";
	              _this.bars.selectAll(".vzb-bc-bar-" + d[ageDim]).selectAll(".vzb-bc-side-" + side).selectAll(".vzb-bc-stack-" + indexStack).classed('vzb-selected', true);
	              //_this.labels.select("#vzb-bc-label-" + d[ageDim]).classed('vzb-selected', true);
	            });
	          }
	        },
	
	        _unselectBars: function() {
	          this.stackBars.classed('vzb-dimmed-selected', false);
	          this.stackBars.classed('vzb-selected', false);
	          //this.labels.selectAll('.vzb-selected').classed('vzb-selected', false);
	        },
	
	        /**
	         * Executes everytime the container or vizabi is resized
	         * Ideally,it contains only operations related to size
	         */
	
	
	        presentationProfileChanges: {
	          medium: {
	            margin: { right: 80, bottom: 80 },
	            infoElHeight: 32
	          },
	          large: {
	            margin: { top: 100, right: 100, left: 100, bottom: 80 },
	            infoElHeight: 32
	          }
	        },
	
	        profiles: {
	          "small": {
	            margin: {
	              top: 70,
	              right: 20,
	              left: 40,
	              bottom: 40
	            },
	            minRadius: 2,
	            maxRadius: 40,
	            centerWidth: 2,
	            titlesSpacing: 5
	          },
	          "medium": {
	            margin: {
	              top: 80,
	              right: 60,
	              left: 60,
	              bottom: 40
	            },
	            minRadius: 3,
	            maxRadius: 60,
	            centerWidth: 2,
	            titlesSpacing: 10
	          },
	          "large": {
	            margin: {
	              top: 100,
	              right: 60,
	              left: 60,
	              bottom: 40
	            },
	            minRadius: 4,
	            maxRadius: 80,
	            centerWidth: 2,
	            titlesSpacing: 20
	          }
	        },
	
	        resize: function() {
	
	          var _this = this;
	
	          this.activeProfile = this.getActiveProfile(this.profiles, this.presentationProfileChanges);
	
	          //this.activeProfile = this.profiles[this.getLayoutProfile()];
	          var margin = this.activeProfile.margin;
	
	          //stage
	          this.height = (parseInt(this.element.style("height"), 10) - margin.top - margin.bottom) || 0;
	          this.width = (parseInt(this.element.style("width"), 10) - margin.left - margin.right) || 0;
	            
	          if(this.height<=0 || this.width<=0) return warn("Pop by age resize() abort: vizabi container is too little or has display:none");
	
	          this.graph
	            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	          this.barsCrop
	            .attr("width", this.width)
	            .attr("height", this.height);
	
	          //update scales to the new range
	          if(this.model.marker.axis_y.scaleType !== "ordinal") {
	            this.yScale.range([this.height, 0]);
	          } else {
	            this.yScale.rangePoints([this.height, 0]).range();
	          }
	
	          var maxRange = this.twoSided ? ((this.width - this.activeProfile.centerWidth) * .5) : this.width; 
	          
	          if(this.model.marker.axis_x.scaleType !== "ordinal") {
	            this.xScale.range([0, maxRange]);
	          } else {
	            this.xScale.rangePoints([0, maxRange]).range();
	          }
	
	          //apply scales to axes and redraw
	          this.yAxis.scale(this.yScale)
	            .orient("left")
	            .tickSize(6, 6)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_y.scaleType,
	              toolMargin: margin,
	              limitMaxTickNumber: 19
	            });
	
	          var group_by = this.model.age.grouping || 1;
	        
	          var format = this.ui.chart.inpercent ? d3.format((group_by > 3 ? "":".1") + "%") : this.model.marker.axis_x.getTickFormatter();  
	
	          this.xAxis.scale(this.xScale)
	            .orient("bottom")
	            .tickFormat(format)
	            .tickSize(6, 0)
	            .tickSizeMinor(3, 0)
	            .labelerOptions({
	              scaleType: this.model.marker.axis_x.scaleType,
	              toolMargin: margin,
	              limitMaxTickNumber: 6
	            });
	            
	          var translateX = this.twoSided ? ((this.width + _this.activeProfile.centerWidth) * .5) : 0;
	
	          this.xAxisEl.attr("transform", "translate(" + translateX + "," + this.height + ")")
	            .call(this.xAxis);
	
	          this.yAxisEl.attr("transform", "translate(" + 0 + ",0)")
	            .call(this.yAxis);
	          //this.xAxisEl.call(this.xAxis);
	
	          if(this.xScaleLeft) {
	            if(this.model.marker.axis_x.scaleType !== "ordinal") {
	              this.xScaleLeft.range([(this.width - this.activeProfile.centerWidth) * .5, 0]);
	            } else {
	              this.xScaleLeft.rangePoints([(this.width - this.activeProfile.centerWidth) * .5, 0]).range();
	            }
	
	            this.xAxisLeft.scale(this.xScaleLeft)
	              .orient("bottom")
	              .tickFormat(format)
	              .tickSize(6, 0)
	              .tickSizeMinor(3, 0)
	              .labelerOptions({
	                scaleType: this.model.marker.axis_x.scaleType,
	                toolMargin: margin,
	                limitMaxTickNumber: 6
	              });
	
	            this.xAxisLeftEl.attr("transform", "translate(0," + this.height + ")")
	              .call(this.xAxisLeft);
	          }    
	          
	          this.bars.attr("transform", "translate(" + translateX + ",0)");
	          this.labels.attr("transform", "translate(" + translateX + ",0)");
	
	          this.title
	            .attr('x', margin.left + (this.twoSided ? translateX - this.activeProfile.titlesSpacing : 0))
	            .style('text-anchor', this.twoSided ? "end":"null")
	            .attr('y', margin.top / 2);
	          this.titleRight
	            .attr('x', margin.left + translateX + this.activeProfile.titlesSpacing)
	            .attr('y', margin.top / 2);
	
	          this.year.attr('x', this.width + margin.left).attr('y', margin.top / 2);
	
	        }
	      });
	
	      //BAR CHART TOOL
	      var AgePyramid = Tool.extend('AgePyramid', {
	
	        /**
	         * Initializes the tool (Bar Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	
	          this.name = "agepyramid";
	
	          //specifying components
	          this.components = [{
	            component: AgePyramid$1,
	            placeholder: '.vzb-tool-viz',
	            model: ["state.time", "state.entities", "state.entities_side", "state.entities_stack", "state.entities_age", "state.marker", "state.marker_side", "language", "ui"] //pass models to component
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        },
	
	        default_model: {
	          ui: {
	            chart: {
	              inpercent: false,
	              stacked: true
	            }
	          }
	        }
	
	
	      });
	
	      //BAR CHART TOOL
	      var JOINTPyramidLine = Tool.extend('JOINTPyramidLine', {
	
	        /**
	         * Initializes the tool (Bar Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	          
	          this.name = "joint_pyramidline";
	          
	          this.template = 
	            '<div class="vzb-tool vzb-tool-' + this.name + '">' + 
	              '<div class="vzb-tool-stage vzb-tool-stage-left" style="position:absolute; left: 0; width: 50%; height: 100%;">' + 
	                '<div class="vzb-tool-viz vzb-tool-viz-pyramid"></div>' + 
	              '</div>' + 
	              '<div class="vzb-tool-stage vzb-tool-stage-right" style="position:absolute; right: 0; width: 50%; height: 100%;">' +
	                '<div class="vzb-tool-viz vzb-tool-viz-line"></div>' + 
	                '<div class="vzb-tool-timeslider"></div>' + 
	              '</div>' + 
	              '<div class="vzb-tool-sidebar">' + 
	                '<div class="vzb-tool-dialogs"></div>' +
	                '<div class="vzb-tool-buttonlist"></div>' + 
	              '</div>' +         
	              '<div class="vzb-tool-datanotes vzb-hidden"></div>' + 
	              '<div class="vzb-tool-treemenu vzb-hidden"></div>' + 
	              '<div class="vzb-tool-datawarning vzb-hidden"></div>' + 
	              '<div class="vzb-tool-labels vzb-hidden"></div>' + 
	            '</div>';    
	
	          
	
	          //specifying components
	          this.components = [{
	            component: AgePyramid$1,
	            placeholder: '.vzb-tool-viz-pyramid',
	            model: ["state.time", "state.entities", "state.entities_side", "state.entities_stack", "state.entities_age", "state.marker_pyramid", "state.marker_side", "language", "ui"] //pass models to component
	          }, {      
	            component: LCComponent,
	            placeholder: '.vzb-tool-viz-line',
	            model: ["state.time", "state.entities", "state.marker_line", "language"]
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker_pyramid"]
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        }
	
	      });
	
	      //BAR CHART TOOL
	      var JOINTCartogramLine = Tool.extend('JOINTCartogramLine', {
	
	        /**
	         * Initializes the tool (Bar Chart Tool).
	         * Executed once before any template is rendered.
	         * @param {Object} placeholder Placeholder element for the tool
	         * @param {Object} external_model Model as given by the external page
	         */
	        init: function(placeholder, external_model) {
	          
	          this.name = "joint_cartogramline";
	          
	          this.template = 
	            '<div class="vzb-tool vzb-tool-' + this.name + '">' + 
	              '<div class="vzb-tool-stage vzb-tool-stage-left" style="position:absolute; left: 0; width: 65%; height: 100%;">' + 
	                '<div class="vzb-tool-viz vzb-tool-viz-cartogram"></div>' + 
	              '</div>' + 
	              '<div class="vzb-tool-stage vzb-tool-stage-right" style="position:absolute; right: 0; top: 0; width: 40%; height: 100%;">' +
	                '<div class="vzb-tool-viz vzb-tool-viz-line"></div>' + 
	                '<div class="vzb-tool-timeslider"></div>' + 
	              '</div>' + 
	              '<div class="vzb-tool-sidebar">' + 
	                '<div class="vzb-tool-dialogs"></div>' +
	                '<div class="vzb-tool-buttonlist"></div>' + 
	              '</div>' +         
	              '<div class="vzb-tool-datanotes vzb-hidden"></div>' + 
	              '<div class="vzb-tool-treemenu vzb-hidden"></div>' + 
	              '<div class="vzb-tool-datawarning vzb-hidden"></div>' + 
	              '<div class="vzb-tool-labels vzb-hidden"></div>' + 
	            '</div>';
	          
	          
	          //specifying components
	          this.components = [{
	            component: CartogramComponent,
	            placeholder: '.vzb-tool-viz-cartogram',
	            model: ["state.time", "state.entities", "state.marker", "language", "ui"] //pass models to component
	          }, {
	            component: LCComponent,
	            placeholder: '.vzb-tool-viz-line',
	            model: ["state.time", "state.entities_line", "state.marker_line", "language"]
	          }, {
	            component: TimeSlider,
	            placeholder: '.vzb-tool-timeslider',
	            model: ["state.time", "state.entities", "state.marker"]
	          }, {
	            component: Dialogs,
	            placeholder: '.vzb-tool-dialogs',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: ButtonList,
	            placeholder: '.vzb-tool-buttonlist',
	            model: ['state', 'ui', 'language']
	          }, {
	            component: TreeMenu,
	            placeholder: '.vzb-tool-treemenu',
	            model: ['state.marker', 'language']
	          }, {
	            component: DataWarning,
	            placeholder: '.vzb-tool-datawarning',
	            model: ['language']
	          }, {
	            component: DataNotes,
	            placeholder: '.vzb-tool-datanotes',
	            model: ['state.marker', 'language']
	          }];
	
	          //constructor is the same as any tool
	          this._super(placeholder, external_model);
	        },
	        
	        readyOnce: function(){
	          this.element = d3.select(this.element);
	          //this.element.select(".vzb-ct-axis-y-title").classed("vzb-hidden", true);
	          //this.element.select(".vzb-ct-axis-y-info").style("visibility", "hidden");
	          this.element.select(".vzb-lc-axis-y-title").classed("vzb-hidden", true);
	          this.element.select(".vzb-lc-axis-x-title").classed("vzb-hidden", true);
	          this.element.select(".vzb-lc-axis-y-info").classed("vzb-hidden", true);
	          this.element.select(".vzb-data-warning").classed("vzb-hidden", true);
	        
	        }
	
	      });
	
	      var language = {
	        id: "en",
	        strings: {}
	      };
	
	      // Fallback in case if WS is not available - requesting data from local files
	      var locationArray = window.location.href.split("/");
	      var localUrl = locationArray.splice(0, locationArray.indexOf("preview")).join("/") + "/preview/";
	
	      globals.ext_resources = deepExtend({
	        host: localUrl,
	        preloadPath: 'data/',
	        dataPath: 'data/waffles/'
	      }, globals.ext_resources);
	
	      //OVERWRITE OPTIONS
	
	      BarChart.define('default_model', {
	        state: {
	          time: {
	            start: "1800",
	            end: "2012",
	            value: "2000",
	            step: 1
	          },
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["usa", "swe", "nor"],
	                "geo.cat": ["country", "unstate"]
	              }
	            }
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["world_4region"]
	              }
	            }
	          },
	          marker: {
	            space: ["entities", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "sg_population", // systema globalis
	              //which: "population_total",
	              scaleType: "log",
	              allow: {
	                scales: ["linear", "log"]
	              }
	            },
	            axis_x: {
	              use: "property",
	              which: "geo.name",
	              allow: {
	                scales: ["ordinal"],
	                names: ["!geo", "!_default"]
	              }
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region",
	              scaleType: "ordinal"
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "dont-panic-poverty.csv"
	        },
	        language: language,
	        ui: {
	          presentation: false
	        }
	      });
	
	      BarRankChart.define('default_model', {
	        state: {
	          time: {
	            start: "1950",
	            end: "2015",
	            value: "2015",
	            step: 1
	          },
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["country", "unstate"]
	              }
	            },
	            opacitySelectDim: .3,
	            opacityRegular: 1
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["world_4region"]
	              }
	            }
	          },
	          entities_allpossible: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["*"],
	                "geo.cat": ["country", "unstate"]
	              }
	            }
	          },
	          marker_allpossible: {
	            space: ["entities_allpossible"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            }
	          },
	          marker: {
	            space: ["entities", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            axis_x: {
	              use: "indicator",
	              which: "sg_population", //systema globalis
	              //which: "population_total",
	              scaleType: "log",
	              allow: {
	                scales: [
	                  "linear",
	                  "log"
	                ]
	              }
	            },
	            // should not be here because axis-y is not geo.name but order of population
	            axis_y: {
	              use: "property",
	              which: "geo.name",
	              scaleType: "log",
	              allow: {
	                scales: [
	                  "ordinal"
	                ]
	              }
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region"
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        language: language,
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "dont-panic-poverty.csv",
	          splash: true
	        },
	        ui: {
	          presentation: false
	        }
	      });
	
	      BubbleMap.define('datawarning_content', {
	        title: "",
	        body: "Comparing the size of economy across countries and time is not trivial. The methods vary and the prices change. Gapminder has adjusted the picture for many such differences, but still we recommend you take these numbers with a large grain of salt.<br/><br/> Countries on a lower income levels have lower data quality in general, as less resources are available for compiling statistics. Historic estimates of GDP before 1950 are generally also more rough. <br/><br/> Data for child mortality is more reliable than GDP per capita, as the unit of comparison, dead children, is universally comparable across time and place. This is one of the reasons this indicator has become so useful to measure social progress. But the historic estimates of child mortality are still suffering from large uncertainties.<br/><br/> Learn more about the datasets and methods in this <a href='http://www.gapminder.org/news/data-sources-dont-panic-end-poverty' target='_blank'>blog post</a>",
	        doubtDomain: [1800, 1950, 2015],
	        doubtRange: [1.0, .3, .2]
	      });
	
	      BubbleMap.define('default_model', {
	        state: {
	          time: {
	            start: "1800",
	            end: "2015",
	            value: "2015",
	            step: 1,
	            speed: 300
	          },
	          entities: {
	            dim: "geo",
	            opacitySelectDim: .3,
	            opacityRegular: 1,
	            show: {
	              _defs_: {
	                "geo.cat": ["country", "unstate"]
	              }
	            },
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["world_4region"]
	              }
	            }
	          },
	          marker: {
	            space: ["entities", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            size: {
	              use: "indicator",
	              //which: "sg_population",//systema globalis
	              which: "population_total",
	              scaleType: "linear",
	              allow: {
	                scales: ["linear"]
	              },
	              extent: [0.04, 0.85]
	            },
	            lat: {
	              use: "property",
	              which: "geo.latitude",
	              _important: true
	            },
	            lng: {
	              use: "property",
	              which: "geo.longitude",
	              _important: true
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region",
	              scaleType: "ordinal",
	              allow: {
	                names: ["!geo.name"]
	              }
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "dont-panic-poverty.csv",
	          splash: true
	        },
	        language: language,
	        ui: {
	          chart: {
	            labels: {
	              dragging: true
	            }
	          },
	          presentation: false
	        }
	      });
	
	      MountainChart.define('datawarning_content', {
	        title: "Income data has large uncertainty!",
	        body: "There are many different ways to estimate and compare income. Different methods are used in different countries and years. Unfortunately no data source exists that would enable comparisons across all countries, not even for one single year. Gapminder has managed to adjust the picture for some differences in the data, but there are still large issues in comparing individual countries. The precise shape of a country should be taken with a large grain of salt.<br/><br/> Gapminder strongly agrees with <a href='https://twitter.com/brankomilan' target='_blank'>Branko Milanovic</a> about the urgent need for a comparable global income survey, especially for the purpose of monitoring the UN poverty-goal.<br/><br/> We are constantly improving our datasets and methods. Please expect revision of this graph within the coming months. <br/><br/> Learn more about the datasets and methods in this <a href='http://www.gapminder.org/news/data-sources-dont-panic-end-poverty' target='_blank'>blog post</a>",
	        doubtDomain: [1800, 1950, 2015],
	        doubtRange: [1.0, .8, .6]
	      });
	
	      MountainChart.define('default_model', {
	        state: {
	          time: {
	            start: 1800,
	            end: 2015,
	            value: 2015,
	            step: 1,
	            delay: 100,
	            delayThresholdX2: 50,
	            delayThresholdX4: 25
	          },
	          entities: {
	            dim: "geo",
	            opacitySelectDim: .3,
	            opacityRegular: .7,
	            show: {
	              _defs_: {
	                "geo": ["*"],
	                "geo.cat": ["country", "unstate"]
	              }
	            }
	          },
	          entities_allpossible: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["*"],
	                "geo.cat": ["country", "unstate"]
	              }
	            }
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["world_4region"]
	              }
	            }
	          },
	          marker_allpossible: {
	            space: ["entities_allpossible"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            }
	          },
	          marker: {
	            space: ["entities", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "sg_population",//systema globalis
	              //which: "population_total",
	              scaleType: 'linear'
	            },
	            axis_x: {
	              use: "indicator",
	              which: "sg_gdp_p_cap_const_ppp2011_dollar",//systema globalis
	              //which: "income_per_person_gdppercapita_ppp_inflation_adjusted",
	              scaleType: 'log',
	              domainMin: .11, //0
	              domainMax: 500, //100
	              tailFatX: 1.85,
	              tailCutX: .2,
	              tailFade: .7,
	              xScaleFactor: 1.039781626,
	              xScaleShift: -1.127066411
	            },
	            axis_s: {
	              use: "indicator",
	              which: "sg_gini", //systema globalis
	              //which: "inequality_index_gini",
	              scaleType: 'linear'
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region",
	              scaleType: "ordinal",
	              allow: {
	                names: ["!geo.name"]
	              }
	            },
	            stack: {
	              use: "constant",
	              which: "all" // set a property of data or values "all" or "none"
	            },
	            group: {
	              use: "property",
	              which: "geo.world_4region", // set a property of data
	              manualSorting: ["asia", "africa", "americas", "europe"],
	              merge: false
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        language: language,
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "dont-panic-poverty.csv",
	          splash: true
	        },
	        ui: {
	          chart: {
	            manualSortingEnabled: true,
	            yMaxMethod: "latest",
	            probeX: 1.85,
	            xLogStops: [1, 2, 5],
	            xPoints: 50
	          },
	          presentation: false
	        }
	      });
	
	
	      LineChart.define('default_model', {
	        state: {
	          time: {
	            start: 1800,
	            end: 2012,
	            value: 2012,
	            step: 1,
	          },
	          //entities we want to show
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["usa", "swe", "chn"],
	                "geo.cat": ["country", "unstate"]
	              }
	            }
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["world_4region"]
	              }
	            }
	          },
	          //how we show it
	          marker: {
	            space: ["entities", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "sg_gdp_p_cap_const_ppp2011_dollar",//systema globalis
	              //which: "income_per_person_gdppercapita_ppp_inflation_adjusted",
	              scaleType: "log",
	              allow: {
	                scales: ["linear", "log", "time"]
	              }
	
	            },
	            axis_x: {
	              use: "indicator",
	              which: "time",
	              scaleType: "time",
	              allow: {
	                scales: ["time"]
	              }
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region",
	              allow: {
	                scales: ["ordinal"],
	                names: ["!geo.name"]
	              }
	            }
	          },
	          entities_allpossible: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["*"],
	                "geo.cat": ["country", "unstate"]
	              }
	            }
	          },
	          marker_allpossible: {
	            space: ["entities_allpossible"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "dont-panic-poverty.csv",
	          splash: false
	        },
	        language: language,
	        ui: {
	          chart: {
	            labels: {
	              min_number_of_entities_when_values_hide: 2 //values hide when showing 2 entities or more
	            },
	            whenHovering: {
	              hideVerticalNow: false,
	              showProjectionLineX: true,
	              showProjectionLineY: true,
	              higlightValueX: true,
	              higlightValueY: true,
	              showTooltip: false
	            }
	          },
	          presentation: false
	        }
	      });
	
	      BubbleChart.define('datawarning_content', {
	        title: "",
	        body: "Comparing the size of economy across countries and time is not trivial. The methods vary and the prices change. Gapminder has adjusted the picture for many such differences, but still we recommend you take these numbers with a large grain of salt.<br/><br/> Countries on a lower income levels have lower data quality in general, as less resources are available for compiling statistics. Historic estimates of GDP before 1950 are generally also more rough. <br/><br/> Data for child mortality is more reliable than GDP per capita, as the unit of comparison, dead children, is universally comparable across time and place. This is one of the reasons this indicator has become so useful to measure social progress. But the historic estimates of child mortality are still suffering from large uncertainties.<br/><br/> Learn more about the datasets and methods in this <a href='http://www.gapminder.org/news/data-sources-dont-panic-end-poverty' target='_blank'>blog post</a>",
	        doubtDomain: [1800, 1950, 2015],
	        doubtRange: [1.0, .3, .2]
	      });
	
	      BubbleChart.define('default_model', {
	
	        state: {
	          time: {
	            start: "1800",
	            end: "2015",
	            value: "2015",
	            step: 1
	          },
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["country", "unstate"]
	              }
	            }
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["world_4region"]
	              }
	            }
	          },
	          marker: {
	            space: ["entities", "time"],
	            type: "geometry",
	            shape: "circle",
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            size_label: {
	              use: "constant",
	              which: "_default",
	              scaleType: "ordinal",
	              _important: false,
	              extent: [0, 0.33]
	            },
	
	            axis_y: {
	              use: "indicator",
	              //which: "sg_child_mortality_rate_per1000", //systema globalis
	              which: "life_expectancy_years",
	              scaleType: "linear",
	              zoomedMin: 15,
	              allow: {
	                scales: ["linear", "log", "time"]
	              }
	            },
	            axis_x: {
	              use: "indicator",
	              //which: "sg_gdp_p_cap_const_ppp2011_dollar",//systema globalis
	              which: "income_per_person_gdppercapita_ppp_inflation_adjusted", 
	              scaleType: "log",
	              allow: {
	                scales: ["linear", "log", "time"]
	              }
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region",
	              scaleType: "ordinal",
	              allow: {
	                names: ["!geo.name"]
	              }
	            },
	            size: {
	              use: "indicator",
	              //which: "sg_population",//systema globalis
	              which: "population_total", 
	              scaleType: "linear",
	              allow: {
	                scales: ["linear"]
	              },
	              extent: [0, 0.85]
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "dont-panic-poverty.csv",
	          splash: true
	        },
	        language: language,
	        ui: {
	          chart: {
	            whenHovering: {
	              showProjectionLineX: true,
	              showProjectionLineY: true,
	              higlightValueX: true,
	              higlightValueY: true
	            },
	            labels: {
	              dragging: true,
	              removeLabelBox: false
	            },
	            trails: true,
	            lockNonSelected: 0
	          },
	          presentation: false,
	          cursorMode: 'arrow',
	          zoomOnScrolling: false,
	          adaptMinMaxZoom: false
	        }
	      });
	
	      PopByAge.define('default_model', {
	        state: {
	          time: {
	            value: '2013',
	            start: '1950',
	            end: '2100'
	          },
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["usa"]
	              }
	            }
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["world_4region"]
	              }
	            }
	          },
	          entities_age: {
	            dim: "age",
	            show: {
	              _defs_: {
	                "age": [
	                  [0, 95]
	                ] //show 0 through 100
	              }
	            },
	            grouping: 5
	          },
	          marker: {
	            space: ["entities", "entities_age", "time"],
	            label: {
	              use: "indicator",
	              which: "age"
	            },
	            label_name: {
	              use: "property",
	              which: "geo"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "age",
	              // domain Max should be set manually as age max from entites_age plus one grouping value (95 + 5 = 100)
	              // that way the last age group fits in on the scale
	              domainMax: 100,
	              domainMin: 0
	            },
	            axis_x: {
	              use: "indicator",
	              which: "sg_population"
	            },
	            color: {
	              use: "constant",
	              which: "#ffb600",
	              allow: {
	                names: ["!geo.name"]
	              }
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "geo.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "usa.csv",
	          splash: false
	        },
	        language: language,
	        ui: {
	          presentation: false
	        }
	      });
	
	      AgePyramid.define('default_model', {
	        state: {
	          time: {
	            value: '2011',
	            start: '1950',
	            end: '2100',
	            step: 1,
	            delayThresholdX2: 0,
	            delayThresholdX4: 0,
	            immediatePlay: true,
	            delay: 1500
	          },
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["*"]
	              }
	            }
	          },
	          entities_minimap: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo.cat": ["country"]
	              }
	            }
	          },
	          entities_age: {
	            dim: "age",
	            show: {
	              _defs_: {
	                "age": [
	                  [0, 95]
	                ] //show 0 through 100
	              }
	            },
	            grouping: 1,
	            _multiple: true
	          },
	          entities_stack: {
	            space: ["entities_age", "entities_side"],
	            dim: "education_attainment",
	            _multiple: true
	          },
	          entities_side: {
	            dim: "population_group"
	          },
	          marker: {
	            space: ["entities", "entities_side", "entities_stack", "entities_age", "time"],
	            label: {
	              use: "indicator",
	              which: "age"
	            },
	            label_name: {
	              use: "property",
	              which: "population_group"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "age",
	              // domain Max should be set manually as age max from entites_age plus one grouping value (95 + 5 = 100)
	              // that way the last age group fits in on the scale
	              domainMax: 100,
	              domainMin: 0
	            },
	            axis_x: {
	              use: "indicator",
	              which: "population",
	              //domainMin: 0,
	              //domainMax: 1400000000
	            },
	            color: {
	              use: "property",
	              which: "education_attainment"
	              // allow: {
	              //   names: ["!stack.name"]
	              // }
	            },
	            side: {
	              use: "property",
	              which: "population_group"
	            }
	          },
	          marker_side: {
	            space: ["entities", "entities_side", "time"],
	            hook_total: {
	              use: "indicator",
	              which: "population"
	            }      
	          },
	          marker_minimap:{
	            space: ["entities_stack"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "education_attainment"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        language: language,
	        //NO DEFAULT DATA SOURCE. DATA COMES FROM EXTERNAL PAGE
	        ui: {
	          chart: {
	            stacked: true,
	            inpercent: false,
	            flipSides: true
	          },
	          presentation: false
	        }
	      });
	
	      JOINTPyramidLine.define('default_model', {
	        state: {
	          time: {
	            value: '2011',
	            start: '1996',
	            end: '2011'
	          },
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["*"]
	              }
	            }
	          },
	          entities_age: {
	            dim: "age",
	            show: {
	              _defs_: {
	                "age": [
	                  [0, 95]
	                ] //show 0 through 100
	              }
	            },
	            grouping: 5,
	            _multiple: true
	          },
	          entities_stack: {
	            space: ["entities_age", "entities_side"],
	            dim: "education",
	            _multiple: true,
	            select: []
	          },
	          entities_side: {
	            dim: "sex"
	          },
	          marker_pyramid: {
	            space: ["entities", "entities_side", "entities_stack", "entities_age", "time"],
	            label: {
	              use: "indicator",
	              which: "age"
	            },
	            label_name: {
	              use: "property",
	              which: "sex"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "age",
	              // domain Max should be set manually as age max from entites_age plus one grouping value (95 + 5 = 100)
	              // that way the last age group fits in on the scale
	              domainMax: 100,
	              domainMin: 0
	            },
	            axis_x: {
	              use: "indicator",
	              which: "zaf_population"
	            },
	            color: {
	              use: "property",
	              which: "education"
	            },
	            side: {
	              use: "property",
	              which: "sex"
	            }
	          },
	          marker_line: {
	            space: ["entities", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "tfr",
	              scaleType: "linear",
	              allow: {
	                scales: ["linear", "log"]
	              }
	            },
	            axis_x: {
	              use: "indicator",
	              which: "time",
	              scaleType: "time",
	              allow: {
	                scales: ["time"]
	              }
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region",
	              allow: {
	                scales: ["ordinal"],
	                names: ["!geo.name"]
	              }
	            }
	          },
	          marker_side: {
	            space: ["entities", "entities_side", "time"],
	            hook_total: {
	              use: "indicator",
	              which: "zaf_population"
	            }      
	          }
	        },
	        language: language,
	        //NO DEFAULT DATA SOURCE. DATA COMES FROM EXTERNAL PAGE
	        ui: {
	          chart: {
	            labels: {
	              min_number_of_entities_when_values_hide: 2 //values hide when showing 2 entities or more
	            },
	            whenHovering: {
	              hideVerticalNow: false,
	              showProjectionLineX: true,
	              showProjectionLineY: true,
	              higlightValueX: true,
	              higlightValueY: true,
	              showTooltip: false
	            },
	            stacked: true,
	            inpercent: false
	          },    
	          presentation: false
	        }
	      });
	
	
	
	
	      JOINTCartogramLine.define('datawarning_content', {
	        title: "",
	        body: "Comparing the size of economy across countries and time is not trivial. The methods vary and the prices change. Gapminder has adjusted the picture for many such differences, but still we recommend you take these numbers with a large grain of salt.<br/><br/> Countries on a lower income levels have lower data quality in general, as less resources are available for compiling statistics. Historic estimates of GDP before 1950 are generally also more rough. <br/><br/> Data for child mortality is more reliable than GDP per capita, as the unit of comparison, dead children, is universally comparable across time and place. This is one of the reasons this indicator has become so useful to measure social progress. But the historic estimates of child mortality are still suffering from large uncertainties.<br/><br/> Learn more about the datasets and methods in this <a href='http://www.gapminder.org/news/data-sources-dont-panic-end-poverty' target='_blank'>blog post</a>",
	        doubtDomain: [1800, 1950, 2015],
	        doubtRange: [1.0, .3, .2]
	      });
	
	      JOINTCartogramLine.define('default_model', {
	        state: {
	          time: {
	            value: '2011',
	            start: '1996',
	            end: '2011'
	          },
	          entities: {
	            dim: "geo",
	            opacitySelectDim: .3,
	            opacityRegular: 1,
	            show: {
	              _defs_: {
	                "geo": ["*"]
	              }
	            },
	          },
	          entities_line: {
	            dim: "geo",
	            opacitySelectDim: .3,
	            opacityRegular: 1,
	            show: {
	              _defs_: {
	                "geo": ["zaf"]
	              }
	            },
	          },
	          marker: {
	            space: ["entities", "time"],
	            size: {
	              use: "constant",
	              //which: "sg_population",//systema globalis
	              which: "_default",
	              scaleType: "ordinal",
	              _important: true,
	              showArcs: false,
	              allow: {
	                scales: ["linear", "ordinal"]
	              },
	              extent: [0, 1]
	            },
	            color: {
	              use: "indicator",
	              which: "piped_water_percentage",
	              scaleType: "linear",
	              _important: true
	            },
	            label: {
	              use: "property",
	              which: "geo.name"
	              //which: "province.name"
	            }
	          },
	          marker_line: {
	            space: ["entities_line", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            axis_y: {
	              use: "indicator",
	              which: "piped_water_percentage",
	              scaleType: "linear",
	              allow: {
	                scales: ["linear", "log"]
	              }
	            },
	            axis_x: {
	              use: "indicator",
	              which: "time",
	              scaleType: "time",
	              allow: {
	                scales: ["time"]
	              }
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region",
	              allow: {
	                scales: ["ordinal"],
	                names: ["!geo.name"]
	              }
	            }
	          }
	        },
	        language: language,
	        //NO DEFAULT DATA SOURCE. DATA COMES FROM EXTERNAL PAGE
	        ui: {
	          chart: {
	            labels: {
	              min_number_of_entities_when_values_hide: 0 //values hide when showing 2 entities or more
	            },
	            hideXAxisValue: true,
	            whenHovering: {
	              hideVerticalNow: true,
	              showProjectionLineX: true,
	              showProjectionLineY: true,
	              higlightValueX: true,
	              higlightValueY: true,
	              showTooltip: false
	            },
	            stacked: true,
	            inpercent: false
	          },    
	          presentation: true
	        }
	      });
	
	
	
	
	
	      DonutChart.define('default_model', {
	        state: {
	          // available time would have the range of 1990-2012 years (%Y), with the deafult position at 2000
	          time: {
	            start: "1990",
	            end: "2012",
	            value: "2000"
	          },
	          //Entities include all ("*") geo's of category "regions" -- equivalent to 'geo: ["asi", "ame", "eur", "afr"]'
	          entities: {
	            dim: "geo",
	            show: {
	              _defs_: {
	                "geo": ["usa", "bra", "chn", "ind", "idn"],
	                "geo.cat": ["country"]
	              }
	            }
	          },
	          //Markers correspond to visuals that we want to show. We have label, axis and color
	          marker: {
	            space: ["entities", "time"],
	            label: {
	              use: "property",
	              which: "geo.name"
	            },
	            axis: {
	              use: "indicator",
	              which: "sg_population"
	            },
	            color: {
	              use: "property",
	              which: "geo.world_4region"
	            }
	          }
	        },
	        data: {
	          reader: "csv",
	          path: globals.ext_resources.host + globals.ext_resources.dataPath + "basic-indicators.csv",
	          splash: false
	        },
	        language: language,
	        ui: {
	          presentation: false
	        }
	
	      });
	
	      Cartogram.define('datawarning_content', {
	        title: "",
	        body: "Comparing the size of economy across countries and time is not trivial. The methods vary and the prices change. Gapminder has adjusted the picture for many such differences, but still we recommend you take these numbers with a large grain of salt.<br/><br/> Countries on a lower income levels have lower data quality in general, as less resources are available for compiling statistics. Historic estimates of GDP before 1950 are generally also more rough. <br/><br/> Data for child mortality is more reliable than GDP per capita, as the unit of comparison, dead children, is universally comparable across time and place. This is one of the reasons this indicator has become so useful to measure social progress. But the historic estimates of child mortality are still suffering from large uncertainties.<br/><br/> Learn more about the datasets and methods in this <a href='http://www.gapminder.org/news/data-sources-dont-panic-end-poverty' target='_blank'>blog post</a>",
	        doubtDomain: [1800, 1950, 2015],
	        doubtRange: [1.0, .3, .2]
	      });
	
	      Cartogram.define('default_model', {
	        state: {
	          time: {
	            start: "1800",
	            end: "2015",
	            value: "2015",
	            step: 1,
	            speed: 300,
	            dim: "year"
	          },
	          entities: {
	            dim: "municipality",
	            //dim: "province",
	            opacitySelectDim: .3,
	            opacityRegular: 1,
	            show: {
	              _defs_: {
	                "municipality.cat": ["province", "municipality"],
	                //"province.cat": ["province", "municipality"]
	              }
	            },
	          },
	          entities_minimap: {
	            dim: "municipality",
	            //dim: "province",
	            show: {
	              _defs_: {
	                "municipality.cat": ["province", "municipality"],
	                //"province.cat": ["province", "municipality"]
	              }
	            }
	          },
	          marker: {
	            space: ["entities", "time"],
	            size: {
	              use: "constant",
	              //which: "sg_population",//systema globalis
	              which: "_default",
	              scaleType: "ordinal",
	              _important: true,
	              showArcs: false,
	              allow: {
	                scales: ["linear", "ordinal"]
	              },
	              extent: [0, 1]
	            },
	            color: {
	              use: "indicator",
	              which: "piped_water_percentage",
	              scaleType: "linear",
	              _important: true
	            },
	            label: {
	              use: "property",
	              which: "municipality.name"
	              //which: "province.name"
	            }
	          },
	          marker_minimap:{
	            space: ["entities_minimap"],
	              type: "geometry",
	              shape: "svg",
	              label: {
	                use: "property",
	                which: "municipality.name"
	                //which: "province.name"
	              },
	              geoshape: {
	                use: "property",
	                which: "shape_lores_svg"
	              }
	          }
	        },
	        //NO DEFAULT DATA SOURCE. DATA COMES FROM EXTERNAL PAGE
	        language: language,
	        ui: {
	          chart: {
	            labels: {
	              dragging: true
	            },
	            lockNonSelected: 0,
	            lockActive: 0,
	            sizeSelectorActive:0
	          },
	          presentation: false
	        }
	      });
	
	      //Waffle Server Reader custom path
	      WSReader.define('basepath', globals.ext_resources.host + globals.ext_resources.dataPath);
	
	      //preloading mountain chart precomputed shapes
	      MountainChartComponent.define("preload", function(done) {
	        var shape_path = globals.ext_resources.shapePath ? globals.ext_resources.shapePath :
	            globals.ext_resources.host + globals.ext_resources.preloadPath + "mc_precomputed_shapes.json";     
	
	        d3.json(shape_path, function(error, json) {
	          if(error) return console.warn("Failed loading json " + shape_path + ". " + error);
	          MountainChartComponent.define('precomputedShapes', json);
	          done.resolve();
	        });
	      });
	
	      //preloading bubble map country shapes
	      BubbleMapComponent.define("preload", function(done) {
	        var shape_path = globals.ext_resources.shapePath ? globals.ext_resources.shapePath :
	            globals.ext_resources.host + globals.ext_resources.preloadPath + "world-50m.json"; 
	          
	        d3.json(shape_path, function(error, json) {
	          if(error) return console.warn("Failed loading json " + shape_path + ". " + error);
	          BubbleMapComponent.define('world', json);
	          done.resolve();
	        });
	      });
	
	      CartogramComponent.define("preload", function(done) {
	        var shape_path = globals.ext_resources.shapePath ? globals.ext_resources.shapePath :
	            globals.ext_resources.host + globals.ext_resources.preloadPath + "municipalities.json"; 
	        
	        d3.json(shape_path, function(error, json) {
	          if(error) return console.warn("Failed loading json " + shape_path + ". " + error);
	          CartogramComponent.define('world', json);
	          CartogramComponent.define('geometries', json.objects.topo.geometries);
	          CartogramComponent.define('id_lookup', json.objects.id_lookup);
	          done.resolve();
	        });
	      });
	
	      CartogramComponent.define("preload", function(done) {
	        var shape_path = globals.ext_resources.shapePath ? globals.ext_resources.shapePath :
	            globals.ext_resources.host + globals.ext_resources.preloadPath + "municipalities.json"; 
	        
	        d3.json(shape_path, function(error, json) {
	          if(error) return console.warn("Failed loading json " + shape_path + ". " + error);
	          CartogramComponent.define('world', json);
	          CartogramComponent.define('geometries', json.objects.topo.geometries);
	          CartogramComponent.define('id_lookup', json.objects.id_lookup);
	          done.resolve();
	        });
	      });
	
	
	      //preloading concept properties for all charts
	      Tool.define("preload", function(promise) {
	
	        var _this = this;
	
	        var conceptprops_path = globals.ext_resources.conceptpropsPath ? globals.ext_resources.conceptpropsPath :
	            globals.ext_resources.host + globals.ext_resources.preloadPath + "metadata.json";    
	        
	        //TODO: concurrent
	        //load language first
	        this.preloadLanguage().then(function() {
	          //then concept properties
	          
	          if (!_this.model.data || _this.model.data.noConceptprops) {
	            promise.resolve();
	            return;
	          }
	          
	          d3.json(conceptprops_path, function(conceptprops) {
	
	            globals.conceptprops = conceptprops;
	              
	            if(!globals.conceptprops.indicatorsDB["_default"]) globals.conceptprops.indicatorsDB["_default"] = {
	                "use": "constant",
	                "scales": ["ordinal"]
	            }
	            if(globals.conceptprops.indicatorsTree.children.map(function(m){return m.id}).indexOf("_default")===-1) {
	                globals.conceptprops.indicatorsTree.children.push({"id": "_default"});
	            }
	
	            // TODO: REMOVE THIS HACK
	            // We are currently saving concept properties info to default state manually in order
	            // to produce small URLs considering some of the info in concept properties to be default
	            // we need a consistent way to add concept properties to Vizabi
	            addMinMax("axis_x");
	            addMinMax("axis_y");
	            addMinMax("size");
	            addMinMax("size_label");
	            addPalettes("color");
	
	            promise.resolve();
	
	          });
	        });
	
	        // TODO: REMOVE THIS HACK (read above)
	        function addPalettes(hook) {
	          //protection in case id state or marker or [hook] is undefined
	          if(!((_this.default_model.state||{}).marker||{})[hook]) return;
	          
	          var color = _this.default_model.state.marker[hook];
	          var palette = ((globals.conceptprops.indicatorsDB[color.which]||{}).color||{}).palette||{};
	          var paletteLabels = ((globals.conceptprops.indicatorsDB[color.which]||{}).color||{}).paletteLabels||{};
	          color.palette = extend({}, color.palette, palette);
	          color.paletteLabels = clone(paletteLabels);
	        }
	
	        function addMinMax(hook) {
	          //protection in case id state or marker or [hook] is undefined
	          if(!((_this.default_model.state||{}).marker||{})[hook]) return;
	          
	          var axis = _this.default_model.state.marker[hook];
	          if(axis.use === "indicator" && globals.conceptprops.indicatorsDB[axis.which] && globals.conceptprops.indicatorsDB[axis.which].domain) {
	            var domain = globals.conceptprops.indicatorsDB[axis.which].domain;
	            axis.domainMin = axis.domainMin || domain[0];
	            axis.domainMax = axis.domainMax || domain[1];
	            axis.zoomedMin = axis.zoomedMin || axis.domainMin || domain[0];
	            axis.zoomedMax = axis.zoomedMax || axis.domainMax || domain[1];
	          }
	        }
	
	      });
	
	      Tool.define("preloadLanguage", function() {
	        var _this = this;
	        var promise = new Promise();
	
	        var langModel = this.model.language;
	        
	        // quit if no language model is set (go translationless)
	        if(!langModel) return promise.resolve();
	        
	        var translation_path = globals.ext_resources.translationPath ? globals.ext_resources.translationPath :
	            globals.ext_resources.host + globals.ext_resources.preloadPath + "translation/" + langModel.id + ".json";
	
	        if(!langModel.strings[langModel.id]) {
	          d3.json(translation_path, function(langdata) {
	            langModel.strings[langModel.id] = langdata;
	            _this.model.language.strings.trigger("change");
	            promise.resolve();
	          });
	        } else {
	          this.model.language.strings.trigger("change");
	          promise = promise.resolve();
	        }
	
	        return promise;
	
	      });
	      globals.version = "0.15.1-1"; globals.build = "1470663182485"; globals.templates = (function(templates) {templates['bubblesize.html'] = '<div class="vzb-bs-holder"> <svg class="vzb-bs-svg"> <g class="vzb-bs-slider-wrap"> <g class="vzb-bs-slider"> </g> </g> </svg> </div> ';templates['about.html'] = '<div class="vzb-dialog-modal"> <div class="vzb-dialog-title"> <%=t ( "buttons/about") %> </div> <div class="vzb-dialog-content"> <p class="vzb-about-text0"></p> <p class="vzb-about-text1"></p> <br/> <p class="vzb-about-version"></p> <p class="vzb-about-updated"></p> <br/> <p class="vzb-about-text2"></p> <br/> <p class="vzb-about-report"></p> <br/> <p class="vzb-about-credits"></p> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div> ';templates['axes.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="axes" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="axes" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/axes") %> </div> <div class="vzb-dialog-content"> <p class="vzb-dialog-sublabel"> <%=t ("buttons/axis_x") %> <span class="vzb-xaxis-selector"></span> </p> <div class="vzb-xaxis-minmax vzb-dialog-paragraph"></div> <p class="vzb-dialog-sublabel"> <%=t ("buttons/axis_y") %> <span class="vzb-yaxis-selector"></span> </p> <div class="vzb-yaxis-minmax vzb-dialog-paragraph"></div> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div>';templates['axesmc.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="axesmc" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="axesmc" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/axes") %> </div> <div class="vzb-dialog-content"> <div class="vzb-yaxis-container"> <p class="vzb-dialog-sublabel"><%=t ( "hints/mount/maxYvalue") %></p> <form class="vzb-dialog-paragraph"> <label><input type="radio" name="ymax" value="immediate"><%=t ( "mount/maxYmode/immediate") %></label> <label><input type="radio" name="ymax" value="latest"><%=t ( "mount/maxYmode/latest") %></label> </form> </div> <div class="vzb-xaxis-container"> <p class="vzb-dialog-sublabel"> <%=t ( "hints/mount/logXstops") %> </p> <form class="vzb-dialog-paragraph"> <input type="checkbox" name="logstops" value="1">1 <input type="checkbox" name="logstops" value="2">2 <input type="checkbox" name="logstops" value="5">5 </form> </div> <p class="vzb-dialog-sublabel"> <%=t ( "hints/mount/xlimits") %> </p> <div class="vzb-xlimits-container vzb-dialog-paragraph"></div> <div class="vzb-probe-container"> <p class="vzb-dialog-sublabel"> <%=t ( "hints/mount/probe") %> </p> <input type="text" class="vzb-probe-field" name="probe"> </div> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div>';templates['colors.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="colors" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="colors" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/colors") %> <span class="vzb-caxis-selector"></span> </div> <div class="vzb-dialog-content"> <div class="vzb-clegend-container"></div> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div> ';templates['find.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="find" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="find" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "dialogs/find") %> <span class="vzb-dialog-content vzb-find-filter"> <input id="vzb-find-search" type="search"/> </span> </div> <div class="vzb-dialog-content vzb-dialog-content-fixed vzb-dialog-scrollable"> <div class="vzb-find-list">  </div> </div> <div class="vzb-dialog-buttons"> <div class="vzb-dialog-bubbleopacity vzb-dialog-control"></div> <div id="vzb-find-deselect" class="vzb-dialog-button"> <%=t ( "buttons/deselect") %> </div> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> <%=t ( "buttons/ok") %> </div> </div> </div> ';templates['label.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="label" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="label" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/label") %> </div> <div class="vzb-dialog-content"> <span class="vzb-saxis-selector"></span> <div class="vzb-dialog-sizeslider"></div> <div class="vzb-removelabelbox-switch"></div> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div> ';templates['moreoptions.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="moreoptions" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="moreoptions" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ("buttons/more_options") %> </div> <div class="vzb-dialog-content vzb-dialog-scrollable"> <div class="vzb-dialog-options-buttonlist"> </div> <div class="vzb-accordion"> </div> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div>';templates['opacity.html'] = '<div class="vzb-dialog-modal"> <div class="vzb-dialog-title"> <%=t ( "buttons/opacity") %> </div> <div class="vzb-dialog-content"> <p class="vzb-dialog-sublabel"> <%=t ("buttons/opacityRegular") %> </p> <div class="vzb-dialog-bubbleopacity-regular"></div> <p class="vzb-dialog-sublabel"> <%=t ("buttons/opacityNonselect") %> </p> <div class="vzb-dialog-bubbleopacity-selectdim"></div> </div> </div> </div> ';templates['presentation.html'] = '<div class="vzb-dialog-modal"> <div class="vzb-dialog-title"> <%=t ( "dialogs/presentation") %> </div> <div class="vzb-dialog-content"> <div class="vzb-presentationmode-switch"></div> </div> </div> ';templates['show.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="show" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="show" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/show") %> <span class="vzb-dialog-content vzb-show-filter"> <input id="vzb-show-search" type="search"/> </span> </div> <div class="vzb-dialog-content vzb-dialog-content-fixed vzb-dialog-scrollable"> <p class="vzb-dialog-sublabel"> <%=t ( "hints/mount/onlyshowthefollowing") %> </p> <div class="vzb-show-list">  </div> </div> <div class="vzb-dialog-buttons"> <div id="vzb-show-deselect" class="vzb-dialog-button"> <%=t ( "buttons/deselect") %> </div> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> <%=t ( "buttons/ok") %> </div> </div> </div> ';templates['size.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="size" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="size" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/size") %> <span class="vzb-saxis-selector"></span> </div> <div class="vzb-dialog-content"> <div class="vzb-dialog-bubblesize"></div> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div> ';templates['speed.html'] = '<div class="vzb-dialog-modal"> <div class="vzb-dialog-title"> <%=t ( "buttons/speed") %> </div> <div class="vzb-dialog-content"> <div class="vzb-dialog-placeholder"></div> </div> </div> ';templates['stack.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="stack" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="stack" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/stack") %> </div> <div class="vzb-dialog-content vzb-dialog-scrollable">  <form class="vzb-howtostack vzb-dialog-paragraph"> <label> <input type="radio" name="stack" value="none"> <%=t ( "mount/stacking/none") %> </label> <label> <input type="radio" name="stack" value="geo.world_4region"> <%=t ( "mount/stacking/region") %> </label> <label> <input type="radio" name="stack" value="all"> <%=t ( "mount/stacking/world") %> </label> </form> <form class="vzb-howtomerge vzb-dialog-paragraph"> <p class="vzb-dialog-sublabel"> <%=t ( "hints/mount/howtomerge") %> </p> <label> <input type="radio" name="merge" value="none"> <%=t ( "mount/merging/none") %> </label> <label> <input type="radio" name="merge" value="grouped"> <%=t ( "mount/merging/region") %> </label> <label> <input type="radio" name="merge" value="stacked"> <%=t ( "mount/merging/world") %> </label> </form> <form class="vzb-manual-sorting"> <p class="vzb-dialog-sublabel"> <%=t ( "mount/manualSorting") %> </p> <div class="vzb-dialog-draggablelist vzb-dialog-control"></div> </form> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary">OK</div> </div> </div>';templates['zoom.html'] = '<div class="vzb-dialog-modal"> <span class="thumb-tack-class thumb-tack-class-ico-pin fa" data-dialogtype="label" data-click="pinDialog"></span> <span class="thumb-tack-class thumb-tack-class-ico-drag fa" data-dialogtype="label" data-click="dragDialog"></span> <div class="vzb-dialog-title"> <%=t ( "buttons/zoom") %> <div class="vzb-dialog-zoom-buttonlist"></div> </div> <div class="vzb-dialog-content"> <div class="vzb-zoomonscrolling-switch"></div> <div class="vzb-adaptminmaxzoom-switch"></div> </div> <div class="vzb-dialog-buttons"> <div data-click="closeDialog" class="vzb-dialog-button vzb-label-primary"> OK </div> </div> </div> ';templates['minmaxinputs.html'] = '<div class="vzb-mmi-holder"> <span class="vzb-mmi-domainmin-label"></span> <input type="text" class="vzb-mmi-domainmin" name="min"> <span class="vzb-mmi-domainmax-label"></span> <input type="text" class="vzb-mmi-domainmax" name="max"> <br class="vzb-mmi-break"/> <span class="vzb-mmi-zoomedmin-label"></span> <input type="text" class="vzb-mmi-zoomedmin" name="min"> <span class="vzb-mmi-zoomedmax-label"></span> <input type="text" class="vzb-mmi-zoomedmax" name="max"> </div>';templates['sizeslider.html'] = '<div class="vzb-szs-holder"> <svg class="vzb-szs-svg"> <g class="vzb-szs-slider-wrap"> <g class="vzb-szs-slider"> </g> </g> </svg> </div> ';templates['timeslider.html'] = '<div class="vzb-timeslider vzb-ts-loading"> <div class="vzb-ts-slider-wrapper"> <svg class="vzb-ts-slider"> <g> <g class="vzb-ts-slider-axis"></g> <g class="vzb-ts-slider-select"></g> <g class="vzb-ts-slider-slide"> <circle class="vzb-ts-slider-handle"></circle> <text class="vzb-ts-slider-value"></text> </g> </g> </svg> </div>  <div class="vzb-ts-btns"> <button class="vzb-ts-btn-loading vzb-ts-btn"> <div class="vzb-loader"></div> </button> <button class="vzb-ts-btn-play vzb-ts-btn"> <svg class="vzb-icon vzb-icon-play" viewBox="3 3 42 42" xmlns="http://www.w3.org/2000/svg"> <path xmlns="http://www.w3.org/2000/svg" d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-4 29V15l12 9-12 9z"/> </svg> </button> <button class="vzb-ts-btn-pause vzb-ts-btn"> <svg class="vzb-icon vzb-icon-pause" viewBox="3 3 42 42" xmlns="http://www.w3.org/2000/svg"> <path xmlns="http://www.w3.org/2000/svg" d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-2 28h-4V16h4v16zm8 0h-4V16h4v16z"/> </svg> </button> </div> </div> ';templates['agepyramid.html'] = ' <svg class="vzb-agepyramid"> <g class="vzb-bc-header"> <text class="vzb-bc-title"></text> <text class="vzb-bc-title vzb-bc-title-right"></text> <text class="vzb-bc-year"></text> </g> <g class="vzb-bc-graph"> <svg class="vzb-bc-bars-crop"> <g class="vzb-bc-bars"></g> <g class="vzb-bc-labels"></g> </svg> <text class="vzb-bc-axis-y-title"></text> <g class="vzb-bc-axis-x"></g> <g class="vzb-bc-axis-x vzb-bc-axis-x-left"></g> <g class="vzb-bc-axis-y"></g> <g class="vzb-bc-axis-labels">  </g> </g> </svg> ';templates['axislabeler.html'] = ' <svg class="vzb-axislabeler"> <g class="vzb-al-graph"> <g class="vzb-al-axis-x"></g> <g class="vzb-al-axis-y"></g> </g> </svg> ';templates['barchart.html'] = ' <svg class="vzb-barchart"> <g class="vzb-bc-graph"> <g class="vzb-bc-bars"></g> <g class="vzb-bc-bar-labels"></g> <g class="vzb-bc-axis-y-title"></g> <text class="vzb-bc-year"></text> <g class="vzb-bc-axis-x-title"></g> <g class="vzb-bc-axis-x"></g> <g class="vzb-bc-axis-y"></g> <g class="vzb-bc-axis-labels">  </g> </g> </svg> ';templates['barrank.html'] = ' <div class="vzb-barrankchart"> <svg class="vzb-br-header"> <text class="vzb-br-title"></text> <text class="vzb-br-total"></text> </svg> <div class="barsviewport"> <svg class="vzb-br-bars-svg"> <g class="vzb-br-bars"></g> </svg> </div> </div> ';templates['bubblechart.html'] = ' <div class="vzb-bubblechart"> <svg class="vzb-bubblechart-svg vzb-export"> <g class="vzb-bc-graph"> <g class="vzb-bc-year"></g> <svg class="vzb-bc-axis-x"><g></g></svg> <svg class="vzb-bc-axis-y"><g></g></svg> <line class="vzb-bc-projection-x"></line> <line class="vzb-bc-projection-y"></line> <svg class="vzb-bc-bubbles-crop"> <rect class="vzb-bc-eventarea"></rect> <g class="vzb-bc-trails"></g> <g class="vzb-bc-bubbles"></g> <g class="vzb-bc-lines"></g> <g class="vzb-bc-bubble-crown vzb-hidden"> <circle class="vzb-crown-glow"></circle> <circle class="vzb-crown"></circle> </g> </svg> <g class="vzb-bc-axis-y-title"></g> <g class="vzb-bc-axis-x-title"></g> <g class="vzb-bc-axis-s-title"></g> <g class="vzb-bc-axis-c-title"></g> <g class="vzb-bc-axis-y-info vzb-noexport"></g> <g class="vzb-bc-axis-x-info vzb-noexport"></g> <svg class="vzb-bc-labels-crop"> <g class="vzb-bc-labels"></g> </svg> <g class="vzb-data-warning vzb-noexport"> <svg></svg> <text></text> </g> <rect class="vzb-bc-zoom-rect"></rect> <g class="vzb-bc-tooltip vzb-hidden"> <rect class="vzb-tooltip-glow"></rect> <rect class="vzb-tooltip-border"></rect> <text class="vzb-tooltip-text"></text> </g> </g> </svg> <svg> <defs> <filter id="vzb-glow-filter" x="-50%" y="-50%" width="200%" height="200%"> <feGaussianBlur in="SourceGraphic" stdDeviation="2"></feGaussianBlur> </filter> </defs> </svg>  <div class="vzb-tooltip vzb-hidden vzb-tooltip-mobile"></div> </div> ';templates['bubblemap.html'] = ' <div class="vzb-bubblemap"> <svg class="vzb-bmc-map-background vzb-export"> <g class="vzb-bmc-map-graph"></g> </svg> <svg class="vzb-bubblemap-svg vzb-export"> <g class="vzb-bmc-graph"> <g class="vzb-bmc-year"></g> <g class="vzb-bmc-lines"></g> <g class="vzb-bmc-bubbles"></g> <g class="vzb-bmc-bubble-labels"></g> <g class="vzb-bmc-axis-y-title"> <text></text> </g> <g class="vzb-bmc-axis-c-title"> <text></text> </g> <g class="vzb-bmc-axis-y-info vzb-noexport"> </g> <g class="vzb-bmc-axis-c-info vzb-noexport"> </g> <g class="vzb-data-warning vzb-noexport"> <svg></svg> <text></text> </g> <g class="vzb-bmc-labels"></g> <g class="vzb-bmc-tooltip vzb-hidden"> <rect class="vzb-tooltip-border"></rect> <text class="vzb-tooltip-text"></text> </g> </g> </svg> </div> ';templates['cartogram.html'] = ' <div class="vzb-cartogram"> <svg class="vzb-cartogram-svg"> <g class="vzb-ct-graph"> <g class="vzb-ct-year"></g> <svg class="vzb-ct-map-background vzb-export"> <g class="vzb-ct-map-graph"></g> </svg> <svg class="vzb-ct-labels-crop"> <g class="vzb-ct-labels"> <line class="vzb-ct-vertical-now"></line> </g> </svg> <g class="vzb-ct-axis-y-title"><text></text></g> <g class="vzb-ct-axis-c-title"><text></text></g> <g class="vzb-ct-axis-y-info"></g> <g class="vzb-ct-axis-c-info"></g> <g class="vzb-ct-tooltip vzb-hidden"> <rect class="vzb-tooltip-border"></rect> <text class="vzb-tooltip-text"></text> </g> <g class="vzb-data-warning vzb-noexport"> <svg></svg> <text></text> </g> </g> </svg> </div> ';templates['donutchart.html'] = ' <div class="vzb-donutchart"> <svg class="vzb-dc-graph">  </svg> <div class="vzb-tooltip vzb-hidden"></div> </div> ';templates['linechart.html'] = ' <div class="vzb-linechart"> <svg class="vzb-linechart-svg"> <g class="vzb-lc-graph"> <svg class="vzb-lc-axis-x"><g></g></svg> <svg class="vzb-lc-axis-y"><g></g></svg> <text class="vzb-lc-axis-x-value"></text> <text class="vzb-lc-axis-y-value"></text> <svg class="vzb-lc-lines-crop"> <svg class="vzb-lc-lines"></svg> <line class="vzb-lc-projection-x"></line> <line class="vzb-lc-projection-y"></line> </svg> <svg class="vzb-lc-labels-crop"> <g class="vzb-lc-labels"> <line class="vzb-lc-vertical-now"></line> </g> </svg> <g class="vzb-lc-axis-y-title"></g> <g class="vzb-lc-axis-x-title"></g> <g class="vzb-lc-axis-y-info"></g>  </g> </svg> <div class="vzb-tooltip vzb-hidden"></div> </div> ';templates['mountainchart.html'] = ' <div class="vzb-mountainchart"> <svg class="vzb-mountainchart-svg vzb-export"> <g class="vzb-mc-graph"> <rect class="vzb-mc-eventarea"></rect> <g class="vzb-mc-year"></g> <g class="vzb-mc-mountains-mergestacked"></g> <g class="vzb-mc-mountains-mergegrouped"></g> <g class="vzb-mc-mountains"></g> <g class="vzb-mc-mountains-labels"></g> <g class="vzb-mc-axis-y-title"> <text></text> </g> <g class="vzb-mc-axis-x-title"> <text></text> </g> <g class="vzb-mc-axis-info vzb-noexport"> </g> <g class="vzb-data-warning vzb-noexport"> <svg></svg> <text></text> </g> <g class="vzb-mc-axis-x"></g> <g class="vzb-mc-axis-labels"></g> <g class="vzb-mc-probe"> <text class="vzb-shadow vzb-mc-probe-value-ul"></text> <text class="vzb-shadow vzb-mc-probe-value-ur"></text> <text class="vzb-shadow vzb-mc-probe-value-dl"></text> <text class="vzb-shadow vzb-mc-probe-value-dr"></text> <text class="vzb-mc-probe-value-ul"></text> <text class="vzb-mc-probe-value-ur"></text> <text class="vzb-mc-probe-value-dl"></text> <text class="vzb-mc-probe-value-dr"></text> <text class="vzb-mc-probe-extremepoverty"></text> <line></line> </g> <g class="vzb-mc-tooltip vzb-hidden"> <rect class="vzb-tooltip-border"></rect> <text class="vzb-tooltip-text"></text> </g> </g> </svg> </div> ';templates['popbyage.html'] = ' <svg class="vzb-popbyage"> <g class="vzb-bc-header"> <text class="vzb-bc-title"></text> <text class="vzb-bc-year"></text> </g> <g class="vzb-bc-graph"> <g class="vzb-bc-bars"></g> <g class="vzb-bc-labels"></g> <text class="vzb-bc-axis-y-title"></text> <g class="vzb-bc-axis-x"></g> <g class="vzb-bc-axis-y"></g> <g class="vzb-bc-axis-labels">  </g> </g> </svg> '; return templates})({});
	
	      return Vzb;
	
	}));

/***/ }
]);
//# sourceMappingURL=angular2-vizabi.js.map